---
title: 🚀 我们正在进入“任务级编程”时代，Copilot 已经过时了
date: 2025-06-04 15:30:06
tags:
---

近日，OpenAI 重大升级的 Codex 终于开放使用了。老夫也在第一时间试用了一下。这个版本的 Codex 不再是我们熟悉的“代码补全助手”Copilot，它开始具备真正的“任务代理”能力——理解你要做什么、自己动手干、并提交一份可以合并的 PR。

这标志着一个全新的时代正在到来：**任务级编程（Task-Level Programming）**。

在这个新时代里，AI 不再只是帮你写几行代码，而是可以理解你提出的目标，自动去完成整个任务的工作流，包括分析上下文、查找 bug、设计变更方案、生成代码、运行测试、再打包成一个 PR 等。开发者的角色也将发生变化：从写代码的“工人”变成分配任务、评估质量的“指挥官”。

---

### 🧠 什么是“任务级编程”？

回顾编程工具的发展，我们可以看到几个阶段性的变革：

* **IDE 智能提示**：代表了“字符级编程”的黄金时代，从 IntelliSense 到 TabNine，自动补全成为开发者的标配工具。
* **Copilot 式补全**：开启了“函数级编程”时代。你只要写一句注释或函数名，它就能帮你补出整个实现逻辑，甚至包含 edge case 的处理。
* **Codex 任务代理**：正式迈入“任务级编程”时代。你用自然语言分配一个任务，它能识别全局上下文，查阅依赖关系，主动完成整个功能开发并提交代码。

这是工具能力的飞跃，也意味着开发者思维方式的转型。程序员正在从代码的“创造者”转变为任务的“构建者”，更接近产品经理、架构师的角色。

---

### 🔧 Codex：不再是补全，而是执行

Codex 的 2025.6 更新让它获得了前所未有的执行能力，而不再只是文字预测模型。

#### ✅ 云端执行任务

每个任务在独立沙箱中运行，具备可控联网、环境隔离、依赖安装等能力。用户可以决定是否允许联网（如下载 openjdk）、是否运行测试用例、是否提交 PR。

#### ✅ 自动生成 & 更新 Pull Request

Codex 会根据任务内容自动识别应修改的文件并生成差异内容，随后打包成 PR 推送到你的代码仓库中。如果你后续修改了需求，它也能更新原有 PR，而不是每次新建一个。

#### ✅ 支持语音输入、联网配置、文件变更控制

在 ChatGPT 中，你甚至可以说一句：“修复订单模块中创建订单失败的问题”，Codex 就会扫描代码，找到关键逻辑，分析可能的问题点，并在隔离环境中测试修复建议。

#### ✅ 理解全项目上下文（192K tokens）

Codex 可读取接近 200K 字符的代码上下文，足以分析大型项目结构、模块间依赖、注释与 commit 记录、schema 结构等。这比 Copilot 的窗口大十倍以上，具备了真正的“项目级智能”。

#### ✅ 自动运行测试

在每一个任务执行过程中，Codex 不仅可以生成对应的单元测试，还能自动在隔离的沙箱环境中运行测试用例，验证逻辑正确性。测试失败时，它会尝试修复、重新运行，直到通过或生成说明文档解释原因。这使得它具备了“开发 + 验证”一体化的能力，极大减轻了人工测试与调试负担。

---

### 🎯 Copilot 的边界，也是 Codex 的起点

| 特性              | GitHub Copilot | OpenAI Codex（2025）       |
| --------------- | -------------- | ------------------------ |
| 理解粒度            | 当前文件、当前函数      | 整个代码库、多个模块               |
| 行为              | 辅助补全，开发者主导     | 执行任务，自动 PR，开发者审查         |
| 工作模式            | 嵌入 IDE，实时建议    | ChatGPT 任务侧栏，沙箱中运行完整开发流程 |
| 自动化程度           | 代码级补全          | 任务级开发                    |
| 能否联网执行/安装依赖     | ❌ 不支持          | ✅ 支持（需授权）                |
| 是否能跑测试/写测试用例    | 手动补全测试模板       | 自动生成测试代码并运行验证            |
| Pull Request 处理 | 无内建 PR 支持      | 自动创建/更新 PR               |

结论：**Copilot 是一个增强的 IDE 工具，而 Codex 是一个自动化的开发代理。** Copilot 帮你“写得快”，而 Codex 帮你“少写甚至不写”。在未来，“写代码”不再是生产力的衡量标准，“构建解决方案”才是。

---

### 🛠️ 开发者在这个新时代的角色变化

在“任务级编程”中，开发者的身份从传统意义上的“键盘工匠”发生转变，开始更像是一个协调器、产品化思维者、审查员：

* 我们不再是代码的“搬运工”，而是任务的分发者与质量把控者；
* 我们更多是在告诉 Codex：“我想修复这个问题”，而不是“我来写具体哪几行”；
* 我们需要关注业务逻辑、系统结构、跨模块一致性等“高阶目标”；
* 我们的核心竞争力从“代码实现力”变成“需求理解力、判断力与审查力”。

换句话说，AI 帮我们完成的是“代码执行”，而我们要完成的是“需求判断 + 成果验收”。

---

### 📺 实际演示（基于 Java 场景）

#### 初始化项目
```prompt
请为我创建一个 Maven Java 项目，包含以下内容：

实体类 User

DTO 类 UserDto

异常类 UserNotFoundException

服务类 UserService，包含 getUserById 方法，使用 Optional<User>

包结构建议为 com.example

并生成对应的 pom.xml、目录结构和测试代码。
``` 
任务完成，我们可以看到Codex已经按要求帮我们生成了6个文件：
![project-init](./images/codex/project-init.png)

查看拉取请求：
![project-init-pr](./images/codex/project-init-pr.png)

#### 🧪 场景：我让 Codex 修复了一个 NPE 错误

1. 在Codex中创建任务：

   > 修复 `UserService.getUserById()` 中可能的 null pointer 问题

2. Codex 自动分析整个代码库，找到该方法：

```java
public User getUserById(int id) {
    return userRepository.findById(id).orElse(null);
}
```

3. 它识别出 `null` 返回是导致 NPE 的关键，建议修改为：

```java
public Optional<User> getUserById(int id) {
    return userRepository.findById(id);
}
```
通过查看任务日志我们可以看到Codex的思考过程：
![npe](./images/codex/npe.png)

4. 它还自动修改了调用该方法的多个文件，并生成了对应的变更说明和 Pull Request。

5. 自动生成了对应的单元测试，并在沙箱环境中运行测试，确保修改不会引入新的问题。
由于在项目开始，我们让Codex帮我们生成了测试代码，所以它可以直接运行测试，无需人工编写。
![unit-test](./images/codex/unit-test.png)

整个过程不到两分钟，我只需要看一眼差异内容，点击 Merge。

这就是任务级编程的魅力——你不再“逐行写”，而是在“提出目标”之后让 AI 执行，而你则成为那个决定是否接受成果的人。

---

### 🧭 总结：Copilot 是“写代码”的终点，Codex 是“指挥代码”的起点

* 软件开发的交互方式正在转变为任务驱动，而非字符驱动；
* 工具不再局限于 IDE 插件，而是深入 DevOps 全链路，嵌入 CI/CD、PR 流程；
* 我们需要学习的不是 API 文档，而是如何写出让 AI 理解的“开发意图”；
* 下一代开发者，将不再问“你会写什么语言”，而是“你如何安排 AI 为你完成工作”。

任务级编程不是幻想，而是已来。

欢迎来到新时代。
