{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/hello-bg.png","path":"images/hello-bg.png","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon_bak.ico","path":"assets/favicon_bak.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/wechat_qr.jpg","path":"assets/wechat_qr.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Jason.jpg","path":"avatar/Jason.jpg","modified":0,"renderable":1},{"_id":"source/images/http/http-request.png","path":"images/http/http-request.png","modified":0,"renderable":0},{"_id":"source/images/http/request-methods.png","path":"images/http/request-methods.png","modified":0,"renderable":0},{"_id":"source/images/http/TCP-connection-1.png","path":"images/http/TCP-connection-1.png","modified":0,"renderable":0},{"_id":"source/images/http/curl-header.png","path":"images/http/curl-header.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-1.png","path":"images/http/handshake-1.png","modified":0,"renderable":0},{"_id":"source/images/http/perisitent-connection.png","path":"images/http/perisitent-connection.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect.png","path":"images/http/auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect2.png","path":"images/http/auto-disconnect2.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-2.png","path":"images/http/handshake-2.png","modified":0,"renderable":0},{"_id":"source/images/http/http-keep-alive-header.png","path":"images/http/http-keep-alive-header.png","modified":0,"renderable":0},{"_id":"source/images/internal-loss/depressed.jpg","path":"images/internal-loss/depressed.jpg","modified":0,"renderable":0},{"_id":"source/images/http/timeout-auto-disconnect.png","path":"images/http/timeout-auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","path":"images/internal-loss/20231109_sy_01.jpg","modified":0,"renderable":0},{"_id":"source/images/internal-loss/996.jpg","path":"images/internal-loss/996.jpg","modified":0,"renderable":0},{"_id":"source/images/garnet/client.png","path":"images/garnet/client.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compatible.png","path":"images/garnet/compatible.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compare1.png","path":"images/garnet/compare1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/log.png","path":"images/garnet/log.png","modified":0,"renderable":0},{"_id":"source/images/garnet/1.png","path":"images/garnet/1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/connect.png","path":"images/garnet/connect.png","modified":0,"renderable":0},{"_id":"source/images/garnet/custom-command.png","path":"images/garnet/custom-command.png","modified":0,"renderable":0},{"_id":"source/images/https/bg.jpg","path":"images/https/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/https/expire.png","path":"images/https/expire.png","modified":0,"renderable":0},{"_id":"source/images/garnet/running.png","path":"images/garnet/running.png","modified":0,"renderable":0},{"_id":"source/images/https/ca.png","path":"images/https/ca.png","modified":0,"renderable":0},{"_id":"source/images/https/ca2.png","path":"images/https/ca2.png","modified":0,"renderable":0},{"_id":"source/images/https/client-hello.png","path":"images/https/client-hello.png","modified":0,"renderable":0},{"_id":"source/images/https/encrypted.png","path":"images/https/encrypted.png","modified":0,"renderable":0},{"_id":"source/images/https/security.png","path":"images/https/security.png","modified":0,"renderable":0},{"_id":"source/images/https/negotiated-cipher-suite.png","path":"images/https/negotiated-cipher-suite.png","modified":0,"renderable":0},{"_id":"source/images/https/cipher-suites.png","path":"images/https/cipher-suites.png","modified":0,"renderable":0},{"_id":"source/images/https/handshake.png","path":"images/https/handshake.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/recruitment.png","path":"images/redis-interview/recruitment.png","modified":0,"renderable":0},{"_id":"source/images/dump/bg.png","path":"images/dump/bg.png","modified":0,"renderable":0},{"_id":"source/images/dump/crash.jpeg","path":"images/dump/crash.jpeg","modified":0,"renderable":0},{"_id":"source/images/redis-interview/bg.png","path":"images/redis-interview/bg.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-avalanche.png","path":"images/redis-interview/cache-avalanche.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-breakdown.png","path":"images/redis-interview/cache-breakdown.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/memory.png","path":"images/redis-interview/memory.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-penetration.png","path":"images/redis-interview/cache-penetration.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_2.png","path":"images/dump/windbg_2.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_4.png","path":"images/dump/windbg_4.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_1.png","path":"images/dump/windbg_1.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_3.png","path":"images/dump/windbg_3.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/bg.jpg","path":"images/dead-message/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","path":"images/dead-message/dead-letter-exchange-1.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-2.jpg","path":"images/dead-message/dead-letter-2.jpg","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-3.png","path":"images/dead-message/dead-letter-3.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_2.png","path":"images/dead-message/delay_comsuption_2.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_1.png","path":"images/dead-message/delay_comsuption_1.png","modified":0,"renderable":0},{"_id":"source/images/image-search/images.png","path":"images/image-search/images.png","modified":0,"renderable":0},{"_id":"source/images/image-search/search.gif","path":"images/image-search/search.gif","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/pause-1.png","path":"images/task-completion-source/pause-1.png","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/pause-2.png","path":"images/task-completion-source/pause-2.png","modified":0,"renderable":0},{"_id":"source/images/image-search/bg.jpg","path":"images/image-search/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/image-search/process.png","path":"images/image-search/process.png","modified":0,"renderable":0},{"_id":"source/images/image-search/qdrant.png","path":"images/image-search/qdrant.png","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/bg.jpg","path":"images/task-completion-source/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/proxy/reverse-proxy.png","path":"images/proxy/reverse-proxy.png","modified":0,"renderable":0},{"_id":"source/images/proxy/forward-proxy.png","path":"images/proxy/forward-proxy.png","modified":0,"renderable":0},{"_id":"source/images/proxy/transparent-proxy.png","path":"images/proxy/transparent-proxy.png","modified":0,"renderable":0},{"_id":"source/images/proxy/bg.jpg","path":"images/proxy/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/docker-1/configurations.png","path":"images/docker-1/configurations.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/bg.png","path":"images/docker-1/bg.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/multi-env.png","path":"images/docker-1/multi-env.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/after.png","path":"images/docker-2/after.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/before.png","path":"images/docker-2/before.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect1.png","path":"images/docker-2/inspect1.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect2.png","path":"images/docker-2/inspect2.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect3.png","path":"images/docker-2/inspect3.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/default-exchange.png","path":"images/rabbitmq-basic/default-exchange.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","path":"images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout.png","path":"images/rabbitmq-basic/fanout.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout.mp4","path":"images/rabbitmq-basic/fanout.mp4","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/16elk-ujaxc.gif","path":"images/rabbitmq-basic/16elk-ujaxc.gif","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/main.png","path":"images/rabbitmq-basic/main.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/channel1.png","path":"images/rabbitmq-basic/channel1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/channel2.png","path":"images/rabbitmq-basic/channel2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/vro2s-b2mub.gif","path":"images/rabbitmq-basic/vro2s-b2mub.gif","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/direct-exchange.svg","path":"images/rabbitmq-basic/direct-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/topic-exchange.svg","path":"images/rabbitmq-basic/topic-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout-exchange.svg","path":"images/rabbitmq-basic/fanout-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/rabbitmq-headers-exchange.svg","path":"images/rabbitmq-basic/rabbitmq-headers-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/normal.png","path":"images/rabbitmq-quarum/normal.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/quarum1.png","path":"images/rabbitmq-quarum/quarum1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/quarum2.png","path":"images/rabbitmq-quarum/quarum2.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/daemonset-1.png","path":"images/daemonset/daemonset-1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_error1.png","path":"images/rabbitmq-quarum/stream_error1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_error2.png","path":"images/rabbitmq-quarum/stream_error2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_offset.png","path":"images/rabbitmq-quarum/stream_offset.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/courgette.log","path":"images/rabbitmq-quarum/courgette.log","modified":0,"renderable":0},{"_id":"source/images/daemonset/bg.png","path":"images/daemonset/bg.png","modified":1,"renderable":0},{"_id":"source/images/daemonset/DaemonSets.png","path":"images/daemonset/DaemonSets.png","modified":1,"renderable":0},{"_id":"source/images/daemonset/nodes.png","path":"images/daemonset/nodes.png","modified":1,"renderable":0},{"_id":"source/images/daemonset/daemonset-pods.png","path":"images/daemonset/daemonset-pods.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world-bak.md1","hash":"1e16dbc0dbf8b18e83f47dbbdffd0d1f27cfe955","modified":1710398484836},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688482306000},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1688482306000},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1688482306000},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1688482306000},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1688482306000},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1688482306000},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1688482306000},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1688482306000},{"_id":"source/_posts/hello-world.md","hash":"3c422ea24b75465e6ea2a80c268251ca0a03e042","modified":1714100836002},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1688482306000},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1688482306000},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1688482306000},{"_id":"themes/archer/package.json","hash":"81af75826e854ac80f6337dc4f1ce4b51f066b0b","modified":1688482306000},{"_id":"themes/archer/_config.yml","hash":"0dd04e79b90209217c5bdff1e8160f2976b30312","modified":1710819811209},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1688482306000},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1688482306000},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1688482306000},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1688482306000},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1688482306000},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1688482306000},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1688482306000},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1688482306000},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1688482306000},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1688482306000},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1688482306000},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1688482306000},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1688482306000},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1688482306000},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1688482306000},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1688482306000},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1688482306000},{"_id":"themes/archer/layout/layout.ejs","hash":"1bee90a75c1f4b04c90421419dd68acdec15b998","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1688482306000},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"236e6550d94519d44292e6b14e30ea8234050025","modified":1711684219591},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"687c08823e7ce43e6ebb44f2fb4b75549abfed29","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1688482306000},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1688482306000},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1688482306000},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1688482306000},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1688482306000},{"_id":"themes/archer/source/assets/favicon_bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1688482306000},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1688482306000},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1688482306000},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1688482306000},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1688482306000},{"_id":"themes/archer/source/assets/wechat_qr.jpg","hash":"20763d666624facc585e34645018deadb343b4b5","modified":1705482083315},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1688482306000},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1688482306000},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1688482306000},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1688482306000},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1688482306000},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1688482306000},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1688482306000},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1688482306000},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1688482306000},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1688482306000},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1688482306000},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1688482306000},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1688482306000},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1688482306000},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1688482306000},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1688482306000},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1688482306000},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1688482306000},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1688482306000},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1688482306000},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1688482306000},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1688482306000},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1688482306000},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1688482306000},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1688482306000},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1688482306000},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1688482306000},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1688482306000},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1688482306000},{"_id":"themes/archer/source/avatar/Jason.jpg","hash":"0eae332ea91f9e04b54f35d2ed1b17b5b37aee64","modified":1710397722571},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1688482306000},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1688482306000},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1688482306000},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1688482306000},{"_id":"themes/archer/source/assets/favicon.ico","hash":"c136618e070daf370da961ac730973293a088b9e","modified":1710382119333},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1688482306000},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1688482306000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1688482306000},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1688482306000},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1688482306000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1688482306000},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1688482306000},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1688482306000},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1688482306000},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1688482306000},{"_id":"themes/archer/package-lock.json","hash":"400ab1cc2a2f1380a5e9ab69abe3a5b93f923d8d","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1688482306000},{"_id":"source/images/hello-bg.png","hash":"f70f2a6805ceb4ab1175e391c03923b7264bc431","modified":1705386424945},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1688482306000},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1688482306000},{"_id":"public/index.html","hash":"f025dd61ff56e7eebc3475a3c9d7f434c3909600","modified":1713255953227},{"_id":"public/2024/03/13/hello-world/index.html","hash":"4bf0b296c696bab720be5dcec3e6b959ce39cb6d","modified":1713255953227},{"_id":"public/archives/index.html","hash":"11ad5b8b9080e766721066453dbc969fce5154e3","modified":1713255953227},{"_id":"public/archives/2024/index.html","hash":"61a561d1066a58c3b3640c451d4e830ce36bb500","modified":1713255953227},{"_id":"public/archives/2024/03/index.html","hash":"d36a33e3caa67d60e085245ce530e16fd1525c2f","modified":1713255953227},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1713255953227},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1713255953227},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1713255953227},{"_id":"public/assets/favicon_bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1713255953227},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1713255953227},{"_id":"public/assets/wechat_qr.jpg","hash":"20763d666624facc585e34645018deadb343b4b5","modified":1713255953227},{"_id":"public/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1713255953227},{"_id":"public/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1713255953227},{"_id":"public/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1713255953227},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1713255953227},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1713255953227},{"_id":"public/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1713255953227},{"_id":"public/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1713255953227},{"_id":"public/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1713255953227},{"_id":"public/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1713255953227},{"_id":"public/avatar/Jason.jpg","hash":"0eae332ea91f9e04b54f35d2ed1b17b5b37aee64","modified":1713255953227},{"_id":"public/assets/favicon.ico","hash":"c136618e070daf370da961ac730973293a088b9e","modified":1713255953227},{"_id":"public/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1713255953227},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1713255953227},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1713255953227},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1713255953227},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1713255953227},{"_id":"public/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1713255953227},{"_id":"public/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1713255953227},{"_id":"public/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1713255953227},{"_id":"public/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1713255953227},{"_id":"public/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1713255953227},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1713255953227},{"_id":"public/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1713255953227},{"_id":"public/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1713255953227},{"_id":"public/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1713255953227},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1713255953227},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1713255953227},{"_id":"public/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1713255953227},{"_id":"public/images/hello-bg.png","hash":"f70f2a6805ceb4ab1175e391c03923b7264bc431","modified":1713255953227},{"_id":"public/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1713255953227},{"_id":"public/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1713255953227},{"_id":"public/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1713255953227},{"_id":"public/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1713255953227},{"_id":"source/_posts/http.md","hash":"e538858062edce06c26c8060d05f61b3e6fe772b","modified":1714100804259},{"_id":"source/images/http-request.png","hash":"eed1c7354200ef63062c4290552839cea43c5c07","modified":1710907639923},{"_id":"source/images/http/http-request.png","hash":"4d29675c37a4cc0df885db03cff820aa3f98080c","modified":1710926387387},{"_id":"source/images/http/request-methods.png","hash":"5914a2642fc3c771aaddbb5a4db79d020c75ba27","modified":1710917201189},{"_id":"source/images/http/handshake-1.png","hash":"698f25b0696249dbbadbf1b71ea5e3e48b57348e","modified":1711100170452},{"_id":"source/images/http/curl-header.png","hash":"e5c4a20f54045759a1a29f7f35a344d45ee51ecb","modified":1711013282028},{"_id":"source/images/http/TCP-connection-1.png","hash":"588cade2c5e791bee0f282a6290889ba15c3a039","modified":1711091658444},{"_id":"source/images/http/perisitent-connection.png","hash":"0e16961aaa4851908823dccfa904d3f4f6989c08","modified":1711092222874},{"_id":"source/_posts/organization-internal-loss.md","hash":"b157730ebdda6cfd58233ff8ec9d9bfed27d37b1","modified":1714100795957},{"_id":"source/images/http/http-keep-alive-header.png","hash":"d2b1f6ccc2903ffbd4308627c2562b42c80a2cb7","modified":1711435826469},{"_id":"source/images/http/handshake-2.png","hash":"f50dd3fab7ff21a20cd91622aefb077b7ec74b89","modified":1711353457535},{"_id":"source/images/http/timeout-auto-disconnect.png","hash":"87f74686dc596abb5be91260a40dcf38ed3d0d17","modified":1711433208748},{"_id":"source/images/http/auto-disconnect.png","hash":"6eb07b19f5350b86e32c41503abdef786d1cc8a3","modified":1711368567428},{"_id":"source/images/internal-loss/depressed.jpg","hash":"8ff19e979ef211030d79fc29eca3bef0ed42f9e9","modified":1711678444570},{"_id":"source/images/http/auto-disconnect2.png","hash":"d96b55fe2a3d138263e29ec9ba3a171b78eaf003","modified":1711356920847},{"_id":"source/_posts/garnet.md","hash":"9fa10e3a47f78d4b6f8465f3e49e33da56758f21","modified":1714100842478},{"_id":"source/images/internal-loss/996.jpg","hash":"d712414d1167ea1a5790683d549a3dbf56cc3c8c","modified":1711684344049},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","hash":"f637ac12cf901b7e557077687482f7232bbc2a72","modified":1711685199687},{"_id":"source/_posts/https.md","hash":"00df307cec478b57c6b9ab848f2b3d2ef578098a","modified":1714100800272},{"_id":"source/images/garnet/compatible.png","hash":"1714c1d5f1c6fd0421b4594015595976b5fd4ee4","modified":1712567994543},{"_id":"source/images/garnet/compare1.png","hash":"ed8a21697688433ffe376d2a4ccaa7ec53c667ff","modified":1712648062046},{"_id":"source/images/garnet/client.png","hash":"4889111b6b22a0f07ed3e80b70ee4e1e99c8045e","modified":1712652420303},{"_id":"source/images/https/expire.png","hash":"801009fef98fa9d46a677f153f097e6476c139e2","modified":1712824416637},{"_id":"source/images/garnet/connect.png","hash":"82d4fc4511b032c7c797018845ca40d83ac7aa9d","modified":1712650225409},{"_id":"source/images/garnet/custom-command.png","hash":"bea263307a51c77205885ace2c3060272e444339","modified":1712736760989},{"_id":"source/images/garnet/1.png","hash":"0d8a64004413ec34a334cce4925372781b3c88b0","modified":1712566365601},{"_id":"source/images/garnet/log.png","hash":"0c32a044823dd2b85353c2816c9109c9df0626b4","modified":1712721260633},{"_id":"source/images/garnet/running.png","hash":"3253e7a14adf9509baead2613151f614a0012ab5","modified":1712567881514},{"_id":"source/images/https/bg.jpg","hash":"9424b491fdae5f8c91344596469c3980217e2206","modified":1712821936174},{"_id":"source/images/https/ca.png","hash":"a3f65f3b7f108a2e18c61d13c3024d761586a9ca","modified":1712826407187},{"_id":"source/images/https/encrypted.png","hash":"51f01f7c79cbb8e5ace366b423a46c677483d4f3","modified":1712827358003},{"_id":"source/images/https/client-hello.png","hash":"65039f3b5656ce343d9c36842642aedef464f9d1","modified":1712827328350},{"_id":"source/images/https/ca2.png","hash":"e71ae267fc6a9eda8943e4881e2f408b0a84055f","modified":1712827074795},{"_id":"source/images/https/security.png","hash":"e040846f476100e1ac38f67dec1fc9735978fc9f","modified":1713148972216},{"_id":"source/images/https/handshake.png","hash":"9d2b92013eb6b78a0f3b84855a383b29962da2ba","modified":1713152131440},{"_id":"source/images/https/negotiated-cipher-suite.png","hash":"32d7a6f6ad24e6c5755d2ba2626e0ba71520fd50","modified":1713149675775},{"_id":"source/images/https/cipher-suites.png","hash":"e9faeff8e36d3efd82a5a0800c85a8e23d6ebf56","modified":1713149632927},{"_id":"public/2024/04/11/https/index.html","hash":"2362c2a6c75b4e53e8b103cbd0b2835a053c196d","modified":1713255953227},{"_id":"public/2024/04/07/garnet/index.html","hash":"7cff3ee5ac31859ab0e80195973947cb53b47b7f","modified":1713255953227},{"_id":"public/2024/03/28/organization-internal-loss/index.html","hash":"0f5834ba9bf426bc3eaa541aad3e766ab0999293","modified":1713255953227},{"_id":"public/2024/03/19/http/index.html","hash":"a4dbd8c74d50450f71d405b53817e86e364bd775","modified":1713255953227},{"_id":"public/archives/2024/04/index.html","hash":"568ad7f062ee32b31612d64d952b5b0bb9d75d5e","modified":1713255953227},{"_id":"public/tags/http-http协议-Connection/index.html","hash":"d3497d1a24185c46cbedbaf85f299faa6b8a3bbc","modified":1713255953227},{"_id":"public/tags/组织-内耗/index.html","hash":"d61eae406afac4c434fce25687e14d64f23503d2","modified":1713255953227},{"_id":"public/tags/Garnet-缓存-微软/index.html","hash":"c4ced32b5309e68eb92157930783b0c1be407091","modified":1713255953227},{"_id":"public/tags/https-http-ssl-tls/index.html","hash":"919e587f1e97e883ec79744b4e764b6dd551bd7f","modified":1713255953227},{"_id":"public/images/http/http-request.png","hash":"4d29675c37a4cc0df885db03cff820aa3f98080c","modified":1713255953227},{"_id":"public/images/http/TCP-connection-1.png","hash":"588cade2c5e791bee0f282a6290889ba15c3a039","modified":1713255953227},{"_id":"public/images/http/handshake-1.png","hash":"698f25b0696249dbbadbf1b71ea5e3e48b57348e","modified":1713255953227},{"_id":"public/images/http/curl-header.png","hash":"e5c4a20f54045759a1a29f7f35a344d45ee51ecb","modified":1713255953227},{"_id":"public/images/http/perisitent-connection.png","hash":"0e16961aaa4851908823dccfa904d3f4f6989c08","modified":1713255953227},{"_id":"public/images/internal-loss/depressed.jpg","hash":"8ff19e979ef211030d79fc29eca3bef0ed42f9e9","modified":1713255953227},{"_id":"public/images/http/http-keep-alive-header.png","hash":"d2b1f6ccc2903ffbd4308627c2562b42c80a2cb7","modified":1713255953227},{"_id":"public/images/garnet/client.png","hash":"4889111b6b22a0f07ed3e80b70ee4e1e99c8045e","modified":1713255953227},{"_id":"public/images/garnet/compatible.png","hash":"1714c1d5f1c6fd0421b4594015595976b5fd4ee4","modified":1713255953227},{"_id":"public/images/garnet/compare1.png","hash":"ed8a21697688433ffe376d2a4ccaa7ec53c667ff","modified":1713255953227},{"_id":"public/images/garnet/connect.png","hash":"82d4fc4511b032c7c797018845ca40d83ac7aa9d","modified":1713255953227},{"_id":"public/images/garnet/custom-command.png","hash":"bea263307a51c77205885ace2c3060272e444339","modified":1713255953227},{"_id":"public/images/https/bg.jpg","hash":"9424b491fdae5f8c91344596469c3980217e2206","modified":1713255953227},{"_id":"public/images/https/expire.png","hash":"801009fef98fa9d46a677f153f097e6476c139e2","modified":1713255953227},{"_id":"public/images/garnet/running.png","hash":"3253e7a14adf9509baead2613151f614a0012ab5","modified":1713255953227},{"_id":"public/images/https/ca.png","hash":"a3f65f3b7f108a2e18c61d13c3024d761586a9ca","modified":1713255953227},{"_id":"public/images/https/security.png","hash":"e040846f476100e1ac38f67dec1fc9735978fc9f","modified":1713255953227},{"_id":"public/images/https/handshake.png","hash":"9d2b92013eb6b78a0f3b84855a383b29962da2ba","modified":1713255953227},{"_id":"public/images/http/auto-disconnect.png","hash":"6eb07b19f5350b86e32c41503abdef786d1cc8a3","modified":1713255953227},{"_id":"public/images/http/timeout-auto-disconnect.png","hash":"87f74686dc596abb5be91260a40dcf38ed3d0d17","modified":1713255953227},{"_id":"public/images/internal-loss/20231109_sy_01.jpg","hash":"f637ac12cf901b7e557077687482f7232bbc2a72","modified":1713255953227},{"_id":"public/images/http/handshake-2.png","hash":"f50dd3fab7ff21a20cd91622aefb077b7ec74b89","modified":1713255953227},{"_id":"public/images/garnet/log.png","hash":"0c32a044823dd2b85353c2816c9109c9df0626b4","modified":1713255953227},{"_id":"public/images/garnet/1.png","hash":"0d8a64004413ec34a334cce4925372781b3c88b0","modified":1713255953227},{"_id":"public/images/internal-loss/996.jpg","hash":"d712414d1167ea1a5790683d549a3dbf56cc3c8c","modified":1713255953227},{"_id":"public/images/http/auto-disconnect2.png","hash":"d96b55fe2a3d138263e29ec9ba3a171b78eaf003","modified":1713255953227},{"_id":"public/images/https/encrypted.png","hash":"51f01f7c79cbb8e5ace366b423a46c677483d4f3","modified":1713255953227},{"_id":"public/images/https/negotiated-cipher-suite.png","hash":"32d7a6f6ad24e6c5755d2ba2626e0ba71520fd50","modified":1713255953227},{"_id":"public/images/https/cipher-suites.png","hash":"e9faeff8e36d3efd82a5a0800c85a8e23d6ebf56","modified":1713255953227},{"_id":"public/images/http/request-methods.png","hash":"5914a2642fc3c771aaddbb5a4db79d020c75ba27","modified":1713255953227},{"_id":"public/images/https/client-hello.png","hash":"65039f3b5656ce343d9c36842642aedef464f9d1","modified":1713255953227},{"_id":"public/images/https/ca2.png","hash":"e71ae267fc6a9eda8943e4881e2f408b0a84055f","modified":1713255953227},{"_id":"source/_posts/redis-interview.md","hash":"f83cab69b0f20b5d7300c5e68729006e9be6d913","modified":1713425000574},{"_id":"source/images/redis-interview/recruitment.png","hash":"9da7eff910bfb50b7f11618614003b6153e71d98","modified":1713425715760},{"_id":"source/_posts/redis-interview-1.md","hash":"951b57d41f67b3f9287684d1808c63e0ab08023d","modified":1714102286087},{"_id":"source/_posts/dump.md","hash":"fc0d11e98d4a2c35e8f590fc901c33ec87cf1654","modified":1715157478693},{"_id":"source/images/dump/crash.jpeg","hash":"e25f4327f9073e01e8b1a3e13c209ca732880e15","modified":1714290837084},{"_id":"source/images/redis-interview/memory.png","hash":"37fadd91ec8573c6c30ec5fd32562f2c3d22d5a9","modified":1714031983730},{"_id":"source/images/dump/bg.png","hash":"32c7ad31ef1117233e7691e74198041f62870e63","modified":1714290251488},{"_id":"source/images/redis-interview/cache-avalanche.png","hash":"8bcdb1787aa12c08febeb8c2324cf7fa9c6d3c02","modified":1714100497420},{"_id":"source/images/redis-interview/bg.png","hash":"e5be0650aa2343b4a62218b58ebae10c4f4b9ba6","modified":1714101428369},{"_id":"source/images/redis-interview/cache-breakdown.png","hash":"de31f8ba0958f9428c1148746206f8351fa1bf18","modified":1714100525728},{"_id":"source/images/redis-interview/cache-penetration.png","hash":"17f21e18052f40f20189a31c4bfbf749a1dedcbc","modified":1714100540904},{"_id":"source/images/dump/windbg_3.png","hash":"47fa0c7ac253a9a44eef9bc6d5dce90d96445ba2","modified":1715068901454},{"_id":"source/images/dump/windbg_2.png","hash":"e55722d89679167f37e0b851a53e27ae989663f8","modified":1714439116512},{"_id":"source/images/dump/windbg_4.png","hash":"5618b95c756aab451803e23e9c0f77b5fa94e6b4","modified":1715069009388},{"_id":"source/images/dump/windbg_1.png","hash":"fec01b96435a46269b0a241c8feb13764458b0e9","modified":1714438955774},{"_id":"source/_posts/dead-message.md","hash":"e0a8e83a589cd97cb599fd243d348f4b1896eb71","modified":1716628987803},{"_id":"source/images/dead-message/bg.jpg","hash":"e0de32bdd097eeb58f534882e876a282606db679","modified":1716366165441},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","hash":"7b141675f4bd37c8d65a63b5d22612430b945720","modified":1716621402662},{"_id":"source/images/dead-message/dead-letter-2.jpg","hash":"424a4237b4485e845ed3e9e6e74ee1f34485d196","modified":1716542966790},{"_id":"source/_posts/TaskCompletionSource.md","hash":"a2bcfbda71ac8d8406e1bd14fa333169457384e5","modified":1717658556858},{"_id":"source/images/dead-message/delay_comsuption_2.png","hash":"f9b57ebe4ba7cefabad08a139f92e619fd1aae8f","modified":1716627676317},{"_id":"source/images/dead-message/dead-letter-3.png","hash":"d8017b10c2efd5448993b92f0a35783e4d0b71f7","modified":1716626485267},{"_id":"source/images/dead-message/delay_comsuption_1.png","hash":"c093bbb3f975f40087d037aa56b8fd32ed866332","modified":1716627815685},{"_id":"source/_posts/similar-image-search.md","hash":"80b6ecb4440b108c26f92fd41d4f1d326f88eba5","modified":1717774298746},{"_id":"source/images/task-completion-source/pause-2.png","hash":"f681d83790b004e1703e18560c2f7d2db0cd6d01","modified":1717658059375},{"_id":"source/images/task-completion-source/pause-1.png","hash":"14d301e1283ad280dd8ea0525be0e5c38531ef74","modified":1717658041988},{"_id":"source/images/image-search/search.gif","hash":"eb44e6dcab6b4292eb95ef63cbf64035ed01c878","modified":1717770772367},{"_id":"source/images/image-search/images.png","hash":"b2a77e00a2290543613f0df77f8c30337c91f441","modified":1717681798910},{"_id":"source/_posts/proxy.md","hash":"fbe68bb5c014a73c809edf55bd34ac75f88dc814","modified":1718931872131},{"_id":"source/images/proxy/Forward-proxy-vs-reverse-proxy-1.png","hash":"ada4870485a68b34acdbb8088db368dc134332d3","modified":1718849773403},{"_id":"source/images/image-search/process.png","hash":"c1f5c3452b606dc8a510d9b3a5a24b330eff06eb","modified":1717772066200},{"_id":"source/images/image-search/qdrant.png","hash":"0c42f079a8b35f9fe8da6c3b3cf3180e9d603c62","modified":1717773798375},{"_id":"source/images/task-completion-source/bg.jpg","hash":"762d9571bdc71e36879c00907cb524e825980694","modified":1718067987009},{"_id":"source/images/image-search/bg.jpg","hash":"a02f0b66241373b0fb83610977010c41297c6985","modified":1718069912767},{"_id":"source/images/proxy/forward-proxy.png","hash":"49892dfa05b23599732f106b70b44fa95bc2eaa5","modified":1718888217801},{"_id":"source/images/proxy/reverse-proxy.png","hash":"57444303e4d4327cd1ebaedd3d954dfcf2486b69","modified":1718888319294},{"_id":"source/images/proxy/transparent-proxy.png","hash":"e2bc2ee06dbfa33170ec3120277f21f4e3e503f9","modified":1718890992387},{"_id":"source/images/proxy/bg.jpg","hash":"c884b6efad5351ee2996fe0d18715fb27f7b3749","modified":1718931303461},{"_id":"source/_posts/docker-1.md","hash":"3f9d81f24d238d3b9a48b5ec67c5a65fb52388f8","modified":1720255588285},{"_id":"source/_posts/docker-2.md","hash":"a75951a67f13186efc0b09411b6255a83af11df5","modified":1720444768360},{"_id":"source/images/docker-1/bg.png","hash":"e3b82c04b261788b6c333288578220dad894e135","modified":1720252982915},{"_id":"source/images/docker-1/configurations.png","hash":"c6f58a834400b5d6fff7c76249562888a908304c","modified":1720252449460},{"_id":"source/images/docker-1/multi-env.png","hash":"a8aa3cdee473ee5987c28a30c4def6b06b1c4708","modified":1720253343754},{"_id":"source/images/docker-2/before.png","hash":"4d6df539061278c5a371d63bbf494a54ac390588","modified":1720419780264},{"_id":"source/images/docker-2/after.png","hash":"2aa4ca9b53dc8a4270e3174115fcf96887185f64","modified":1720439019007},{"_id":"source/_posts/rabbitmq-basic.md","hash":"9d43ee83b6448cbc3cfd9e77099ab1ee31027684","modified":1720615377682},{"_id":"source/images/rabbitmq-basic/default-exchange.png","hash":"da48c3eae865c3758c2998b9234193ef1c52e26c","modified":1720515775722},{"_id":"source/images/docker-2/inspect3.png","hash":"e8523ef78b9823458520eb25300303381b046a8e","modified":1720441204166},{"_id":"source/images/docker-2/inspect2.png","hash":"30515858e2dddad39c76f016c55a02af8f639856","modified":1720441069919},{"_id":"source/images/docker-2/inspect1.png","hash":"e818b04708ae3c4ffa2ca0e3e890c5d2d4c0bb05","modified":1720441093812},{"_id":"source/images/rabbitmq-basic/fanout.png","hash":"6458eb591f42ff61e67364d480c4b2c0dc1ff3bf","modified":1720524567852},{"_id":"source/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","hash":"ec548510fb86ab373be5decbb3f65896813d048b","modified":1720517279179},{"_id":"source/images/rabbitmq-basic/direct-exchange.svg","hash":"e1e7e8648d3c479c2b4223af6be07e434ea62730","modified":1720612845887},{"_id":"source/images/rabbitmq-basic/fanout-exchange.svg","hash":"5e14973b4eba3986a1805c585260d34e781c512a","modified":1720612870539},{"_id":"source/images/rabbitmq-basic/main.png","hash":"e45cabff6e1cc9ea8477412977a49277b9656faa","modified":1720530900322},{"_id":"source/images/rabbitmq-basic/channel1.png","hash":"fcde762d9619fe15b3fbdbe32455dfee9214dee0","modified":1720580078238},{"_id":"source/images/rabbitmq-basic/channel2.png","hash":"f09e7365fd1026393f0b89777406570fbb1be70b","modified":1720580479287},{"_id":"source/images/rabbitmq-basic/topic-exchange.svg","hash":"ed3868a0efc180866dca5c7ba33cb6797ad96bc5","modified":1720612864235},{"_id":"source/images/rabbitmq-basic/rabbitmq-headers-exchange.svg","hash":"b9983fdc354c45500fcfe57e9f78ab4cb88a2c4d","modified":1720612881431},{"_id":"source/images/rabbitmq-basic/fanout.mp4","hash":"132a8c24996e91d19467bff53d9fb453c609cb79","modified":1720611325113},{"_id":"source/images/rabbitmq-basic/vro2s-b2mub.gif","hash":"70b8ce43edd1599dd11a8c8dd529c26405323082","modified":1720612469268},{"_id":"source/images/rabbitmq-basic/16elk-ujaxc.gif","hash":"0b01075739b5d1b96d35a878bf55ff2575b50d41","modified":1720527427526},{"_id":"source/_posts/rabbitmq-quorum.md","hash":"01529732ac69c5892cb1c977a36b8093fed2fe84","modified":1720857305748},{"_id":"source/images/rabbitmq-quarum/quarum1.png","hash":"e24787c731793ab83bc335c08dcf21060babd92d","modified":1720704401188},{"_id":"source/images/rabbitmq-quarum/quarum2.png","hash":"7c88c03d166aee001257f3fe29918c29ff0df8bb","modified":1720680123566},{"_id":"source/images/rabbitmq-quarum/normal.png","hash":"7a81405dc9d73b0a7cdff3b685c35853bad1cb1a","modified":1720679165151},{"_id":"source/images/rabbitmq-quarum/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1720774060906},{"_id":"source/_posts/daemonset.md","hash":"dc1479c32a9a1a5ffb3bb5fe01ffcef631e01353","modified":1722586430320},{"_id":"source/images/daemonset/daemonset-1.png","hash":"30bd683b3eba29092f63bb3c3d1b3742a94706e4","modified":1722562440090},{"_id":"source/images/rabbitmq-quarum/stream_error1.png","hash":"ce4c9e1a9a9da1cb4278e2e74be852611c8c265d","modified":1720855445532},{"_id":"source/images/rabbitmq-quarum/stream_error2.png","hash":"0d84d8d3ae357383925c86c728d865ce461bce8b","modified":1720855694734},{"_id":"source/images/rabbitmq-quarum/stream_offset.png","hash":"156f277e1c766644c8704892454397fc113f153d","modified":1720856674850},{"_id":"source/images/daemonset/DaemonSets.png","hash":"b2d8cb6e9f9a3246d70a6c4f1fa6656c6128eb67","modified":1722580496257},{"_id":"source/images/daemonset/daemonset-pods.png","hash":"ffc713e43daebc3db7fbcde65c154bfc0c4e5148","modified":1722586245355},{"_id":"source/images/daemonset/nodes.png","hash":"9ddeb9b6441cfee33edce7aa99af8058c7a291b1","modified":1722586074002},{"_id":"source/images/daemonset/bg.png","hash":"b1603478da28b1f0e9b0f1e54d6eca8e30537b4b","modified":1722579353097}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"欢迎来到 ITProHub！","_content":"![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/hello-world.md","raw":"---\ntitle: 欢迎来到 ITProHub！\n---\n![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"hello-world","published":1,"date":"2024-03-13T07:54:13.172Z","updated":"2024-04-26T03:07:16.002Z","_id":"cltwq4btx0000f4p1f3yha908","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"深入理解 HTTP Connection 头","date":"2024-03-19T08:11:52.000Z","_content":"HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/http.md","raw":"---\ntitle: 深入理解 HTTP Connection 头\ndate: 2024-03-19 16:11:52\ntags: http http协议 Connection\n---\nHTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"http","published":1,"updated":"2024-04-26T03:06:44.259Z","_id":"cltzedeaa0000d0p1ajbjc7gt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"组织发展致命杀手：内耗","date":"2024-03-28T09:49:50.000Z","_content":"\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/organization-internal-loss.md","raw":"---\ntitle: 组织发展致命杀手：内耗\ndate: 2024-03-28 17:49:50\ntags: 组织 内耗\n---\n\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"organization-internal-loss","published":1,"updated":"2024-04-26T03:06:35.957Z","_id":"cluc17m5x0000qsp19fjj1lmy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Garnet，缓存的新选择！","date":"2024-04-07T07:24:24.000Z","_content":"\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/garnet.md","raw":"---\ntitle: Garnet，缓存的新选择！\ndate: 2024-04-07 15:24:24\ntags: Garnet 缓存 微软\n---\n\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"garnet","published":1,"updated":"2024-04-26T03:07:22.478Z","_id":"clup9vupa0000okp14bz96eiy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"HTTPS的工作原理以及安装","date":"2024-04-11T07:36:46.000Z","_content":"\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/https.md","raw":"---\ntitle: HTTPS的工作原理以及安装\ndate: 2024-04-11 15:36:46\ntags: https http ssl tls\n---\n\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"https","published":1,"updated":"2024-04-26T03:06:40.272Z","_id":"cluuzgyxx000088p1frvnfrom","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Redis成长记 - Redis的陷阱（一）","date":"2024-04-18T07:09:28.000Z","_content":"相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/redis-interview-1.md","raw":"---\ntitle: Redis成长记 - Redis的陷阱（一）\ndate: 2024-04-18 15:09:28\ntags: redis 面试 求职\n---\n相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"redis-interview-1","published":1,"updated":"2024-04-26T03:31:26.087Z","_id":"clv5zlgr50003fcp11585dpte","comments":1,"layout":"post","photos":[],"link":"","content":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Dump分析入门指南","date":"2024-04-28T06:18:14.000Z","_content":"\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","source":"_posts/dump.md","raw":"---\ntitle: Dump分析入门指南\ndate: 2024-04-28 14:18:14\ntags: dump 性能 异常\n---\n\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","slug":"dump","published":1,"updated":"2024-05-08T08:37:58.693Z","_id":"clvj8jhdc0000pop171ud7xg2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n"},{"title":"深入解析消息队列中的死信队列","date":"2024-05-22T07:37:54.000Z","_content":"\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","source":"_posts/dead-message.md","raw":"---\ntitle: 深入解析消息队列中的死信队列\ndate: 2024-05-22 15:37:54\ntags:\n---\n\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","slug":"dead-message","published":1,"updated":"2024-05-25T09:23:07.803Z","_id":"clwhmpusl0000asp18nsiccvg","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n"},{"title":"C# 学习笔记： TaskCompletionSource","date":"2024-05-30T00:52:16.000Z","published":1,"_content":"\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/TaskCompletionSource.md","raw":"---\ntitle: C# 学习笔记： TaskCompletionSource\ndate: 2024-05-30 08:52:16\npublished: true\ntags:\n---\n\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"TaskCompletionSource","updated":"2024-06-06T07:22:36.858Z","_id":"clwsyjjsh00003wp1ctwte4zb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"从零开始搭建自己的相似图片搜索引擎","date":"2024-05-30T08:02:51.000Z","_content":"\n之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。\n功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。\n\n本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n![流程](/images/image-search/process.png)\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。\n从WB获取图片，保存到本地，那么我们第一步就算是完成了。\n\n  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。\n\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n# 嵌入\n这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。\n\n我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B/32 变体。\n详细的文档可以参考[《clip》](https://github.com/openai/CLIP)\n```python\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\n\n# 创建或获取一个集合\ncollection_name = 'image_vectors'\n\n# 遍历图片文件夹中的所有图片\nfor image_name in os.listdir(source_folder):\n    image_path = os.path.join(source_folder, image_name)\n    \n    # 确保文件是图片\n    if os.path.isfile(image_path) and image_name.lower().endswith(('png', 'jpg', 'jpeg', 'bmp', 'gif')):\n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 搜索相似结果\n        point = rest.PointStruct(\n            id=point_id,\n            vector=image_features,\n            payload={'file_name': image_name}\n        )\n        \n        # 将向量存储到Qdrant\n\n        # TODO 移动图片到目标文件夹        \n```\n做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。\n![图片](/images/image-search/qdrant.png)\n\n# 前端页面\n既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。\n所以我们的主要实现步骤有一下几个：\n1. 上传图片；\n2. 计算图片向量；\n3. 搜索相似图片；\n4. 返回相似图片；\n\n为了快速兑现功能，这里我也直接用python实现了一个简单的demo\n```python\napp = Flask(__name__)\nUPLOAD_FOLDER = 'uploads'\nCLIPPED_FOLDER = 'image_scraper/images/clipped'\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\ncollection_name = 'image_vectors'\n\n# 检查集合是否存在，如果不存在则创建\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return \"No file part\", 400\n    file = request.files['file']\n    if file.filename == '':\n        return \"No selected file\", 400\n    if file and allowed_file(file.filename):\n        \n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 在Qdrant中搜索相似图片\n        search_result = qdrant_client.search(\n            collection_name=collection_name,\n            query_vector=image_features,\n            limit=5  # 设置返回的结果数量\n        )\n\n        # 获取相似图片的文件名\n        similar_images = [hit.payload['file_name'] for hit in search_result]\n        \n        return render_template('result.html', images=similar_images)\n    return \"File not allowed\", 400\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n```\n\n\n最终的结果，大功告成！\n![图片](/images/image-search/search.gif)\n\n# 总结\n通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。\n\n这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。\n\n希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/similar-image-search.md","raw":"---\ntitle: 从零开始搭建自己的相似图片搜索引擎\ndate: 2024-05-30 16:02:51\ntags:\n---\n\n之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。\n功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。\n\n本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n![流程](/images/image-search/process.png)\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。\n从WB获取图片，保存到本地，那么我们第一步就算是完成了。\n\n  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。\n\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n# 嵌入\n这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。\n\n我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B/32 变体。\n详细的文档可以参考[《clip》](https://github.com/openai/CLIP)\n```python\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\n\n# 创建或获取一个集合\ncollection_name = 'image_vectors'\n\n# 遍历图片文件夹中的所有图片\nfor image_name in os.listdir(source_folder):\n    image_path = os.path.join(source_folder, image_name)\n    \n    # 确保文件是图片\n    if os.path.isfile(image_path) and image_name.lower().endswith(('png', 'jpg', 'jpeg', 'bmp', 'gif')):\n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 搜索相似结果\n        point = rest.PointStruct(\n            id=point_id,\n            vector=image_features,\n            payload={'file_name': image_name}\n        )\n        \n        # 将向量存储到Qdrant\n\n        # TODO 移动图片到目标文件夹        \n```\n做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。\n![图片](/images/image-search/qdrant.png)\n\n# 前端页面\n既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。\n所以我们的主要实现步骤有一下几个：\n1. 上传图片；\n2. 计算图片向量；\n3. 搜索相似图片；\n4. 返回相似图片；\n\n为了快速兑现功能，这里我也直接用python实现了一个简单的demo\n```python\napp = Flask(__name__)\nUPLOAD_FOLDER = 'uploads'\nCLIPPED_FOLDER = 'image_scraper/images/clipped'\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\ncollection_name = 'image_vectors'\n\n# 检查集合是否存在，如果不存在则创建\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return \"No file part\", 400\n    file = request.files['file']\n    if file.filename == '':\n        return \"No selected file\", 400\n    if file and allowed_file(file.filename):\n        \n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 在Qdrant中搜索相似图片\n        search_result = qdrant_client.search(\n            collection_name=collection_name,\n            query_vector=image_features,\n            limit=5  # 设置返回的结果数量\n        )\n\n        # 获取相似图片的文件名\n        similar_images = [hit.payload['file_name'] for hit in search_result]\n        \n        return render_template('result.html', images=similar_images)\n    return \"File not allowed\", 400\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n```\n\n\n最终的结果，大功告成！\n![图片](/images/image-search/search.gif)\n\n# 总结\n通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。\n\n这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。\n\n希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"similar-image-search","published":1,"updated":"2024-06-07T15:31:38.746Z","_id":"clx2wbfft0000usp1aprk4rln","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。<br>功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。</p>\n<p>本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；<br><img src=\"/images/image-search/process.png\" alt=\"流程\"></li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。<br>从WB获取图片，保存到本地，那么我们第一步就算是完成了。</p>\n<p>  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。</p>\n<p>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/images/image-search/images.png\" alt=\"图片\"></p>\n<h1 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h1><p>这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。</p>\n<p>我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B&#x2F;32 变体。<br>详细的文档可以参考<a href=\"https://github.com/openai/CLIP\">《clip》</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建或获取一个集合</span></span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历图片文件夹中的所有图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> image_name <span class=\"keyword\">in</span> os.listdir(source_folder):</span><br><span class=\"line\">    image_path = os.path.join(source_folder, image_name)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 确保文件是图片</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.isfile(image_path) <span class=\"keyword\">and</span> image_name.lower().endswith((<span class=\"string\">&#x27;png&#x27;</span>, <span class=\"string\">&#x27;jpg&#x27;</span>, <span class=\"string\">&#x27;jpeg&#x27;</span>, <span class=\"string\">&#x27;bmp&#x27;</span>, <span class=\"string\">&#x27;gif&#x27;</span>)):</span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 搜索相似结果</span></span><br><span class=\"line\">        point = rest.PointStruct(</span><br><span class=\"line\">            <span class=\"built_in\">id</span>=point_id,</span><br><span class=\"line\">            vector=image_features,</span><br><span class=\"line\">            payload=&#123;<span class=\"string\">&#x27;file_name&#x27;</span>: image_name&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将向量存储到Qdrant</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># TODO 移动图片到目标文件夹        </span></span><br></pre></td></tr></table></figure>\n<p>做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。<br><img src=\"/images/image-search/qdrant.png\" alt=\"图片\"></p>\n<h1 id=\"前端页面\"><a href=\"#前端页面\" class=\"headerlink\" title=\"前端页面\"></a>前端页面</h1><p>既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。<br>所以我们的主要实现步骤有一下几个：</p>\n<ol>\n<li>上传图片；</li>\n<li>计算图片向量；</li>\n<li>搜索相似图片；</li>\n<li>返回相似图片；</li>\n</ol>\n<p>为了快速兑现功能，这里我也直接用python实现了一个简单的demo</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">UPLOAD_FOLDER = <span class=\"string\">&#x27;uploads&#x27;</span></span><br><span class=\"line\">CLIPPED_FOLDER = <span class=\"string\">&#x27;image_scraper/images/clipped&#x27;</span></span><br><span class=\"line\">os.makedirs(UPLOAD_FOLDER, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查集合是否存在，如果不存在则创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;index.html&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/upload&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_file</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;file&#x27;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.files:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No file part&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    file = request.files[<span class=\"string\">&#x27;file&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.filename == <span class=\"string\">&#x27;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No selected file&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> file <span class=\"keyword\">and</span> allowed_file(file.filename):</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 在Qdrant中搜索相似图片</span></span><br><span class=\"line\">        search_result = qdrant_client.search(</span><br><span class=\"line\">            collection_name=collection_name,</span><br><span class=\"line\">            query_vector=image_features,</span><br><span class=\"line\">            limit=<span class=\"number\">5</span>  <span class=\"comment\"># 设置返回的结果数量</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取相似图片的文件名</span></span><br><span class=\"line\">        similar_images = [hit.payload[<span class=\"string\">&#x27;file_name&#x27;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;result.html&#x27;</span>, images=similar_images)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;File not allowed&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>最终的结果，大功告成！<br><img src=\"/images/image-search/search.gif\" alt=\"图片\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。</p>\n<p>这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。</p>\n<p>希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。<br>功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。</p>\n<p>本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；<br><img src=\"/images/image-search/process.png\" alt=\"流程\"></li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。<br>从WB获取图片，保存到本地，那么我们第一步就算是完成了。</p>\n<p>  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。</p>\n<p>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/images/image-search/images.png\" alt=\"图片\"></p>\n<h1 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h1><p>这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。</p>\n<p>我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B&#x2F;32 变体。<br>详细的文档可以参考<a href=\"https://github.com/openai/CLIP\">《clip》</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建或获取一个集合</span></span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历图片文件夹中的所有图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> image_name <span class=\"keyword\">in</span> os.listdir(source_folder):</span><br><span class=\"line\">    image_path = os.path.join(source_folder, image_name)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 确保文件是图片</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.isfile(image_path) <span class=\"keyword\">and</span> image_name.lower().endswith((<span class=\"string\">&#x27;png&#x27;</span>, <span class=\"string\">&#x27;jpg&#x27;</span>, <span class=\"string\">&#x27;jpeg&#x27;</span>, <span class=\"string\">&#x27;bmp&#x27;</span>, <span class=\"string\">&#x27;gif&#x27;</span>)):</span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 搜索相似结果</span></span><br><span class=\"line\">        point = rest.PointStruct(</span><br><span class=\"line\">            <span class=\"built_in\">id</span>=point_id,</span><br><span class=\"line\">            vector=image_features,</span><br><span class=\"line\">            payload=&#123;<span class=\"string\">&#x27;file_name&#x27;</span>: image_name&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将向量存储到Qdrant</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># TODO 移动图片到目标文件夹        </span></span><br></pre></td></tr></table></figure>\n<p>做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。<br><img src=\"/images/image-search/qdrant.png\" alt=\"图片\"></p>\n<h1 id=\"前端页面\"><a href=\"#前端页面\" class=\"headerlink\" title=\"前端页面\"></a>前端页面</h1><p>既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。<br>所以我们的主要实现步骤有一下几个：</p>\n<ol>\n<li>上传图片；</li>\n<li>计算图片向量；</li>\n<li>搜索相似图片；</li>\n<li>返回相似图片；</li>\n</ol>\n<p>为了快速兑现功能，这里我也直接用python实现了一个简单的demo</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">UPLOAD_FOLDER = <span class=\"string\">&#x27;uploads&#x27;</span></span><br><span class=\"line\">CLIPPED_FOLDER = <span class=\"string\">&#x27;image_scraper/images/clipped&#x27;</span></span><br><span class=\"line\">os.makedirs(UPLOAD_FOLDER, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查集合是否存在，如果不存在则创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;index.html&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/upload&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_file</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;file&#x27;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.files:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No file part&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    file = request.files[<span class=\"string\">&#x27;file&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.filename == <span class=\"string\">&#x27;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No selected file&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> file <span class=\"keyword\">and</span> allowed_file(file.filename):</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 在Qdrant中搜索相似图片</span></span><br><span class=\"line\">        search_result = qdrant_client.search(</span><br><span class=\"line\">            collection_name=collection_name,</span><br><span class=\"line\">            query_vector=image_features,</span><br><span class=\"line\">            limit=<span class=\"number\">5</span>  <span class=\"comment\"># 设置返回的结果数量</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取相似图片的文件名</span></span><br><span class=\"line\">        similar_images = [hit.payload[<span class=\"string\">&#x27;file_name&#x27;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;result.html&#x27;</span>, images=similar_images)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;File not allowed&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>最终的结果，大功告成！<br><img src=\"/images/image-search/search.gif\" alt=\"图片\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。</p>\n<p>这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。</p>\n<p>希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"代理服务解析：正向代理、反向代理和透明代理","date":"2024-06-20T02:06:56.000Z","_content":"\n在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。\n\n然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。\n\n# 什么是代理服务器？\n代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。\n\n# 正向代理\n## 定义\n正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。\n\n## 工作原理\n![正向代理](/images/proxy/forward-proxy.png)\n1. 客户端向代理服务器发送请求。\n2. 代理服务器向目标服务器转发请求。\n3. 目标服务器响应代理服务器。\n4. 代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。\n2. 缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。\n3. 匿名性：隐藏客户端的真实IP地址，保护隐私。\n\n## 示例代码\n```\n# 简单的正向代理示例（Python）\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport requests\n\nclass Proxy(BaseHTTPRequestHandler):\n    def do_GET(self):\n        url = self.path[1:]\n        response = requests.get(url)\n        self.send_response(response.status_code)\n        self.send_header('Content-type', response.headers['Content-Type'])\n        self.end_headers()\n        self.wfile.write(response.content)\n\nif __name__ == \"__main__\":\n    server = HTTPServer(('localhost', 8080), Proxy)\n    print(\"Starting proxy server on port 8080\")\n    server.serve_forever()\n\n```\n\n# 反向代理\n## 定义\n反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。\n\n尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。\n反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。\n\n## 反向代理和正向代理的相似之处\n正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。\n正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。\n正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。\n也可以使用相同的软件来配置正向和反向代理。\n\n例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。\n\n## 工作原理\n![反向代理](/images/proxy/reverse-proxy.png)\n1. 客户端向反向代理服务器发送请求。\n2. 反向代理服务器向内部服务器转发请求。\n3. 内部服务器响应反向代理服务器。\n4. 反向代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。\n2. 安全性：隐藏内部服务器的IP地址，增加安全性。\n3. SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。\n\n## 示例\n```\n# Nginx 反向代理配置示例\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend_server;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n\n# 透明代理\n## 定义\n透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。\n\n透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。\n\n透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。\n\n## 工作原理\n![反向代理](/images/proxy/transparent-proxy.png)\n1. 客户端向目标服务器发送请求。\n2. 透明代理截获并转发请求。\n3. 目标服务器响应请求。\n4. 透明代理截获并转发响应。\n\n## 应用场景\n1. 监控和过滤：用于网络监控、过滤和记录网络流量。\n2. 缓存：透明代理缓存常用内容，提高访问速度。\n3. 访问控制：控制对特定网站或服务的访问。\n\n## 示例代码\n```shell\n# 使用iptables设置透明代理\n# 假设代理服务器IP为192.168.1.1，目标端口为8080\niptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080\niptables -t nat -A POSTROUTING -j MASQUERADE\n```\n\n# 总结\n代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。","source":"_posts/proxy.md","raw":"---\ntitle: 代理服务解析：正向代理、反向代理和透明代理\ndate: 2024-06-20 10:06:56\ntags:\n---\n\n在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。\n\n然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。\n\n# 什么是代理服务器？\n代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。\n\n# 正向代理\n## 定义\n正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。\n\n## 工作原理\n![正向代理](/images/proxy/forward-proxy.png)\n1. 客户端向代理服务器发送请求。\n2. 代理服务器向目标服务器转发请求。\n3. 目标服务器响应代理服务器。\n4. 代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。\n2. 缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。\n3. 匿名性：隐藏客户端的真实IP地址，保护隐私。\n\n## 示例代码\n```\n# 简单的正向代理示例（Python）\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport requests\n\nclass Proxy(BaseHTTPRequestHandler):\n    def do_GET(self):\n        url = self.path[1:]\n        response = requests.get(url)\n        self.send_response(response.status_code)\n        self.send_header('Content-type', response.headers['Content-Type'])\n        self.end_headers()\n        self.wfile.write(response.content)\n\nif __name__ == \"__main__\":\n    server = HTTPServer(('localhost', 8080), Proxy)\n    print(\"Starting proxy server on port 8080\")\n    server.serve_forever()\n\n```\n\n# 反向代理\n## 定义\n反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。\n\n尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。\n反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。\n\n## 反向代理和正向代理的相似之处\n正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。\n正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。\n正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。\n也可以使用相同的软件来配置正向和反向代理。\n\n例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。\n\n## 工作原理\n![反向代理](/images/proxy/reverse-proxy.png)\n1. 客户端向反向代理服务器发送请求。\n2. 反向代理服务器向内部服务器转发请求。\n3. 内部服务器响应反向代理服务器。\n4. 反向代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。\n2. 安全性：隐藏内部服务器的IP地址，增加安全性。\n3. SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。\n\n## 示例\n```\n# Nginx 反向代理配置示例\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend_server;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n\n# 透明代理\n## 定义\n透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。\n\n透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。\n\n透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。\n\n## 工作原理\n![反向代理](/images/proxy/transparent-proxy.png)\n1. 客户端向目标服务器发送请求。\n2. 透明代理截获并转发请求。\n3. 目标服务器响应请求。\n4. 透明代理截获并转发响应。\n\n## 应用场景\n1. 监控和过滤：用于网络监控、过滤和记录网络流量。\n2. 缓存：透明代理缓存常用内容，提高访问速度。\n3. 访问控制：控制对特定网站或服务的访问。\n\n## 示例代码\n```shell\n# 使用iptables设置透明代理\n# 假设代理服务器IP为192.168.1.1，目标端口为8080\niptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080\niptables -t nat -A POSTROUTING -j MASQUERADE\n```\n\n# 总结\n代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。","slug":"proxy","published":1,"updated":"2024-06-21T01:04:32.131Z","_id":"clxn8zmh40000qop1ci6hbdrd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。</p>\n<p>然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。</p>\n<h1 id=\"什么是代理服务器？\"><a href=\"#什么是代理服务器？\" class=\"headerlink\" title=\"什么是代理服务器？\"></a>什么是代理服务器？</h1><p>代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。</p>\n<h1 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/forward-proxy.png\" alt=\"正向代理\"></p>\n<ol>\n<li>客户端向代理服务器发送请求。</li>\n<li>代理服务器向目标服务器转发请求。</li>\n<li>目标服务器响应代理服务器。</li>\n<li>代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。</li>\n<li>缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。</li>\n<li>匿名性：隐藏客户端的真实IP地址，保护隐私。</li>\n</ol>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 简单的正向代理示例（Python）</span><br><span class=\"line\">from http.server import BaseHTTPRequestHandler, HTTPServer</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy(BaseHTTPRequestHandler):</span><br><span class=\"line\">    def do_GET(self):</span><br><span class=\"line\">        url = self.path[1:]</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\">        self.send_response(response.status_code)</span><br><span class=\"line\">        self.send_header(&#x27;Content-type&#x27;, response.headers[&#x27;Content-Type&#x27;])</span><br><span class=\"line\">        self.end_headers()</span><br><span class=\"line\">        self.wfile.write(response.content)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    server = HTTPServer((&#x27;localhost&#x27;, 8080), Proxy)</span><br><span class=\"line\">    print(&quot;Starting proxy server on port 8080&quot;)</span><br><span class=\"line\">    server.serve_forever()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。</p>\n<p>尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。<br>反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。</p>\n<h2 id=\"反向代理和正向代理的相似之处\"><a href=\"#反向代理和正向代理的相似之处\" class=\"headerlink\" title=\"反向代理和正向代理的相似之处\"></a>反向代理和正向代理的相似之处</h2><p>正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。<br>正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。<br>正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。<br>也可以使用相同的软件来配置正向和反向代理。</p>\n<p>例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。</p>\n<h2 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/reverse-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向反向代理服务器发送请求。</li>\n<li>反向代理服务器向内部服务器转发请求。</li>\n<li>内部服务器响应反向代理服务器。</li>\n<li>反向代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。</li>\n<li>安全性：隐藏内部服务器的IP地址，增加安全性。</li>\n<li>SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Nginx 反向代理配置示例</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://backend_server;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。</p>\n<p>透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。</p>\n<p>透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。</p>\n<h2 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/transparent-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向目标服务器发送请求。</li>\n<li>透明代理截获并转发请求。</li>\n<li>目标服务器响应请求。</li>\n<li>透明代理截获并转发响应。</li>\n</ol>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>监控和过滤：用于网络监控、过滤和记录网络流量。</li>\n<li>缓存：透明代理缓存常用内容，提高访问速度。</li>\n<li>访问控制：控制对特定网站或服务的访问。</li>\n</ol>\n<h2 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用iptables设置透明代理</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">假设代理服务器IP为192.168.1.1，目标端口为8080</span></span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。</p>\n<p>然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。</p>\n<h1 id=\"什么是代理服务器？\"><a href=\"#什么是代理服务器？\" class=\"headerlink\" title=\"什么是代理服务器？\"></a>什么是代理服务器？</h1><p>代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。</p>\n<h1 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/forward-proxy.png\" alt=\"正向代理\"></p>\n<ol>\n<li>客户端向代理服务器发送请求。</li>\n<li>代理服务器向目标服务器转发请求。</li>\n<li>目标服务器响应代理服务器。</li>\n<li>代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。</li>\n<li>缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。</li>\n<li>匿名性：隐藏客户端的真实IP地址，保护隐私。</li>\n</ol>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 简单的正向代理示例（Python）</span><br><span class=\"line\">from http.server import BaseHTTPRequestHandler, HTTPServer</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy(BaseHTTPRequestHandler):</span><br><span class=\"line\">    def do_GET(self):</span><br><span class=\"line\">        url = self.path[1:]</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\">        self.send_response(response.status_code)</span><br><span class=\"line\">        self.send_header(&#x27;Content-type&#x27;, response.headers[&#x27;Content-Type&#x27;])</span><br><span class=\"line\">        self.end_headers()</span><br><span class=\"line\">        self.wfile.write(response.content)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    server = HTTPServer((&#x27;localhost&#x27;, 8080), Proxy)</span><br><span class=\"line\">    print(&quot;Starting proxy server on port 8080&quot;)</span><br><span class=\"line\">    server.serve_forever()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。</p>\n<p>尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。<br>反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。</p>\n<h2 id=\"反向代理和正向代理的相似之处\"><a href=\"#反向代理和正向代理的相似之处\" class=\"headerlink\" title=\"反向代理和正向代理的相似之处\"></a>反向代理和正向代理的相似之处</h2><p>正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。<br>正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。<br>正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。<br>也可以使用相同的软件来配置正向和反向代理。</p>\n<p>例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。</p>\n<h2 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/reverse-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向反向代理服务器发送请求。</li>\n<li>反向代理服务器向内部服务器转发请求。</li>\n<li>内部服务器响应反向代理服务器。</li>\n<li>反向代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。</li>\n<li>安全性：隐藏内部服务器的IP地址，增加安全性。</li>\n<li>SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Nginx 反向代理配置示例</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://backend_server;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。</p>\n<p>透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。</p>\n<p>透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。</p>\n<h2 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/transparent-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向目标服务器发送请求。</li>\n<li>透明代理截获并转发请求。</li>\n<li>目标服务器响应请求。</li>\n<li>透明代理截获并转发响应。</li>\n</ol>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>监控和过滤：用于网络监控、过滤和记录网络流量。</li>\n<li>缓存：透明代理缓存常用内容，提高访问速度。</li>\n<li>访问控制：控制对特定网站或服务的访问。</li>\n</ol>\n<h2 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用iptables设置透明代理</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">假设代理服务器IP为192.168.1.1，目标端口为8080</span></span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。</p>\n"},{"title":"Docker隐藏在细节中的技术基础","date":"2024-07-05T11:59:06.000Z","_content":"## 引言\nDocker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。\n\n开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转[Docker教程](https://www.runoob.com/docker/docker-tutorial.html)\n\n## 为什么需要Docker\n![multi-envs](/images/docker-1/multi-env.png)\n软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？\n\n用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。\n\n如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：\"它在我的机器上是正常的呀\"，言下之意就是，其他机器很可能跑不了。\n\n环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。\n\n## 虚拟机与容器：理解深层次差异\n### 资源隔离与共享\n+ 虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。\n+ 容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。\n\n### 常见误区：容器的隔离性\n很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。\n\n## 文件系统与存储卷：隐形的性能瓶颈\n### Union File System\nDocker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。\n\n### 联合文件系统的分层结构\n联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。\n\n### 分层文件系统与写操作\n在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：\n\n1. 读取原始文件：从只读层读取文件内容。\n2. 复制到可写层：将读取的文件内容复制到可写层。\n3. 修改文件：在可写层中修改文件内容。\n\n### 性能下降的原因\n1. 写时复制操作\n每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I/O操作的开销，尤其是在频繁写入或修改大量文件时。\n\n2. 层次结构复杂性\n分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。\n\n3. 合并视图的开销\n联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。\n\n\n### 实际案例：大量文件写入操作\n如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。\n\n在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。\n\n```dockerfile\n# Dockerfile 示例\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nVOLUME /app/data\nCMD [\"python\", \"app.py\"]\n```\n\n在docker-compose.yml中配置卷挂载：\n\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    volumes:\n      - ./data:/app/data\n```\n\n## 网络与安全：看不见的陷阱\n### 网络模式选择\nDocker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。\n\n### 安全隐患：默认桥接网络\n默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。\n\n```bash\n# 创建用户自定义桥接网络\ndocker network create --driver bridge my_bridge_network\n\n# 启动容器时指定网络\ndocker run --network my_bridge_network my_app\n```\n\n## 镜像管理：隐形的资源浪费\n### 镜像层叠与大小控制\nDocker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。\n\n### 实践建议：定期清理\n定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n\n# 清理未使用的卷\ndocker volume prune\n\n# 清理未使用的网络\ndocker network prune\n```\n\n## 日志管理：忽视的存储负担\n### 日志驱动与存储策略\nDocker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。\n\n### 实践建议：日志轮转与外部存储\n配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n或者将日志发送到外部系统，如ELK堆栈：\n\n```json\n{\n  \"log-driver\": \"gelf\",\n  \"log-opts\": {\n    \"gelf-address\": \"udp://logstash:12201\"\n  }\n}\n```\n\n## 结语\n通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。\n\n***\n\n希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/docker-1.md","raw":"---\ntitle: Docker隐藏在细节中的技术基础\ndate: 2024-07-05 19:59:06\ntags:\n---\n## 引言\nDocker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。\n\n开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转[Docker教程](https://www.runoob.com/docker/docker-tutorial.html)\n\n## 为什么需要Docker\n![multi-envs](/images/docker-1/multi-env.png)\n软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？\n\n用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。\n\n如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：\"它在我的机器上是正常的呀\"，言下之意就是，其他机器很可能跑不了。\n\n环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。\n\n## 虚拟机与容器：理解深层次差异\n### 资源隔离与共享\n+ 虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。\n+ 容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。\n\n### 常见误区：容器的隔离性\n很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。\n\n## 文件系统与存储卷：隐形的性能瓶颈\n### Union File System\nDocker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。\n\n### 联合文件系统的分层结构\n联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。\n\n### 分层文件系统与写操作\n在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：\n\n1. 读取原始文件：从只读层读取文件内容。\n2. 复制到可写层：将读取的文件内容复制到可写层。\n3. 修改文件：在可写层中修改文件内容。\n\n### 性能下降的原因\n1. 写时复制操作\n每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I/O操作的开销，尤其是在频繁写入或修改大量文件时。\n\n2. 层次结构复杂性\n分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。\n\n3. 合并视图的开销\n联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。\n\n\n### 实际案例：大量文件写入操作\n如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。\n\n在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。\n\n```dockerfile\n# Dockerfile 示例\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nVOLUME /app/data\nCMD [\"python\", \"app.py\"]\n```\n\n在docker-compose.yml中配置卷挂载：\n\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    volumes:\n      - ./data:/app/data\n```\n\n## 网络与安全：看不见的陷阱\n### 网络模式选择\nDocker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。\n\n### 安全隐患：默认桥接网络\n默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。\n\n```bash\n# 创建用户自定义桥接网络\ndocker network create --driver bridge my_bridge_network\n\n# 启动容器时指定网络\ndocker run --network my_bridge_network my_app\n```\n\n## 镜像管理：隐形的资源浪费\n### 镜像层叠与大小控制\nDocker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。\n\n### 实践建议：定期清理\n定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n\n# 清理未使用的卷\ndocker volume prune\n\n# 清理未使用的网络\ndocker network prune\n```\n\n## 日志管理：忽视的存储负担\n### 日志驱动与存储策略\nDocker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。\n\n### 实践建议：日志轮转与外部存储\n配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n或者将日志发送到外部系统，如ELK堆栈：\n\n```json\n{\n  \"log-driver\": \"gelf\",\n  \"log-opts\": {\n    \"gelf-address\": \"udp://logstash:12201\"\n  }\n}\n```\n\n## 结语\n通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。\n\n***\n\n希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！","slug":"docker-1","published":1,"updated":"2024-07-06T08:46:28.285Z","_id":"cly9sj5hb00002wp1b9ose1ha","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Docker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。</p>\n<p>开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转<a href=\"https://www.runoob.com/docker/docker-tutorial.html\">Docker教程</a></p>\n<h2 id=\"为什么需要Docker\"><a href=\"#为什么需要Docker\" class=\"headerlink\" title=\"为什么需要Docker\"></a>为什么需要Docker</h2><p><img src=\"/images/docker-1/multi-env.png\" alt=\"multi-envs\"><br>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？</p>\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。</p>\n<p>如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：”它在我的机器上是正常的呀”，言下之意就是，其他机器很可能跑不了。</p>\n<p>环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n<h2 id=\"虚拟机与容器：理解深层次差异\"><a href=\"#虚拟机与容器：理解深层次差异\" class=\"headerlink\" title=\"虚拟机与容器：理解深层次差异\"></a>虚拟机与容器：理解深层次差异</h2><h3 id=\"资源隔离与共享\"><a href=\"#资源隔离与共享\" class=\"headerlink\" title=\"资源隔离与共享\"></a>资源隔离与共享</h3><ul>\n<li>虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。</li>\n<li>容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。</li>\n</ul>\n<h3 id=\"常见误区：容器的隔离性\"><a href=\"#常见误区：容器的隔离性\" class=\"headerlink\" title=\"常见误区：容器的隔离性\"></a>常见误区：容器的隔离性</h3><p>很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。</p>\n<h2 id=\"文件系统与存储卷：隐形的性能瓶颈\"><a href=\"#文件系统与存储卷：隐形的性能瓶颈\" class=\"headerlink\" title=\"文件系统与存储卷：隐形的性能瓶颈\"></a>文件系统与存储卷：隐形的性能瓶颈</h2><h3 id=\"Union-File-System\"><a href=\"#Union-File-System\" class=\"headerlink\" title=\"Union File System\"></a>Union File System</h3><p>Docker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。</p>\n<h3 id=\"联合文件系统的分层结构\"><a href=\"#联合文件系统的分层结构\" class=\"headerlink\" title=\"联合文件系统的分层结构\"></a>联合文件系统的分层结构</h3><p>联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。</p>\n<h3 id=\"分层文件系统与写操作\"><a href=\"#分层文件系统与写操作\" class=\"headerlink\" title=\"分层文件系统与写操作\"></a>分层文件系统与写操作</h3><p>在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：</p>\n<ol>\n<li>读取原始文件：从只读层读取文件内容。</li>\n<li>复制到可写层：将读取的文件内容复制到可写层。</li>\n<li>修改文件：在可写层中修改文件内容。</li>\n</ol>\n<h3 id=\"性能下降的原因\"><a href=\"#性能下降的原因\" class=\"headerlink\" title=\"性能下降的原因\"></a>性能下降的原因</h3><ol>\n<li><p>写时复制操作<br>每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I&#x2F;O操作的开销，尤其是在频繁写入或修改大量文件时。</p>\n</li>\n<li><p>层次结构复杂性<br>分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。</p>\n</li>\n<li><p>合并视图的开销<br>联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。</p>\n</li>\n</ol>\n<h3 id=\"实际案例：大量文件写入操作\"><a href=\"#实际案例：大量文件写入操作\" class=\"headerlink\" title=\"实际案例：大量文件写入操作\"></a>实际案例：大量文件写入操作</h3><p>如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。</p>\n<p>在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile 示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/data</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>在docker-compose.yml中配置卷挂载：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data:/app/data</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络与安全：看不见的陷阱\"><a href=\"#网络与安全：看不见的陷阱\" class=\"headerlink\" title=\"网络与安全：看不见的陷阱\"></a>网络与安全：看不见的陷阱</h2><h3 id=\"网络模式选择\"><a href=\"#网络模式选择\" class=\"headerlink\" title=\"网络模式选择\"></a>网络模式选择</h3><p>Docker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。</p>\n<h3 id=\"安全隐患：默认桥接网络\"><a href=\"#安全隐患：默认桥接网络\" class=\"headerlink\" title=\"安全隐患：默认桥接网络\"></a>安全隐患：默认桥接网络</h3><p>默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户自定义桥接网络</span></span><br><span class=\"line\">docker network create --driver bridge my_bridge_network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时指定网络</span></span><br><span class=\"line\">docker run --network my_bridge_network my_app</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"镜像管理：隐形的资源浪费\"><a href=\"#镜像管理：隐形的资源浪费\" class=\"headerlink\" title=\"镜像管理：隐形的资源浪费\"></a>镜像管理：隐形的资源浪费</h2><h3 id=\"镜像层叠与大小控制\"><a href=\"#镜像层叠与大小控制\" class=\"headerlink\" title=\"镜像层叠与大小控制\"></a>镜像层叠与大小控制</h3><p>Docker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。</p>\n<h3 id=\"实践建议：定期清理\"><a href=\"#实践建议：定期清理\" class=\"headerlink\" title=\"实践建议：定期清理\"></a>实践建议：定期清理</h3><p>定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的卷</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的网络</span></span><br><span class=\"line\">docker network prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志管理：忽视的存储负担\"><a href=\"#日志管理：忽视的存储负担\" class=\"headerlink\" title=\"日志管理：忽视的存储负担\"></a>日志管理：忽视的存储负担</h2><h3 id=\"日志驱动与存储策略\"><a href=\"#日志驱动与存储策略\" class=\"headerlink\" title=\"日志驱动与存储策略\"></a>日志驱动与存储策略</h3><p>Docker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。</p>\n<h3 id=\"实践建议：日志轮转与外部存储\"><a href=\"#实践建议：日志轮转与外部存储\" class=\"headerlink\" title=\"实践建议：日志轮转与外部存储\"></a>实践建议：日志轮转与外部存储</h3><p>配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>或者将日志发送到外部系统，如ELK堆栈：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gelf&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;gelf-address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;udp://logstash:12201&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。</p>\n<hr>\n<p>希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Docker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。</p>\n<p>开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转<a href=\"https://www.runoob.com/docker/docker-tutorial.html\">Docker教程</a></p>\n<h2 id=\"为什么需要Docker\"><a href=\"#为什么需要Docker\" class=\"headerlink\" title=\"为什么需要Docker\"></a>为什么需要Docker</h2><p><img src=\"/images/docker-1/multi-env.png\" alt=\"multi-envs\"><br>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？</p>\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。</p>\n<p>如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：”它在我的机器上是正常的呀”，言下之意就是，其他机器很可能跑不了。</p>\n<p>环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n<h2 id=\"虚拟机与容器：理解深层次差异\"><a href=\"#虚拟机与容器：理解深层次差异\" class=\"headerlink\" title=\"虚拟机与容器：理解深层次差异\"></a>虚拟机与容器：理解深层次差异</h2><h3 id=\"资源隔离与共享\"><a href=\"#资源隔离与共享\" class=\"headerlink\" title=\"资源隔离与共享\"></a>资源隔离与共享</h3><ul>\n<li>虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。</li>\n<li>容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。</li>\n</ul>\n<h3 id=\"常见误区：容器的隔离性\"><a href=\"#常见误区：容器的隔离性\" class=\"headerlink\" title=\"常见误区：容器的隔离性\"></a>常见误区：容器的隔离性</h3><p>很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。</p>\n<h2 id=\"文件系统与存储卷：隐形的性能瓶颈\"><a href=\"#文件系统与存储卷：隐形的性能瓶颈\" class=\"headerlink\" title=\"文件系统与存储卷：隐形的性能瓶颈\"></a>文件系统与存储卷：隐形的性能瓶颈</h2><h3 id=\"Union-File-System\"><a href=\"#Union-File-System\" class=\"headerlink\" title=\"Union File System\"></a>Union File System</h3><p>Docker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。</p>\n<h3 id=\"联合文件系统的分层结构\"><a href=\"#联合文件系统的分层结构\" class=\"headerlink\" title=\"联合文件系统的分层结构\"></a>联合文件系统的分层结构</h3><p>联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。</p>\n<h3 id=\"分层文件系统与写操作\"><a href=\"#分层文件系统与写操作\" class=\"headerlink\" title=\"分层文件系统与写操作\"></a>分层文件系统与写操作</h3><p>在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：</p>\n<ol>\n<li>读取原始文件：从只读层读取文件内容。</li>\n<li>复制到可写层：将读取的文件内容复制到可写层。</li>\n<li>修改文件：在可写层中修改文件内容。</li>\n</ol>\n<h3 id=\"性能下降的原因\"><a href=\"#性能下降的原因\" class=\"headerlink\" title=\"性能下降的原因\"></a>性能下降的原因</h3><ol>\n<li><p>写时复制操作<br>每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I&#x2F;O操作的开销，尤其是在频繁写入或修改大量文件时。</p>\n</li>\n<li><p>层次结构复杂性<br>分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。</p>\n</li>\n<li><p>合并视图的开销<br>联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。</p>\n</li>\n</ol>\n<h3 id=\"实际案例：大量文件写入操作\"><a href=\"#实际案例：大量文件写入操作\" class=\"headerlink\" title=\"实际案例：大量文件写入操作\"></a>实际案例：大量文件写入操作</h3><p>如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。</p>\n<p>在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile 示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/data</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>在docker-compose.yml中配置卷挂载：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data:/app/data</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络与安全：看不见的陷阱\"><a href=\"#网络与安全：看不见的陷阱\" class=\"headerlink\" title=\"网络与安全：看不见的陷阱\"></a>网络与安全：看不见的陷阱</h2><h3 id=\"网络模式选择\"><a href=\"#网络模式选择\" class=\"headerlink\" title=\"网络模式选择\"></a>网络模式选择</h3><p>Docker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。</p>\n<h3 id=\"安全隐患：默认桥接网络\"><a href=\"#安全隐患：默认桥接网络\" class=\"headerlink\" title=\"安全隐患：默认桥接网络\"></a>安全隐患：默认桥接网络</h3><p>默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户自定义桥接网络</span></span><br><span class=\"line\">docker network create --driver bridge my_bridge_network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时指定网络</span></span><br><span class=\"line\">docker run --network my_bridge_network my_app</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"镜像管理：隐形的资源浪费\"><a href=\"#镜像管理：隐形的资源浪费\" class=\"headerlink\" title=\"镜像管理：隐形的资源浪费\"></a>镜像管理：隐形的资源浪费</h2><h3 id=\"镜像层叠与大小控制\"><a href=\"#镜像层叠与大小控制\" class=\"headerlink\" title=\"镜像层叠与大小控制\"></a>镜像层叠与大小控制</h3><p>Docker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。</p>\n<h3 id=\"实践建议：定期清理\"><a href=\"#实践建议：定期清理\" class=\"headerlink\" title=\"实践建议：定期清理\"></a>实践建议：定期清理</h3><p>定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的卷</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的网络</span></span><br><span class=\"line\">docker network prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志管理：忽视的存储负担\"><a href=\"#日志管理：忽视的存储负担\" class=\"headerlink\" title=\"日志管理：忽视的存储负担\"></a>日志管理：忽视的存储负担</h2><h3 id=\"日志驱动与存储策略\"><a href=\"#日志驱动与存储策略\" class=\"headerlink\" title=\"日志驱动与存储策略\"></a>日志驱动与存储策略</h3><p>Docker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。</p>\n<h3 id=\"实践建议：日志轮转与外部存储\"><a href=\"#实践建议：日志轮转与外部存储\" class=\"headerlink\" title=\"实践建议：日志轮转与外部存储\"></a>实践建议：日志轮转与外部存储</h3><p>配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>或者将日志发送到外部系统，如ELK堆栈：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gelf&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;gelf-address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;udp://logstash:12201&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。</p>\n<hr>\n<p>希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"Docker镜像构建优化","date":"2024-07-08T01:20:55.000Z","_content":"\n# 引言\n在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。\n\n# Dockerfile中的层定义\n在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。\n\n```dockerfile\n# 每一条指令都会创建一个新层\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\nCMD [\"python\", \"app.py\"]\n```\n上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。\n\n\n在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：\n\n1. 新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。\n\n2. 修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。\n\n3. 删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。\n\n4. 文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。\n\n为了更具体地说明，下面是一个示例Dockerfile及其解释：\n\n```dockerfile\nFROM ubuntu:20.04\n\n# 第一层\nRUN apt-get update && apt-get install -y curl\n\n# 第二层\nRUN echo \"Hello, World!\" > /hello.txt\n\n# 第三层\nRUN chmod 644 /hello.txt\n```\n在这个示例中，每个RUN指令都会创建一个新的层：\n\n1. 第一层：RUN apt-get update && apt-get install -y curl：\n- 这一层包含了更新包索引文件和安装curl工具所做的所有更改。\n- 新增了curl工具的相关文件和目录。\n- 修改了包管理器的状态文件。\n2. 第二层：RUN echo \"Hello, World!\" > /hello.txt：\n- 这一层包含了创建/hello.txt文件并向其中写入\"Hello, World!\"的操作。\n- 新增了文件/hello.txt。\n\n3. 第三层：RUN chmod 644 /hello.txt：\n- 这一层包含了对文件/hello.txt的权限更改。\n- 修改了文件/hello.txt的权限信息。\n\n每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。\n\n# 层带来的好处\nDocker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。\n\n## 层的重用机制\n层的重用主要是通过以下几个步骤实现的：\n\n1. 层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。\n\n2. 层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。\n\n3. 层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。\n\n## 层的重用示例\n假设我们有一个简单的 Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"python\", \"app.py\"]\n```\n为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容\n```\n# requirements.txt 示例\nflask\nrequests\n```\n根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR /app、COPY . . 和 CMD [\"python\", \"app.py\"]）由于没有变化，可以直接从缓存中重用。\n\n构建完镜像以后，让我们inspect一下镜像\n![inspect1](/images/docker-2/inspect1.png)![inspect2](/images/docker-2/inspect2.png)\n\n我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。\n![inspect3](/images/docker-2/inspect3.png)\n\n\n# 层数多带来的问题\n层数多会导致以下几个问题：\n\n1. 镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。\n2. 构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。\n3. 性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I/O操作的开销。\n\n# 减少Dockerfile层数的方法\n合并指令\n将多个指令合并到一个RUN指令中，可以显著减少层数。例如：\n\n```dockerfile\n# 将多个RUN指令合并到一个\nRUN apt-get update && \\\n    apt-get install -y package1 package2 && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n```\n\n减少临时文件\n在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：\n\n```dockerfile\n# 使用多行命令避免临时文件\nRUN wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination\n```\n使用.dockerignore\n类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。\n\n```dockerignore\n# .dockerignore 文件示例\nnode_modules\n.git\n.tmp\n```\n\n# 实际案例：优化一个Dockerfile\n原始Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nRUN apt-get update\nRUN apt-get install -y curl\nRUN apt-get clean\nCMD [\"python\", \"app.py\"]\n```\n优化后的Dockerfile：\n\n```dockerfile\n# 优化后的Dockerfile，减少层数\nFROM python:3.8-slim\n\nWORKDIR /app\n\n# 合并COPY和RUN指令\nCOPY requirements.txt ./\nRUN apt-get update && \\\n    apt-get install -y curl && \\\n    pip install -r requirements.txt && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n\n# 使用.dockerignore忽略不必要的文件\nCOPY . .\n\nCMD [\"python\", \"app.py\"]\n```\n我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。\n![优化dockerfile](/images/docker-2/after.png)\n\n\n# 其他优化技巧\n## 使用多阶段构建\n多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。\n通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。\n\n```dockerfile\n# 多阶段构建示例\nFROM net8-sdk AS build\nWORKDIR /app\n# 拷贝项目文件并还原依赖项\nCOPY . .\n# 构建发布版本\nRUN dotnet publish \"src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj\" -c Release -o /app/publish\n\n# 设置运行时镜像\nFROM net8-runtime\nWORKDIR /app\n# 从构建镜像阶段复制发布的文件到运行时镜像\nCOPY --from=build /app/publish .\n\nEXPOSE 80\nENTRYPOINT [\"dotnet\", \"Uranus.DatacenterMH.dll\"]\n```\n\n\n## 定期清理镜像和容器\n定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n```\n\n结语\n通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/docker-2.md","raw":"---\ntitle: Docker镜像构建优化\ndate: 2024-07-08 09:20:55\ntags:\n---\n\n# 引言\n在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。\n\n# Dockerfile中的层定义\n在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。\n\n```dockerfile\n# 每一条指令都会创建一个新层\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\nCMD [\"python\", \"app.py\"]\n```\n上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。\n\n\n在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：\n\n1. 新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。\n\n2. 修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。\n\n3. 删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。\n\n4. 文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。\n\n为了更具体地说明，下面是一个示例Dockerfile及其解释：\n\n```dockerfile\nFROM ubuntu:20.04\n\n# 第一层\nRUN apt-get update && apt-get install -y curl\n\n# 第二层\nRUN echo \"Hello, World!\" > /hello.txt\n\n# 第三层\nRUN chmod 644 /hello.txt\n```\n在这个示例中，每个RUN指令都会创建一个新的层：\n\n1. 第一层：RUN apt-get update && apt-get install -y curl：\n- 这一层包含了更新包索引文件和安装curl工具所做的所有更改。\n- 新增了curl工具的相关文件和目录。\n- 修改了包管理器的状态文件。\n2. 第二层：RUN echo \"Hello, World!\" > /hello.txt：\n- 这一层包含了创建/hello.txt文件并向其中写入\"Hello, World!\"的操作。\n- 新增了文件/hello.txt。\n\n3. 第三层：RUN chmod 644 /hello.txt：\n- 这一层包含了对文件/hello.txt的权限更改。\n- 修改了文件/hello.txt的权限信息。\n\n每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。\n\n# 层带来的好处\nDocker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。\n\n## 层的重用机制\n层的重用主要是通过以下几个步骤实现的：\n\n1. 层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。\n\n2. 层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。\n\n3. 层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。\n\n## 层的重用示例\n假设我们有一个简单的 Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"python\", \"app.py\"]\n```\n为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容\n```\n# requirements.txt 示例\nflask\nrequests\n```\n根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR /app、COPY . . 和 CMD [\"python\", \"app.py\"]）由于没有变化，可以直接从缓存中重用。\n\n构建完镜像以后，让我们inspect一下镜像\n![inspect1](/images/docker-2/inspect1.png)![inspect2](/images/docker-2/inspect2.png)\n\n我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。\n![inspect3](/images/docker-2/inspect3.png)\n\n\n# 层数多带来的问题\n层数多会导致以下几个问题：\n\n1. 镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。\n2. 构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。\n3. 性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I/O操作的开销。\n\n# 减少Dockerfile层数的方法\n合并指令\n将多个指令合并到一个RUN指令中，可以显著减少层数。例如：\n\n```dockerfile\n# 将多个RUN指令合并到一个\nRUN apt-get update && \\\n    apt-get install -y package1 package2 && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n```\n\n减少临时文件\n在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：\n\n```dockerfile\n# 使用多行命令避免临时文件\nRUN wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination\n```\n使用.dockerignore\n类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。\n\n```dockerignore\n# .dockerignore 文件示例\nnode_modules\n.git\n.tmp\n```\n\n# 实际案例：优化一个Dockerfile\n原始Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nRUN apt-get update\nRUN apt-get install -y curl\nRUN apt-get clean\nCMD [\"python\", \"app.py\"]\n```\n优化后的Dockerfile：\n\n```dockerfile\n# 优化后的Dockerfile，减少层数\nFROM python:3.8-slim\n\nWORKDIR /app\n\n# 合并COPY和RUN指令\nCOPY requirements.txt ./\nRUN apt-get update && \\\n    apt-get install -y curl && \\\n    pip install -r requirements.txt && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n\n# 使用.dockerignore忽略不必要的文件\nCOPY . .\n\nCMD [\"python\", \"app.py\"]\n```\n我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。\n![优化dockerfile](/images/docker-2/after.png)\n\n\n# 其他优化技巧\n## 使用多阶段构建\n多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。\n通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。\n\n```dockerfile\n# 多阶段构建示例\nFROM net8-sdk AS build\nWORKDIR /app\n# 拷贝项目文件并还原依赖项\nCOPY . .\n# 构建发布版本\nRUN dotnet publish \"src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj\" -c Release -o /app/publish\n\n# 设置运行时镜像\nFROM net8-runtime\nWORKDIR /app\n# 从构建镜像阶段复制发布的文件到运行时镜像\nCOPY --from=build /app/publish .\n\nEXPOSE 80\nENTRYPOINT [\"dotnet\", \"Uranus.DatacenterMH.dll\"]\n```\n\n\n## 定期清理镜像和容器\n定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n```\n\n结语\n通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","slug":"docker-2","published":1,"updated":"2024-07-08T13:19:28.360Z","_id":"clycx21xm0000usp12e7x6bo5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。</p>\n<h1 id=\"Dockerfile中的层定义\"><a href=\"#Dockerfile中的层定义\" class=\"headerlink\" title=\"Dockerfile中的层定义\"></a>Dockerfile中的层定义</h1><p>在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 每一条指令都会创建一个新层</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。</p>\n<p>在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：</p>\n<ol>\n<li><p>新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。</p>\n</li>\n<li><p>修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。</p>\n</li>\n<li><p>删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。</p>\n</li>\n<li><p>文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。</p>\n</li>\n</ol>\n<p>为了更具体地说明，下面是一个示例Dockerfile及其解释：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">20.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span> &gt; /hello.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">chmod</span> 644 /hello.txt</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，每个RUN指令都会创建一个新的层：</p>\n<ol>\n<li>第一层：RUN apt-get update &amp;&amp; apt-get install -y curl：</li>\n</ol>\n<ul>\n<li>这一层包含了更新包索引文件和安装curl工具所做的所有更改。</li>\n<li>新增了curl工具的相关文件和目录。</li>\n<li>修改了包管理器的状态文件。</li>\n</ul>\n<ol start=\"2\">\n<li>第二层：RUN echo “Hello, World!” &gt; &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了创建&#x2F;hello.txt文件并向其中写入”Hello, World!”的操作。</li>\n<li>新增了文件&#x2F;hello.txt。</li>\n</ul>\n<ol start=\"3\">\n<li>第三层：RUN chmod 644 &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了对文件&#x2F;hello.txt的权限更改。</li>\n<li>修改了文件&#x2F;hello.txt的权限信息。</li>\n</ul>\n<p>每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。</p>\n<h1 id=\"层带来的好处\"><a href=\"#层带来的好处\" class=\"headerlink\" title=\"层带来的好处\"></a>层带来的好处</h1><p>Docker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。</p>\n<h2 id=\"层的重用机制\"><a href=\"#层的重用机制\" class=\"headerlink\" title=\"层的重用机制\"></a>层的重用机制</h2><p>层的重用主要是通过以下几个步骤实现的：</p>\n<ol>\n<li><p>层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。</p>\n</li>\n<li><p>层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。</p>\n</li>\n<li><p>层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。</p>\n</li>\n</ol>\n<h2 id=\"层的重用示例\"><a href=\"#层的重用示例\" class=\"headerlink\" title=\"层的重用示例\"></a>层的重用示例</h2><p>假设我们有一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># requirements.txt 示例</span><br><span class=\"line\">flask</span><br><span class=\"line\">requests</span><br></pre></td></tr></table></figure>\n<p>根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR &#x2F;app、COPY . . 和 CMD [“python”, “app.py”]）由于没有变化，可以直接从缓存中重用。</p>\n<p>构建完镜像以后，让我们inspect一下镜像<br><img src=\"/images/docker-2/inspect1.png\" alt=\"inspect1\"><img src=\"/images/docker-2/inspect2.png\" alt=\"inspect2\"></p>\n<p>我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。<br><img src=\"/images/docker-2/inspect3.png\" alt=\"inspect3\"></p>\n<h1 id=\"层数多带来的问题\"><a href=\"#层数多带来的问题\" class=\"headerlink\" title=\"层数多带来的问题\"></a>层数多带来的问题</h1><p>层数多会导致以下几个问题：</p>\n<ol>\n<li>镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。</li>\n<li>构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。</li>\n<li>性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I&#x2F;O操作的开销。</li>\n</ol>\n<h1 id=\"减少Dockerfile层数的方法\"><a href=\"#减少Dockerfile层数的方法\" class=\"headerlink\" title=\"减少Dockerfile层数的方法\"></a>减少Dockerfile层数的方法</h1><p>合并指令<br>将多个指令合并到一个RUN指令中，可以显著减少层数。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将多个RUN指令合并到一个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y package1 package2 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>\n\n<p>减少临时文件<br>在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用多行命令避免临时文件</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination</span></span><br></pre></td></tr></table></figure>\n<p>使用.dockerignore<br>类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .dockerignore 文件示例</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">.git</span><br><span class=\"line\">.tmp</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际案例：优化一个Dockerfile\"><a href=\"#实际案例：优化一个Dockerfile\" class=\"headerlink\" title=\"实际案例：优化一个Dockerfile\"></a>实际案例：优化一个Dockerfile</h1><p>原始Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get clean</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>优化后的Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 优化后的Dockerfile，减少层数</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并COPY和RUN指令</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y curl &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    pip install -r requirements.txt &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用.dockerignore忽略不必要的文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。<br><img src=\"/images/docker-2/after.png\" alt=\"优化dockerfile\"></p>\n<h1 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h1><h2 id=\"使用多阶段构建\"><a href=\"#使用多阶段构建\" class=\"headerlink\" title=\"使用多阶段构建\"></a>使用多阶段构建</h2><p>多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。<br>通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多阶段构建示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-sdk AS build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 拷贝项目文件并还原依赖项</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"comment\"># 构建发布版本</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> dotnet publish <span class=\"string\">&quot;src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj&quot;</span> -c Release -o /app/publish</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-runtime</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 从构建镜像阶段复制发布的文件到运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /app/publish .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;dotnet&quot;</span>, <span class=\"string\">&quot;Uranus.DatacenterMH.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"定期清理镜像和容器\"><a href=\"#定期清理镜像和容器\" class=\"headerlink\" title=\"定期清理镜像和容器\"></a>定期清理镜像和容器</h2><p>定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>结语<br>通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。</p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。</p>\n<h1 id=\"Dockerfile中的层定义\"><a href=\"#Dockerfile中的层定义\" class=\"headerlink\" title=\"Dockerfile中的层定义\"></a>Dockerfile中的层定义</h1><p>在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 每一条指令都会创建一个新层</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。</p>\n<p>在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：</p>\n<ol>\n<li><p>新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。</p>\n</li>\n<li><p>修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。</p>\n</li>\n<li><p>删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。</p>\n</li>\n<li><p>文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。</p>\n</li>\n</ol>\n<p>为了更具体地说明，下面是一个示例Dockerfile及其解释：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">20.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span> &gt; /hello.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">chmod</span> 644 /hello.txt</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，每个RUN指令都会创建一个新的层：</p>\n<ol>\n<li>第一层：RUN apt-get update &amp;&amp; apt-get install -y curl：</li>\n</ol>\n<ul>\n<li>这一层包含了更新包索引文件和安装curl工具所做的所有更改。</li>\n<li>新增了curl工具的相关文件和目录。</li>\n<li>修改了包管理器的状态文件。</li>\n</ul>\n<ol start=\"2\">\n<li>第二层：RUN echo “Hello, World!” &gt; &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了创建&#x2F;hello.txt文件并向其中写入”Hello, World!”的操作。</li>\n<li>新增了文件&#x2F;hello.txt。</li>\n</ul>\n<ol start=\"3\">\n<li>第三层：RUN chmod 644 &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了对文件&#x2F;hello.txt的权限更改。</li>\n<li>修改了文件&#x2F;hello.txt的权限信息。</li>\n</ul>\n<p>每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。</p>\n<h1 id=\"层带来的好处\"><a href=\"#层带来的好处\" class=\"headerlink\" title=\"层带来的好处\"></a>层带来的好处</h1><p>Docker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。</p>\n<h2 id=\"层的重用机制\"><a href=\"#层的重用机制\" class=\"headerlink\" title=\"层的重用机制\"></a>层的重用机制</h2><p>层的重用主要是通过以下几个步骤实现的：</p>\n<ol>\n<li><p>层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。</p>\n</li>\n<li><p>层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。</p>\n</li>\n<li><p>层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。</p>\n</li>\n</ol>\n<h2 id=\"层的重用示例\"><a href=\"#层的重用示例\" class=\"headerlink\" title=\"层的重用示例\"></a>层的重用示例</h2><p>假设我们有一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># requirements.txt 示例</span><br><span class=\"line\">flask</span><br><span class=\"line\">requests</span><br></pre></td></tr></table></figure>\n<p>根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR &#x2F;app、COPY . . 和 CMD [“python”, “app.py”]）由于没有变化，可以直接从缓存中重用。</p>\n<p>构建完镜像以后，让我们inspect一下镜像<br><img src=\"/images/docker-2/inspect1.png\" alt=\"inspect1\"><img src=\"/images/docker-2/inspect2.png\" alt=\"inspect2\"></p>\n<p>我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。<br><img src=\"/images/docker-2/inspect3.png\" alt=\"inspect3\"></p>\n<h1 id=\"层数多带来的问题\"><a href=\"#层数多带来的问题\" class=\"headerlink\" title=\"层数多带来的问题\"></a>层数多带来的问题</h1><p>层数多会导致以下几个问题：</p>\n<ol>\n<li>镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。</li>\n<li>构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。</li>\n<li>性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I&#x2F;O操作的开销。</li>\n</ol>\n<h1 id=\"减少Dockerfile层数的方法\"><a href=\"#减少Dockerfile层数的方法\" class=\"headerlink\" title=\"减少Dockerfile层数的方法\"></a>减少Dockerfile层数的方法</h1><p>合并指令<br>将多个指令合并到一个RUN指令中，可以显著减少层数。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将多个RUN指令合并到一个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y package1 package2 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>\n\n<p>减少临时文件<br>在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用多行命令避免临时文件</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination</span></span><br></pre></td></tr></table></figure>\n<p>使用.dockerignore<br>类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .dockerignore 文件示例</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">.git</span><br><span class=\"line\">.tmp</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际案例：优化一个Dockerfile\"><a href=\"#实际案例：优化一个Dockerfile\" class=\"headerlink\" title=\"实际案例：优化一个Dockerfile\"></a>实际案例：优化一个Dockerfile</h1><p>原始Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get clean</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>优化后的Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 优化后的Dockerfile，减少层数</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并COPY和RUN指令</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y curl &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    pip install -r requirements.txt &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用.dockerignore忽略不必要的文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。<br><img src=\"/images/docker-2/after.png\" alt=\"优化dockerfile\"></p>\n<h1 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h1><h2 id=\"使用多阶段构建\"><a href=\"#使用多阶段构建\" class=\"headerlink\" title=\"使用多阶段构建\"></a>使用多阶段构建</h2><p>多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。<br>通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多阶段构建示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-sdk AS build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 拷贝项目文件并还原依赖项</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"comment\"># 构建发布版本</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> dotnet publish <span class=\"string\">&quot;src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj&quot;</span> -c Release -o /app/publish</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-runtime</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 从构建镜像阶段复制发布的文件到运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /app/publish .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;dotnet&quot;</span>, <span class=\"string\">&quot;Uranus.DatacenterMH.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"定期清理镜像和容器\"><a href=\"#定期清理镜像和容器\" class=\"headerlink\" title=\"定期清理镜像和容器\"></a>定期清理镜像和容器</h2><p>定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>结语<br>通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。</p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"深入理解 RabbitMQ 中的基础概念","date":"2024-07-09T08:28:36.000Z","_content":"\nRabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。\n\n# 标准 RabbitMQ 消息流\n1. 生产者向交易所发布一条消息。\n2. 交换机收到消息并且负责消息的路由。\n3. 必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。\n4. 消息一直留在队列中，直到被消费者处理。\n5. 消费者处理该消息。\n![mq-flow](/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg)\n\n# 1. 核心概念\n## 1.1 broker\n简单来说 Broker 就是消息队列服务器实体。\n\n我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：\n\n+ 磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失\n+ 内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。\n## 1.2 Channel\nChannel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。\n\nChannel 信道是生产者/消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。\n\n在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务\n\n### 为什么使用 Channel 而不是直接使用 TCP 连接？\n1. 性能：\n   - 创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。\n   - TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。\n   - Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。\n\n2. 独立性：\n   - 每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。\n   - 这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。\n\n3. 资源复用：\n   - 通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。\n   - 使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。\n\n下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。\n![一个channel对应一个connection](/images/rabbitmq-basic/channel1.png)\n```CSharp\nvar factory = new ConnectionFactory() {\n    HostName = \"127.0.0.1\"\n};\nstring clientProvidedName = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})-Subscriber\";\n\n// 创建一个 TCP 连接\nvar connection = factory.CreateConnection(clientProvidedName);\nstring consumerTag = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})\";\n\n// 在同一个连接上创建第一个 Channel\nvar channel1 = connection.CreateModel();\nvar queueName1 = \"TestMQ.Rabbit.WeChat\";\n\nvar consumer1 = new EventingBasicConsumer(channel1);\nconsumer1.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel1.BasicConsume(queue: queueName1, autoAck: true, consumerTag, consumer: consumer1);\n\n// 在同一个连接上创建第二个 Channel\nvar channel2 = connection.CreateModel();\nvar queueName2 = \"TestMQ.Rabbit.Email\";\n\nvar consumer2 = new EventingBasicConsumer(channel2);\nconsumer2.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel2.BasicConsume(queue: queueName2, autoAck: true, consumerTag, consumer: consumer2);\n```\n![一个channel对应一个connection](/images/rabbitmq-basic/channel2.png)\n\n## 1.3 Exchange\nExchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：\n\n+ Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。\n+ Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。\n+ Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。\n+ Headers Exchange：根据消息头属性来路由消息，而不是路由键。\n## 1.4 Queue\nQueue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。\n\n## 1.5 Vhost（Virtual Host）\nvhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。\n\n\n### 作用和好处\n1. 资源隔离：\n   - 独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。\n   - 安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。\n2.多租户支持：\n   - 隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。\n3. 环境隔离：\n   - 开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。\n4. 简化管理：\n   - 组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。\n\n\n上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange\n![默认交换机](/images/rabbitmq-basic/default-exchange.png)\n\n## 1.6 Routing Key\nRouting Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。\n\n### Exchange 类型与 RoutingKey、BindingKey 的关系\n不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：\n\n1. Direct Exchange：\n   - 交换机将消息路由到 RoutingKey 精确匹配的队列。\n   - 例如，RoutingKey 为 \"orange\" 的消息只会路由到绑定了 BindingKey 为 \"orange\" 的队列。\n    ![direct exchange](/images/rabbitmq-basic/direct-exchange.svg)\n2. Topic Exchange：\n   - 交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。\n   - RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。\n   - 例如，RoutingKey 为 \"user.update.info\" 的消息可以匹配 BindingKey 为 \"user.*.info\" 或 \"user.#\"。\n![direct exchange](/images/rabbitmq-basic/topic-exchange.svg)\n3. Fanout Exchange：\n   - 交换机将消息广播到所有绑定的队列，忽略 RoutingKey。\n   - 在这种情况下，BindingKey 不被使用。\n![direct exchange](/images/rabbitmq-basic/fanout-exchange.svg)\n下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。\n   ![fanout](/images/rabbitmq-basic/vro2s-b2mub.gif)\n4. Headers Exchange：\n   - 交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。\n   - BindingKey 在这种交换机类型中不被使用。\n![direct exchange](/images/rabbitmq-basic/rabbitmq-headers-exchange.svg)\n\n由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。\n\n\n# 3. 使用场景\n虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧\n\n## 3.1 负载均衡\n在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。\n\n## 3.2 异步处理\n将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。\n\n## 3.3 日志系统\n使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。\n\n# 4. 结论\nRabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。\n\n\n参考文档\n[RabbitMq经典队列](https://www.rabbitmq.com/docs/classic-queues)\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/rabbitmq-basic.md","raw":"---\ntitle: 深入理解 RabbitMQ 中的基础概念\ndate: 2024-07-09 16:28:36\ntags:\n---\n\nRabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。\n\n# 标准 RabbitMQ 消息流\n1. 生产者向交易所发布一条消息。\n2. 交换机收到消息并且负责消息的路由。\n3. 必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。\n4. 消息一直留在队列中，直到被消费者处理。\n5. 消费者处理该消息。\n![mq-flow](/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg)\n\n# 1. 核心概念\n## 1.1 broker\n简单来说 Broker 就是消息队列服务器实体。\n\n我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：\n\n+ 磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失\n+ 内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。\n## 1.2 Channel\nChannel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。\n\nChannel 信道是生产者/消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。\n\n在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务\n\n### 为什么使用 Channel 而不是直接使用 TCP 连接？\n1. 性能：\n   - 创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。\n   - TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。\n   - Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。\n\n2. 独立性：\n   - 每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。\n   - 这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。\n\n3. 资源复用：\n   - 通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。\n   - 使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。\n\n下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。\n![一个channel对应一个connection](/images/rabbitmq-basic/channel1.png)\n```CSharp\nvar factory = new ConnectionFactory() {\n    HostName = \"127.0.0.1\"\n};\nstring clientProvidedName = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})-Subscriber\";\n\n// 创建一个 TCP 连接\nvar connection = factory.CreateConnection(clientProvidedName);\nstring consumerTag = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})\";\n\n// 在同一个连接上创建第一个 Channel\nvar channel1 = connection.CreateModel();\nvar queueName1 = \"TestMQ.Rabbit.WeChat\";\n\nvar consumer1 = new EventingBasicConsumer(channel1);\nconsumer1.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel1.BasicConsume(queue: queueName1, autoAck: true, consumerTag, consumer: consumer1);\n\n// 在同一个连接上创建第二个 Channel\nvar channel2 = connection.CreateModel();\nvar queueName2 = \"TestMQ.Rabbit.Email\";\n\nvar consumer2 = new EventingBasicConsumer(channel2);\nconsumer2.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel2.BasicConsume(queue: queueName2, autoAck: true, consumerTag, consumer: consumer2);\n```\n![一个channel对应一个connection](/images/rabbitmq-basic/channel2.png)\n\n## 1.3 Exchange\nExchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：\n\n+ Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。\n+ Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。\n+ Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。\n+ Headers Exchange：根据消息头属性来路由消息，而不是路由键。\n## 1.4 Queue\nQueue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。\n\n## 1.5 Vhost（Virtual Host）\nvhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。\n\n\n### 作用和好处\n1. 资源隔离：\n   - 独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。\n   - 安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。\n2.多租户支持：\n   - 隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。\n3. 环境隔离：\n   - 开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。\n4. 简化管理：\n   - 组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。\n\n\n上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange\n![默认交换机](/images/rabbitmq-basic/default-exchange.png)\n\n## 1.6 Routing Key\nRouting Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。\n\n### Exchange 类型与 RoutingKey、BindingKey 的关系\n不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：\n\n1. Direct Exchange：\n   - 交换机将消息路由到 RoutingKey 精确匹配的队列。\n   - 例如，RoutingKey 为 \"orange\" 的消息只会路由到绑定了 BindingKey 为 \"orange\" 的队列。\n    ![direct exchange](/images/rabbitmq-basic/direct-exchange.svg)\n2. Topic Exchange：\n   - 交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。\n   - RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。\n   - 例如，RoutingKey 为 \"user.update.info\" 的消息可以匹配 BindingKey 为 \"user.*.info\" 或 \"user.#\"。\n![direct exchange](/images/rabbitmq-basic/topic-exchange.svg)\n3. Fanout Exchange：\n   - 交换机将消息广播到所有绑定的队列，忽略 RoutingKey。\n   - 在这种情况下，BindingKey 不被使用。\n![direct exchange](/images/rabbitmq-basic/fanout-exchange.svg)\n下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。\n   ![fanout](/images/rabbitmq-basic/vro2s-b2mub.gif)\n4. Headers Exchange：\n   - 交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。\n   - BindingKey 在这种交换机类型中不被使用。\n![direct exchange](/images/rabbitmq-basic/rabbitmq-headers-exchange.svg)\n\n由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。\n\n\n# 3. 使用场景\n虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧\n\n## 3.1 负载均衡\n在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。\n\n## 3.2 异步处理\n将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。\n\n## 3.3 日志系统\n使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。\n\n# 4. 结论\nRabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。\n\n\n参考文档\n[RabbitMq经典队列](https://www.rabbitmq.com/docs/classic-queues)\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","slug":"rabbitmq-basic","published":1,"updated":"2024-07-10T12:42:57.682Z","_id":"clye6paz2000090p1add188i3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。</p>\n<h1 id=\"标准-RabbitMQ-消息流\"><a href=\"#标准-RabbitMQ-消息流\" class=\"headerlink\" title=\"标准 RabbitMQ 消息流\"></a>标准 RabbitMQ 消息流</h1><ol>\n<li>生产者向交易所发布一条消息。</li>\n<li>交换机收到消息并且负责消息的路由。</li>\n<li>必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。</li>\n<li>消息一直留在队列中，直到被消费者处理。</li>\n<li>消费者处理该消息。<br><img src=\"/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg\" alt=\"mq-flow\"></li>\n</ol>\n<h1 id=\"1-核心概念\"><a href=\"#1-核心概念\" class=\"headerlink\" title=\"1. 核心概念\"></a>1. 核心概念</h1><h2 id=\"1-1-broker\"><a href=\"#1-1-broker\" class=\"headerlink\" title=\"1.1 broker\"></a>1.1 broker</h2><p>简单来说 Broker 就是消息队列服务器实体。</p>\n<p>我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：</p>\n<ul>\n<li>磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失</li>\n<li>内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。</li>\n</ul>\n<h2 id=\"1-2-Channel\"><a href=\"#1-2-Channel\" class=\"headerlink\" title=\"1.2 Channel\"></a>1.2 Channel</h2><p>Channel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。</p>\n<p>Channel 信道是生产者&#x2F;消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。</p>\n<p>在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务</p>\n<h3 id=\"为什么使用-Channel-而不是直接使用-TCP-连接？\"><a href=\"#为什么使用-Channel-而不是直接使用-TCP-连接？\" class=\"headerlink\" title=\"为什么使用 Channel 而不是直接使用 TCP 连接？\"></a>为什么使用 Channel 而不是直接使用 TCP 连接？</h3><ol>\n<li><p>性能：</p>\n<ul>\n<li>创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。</li>\n<li>TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。</li>\n<li>Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。</li>\n</ul>\n</li>\n<li><p>独立性：</p>\n<ul>\n<li>每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。</li>\n<li>这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。</li>\n</ul>\n</li>\n<li><p>资源复用：</p>\n<ul>\n<li>通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。</li>\n<li>使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。</li>\n</ul>\n</li>\n</ol>\n<p>下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。<br><img src=\"/images/rabbitmq-basic/channel1.png\" alt=\"一个channel对应一个connection\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123;</span><br><span class=\"line\">    HostName = <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> clientProvidedName = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)-Subscriber&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = factory.CreateConnection(clientProvidedName);</span><br><span class=\"line\"><span class=\"built_in\">string</span> consumerTag = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第一个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel1 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName1 = <span class=\"string\">&quot;TestMQ.Rabbit.WeChat&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer1 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel1);</span><br><span class=\"line\">consumer1.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel1.BasicConsume(queue: queueName1, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第二个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel2 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName2 = <span class=\"string\">&quot;TestMQ.Rabbit.Email&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer2 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel2);</span><br><span class=\"line\">consumer2.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel2.BasicConsume(queue: queueName2, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rabbitmq-basic/channel2.png\" alt=\"一个channel对应一个connection\"></p>\n<h2 id=\"1-3-Exchange\"><a href=\"#1-3-Exchange\" class=\"headerlink\" title=\"1.3 Exchange\"></a>1.3 Exchange</h2><p>Exchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：</p>\n<ul>\n<li>Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。</li>\n<li>Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。</li>\n<li>Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。</li>\n<li>Headers Exchange：根据消息头属性来路由消息，而不是路由键。</li>\n</ul>\n<h2 id=\"1-4-Queue\"><a href=\"#1-4-Queue\" class=\"headerlink\" title=\"1.4 Queue\"></a>1.4 Queue</h2><p>Queue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。</p>\n<h2 id=\"1-5-Vhost（Virtual-Host）\"><a href=\"#1-5-Vhost（Virtual-Host）\" class=\"headerlink\" title=\"1.5 Vhost（Virtual Host）\"></a>1.5 Vhost（Virtual Host）</h2><p>vhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。</p>\n<h3 id=\"作用和好处\"><a href=\"#作用和好处\" class=\"headerlink\" title=\"作用和好处\"></a>作用和好处</h3><ol>\n<li>资源隔离：<ul>\n<li>独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。</li>\n<li>安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。<br>2.多租户支持：</li>\n<li>隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。</li>\n</ul>\n</li>\n<li>环境隔离：<ul>\n<li>开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。</li>\n</ul>\n</li>\n<li>简化管理：<ul>\n<li>组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。</li>\n</ul>\n</li>\n</ol>\n<p>上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange<br><img src=\"/images/rabbitmq-basic/default-exchange.png\" alt=\"默认交换机\"></p>\n<h2 id=\"1-6-Routing-Key\"><a href=\"#1-6-Routing-Key\" class=\"headerlink\" title=\"1.6 Routing Key\"></a>1.6 Routing Key</h2><p>Routing Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。</p>\n<h3 id=\"Exchange-类型与-RoutingKey、BindingKey-的关系\"><a href=\"#Exchange-类型与-RoutingKey、BindingKey-的关系\" class=\"headerlink\" title=\"Exchange 类型与 RoutingKey、BindingKey 的关系\"></a>Exchange 类型与 RoutingKey、BindingKey 的关系</h3><p>不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：</p>\n<ol>\n<li>Direct Exchange：<ul>\n<li>交换机将消息路由到 RoutingKey 精确匹配的队列。</li>\n<li>例如，RoutingKey 为 “orange” 的消息只会路由到绑定了 BindingKey 为 “orange” 的队列。<br> <img src=\"/images/rabbitmq-basic/direct-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Topic Exchange：<ul>\n<li>交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。</li>\n<li>RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。</li>\n<li>例如，RoutingKey 为 “user.update.info” 的消息可以匹配 BindingKey 为 “user.*.info” 或 “user.#”。<br><img src=\"/images/rabbitmq-basic/topic-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Fanout Exchange：<ul>\n<li>交换机将消息广播到所有绑定的队列，忽略 RoutingKey。</li>\n<li>在这种情况下，BindingKey 不被使用。<br><img src=\"/images/rabbitmq-basic/fanout-exchange.svg\" alt=\"direct exchange\"><br>下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。<br><img src=\"/images/rabbitmq-basic/vro2s-b2mub.gif\" alt=\"fanout\"></li>\n</ul>\n</li>\n<li>Headers Exchange：<ul>\n<li>交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。</li>\n<li>BindingKey 在这种交换机类型中不被使用。<br><img src=\"/images/rabbitmq-basic/rabbitmq-headers-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n</ol>\n<p>由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。</p>\n<h1 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h1><p>虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧</p>\n<h2 id=\"3-1-负载均衡\"><a href=\"#3-1-负载均衡\" class=\"headerlink\" title=\"3.1 负载均衡\"></a>3.1 负载均衡</h2><p>在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。</p>\n<h2 id=\"3-2-异步处理\"><a href=\"#3-2-异步处理\" class=\"headerlink\" title=\"3.2 异步处理\"></a>3.2 异步处理</h2><p>将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。</p>\n<h2 id=\"3-3-日志系统\"><a href=\"#3-3-日志系统\" class=\"headerlink\" title=\"3.3 日志系统\"></a>3.3 日志系统</h2><p>使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4. 结论\"></a>4. 结论</h1><p>RabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/classic-queues\">RabbitMq经典队列</a></p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>RabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。</p>\n<h1 id=\"标准-RabbitMQ-消息流\"><a href=\"#标准-RabbitMQ-消息流\" class=\"headerlink\" title=\"标准 RabbitMQ 消息流\"></a>标准 RabbitMQ 消息流</h1><ol>\n<li>生产者向交易所发布一条消息。</li>\n<li>交换机收到消息并且负责消息的路由。</li>\n<li>必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。</li>\n<li>消息一直留在队列中，直到被消费者处理。</li>\n<li>消费者处理该消息。<br><img src=\"/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg\" alt=\"mq-flow\"></li>\n</ol>\n<h1 id=\"1-核心概念\"><a href=\"#1-核心概念\" class=\"headerlink\" title=\"1. 核心概念\"></a>1. 核心概念</h1><h2 id=\"1-1-broker\"><a href=\"#1-1-broker\" class=\"headerlink\" title=\"1.1 broker\"></a>1.1 broker</h2><p>简单来说 Broker 就是消息队列服务器实体。</p>\n<p>我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：</p>\n<ul>\n<li>磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失</li>\n<li>内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。</li>\n</ul>\n<h2 id=\"1-2-Channel\"><a href=\"#1-2-Channel\" class=\"headerlink\" title=\"1.2 Channel\"></a>1.2 Channel</h2><p>Channel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。</p>\n<p>Channel 信道是生产者&#x2F;消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。</p>\n<p>在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务</p>\n<h3 id=\"为什么使用-Channel-而不是直接使用-TCP-连接？\"><a href=\"#为什么使用-Channel-而不是直接使用-TCP-连接？\" class=\"headerlink\" title=\"为什么使用 Channel 而不是直接使用 TCP 连接？\"></a>为什么使用 Channel 而不是直接使用 TCP 连接？</h3><ol>\n<li><p>性能：</p>\n<ul>\n<li>创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。</li>\n<li>TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。</li>\n<li>Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。</li>\n</ul>\n</li>\n<li><p>独立性：</p>\n<ul>\n<li>每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。</li>\n<li>这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。</li>\n</ul>\n</li>\n<li><p>资源复用：</p>\n<ul>\n<li>通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。</li>\n<li>使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。</li>\n</ul>\n</li>\n</ol>\n<p>下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。<br><img src=\"/images/rabbitmq-basic/channel1.png\" alt=\"一个channel对应一个connection\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123;</span><br><span class=\"line\">    HostName = <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> clientProvidedName = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)-Subscriber&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = factory.CreateConnection(clientProvidedName);</span><br><span class=\"line\"><span class=\"built_in\">string</span> consumerTag = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第一个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel1 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName1 = <span class=\"string\">&quot;TestMQ.Rabbit.WeChat&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer1 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel1);</span><br><span class=\"line\">consumer1.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel1.BasicConsume(queue: queueName1, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第二个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel2 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName2 = <span class=\"string\">&quot;TestMQ.Rabbit.Email&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer2 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel2);</span><br><span class=\"line\">consumer2.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel2.BasicConsume(queue: queueName2, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rabbitmq-basic/channel2.png\" alt=\"一个channel对应一个connection\"></p>\n<h2 id=\"1-3-Exchange\"><a href=\"#1-3-Exchange\" class=\"headerlink\" title=\"1.3 Exchange\"></a>1.3 Exchange</h2><p>Exchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：</p>\n<ul>\n<li>Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。</li>\n<li>Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。</li>\n<li>Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。</li>\n<li>Headers Exchange：根据消息头属性来路由消息，而不是路由键。</li>\n</ul>\n<h2 id=\"1-4-Queue\"><a href=\"#1-4-Queue\" class=\"headerlink\" title=\"1.4 Queue\"></a>1.4 Queue</h2><p>Queue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。</p>\n<h2 id=\"1-5-Vhost（Virtual-Host）\"><a href=\"#1-5-Vhost（Virtual-Host）\" class=\"headerlink\" title=\"1.5 Vhost（Virtual Host）\"></a>1.5 Vhost（Virtual Host）</h2><p>vhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。</p>\n<h3 id=\"作用和好处\"><a href=\"#作用和好处\" class=\"headerlink\" title=\"作用和好处\"></a>作用和好处</h3><ol>\n<li>资源隔离：<ul>\n<li>独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。</li>\n<li>安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。<br>2.多租户支持：</li>\n<li>隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。</li>\n</ul>\n</li>\n<li>环境隔离：<ul>\n<li>开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。</li>\n</ul>\n</li>\n<li>简化管理：<ul>\n<li>组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。</li>\n</ul>\n</li>\n</ol>\n<p>上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange<br><img src=\"/images/rabbitmq-basic/default-exchange.png\" alt=\"默认交换机\"></p>\n<h2 id=\"1-6-Routing-Key\"><a href=\"#1-6-Routing-Key\" class=\"headerlink\" title=\"1.6 Routing Key\"></a>1.6 Routing Key</h2><p>Routing Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。</p>\n<h3 id=\"Exchange-类型与-RoutingKey、BindingKey-的关系\"><a href=\"#Exchange-类型与-RoutingKey、BindingKey-的关系\" class=\"headerlink\" title=\"Exchange 类型与 RoutingKey、BindingKey 的关系\"></a>Exchange 类型与 RoutingKey、BindingKey 的关系</h3><p>不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：</p>\n<ol>\n<li>Direct Exchange：<ul>\n<li>交换机将消息路由到 RoutingKey 精确匹配的队列。</li>\n<li>例如，RoutingKey 为 “orange” 的消息只会路由到绑定了 BindingKey 为 “orange” 的队列。<br> <img src=\"/images/rabbitmq-basic/direct-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Topic Exchange：<ul>\n<li>交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。</li>\n<li>RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。</li>\n<li>例如，RoutingKey 为 “user.update.info” 的消息可以匹配 BindingKey 为 “user.*.info” 或 “user.#”。<br><img src=\"/images/rabbitmq-basic/topic-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Fanout Exchange：<ul>\n<li>交换机将消息广播到所有绑定的队列，忽略 RoutingKey。</li>\n<li>在这种情况下，BindingKey 不被使用。<br><img src=\"/images/rabbitmq-basic/fanout-exchange.svg\" alt=\"direct exchange\"><br>下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。<br><img src=\"/images/rabbitmq-basic/vro2s-b2mub.gif\" alt=\"fanout\"></li>\n</ul>\n</li>\n<li>Headers Exchange：<ul>\n<li>交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。</li>\n<li>BindingKey 在这种交换机类型中不被使用。<br><img src=\"/images/rabbitmq-basic/rabbitmq-headers-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n</ol>\n<p>由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。</p>\n<h1 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h1><p>虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧</p>\n<h2 id=\"3-1-负载均衡\"><a href=\"#3-1-负载均衡\" class=\"headerlink\" title=\"3.1 负载均衡\"></a>3.1 负载均衡</h2><p>在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。</p>\n<h2 id=\"3-2-异步处理\"><a href=\"#3-2-异步处理\" class=\"headerlink\" title=\"3.2 异步处理\"></a>3.2 异步处理</h2><p>将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。</p>\n<h2 id=\"3-3-日志系统\"><a href=\"#3-3-日志系统\" class=\"headerlink\" title=\"3.3 日志系统\"></a>3.3 日志系统</h2><p>使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4. 结论\"></a>4. 结论</h1><p>RabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/classic-queues\">RabbitMq经典队列</a></p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"RabbitMQ之三种队列之间的区别及如何选型","date":"2024-07-11T02:36:12.000Z","_content":"\nRabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。\n\n# 经典队列（Classic Queues）\n## 简介：\n经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。\n\n## 特点：\n\n+ 存储机制：消息存储在磁盘或内存中，支持持久化。\n+ 消息传递：一旦消息被消费者确认，消息会从队列中删除。\n+ 性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。\n+ 高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。\n## 适用场景：\n\n适合大多数常规消息传递场景，如任务调度、事件通知等。\n当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。\n\n# 仲裁队列（Quorum Queues）\n## 简介：\n仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。\n\n## 特点：\n\n- 存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。\n- 高可用性：天然支持高可用性，通过多节点复制实现数据冗余。\n- 数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。\n- 性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。\n\n## 适用场景：\n\n- 适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。\n- 在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。\n\n## 注意事项\n1. 仲裁队列只能声明为持久的\n仲裁队列只能被声明为持久的，否则会引发以下错误消息：\n：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效\n\nQuorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。\n\n2. 仲裁队列的消息默认就是持久化的\n对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。\n\n下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。\n![重启前](/images/rabbitmq-quarum/quarum1.png)\n然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。\n![重启后](/images/rabbitmq-quarum/quarum2.png)\n\n## 仲裁队列 VS 经典队列\n\n### 数据一致性\n仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。\n\n### 数据可靠性\n仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。\n\n# 流式队列（Stream Queues）\n流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。\n\n## 特点：\n+ 存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。\n+ 高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。\n+ 数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。\n+ 订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。\n\n## 什么是消息回放和重复消费？\n消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。\n\n重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。\n\n```CSharp\npublic void InitStreamMQ()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n    // 声明流式队列\n    var args = new Dictionary<string, object> { { \"x-queue-type\", \"stream\" } };\n    channel.QueueDeclare(queue: \"stream_queue\", durable: true, exclusive: false, autoDelete: false, arguments: args);\n    channel.QueueBind(queue: \"stream_queue\", exchange: \"amq.direct\", routingKey: \"stream_queue\");\n}\n\n\n[ActionTitle(Name = \"订阅队列\")]\n[Route(\"subscribe\")]\npublic void SubscribeQuorumMessage()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", VirtualHost = \"/\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n\n    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);\n    // 设置消费者，从指定的偏移量消费消息\n    var consumer = new EventingBasicConsumer(channel);\n    consumer.Received += (model, ea) => {\n        var body = ea.Body.ToArray();\n        var message = Encoding.UTF8.GetString(body);\n        Console.WriteLine(\" [x] Received {0}\", message);\n    };\n\n    /**\n     * x-stream-offset的可选值有以下几种：\n        first: 从日志队列中第一个可消费的消息开始消费\n        last: 消费消息日志中最后一个消息\n        next: 相当于不指定offset，消费不到消息。\n        Offset: 一个数字型的偏移量\n        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)\n     */\n    var args = new Dictionary<string, object> { { \"x-stream-offset\", 2 } };\n    channel.BasicConsume(queue: \"stream_queue\", autoAck: false, arguments: args, consumer: consumer);\n}\n\n```\n这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.\n![offset](/images/rabbitmq-quarum/stream_offset.png)\n\n## 流式队列的工作原理\n流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。\n\n## 适用场景：\n\n+ 适用于实时数据分析、日志处理、实时监控等场景。\n+ 在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。\n\n## PS\n1. Auto-Ack 必须为 false\n在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。\n![aoto ack](/images/rabbitmq-quarum/stream_error2.png)\n\n2. 必须设置prefetchCount\n流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用\n![prefetchCount](/images/rabbitmq-quarum/stream_error1.png)\n\n3. durable必须设置为true\n与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。\n\n\n# 选型建议\n在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：\n\n1. 经典队列：\n   - 适合大多数常规的消息传递需求。\n   - 需要较高的性能和可靠性，但不需要特别高的数据一致性要求。\n2. 仲裁队列：\n   - 适用于对数据一致性和高可用性要求较高的场景。\n   - 需要确保消息不丢失且能够在多节点间保持数据一致性。\n3. 流式队列：\n   - 适合处理大规模实时数据流和高吞吐量的场景。\n   - 需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。\n\n# 总结\n通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。\n\n参考文档\n[Quorum Queues](https://www.rabbitmq.com/docs/quorum-queues)","source":"_posts/rabbitmq-quorum.md","raw":"---\ntitle: RabbitMQ之三种队列之间的区别及如何选型\ndate: 2024-07-11 10:36:12\ntags:\n---\n\nRabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。\n\n# 经典队列（Classic Queues）\n## 简介：\n经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。\n\n## 特点：\n\n+ 存储机制：消息存储在磁盘或内存中，支持持久化。\n+ 消息传递：一旦消息被消费者确认，消息会从队列中删除。\n+ 性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。\n+ 高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。\n## 适用场景：\n\n适合大多数常规消息传递场景，如任务调度、事件通知等。\n当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。\n\n# 仲裁队列（Quorum Queues）\n## 简介：\n仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。\n\n## 特点：\n\n- 存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。\n- 高可用性：天然支持高可用性，通过多节点复制实现数据冗余。\n- 数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。\n- 性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。\n\n## 适用场景：\n\n- 适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。\n- 在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。\n\n## 注意事项\n1. 仲裁队列只能声明为持久的\n仲裁队列只能被声明为持久的，否则会引发以下错误消息：\n：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效\n\nQuorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。\n\n2. 仲裁队列的消息默认就是持久化的\n对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。\n\n下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。\n![重启前](/images/rabbitmq-quarum/quarum1.png)\n然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。\n![重启后](/images/rabbitmq-quarum/quarum2.png)\n\n## 仲裁队列 VS 经典队列\n\n### 数据一致性\n仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。\n\n### 数据可靠性\n仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。\n\n# 流式队列（Stream Queues）\n流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。\n\n## 特点：\n+ 存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。\n+ 高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。\n+ 数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。\n+ 订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。\n\n## 什么是消息回放和重复消费？\n消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。\n\n重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。\n\n```CSharp\npublic void InitStreamMQ()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n    // 声明流式队列\n    var args = new Dictionary<string, object> { { \"x-queue-type\", \"stream\" } };\n    channel.QueueDeclare(queue: \"stream_queue\", durable: true, exclusive: false, autoDelete: false, arguments: args);\n    channel.QueueBind(queue: \"stream_queue\", exchange: \"amq.direct\", routingKey: \"stream_queue\");\n}\n\n\n[ActionTitle(Name = \"订阅队列\")]\n[Route(\"subscribe\")]\npublic void SubscribeQuorumMessage()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", VirtualHost = \"/\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n\n    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);\n    // 设置消费者，从指定的偏移量消费消息\n    var consumer = new EventingBasicConsumer(channel);\n    consumer.Received += (model, ea) => {\n        var body = ea.Body.ToArray();\n        var message = Encoding.UTF8.GetString(body);\n        Console.WriteLine(\" [x] Received {0}\", message);\n    };\n\n    /**\n     * x-stream-offset的可选值有以下几种：\n        first: 从日志队列中第一个可消费的消息开始消费\n        last: 消费消息日志中最后一个消息\n        next: 相当于不指定offset，消费不到消息。\n        Offset: 一个数字型的偏移量\n        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)\n     */\n    var args = new Dictionary<string, object> { { \"x-stream-offset\", 2 } };\n    channel.BasicConsume(queue: \"stream_queue\", autoAck: false, arguments: args, consumer: consumer);\n}\n\n```\n这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.\n![offset](/images/rabbitmq-quarum/stream_offset.png)\n\n## 流式队列的工作原理\n流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。\n\n## 适用场景：\n\n+ 适用于实时数据分析、日志处理、实时监控等场景。\n+ 在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。\n\n## PS\n1. Auto-Ack 必须为 false\n在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。\n![aoto ack](/images/rabbitmq-quarum/stream_error2.png)\n\n2. 必须设置prefetchCount\n流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用\n![prefetchCount](/images/rabbitmq-quarum/stream_error1.png)\n\n3. durable必须设置为true\n与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。\n\n\n# 选型建议\n在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：\n\n1. 经典队列：\n   - 适合大多数常规的消息传递需求。\n   - 需要较高的性能和可靠性，但不需要特别高的数据一致性要求。\n2. 仲裁队列：\n   - 适用于对数据一致性和高可用性要求较高的场景。\n   - 需要确保消息不丢失且能够在多节点间保持数据一致性。\n3. 流式队列：\n   - 适合处理大规模实时数据流和高吞吐量的场景。\n   - 需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。\n\n# 总结\n通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。\n\n参考文档\n[Quorum Queues](https://www.rabbitmq.com/docs/quorum-queues)","slug":"rabbitmq-quorum","published":1,"updated":"2024-07-13T07:55:05.748Z","_id":"clyhb2oqe00009wp18jfjh4m6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>RabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。</p>\n<h1 id=\"经典队列（Classic-Queues）\"><a href=\"#经典队列（Classic-Queues）\" class=\"headerlink\" title=\"经典队列（Classic Queues）\"></a>经典队列（Classic Queues）</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在磁盘或内存中，支持持久化。</li>\n<li>消息传递：一旦消息被消费者确认，消息会从队列中删除。</li>\n<li>性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。</li>\n<li>高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。</li>\n</ul>\n<h2 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><p>适合大多数常规消息传递场景，如任务调度、事件通知等。<br>当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。</p>\n<h1 id=\"仲裁队列（Quorum-Queues）\"><a href=\"#仲裁队列（Quorum-Queues）\" class=\"headerlink\" title=\"仲裁队列（Quorum Queues）\"></a>仲裁队列（Quorum Queues）</h1><h2 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。</p>\n<h2 id=\"特点：-1\"><a href=\"#特点：-1\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。</li>\n<li>高可用性：天然支持高可用性，通过多节点复制实现数据冗余。</li>\n<li>数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。</li>\n<li>性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。</li>\n</ul>\n<h2 id=\"适用场景：-1\"><a href=\"#适用场景：-1\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。</li>\n<li>在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>仲裁队列只能声明为持久的<br>仲裁队列只能被声明为持久的，否则会引发以下错误消息：<br>：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效</li>\n</ol>\n<p>Quorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。</p>\n<ol start=\"2\">\n<li>仲裁队列的消息默认就是持久化的<br>对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。</li>\n</ol>\n<p>下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。<br><img src=\"/images/rabbitmq-quarum/quarum1.png\" alt=\"重启前\"><br>然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。<br><img src=\"/images/rabbitmq-quarum/quarum2.png\" alt=\"重启后\"></p>\n<h2 id=\"仲裁队列-VS-经典队列\"><a href=\"#仲裁队列-VS-经典队列\" class=\"headerlink\" title=\"仲裁队列 VS 经典队列\"></a>仲裁队列 VS 经典队列</h2><h3 id=\"数据一致性\"><a href=\"#数据一致性\" class=\"headerlink\" title=\"数据一致性\"></a>数据一致性</h3><p>仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。</p>\n<h3 id=\"数据可靠性\"><a href=\"#数据可靠性\" class=\"headerlink\" title=\"数据可靠性\"></a>数据可靠性</h3><p>仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。</p>\n<h1 id=\"流式队列（Stream-Queues）\"><a href=\"#流式队列（Stream-Queues）\" class=\"headerlink\" title=\"流式队列（Stream Queues）\"></a>流式队列（Stream Queues）</h1><p>流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。</p>\n<h2 id=\"特点：-2\"><a href=\"#特点：-2\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。</li>\n<li>高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。</li>\n<li>数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。</li>\n<li>订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。</li>\n</ul>\n<h2 id=\"什么是消息回放和重复消费？\"><a href=\"#什么是消息回放和重复消费？\" class=\"headerlink\" title=\"什么是消息回放和重复消费？\"></a>什么是消息回放和重复消费？</h2><p>消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。</p>\n<p>重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InitStreamMQ</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\">    <span class=\"comment\">// 声明流式队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-queue-type&quot;</span>, <span class=\"string\">&quot;stream&quot;</span> &#125; &#125;;</span><br><span class=\"line\">    channel.QueueDeclare(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, durable: <span class=\"literal\">true</span>, exclusive: <span class=\"literal\">false</span>, autoDelete: <span class=\"literal\">false</span>, arguments: args);</span><br><span class=\"line\">    channel.QueueBind(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, exchange: <span class=\"string\">&quot;amq.direct&quot;</span>, routingKey: <span class=\"string\">&quot;stream_queue&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;订阅队列&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;subscribe&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SubscribeQuorumMessage</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, VirtualHost = <span class=\"string\">&quot;/&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.BasicQos(prefetchSize: <span class=\"number\">0</span>, prefetchCount: <span class=\"number\">1</span>, <span class=\"keyword\">global</span>: <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置消费者，从指定的偏移量消费消息</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">    consumer.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * x-stream-offset的可选值有以下几种：</span></span><br><span class=\"line\"><span class=\"comment\">        first: 从日志队列中第一个可消费的消息开始消费</span></span><br><span class=\"line\"><span class=\"comment\">        last: 消费消息日志中最后一个消息</span></span><br><span class=\"line\"><span class=\"comment\">        next: 相当于不指定offset，消费不到消息。</span></span><br><span class=\"line\"><span class=\"comment\">        Offset: 一个数字型的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-stream-offset&quot;</span>, <span class=\"number\">2</span> &#125; &#125;;</span><br><span class=\"line\">    channel.BasicConsume(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, arguments: args, consumer: consumer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.<br><img src=\"/images/rabbitmq-quarum/stream_offset.png\" alt=\"offset\"></p>\n<h2 id=\"流式队列的工作原理\"><a href=\"#流式队列的工作原理\" class=\"headerlink\" title=\"流式队列的工作原理\"></a>流式队列的工作原理</h2><p>流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。</p>\n<h2 id=\"适用场景：-2\"><a href=\"#适用场景：-2\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于实时数据分析、日志处理、实时监控等场景。</li>\n<li>在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。</li>\n</ul>\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><ol>\n<li><p>Auto-Ack 必须为 false<br>在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。<br><img src=\"/images/rabbitmq-quarum/stream_error2.png\" alt=\"aoto ack\"></p>\n</li>\n<li><p>必须设置prefetchCount<br>流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用<br><img src=\"/images/rabbitmq-quarum/stream_error1.png\" alt=\"prefetchCount\"></p>\n</li>\n<li><p>durable必须设置为true<br>与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。</p>\n</li>\n</ol>\n<h1 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h1><p>在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：</p>\n<ol>\n<li>经典队列：<ul>\n<li>适合大多数常规的消息传递需求。</li>\n<li>需要较高的性能和可靠性，但不需要特别高的数据一致性要求。</li>\n</ul>\n</li>\n<li>仲裁队列：<ul>\n<li>适用于对数据一致性和高可用性要求较高的场景。</li>\n<li>需要确保消息不丢失且能够在多节点间保持数据一致性。</li>\n</ul>\n</li>\n<li>流式队列：<ul>\n<li>适合处理大规模实时数据流和高吞吐量的场景。</li>\n<li>需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/quorum-queues\">Quorum Queues</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>RabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。</p>\n<h1 id=\"经典队列（Classic-Queues）\"><a href=\"#经典队列（Classic-Queues）\" class=\"headerlink\" title=\"经典队列（Classic Queues）\"></a>经典队列（Classic Queues）</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在磁盘或内存中，支持持久化。</li>\n<li>消息传递：一旦消息被消费者确认，消息会从队列中删除。</li>\n<li>性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。</li>\n<li>高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。</li>\n</ul>\n<h2 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><p>适合大多数常规消息传递场景，如任务调度、事件通知等。<br>当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。</p>\n<h1 id=\"仲裁队列（Quorum-Queues）\"><a href=\"#仲裁队列（Quorum-Queues）\" class=\"headerlink\" title=\"仲裁队列（Quorum Queues）\"></a>仲裁队列（Quorum Queues）</h1><h2 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。</p>\n<h2 id=\"特点：-1\"><a href=\"#特点：-1\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。</li>\n<li>高可用性：天然支持高可用性，通过多节点复制实现数据冗余。</li>\n<li>数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。</li>\n<li>性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。</li>\n</ul>\n<h2 id=\"适用场景：-1\"><a href=\"#适用场景：-1\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。</li>\n<li>在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>仲裁队列只能声明为持久的<br>仲裁队列只能被声明为持久的，否则会引发以下错误消息：<br>：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效</li>\n</ol>\n<p>Quorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。</p>\n<ol start=\"2\">\n<li>仲裁队列的消息默认就是持久化的<br>对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。</li>\n</ol>\n<p>下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。<br><img src=\"/images/rabbitmq-quarum/quarum1.png\" alt=\"重启前\"><br>然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。<br><img src=\"/images/rabbitmq-quarum/quarum2.png\" alt=\"重启后\"></p>\n<h2 id=\"仲裁队列-VS-经典队列\"><a href=\"#仲裁队列-VS-经典队列\" class=\"headerlink\" title=\"仲裁队列 VS 经典队列\"></a>仲裁队列 VS 经典队列</h2><h3 id=\"数据一致性\"><a href=\"#数据一致性\" class=\"headerlink\" title=\"数据一致性\"></a>数据一致性</h3><p>仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。</p>\n<h3 id=\"数据可靠性\"><a href=\"#数据可靠性\" class=\"headerlink\" title=\"数据可靠性\"></a>数据可靠性</h3><p>仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。</p>\n<h1 id=\"流式队列（Stream-Queues）\"><a href=\"#流式队列（Stream-Queues）\" class=\"headerlink\" title=\"流式队列（Stream Queues）\"></a>流式队列（Stream Queues）</h1><p>流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。</p>\n<h2 id=\"特点：-2\"><a href=\"#特点：-2\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。</li>\n<li>高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。</li>\n<li>数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。</li>\n<li>订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。</li>\n</ul>\n<h2 id=\"什么是消息回放和重复消费？\"><a href=\"#什么是消息回放和重复消费？\" class=\"headerlink\" title=\"什么是消息回放和重复消费？\"></a>什么是消息回放和重复消费？</h2><p>消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。</p>\n<p>重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InitStreamMQ</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\">    <span class=\"comment\">// 声明流式队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-queue-type&quot;</span>, <span class=\"string\">&quot;stream&quot;</span> &#125; &#125;;</span><br><span class=\"line\">    channel.QueueDeclare(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, durable: <span class=\"literal\">true</span>, exclusive: <span class=\"literal\">false</span>, autoDelete: <span class=\"literal\">false</span>, arguments: args);</span><br><span class=\"line\">    channel.QueueBind(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, exchange: <span class=\"string\">&quot;amq.direct&quot;</span>, routingKey: <span class=\"string\">&quot;stream_queue&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;订阅队列&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;subscribe&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SubscribeQuorumMessage</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, VirtualHost = <span class=\"string\">&quot;/&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.BasicQos(prefetchSize: <span class=\"number\">0</span>, prefetchCount: <span class=\"number\">1</span>, <span class=\"keyword\">global</span>: <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置消费者，从指定的偏移量消费消息</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">    consumer.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * x-stream-offset的可选值有以下几种：</span></span><br><span class=\"line\"><span class=\"comment\">        first: 从日志队列中第一个可消费的消息开始消费</span></span><br><span class=\"line\"><span class=\"comment\">        last: 消费消息日志中最后一个消息</span></span><br><span class=\"line\"><span class=\"comment\">        next: 相当于不指定offset，消费不到消息。</span></span><br><span class=\"line\"><span class=\"comment\">        Offset: 一个数字型的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-stream-offset&quot;</span>, <span class=\"number\">2</span> &#125; &#125;;</span><br><span class=\"line\">    channel.BasicConsume(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, arguments: args, consumer: consumer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.<br><img src=\"/images/rabbitmq-quarum/stream_offset.png\" alt=\"offset\"></p>\n<h2 id=\"流式队列的工作原理\"><a href=\"#流式队列的工作原理\" class=\"headerlink\" title=\"流式队列的工作原理\"></a>流式队列的工作原理</h2><p>流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。</p>\n<h2 id=\"适用场景：-2\"><a href=\"#适用场景：-2\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于实时数据分析、日志处理、实时监控等场景。</li>\n<li>在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。</li>\n</ul>\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><ol>\n<li><p>Auto-Ack 必须为 false<br>在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。<br><img src=\"/images/rabbitmq-quarum/stream_error2.png\" alt=\"aoto ack\"></p>\n</li>\n<li><p>必须设置prefetchCount<br>流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用<br><img src=\"/images/rabbitmq-quarum/stream_error1.png\" alt=\"prefetchCount\"></p>\n</li>\n<li><p>durable必须设置为true<br>与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。</p>\n</li>\n</ol>\n<h1 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h1><p>在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：</p>\n<ol>\n<li>经典队列：<ul>\n<li>适合大多数常规的消息传递需求。</li>\n<li>需要较高的性能和可靠性，但不需要特别高的数据一致性要求。</li>\n</ul>\n</li>\n<li>仲裁队列：<ul>\n<li>适用于对数据一致性和高可用性要求较高的场景。</li>\n<li>需要确保消息不丢失且能够在多节点间保持数据一致性。</li>\n</ul>\n</li>\n<li>流式队列：<ul>\n<li>适合处理大规模实时数据流和高吞吐量的场景。</li>\n<li>需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/quorum-queues\">Quorum Queues</a></p>\n"},{"title":"daemonset","date":"2024-08-01T00:54:53.000Z","_content":"https://cast.ai/blog/kubernetes-daemonset-practical-guide-to-monitoring-in-kubernetes/\n\n当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。\n\n# 什么是 DaemonSet？\n![daemonset](/images/daemonset/DaemonSets.png)\n\nDaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。\n\nDaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。\n\n# DaemonSet 的工作原理\n\nDaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。\n\n此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。\n\nDaemonSet 的工作原理非常简单直观：\n\n+ Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。\n\n+ Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。\n\n+ 更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。\n\n# 常见用途\n\nDaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：\n\n1. 日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。\n\n> 由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。\n\n2. 网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。\n\n> 说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。\n    ![daemonset-1](/images/daemonset/daemonset-1.png)\n\n3. 存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。\n\n# 实践一下\n\n随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。\n\n前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 \n\n### 背景\n测试环境总共3个node，一个master和两个工作节点。\n\n![节点](/images/daemonset/nodes.png)\n\n我们希望能够把我们的监控程序部署在每个工作节点中。\n\n### 部署\n1、DaemonSet 配置文件\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: acr/txclientx:5.24.10729.10\n        ports:\n        - containerPort: 80  # 如果你的应用有服务端口，请替换为实际端口\n        env:\n        - name: KhGuid\n          value: \"xxx\"\n        - name: TxCloudSite_Url\n          value: \"https://domain.com\"\n        - name: HttpJsonWriter_Target_Url\n          value: \"http://domain.com/v20/api/loggate/save/{datatype}\"\n        - name: NebulaFides_Url\n          value: \"http://domain.com\"\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"200Mi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"400Mi\"\n\n```\n2、部署到Kubernetes集群\n```bash\nkubectl apply -f agent-daemonset.yaml\n```\n\n3、部署结果\n我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序\n![监控pod](/images/daemonset/daemonset-pods.png)\n\n\n# 结语\n\n通过本文，我们详细介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。","source":"_posts/daemonset.md","raw":"---\ntitle: daemonset\ndate: 2024-08-01 08:54:53\ntags:\n---\nhttps://cast.ai/blog/kubernetes-daemonset-practical-guide-to-monitoring-in-kubernetes/\n\n当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。\n\n# 什么是 DaemonSet？\n![daemonset](/images/daemonset/DaemonSets.png)\n\nDaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。\n\nDaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。\n\n# DaemonSet 的工作原理\n\nDaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。\n\n此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。\n\nDaemonSet 的工作原理非常简单直观：\n\n+ Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。\n\n+ Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。\n\n+ 更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。\n\n# 常见用途\n\nDaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：\n\n1. 日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。\n\n> 由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。\n\n2. 网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。\n\n> 说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。\n    ![daemonset-1](/images/daemonset/daemonset-1.png)\n\n3. 存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。\n\n# 实践一下\n\n随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。\n\n前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 \n\n### 背景\n测试环境总共3个node，一个master和两个工作节点。\n\n![节点](/images/daemonset/nodes.png)\n\n我们希望能够把我们的监控程序部署在每个工作节点中。\n\n### 部署\n1、DaemonSet 配置文件\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: acr/txclientx:5.24.10729.10\n        ports:\n        - containerPort: 80  # 如果你的应用有服务端口，请替换为实际端口\n        env:\n        - name: KhGuid\n          value: \"xxx\"\n        - name: TxCloudSite_Url\n          value: \"https://domain.com\"\n        - name: HttpJsonWriter_Target_Url\n          value: \"http://domain.com/v20/api/loggate/save/{datatype}\"\n        - name: NebulaFides_Url\n          value: \"http://domain.com\"\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"200Mi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"400Mi\"\n\n```\n2、部署到Kubernetes集群\n```bash\nkubectl apply -f agent-daemonset.yaml\n```\n\n3、部署结果\n我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序\n![监控pod](/images/daemonset/daemonset-pods.png)\n\n\n# 结语\n\n通过本文，我们详细介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。","slug":"daemonset","published":1,"updated":"2024-08-02T08:13:50.320Z","_id":"clzc1fk1k0000f0p1a3wehdxm","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://cast.ai/blog/kubernetes-daemonset-practical-guide-to-monitoring-in-kubernetes/\">https://cast.ai/blog/kubernetes-daemonset-practical-guide-to-monitoring-in-kubernetes/</a></p>\n<p>当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。</p>\n<h1 id=\"什么是-DaemonSet？\"><a href=\"#什么是-DaemonSet？\" class=\"headerlink\" title=\"什么是 DaemonSet？\"></a>什么是 DaemonSet？</h1><p><img src=\"/images/daemonset/DaemonSets.png\" alt=\"daemonset\"></p>\n<p>DaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。</p>\n<p>DaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。</p>\n<h1 id=\"DaemonSet-的工作原理\"><a href=\"#DaemonSet-的工作原理\" class=\"headerlink\" title=\"DaemonSet 的工作原理\"></a>DaemonSet 的工作原理</h1><p>DaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。</p>\n<p>此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。</p>\n<p>DaemonSet 的工作原理非常简单直观：</p>\n<ul>\n<li><p>Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。</p>\n</li>\n<li><p>Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。</p>\n</li>\n<li><p>更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。</p>\n</li>\n</ul>\n<h1 id=\"常见用途\"><a href=\"#常见用途\" class=\"headerlink\" title=\"常见用途\"></a>常见用途</h1><p>DaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：</p>\n<ol>\n<li>日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。</li>\n</ol>\n<blockquote>\n<p>由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。</p>\n</blockquote>\n<ol start=\"2\">\n<li>网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。</li>\n</ol>\n<blockquote>\n<p>说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。<br>    <img src=\"/images/daemonset/daemonset-1.png\" alt=\"daemonset-1\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。</li>\n</ol>\n<h1 id=\"实践一下\"><a href=\"#实践一下\" class=\"headerlink\" title=\"实践一下\"></a>实践一下</h1><p>随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。</p>\n<p>前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 </p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>测试环境总共3个node，一个master和两个工作节点。</p>\n<p><img src=\"/images/daemonset/nodes.png\" alt=\"节点\"></p>\n<p>我们希望能够把我们的监控程序部署在每个工作节点中。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>1、DaemonSet 配置文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">acr/txclientx:5.24.10729.10</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 如果你的应用有服务端口，请替换为实际端口</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxCloudSite_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">HttpJsonWriter_Target_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com/v20/api/loggate/save/&#123;datatype&#125;&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">NebulaFides_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">resources:</span></span><br><span class=\"line\">          <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;100m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;200Mi&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">limits:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;200m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;400Mi&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、部署到Kubernetes集群</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f agent-daemonset.yaml</span><br></pre></td></tr></table></figure>\n\n<p>3、部署结果<br>我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序<br><img src=\"/images/daemonset/daemonset-pods.png\" alt=\"监控pod\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文，我们详细介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://cast.ai/blog/kubernetes-daemonset-practical-guide-to-monitoring-in-kubernetes/\">https://cast.ai/blog/kubernetes-daemonset-practical-guide-to-monitoring-in-kubernetes/</a></p>\n<p>当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。</p>\n<h1 id=\"什么是-DaemonSet？\"><a href=\"#什么是-DaemonSet？\" class=\"headerlink\" title=\"什么是 DaemonSet？\"></a>什么是 DaemonSet？</h1><p><img src=\"/images/daemonset/DaemonSets.png\" alt=\"daemonset\"></p>\n<p>DaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。</p>\n<p>DaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。</p>\n<h1 id=\"DaemonSet-的工作原理\"><a href=\"#DaemonSet-的工作原理\" class=\"headerlink\" title=\"DaemonSet 的工作原理\"></a>DaemonSet 的工作原理</h1><p>DaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。</p>\n<p>此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。</p>\n<p>DaemonSet 的工作原理非常简单直观：</p>\n<ul>\n<li><p>Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。</p>\n</li>\n<li><p>Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。</p>\n</li>\n<li><p>更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。</p>\n</li>\n</ul>\n<h1 id=\"常见用途\"><a href=\"#常见用途\" class=\"headerlink\" title=\"常见用途\"></a>常见用途</h1><p>DaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：</p>\n<ol>\n<li>日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。</li>\n</ol>\n<blockquote>\n<p>由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。</p>\n</blockquote>\n<ol start=\"2\">\n<li>网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。</li>\n</ol>\n<blockquote>\n<p>说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。<br>    <img src=\"/images/daemonset/daemonset-1.png\" alt=\"daemonset-1\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。</li>\n</ol>\n<h1 id=\"实践一下\"><a href=\"#实践一下\" class=\"headerlink\" title=\"实践一下\"></a>实践一下</h1><p>随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。</p>\n<p>前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 </p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>测试环境总共3个node，一个master和两个工作节点。</p>\n<p><img src=\"/images/daemonset/nodes.png\" alt=\"节点\"></p>\n<p>我们希望能够把我们的监控程序部署在每个工作节点中。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>1、DaemonSet 配置文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">acr/txclientx:5.24.10729.10</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 如果你的应用有服务端口，请替换为实际端口</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxCloudSite_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">HttpJsonWriter_Target_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com/v20/api/loggate/save/&#123;datatype&#125;&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">NebulaFides_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">resources:</span></span><br><span class=\"line\">          <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;100m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;200Mi&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">limits:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;200m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;400Mi&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、部署到Kubernetes集群</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f agent-daemonset.yaml</span><br></pre></td></tr></table></figure>\n\n<p>3、部署结果<br>我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序<br><img src=\"/images/daemonset/daemonset-pods.png\" alt=\"监控pod\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文，我们详细介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cltzedeaa0000d0p1ajbjc7gt","tag_id":"clu6lbm020000qgp12xagd7wt","_id":"clu6lbm030001qgp1fqm351zz"},{"post_id":"cluc17m5x0000qsp19fjj1lmy","tag_id":"cluc17m5z0001qsp12a5n6e97","_id":"cluc17m600002qsp19wrd4b20"},{"post_id":"clup9vupa0000okp14bz96eiy","tag_id":"clup9vupr0001okp1b20obw5k","_id":"clup9vups0002okp1f72rhs2r"},{"post_id":"cluuzgyxx000088p1frvnfrom","tag_id":"clv0mvgiy0002x4p19oeo5n65","_id":"clv0mvgiy0003x4p186o50a2h"},{"post_id":"clv5zlgr50003fcp11585dpte","tag_id":"clv4x0del0001fcp16qpg9jfq","_id":"clv5zlgr70004fcp1a7h78bur"},{"post_id":"clvj8jhdc0000pop171ud7xg2","tag_id":"clvxfh3ap0000zkp1cdrwco6s","_id":"clvxfh3as0001zkp12iuz6c4w"}],"Tag":[{"name":"http 协议 http协议","_id":"cltzedeah0001d0p1gd2rdzoo"},{"name":"http http协议 Connection","_id":"clu6lbm020000qgp12xagd7wt"},{"name":"组织 内耗","_id":"cluc17m5z0001qsp12a5n6e97"},{"name":"Garnet 缓存 微软","_id":"clup9vupr0001okp1b20obw5k"},{"name":"https http ssl tlc","_id":"clv0mvfpx0000x4p1cun49e2q"},{"name":"https http ssl tls","_id":"clv0mvgiy0002x4p19oeo5n65"},{"name":"redis 面试 求职","_id":"clv4x0del0001fcp16qpg9jfq"},{"name":"dump","_id":"clvj8jhdt0001pop1f18veod2"},{"name":"dump 性能 异常","_id":"clvxfh3ap0000zkp1cdrwco6s"}]}}