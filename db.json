{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon_bak.ico","path":"assets/favicon_bak.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/wechat_qr.jpg","path":"assets/wechat_qr.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Jason.jpg","path":"avatar/Jason.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"source/images/hello-bg.png","path":"images/hello-bg.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/DaemonSets.png","path":"images/daemonset/DaemonSets.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/bg.png","path":"images/daemonset/bg.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/daemonset-1.png","path":"images/daemonset/daemonset-1.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/nodes.png","path":"images/daemonset/nodes.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/daemonset-pods.png","path":"images/daemonset/daemonset-pods.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/after.png","path":"images/docker-2/after.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect1.png","path":"images/docker-2/inspect1.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/before.png","path":"images/docker-2/before.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect3.png","path":"images/docker-2/inspect3.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect2.png","path":"images/docker-2/inspect2.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/bg.jpg","path":"images/dead-message/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-2.jpg","path":"images/dead-message/dead-letter-2.jpg","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_1.png","path":"images/dead-message/delay_comsuption_1.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_2.png","path":"images/dead-message/delay_comsuption_2.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-3.png","path":"images/dead-message/dead-letter-3.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/bg.png","path":"images/docker-1/bg.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/configurations.png","path":"images/docker-1/configurations.png","modified":0,"renderable":0},{"_id":"source/images/dump/bg.png","path":"images/dump/bg.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/multi-env.png","path":"images/docker-1/multi-env.png","modified":0,"renderable":0},{"_id":"source/images/dump/crash.jpeg","path":"images/dump/crash.jpeg","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","path":"images/dead-message/dead-letter-exchange-1.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_3.png","path":"images/dump/windbg_3.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_2.png","path":"images/dump/windbg_2.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_1.png","path":"images/dump/windbg_1.png","modified":0,"renderable":0},{"_id":"source/images/encrypt-hash-signature/certificate.png","path":"images/encrypt-hash-signature/certificate.png","modified":0,"renderable":0},{"_id":"source/images/encrypt-hash-signature/rsa.png","path":"images/encrypt-hash-signature/rsa.png","modified":0,"renderable":0},{"_id":"source/images/encrypt-hash-signature/md5.png","path":"images/encrypt-hash-signature/md5.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/filesystem.png","path":"images/docker-layer/filesystem.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/layers.png","path":"images/docker-layer/layers.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_4.png","path":"images/dump/windbg_4.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/ls_upper.png","path":"images/docker-layer/ls_upper.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/merged.png","path":"images/docker-layer/merged.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/tree.png","path":"images/docker-layer/tree.png","modified":0,"renderable":0},{"_id":"source/images/http/TCP-connection-1.png","path":"images/http/TCP-connection-1.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect.png","path":"images/http/auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect2.png","path":"images/http/auto-disconnect2.png","modified":0,"renderable":0},{"_id":"source/images/http/curl-header.png","path":"images/http/curl-header.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-1.png","path":"images/http/handshake-1.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-2.png","path":"images/http/handshake-2.png","modified":0,"renderable":0},{"_id":"source/images/http/http-request.png","path":"images/http/http-request.png","modified":0,"renderable":0},{"_id":"source/images/http/perisitent-connection.png","path":"images/http/perisitent-connection.png","modified":0,"renderable":0},{"_id":"source/images/http/timeout-auto-disconnect.png","path":"images/http/timeout-auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/helm/Helmcharts.png","path":"images/helm/Helmcharts.png","modified":0,"renderable":0},{"_id":"source/images/http/request-methods.png","path":"images/http/request-methods.png","modified":0,"renderable":0},{"_id":"source/images/http/http-keep-alive-header.png","path":"images/http/http-keep-alive-header.png","modified":0,"renderable":0},{"_id":"source/images/helm/helm3-arch.png","path":"images/helm/helm3-arch.png","modified":0,"renderable":0},{"_id":"source/images/helm/lens-helm.png","path":"images/helm/lens-helm.png","modified":0,"renderable":0},{"_id":"source/images/helm/lens-pod.png","path":"images/helm/lens-pod.png","modified":0,"renderable":0},{"_id":"source/images/helm/new-helm.png","path":"images/helm/new-helm.png","modified":0,"renderable":0},{"_id":"source/images/garnet/1.png","path":"images/garnet/1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/client.png","path":"images/garnet/client.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compare1.png","path":"images/garnet/compare1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compatible.png","path":"images/garnet/compatible.png","modified":0,"renderable":0},{"_id":"source/images/garnet/connect.png","path":"images/garnet/connect.png","modified":0,"renderable":0},{"_id":"source/images/garnet/custom-command.png","path":"images/garnet/custom-command.png","modified":0,"renderable":0},{"_id":"source/images/garnet/running.png","path":"images/garnet/running.png","modified":0,"renderable":0},{"_id":"source/images/garnet/log.png","path":"images/garnet/log.png","modified":0,"renderable":0},{"_id":"source/images/https/bg.jpg","path":"images/https/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/https/ca.png","path":"images/https/ca.png","modified":0,"renderable":0},{"_id":"source/images/https/ca2.png","path":"images/https/ca2.png","modified":0,"renderable":0},{"_id":"source/images/https/client-hello.png","path":"images/https/client-hello.png","modified":0,"renderable":0},{"_id":"source/images/https/encrypted.png","path":"images/https/encrypted.png","modified":0,"renderable":0},{"_id":"source/images/https/cipher-suites.png","path":"images/https/cipher-suites.png","modified":0,"renderable":0},{"_id":"source/images/https/handshake.png","path":"images/https/handshake.png","modified":0,"renderable":0},{"_id":"source/images/https/expire.png","path":"images/https/expire.png","modified":0,"renderable":0},{"_id":"source/images/https/negotiated-cipher-suite.png","path":"images/https/negotiated-cipher-suite.png","modified":0,"renderable":0},{"_id":"source/images/https/security.png","path":"images/https/security.png","modified":0,"renderable":0},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","path":"images/internal-loss/20231109_sy_01.jpg","modified":0,"renderable":0},{"_id":"source/images/internal-loss/depressed.jpg","path":"images/internal-loss/depressed.jpg","modified":0,"renderable":0},{"_id":"source/images/log/bad.png","path":"images/log/bad.png","modified":0,"renderable":0},{"_id":"source/images/log/confident.png","path":"images/log/confident.png","modified":0,"renderable":0},{"_id":"source/images/log/courgette.log","path":"images/log/courgette.log","modified":0,"renderable":0},{"_id":"source/images/log/long.png","path":"images/log/long.png","modified":0,"renderable":0},{"_id":"source/images/internal-loss/996.jpg","path":"images/internal-loss/996.jpg","modified":0,"renderable":0},{"_id":"source/images/mfa/bg.png","path":"images/mfa/bg.png","modified":0,"renderable":0},{"_id":"source/images/mfa/github.png","path":"images/mfa/github.png","modified":0,"renderable":0},{"_id":"source/images/mfa/web.png","path":"images/mfa/web.png","modified":0,"renderable":0},{"_id":"source/images/mfa/run.png","path":"images/mfa/run.png","modified":0,"renderable":0},{"_id":"source/images/image-search/bg.jpg","path":"images/image-search/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/image-search/process.png","path":"images/image-search/process.png","modified":0,"renderable":0},{"_id":"source/images/image-search/images.png","path":"images/image-search/images.png","modified":0,"renderable":0},{"_id":"source/images/image-search/search.gif","path":"images/image-search/search.gif","modified":0,"renderable":0},{"_id":"source/images/image-search/qdrant.png","path":"images/image-search/qdrant.png","modified":0,"renderable":0},{"_id":"source/images/proxy/bg.jpg","path":"images/proxy/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/proxy/forward-proxy.png","path":"images/proxy/forward-proxy.png","modified":0,"renderable":0},{"_id":"source/images/proxy/transparent-proxy.png","path":"images/proxy/transparent-proxy.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/EventTarget.png","path":"images/js-signal/EventTarget.png","modified":0,"renderable":0},{"_id":"source/images/proxy/reverse-proxy.png","path":"images/proxy/reverse-proxy.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/responsive.gif","path":"images/js-signal/responsive.gif","modified":0,"renderable":0},{"_id":"source/images/js-signal/EventTarget3.png","path":"images/js-signal/EventTarget3.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/EventTarget2.png","path":"images/js-signal/EventTarget2.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/switch-theme.gif","path":"images/js-signal/switch-theme.gif","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/16elk-ujaxc.gif","path":"images/rabbitmq-basic/16elk-ujaxc.gif","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/channel2.png","path":"images/rabbitmq-basic/channel2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/default-exchange.png","path":"images/rabbitmq-basic/default-exchange.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/channel1.png","path":"images/rabbitmq-basic/channel1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/direct-exchange.svg","path":"images/rabbitmq-basic/direct-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","path":"images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout-exchange.svg","path":"images/rabbitmq-basic/fanout-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout.mp4","path":"images/rabbitmq-basic/fanout.mp4","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout.png","path":"images/rabbitmq-basic/fanout.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/main.png","path":"images/rabbitmq-basic/main.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/rabbitmq-headers-exchange.svg","path":"images/rabbitmq-basic/rabbitmq-headers-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/topic-exchange.svg","path":"images/rabbitmq-basic/topic-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/vro2s-b2mub.gif","path":"images/rabbitmq-basic/vro2s-b2mub.gif","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/courgette.log","path":"images/rabbitmq-quarum/courgette.log","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/normal.png","path":"images/rabbitmq-quarum/normal.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_error2.png","path":"images/rabbitmq-quarum/stream_error2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/quarum2.png","path":"images/rabbitmq-quarum/quarum2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/quarum1.png","path":"images/rabbitmq-quarum/quarum1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_offset.png","path":"images/rabbitmq-quarum/stream_offset.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_error1.png","path":"images/rabbitmq-quarum/stream_error1.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-breakdown.png","path":"images/redis-interview/cache-breakdown.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/bg.png","path":"images/redis-interview/bg.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-avalanche.png","path":"images/redis-interview/cache-avalanche.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-penetration.png","path":"images/redis-interview/cache-penetration.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/memory.png","path":"images/redis-interview/memory.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/recruitment.png","path":"images/redis-interview/recruitment.png","modified":0,"renderable":0},{"_id":"source/images/quic/quic-logo.png","path":"images/quic/quic-logo.png","modified":0,"renderable":0},{"_id":"source/images/quic/head_of_line_blocking.png","path":"images/quic/head_of_line_blocking.png","modified":0,"renderable":0},{"_id":"source/images/quic/handshake.png","path":"images/quic/handshake.png","modified":0,"renderable":0},{"_id":"source/images/quic/quic.png","path":"images/quic/quic.png","modified":0,"renderable":0},{"_id":"source/images/quic/tcp.png","path":"images/quic/tcp.png","modified":0,"renderable":0},{"_id":"source/images/rspack/bg.png","path":"images/rspack/bg.png","modified":0,"renderable":0},{"_id":"source/images/rspack/result1.png","path":"images/rspack/result1.png","modified":0,"renderable":0},{"_id":"source/images/rspack/tools.png","path":"images/rspack/tools.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/bg.jpg","path":"images/sticky-packet/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/sender-sticky.png","path":"images/sticky-packet/sender-sticky.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/server-sticky.png","path":"images/sticky-packet/server-sticky.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/solve-sender-sticky.png","path":"images/sticky-packet/solve-sender-sticky.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/solve-server-sticky.png","path":"images/sticky-packet/solve-server-sticky.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/1_kDeCUgDd-T-KLvSH4sTiLw.png","path":"images/webrtc/1_kDeCUgDd-T-KLvSH4sTiLw.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/bg.png","path":"images/webrtc/bg.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/connections.png","path":"images/webrtc/connections.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/server.png","path":"images/webrtc/server.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/webrtc-overview.svg","path":"images/webrtc/webrtc-overview.svg","modified":0,"renderable":0},{"_id":"source/images/stream-output/4a7aa-203zt.gif","path":"images/stream-output/4a7aa-203zt.gif","modified":0,"renderable":0},{"_id":"source/images/stream-output/courgette.log","path":"images/stream-output/courgette.log","modified":0,"renderable":0},{"_id":"source/images/stream-output/gpt-1.gif","path":"images/stream-output/gpt-1.gif","modified":0,"renderable":0},{"_id":"source/images/stream-output/regular-http-communication.png","path":"images/stream-output/regular-http-communication.png","modified":0,"renderable":0},{"_id":"source/images/stream-output/gzip.png","path":"images/stream-output/gzip.png","modified":0,"renderable":0},{"_id":"source/images/stream-output/result.gif","path":"images/stream-output/result.gif","modified":0,"renderable":0},{"_id":"source/images/stream-output/sse-communication.png","path":"images/stream-output/sse-communication.png","modified":0,"renderable":0},{"_id":"source/images/stream-output/sse.gif","path":"images/stream-output/sse.gif","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/bg.jpg","path":"images/task-completion-source/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/pause-1.png","path":"images/task-completion-source/pause-1.png","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/pause-2.png","path":"images/task-completion-source/pause-2.png","modified":0,"renderable":0},{"_id":"source/images/log/whoami.jpg","path":"images/log/whoami.jpg","modified":0,"renderable":0},{"_id":"source/images/log/bg.png","path":"images/log/bg.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-result.png","path":"images/parallelism/concurrency-result.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-vs-parallelism-1.png","path":"images/parallelism/concurrency-vs-parallelism-1.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-vs-parallelism-2.png","path":"images/parallelism/concurrency-vs-parallelism-2.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/parallelism-result.png","path":"images/parallelism/parallelism-result.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-vs-parallelism-3.png","path":"images/parallelism/concurrency-vs-parallelism-3.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/log1.png","path":"images/docker-log/log1.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/log2.png","path":"images/docker-log/log2.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/bg.jpg","path":"images/parallelism/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/parallelism/courgette.log","path":"images/parallelism/courgette.log","modified":0,"renderable":0},{"_id":"source/images/docker-log/log3.png","path":"images/docker-log/log3.png","modified":1,"renderable":0},{"_id":"source/images/docker-log/log4.png","path":"images/docker-log/log4.png","modified":1,"renderable":0},{"_id":"source/images/docker-log/log5.png","path":"images/docker-log/log5.png","modified":1,"renderable":0},{"_id":"source/images/docker-log/bg.png","path":"images/docker-log/bg.png","modified":1,"renderable":0},{"_id":"source/images/docker-log/courgette.log","path":"images/docker-log/courgette.log","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/PageAssist.png","path":"images/deepseek-1/PageAssist.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-setting2.png","path":"images/deepseek-1/chatbox-setting2.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-setting.png","path":"images/deepseek-1/chatbox-setting.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-setting4.png","path":"images/deepseek-1/chatbox-setting4.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/chatboxai.png","path":"images/deepseek-1/chatboxai.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/deepseek-models.png","path":"images/deepseek-1/deepseek-models.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/download.png","path":"images/deepseek-1/download.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/env_var.png","path":"images/deepseek-1/env_var.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/models.png","path":"images/deepseek-1/models.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/pull.png","path":"images/deepseek-1/pull.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/pulling.png","path":"images/deepseek-1/pulling.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/success.png","path":"images/deepseek-1/success.png","modified":1,"renderable":0},{"_id":"source/images/deepseek-1/late.jpg","path":"images/deepseek-1/late.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/images/log/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1734591686566},{"_id":"source/images/rabbitmq-quarum/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1720774060906},{"_id":"source/images/stream-output/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1731620201071},{"_id":"source/_posts/TaskCompletionSource.md","hash":"a2bcfbda71ac8d8406e1bd14fa333169457384e5","modified":1717658556858},{"_id":"source/_posts/dead-message.md","hash":"e0a8e83a589cd97cb599fd243d348f4b1896eb71","modified":1716628987803},{"_id":"source/_posts/daemonset.md","hash":"bb165cf091f0a25e1fab93fc06dcc7bd2ec4e71f","modified":1722592868923},{"_id":"source/_posts/docker-1.md","hash":"3f9d81f24d238d3b9a48b5ec67c5a65fb52388f8","modified":1720255588285},{"_id":"source/_posts/docker-layer.md","hash":"f608b1c31fe24320a204f1473a25524dc90110b9","modified":1723448461339},{"_id":"source/_posts/dump.md","hash":"fc0d11e98d4a2c35e8f590fc901c33ec87cf1654","modified":1715157478693},{"_id":"source/_posts/encrypt-hash-signature.md","hash":"608837ab32dd4166ef5ea0339425281ffc9c5667","modified":1730878713008},{"_id":"source/_posts/http.md","hash":"e538858062edce06c26c8060d05f61b3e6fe772b","modified":1714100804259},{"_id":"source/_posts/js-signal.md","hash":"99254f370782596935a99c866ff0dffef867da63","modified":1730790518259},{"_id":"source/_posts/https.md","hash":"00df307cec478b57c6b9ab848f2b3d2ef578098a","modified":1714100800272},{"_id":"source/_posts/hello-world.md","hash":"3c422ea24b75465e6ea2a80c268251ca0a03e042","modified":1714100836002},{"_id":"source/_posts/garnet.md","hash":"9fa10e3a47f78d4b6f8465f3e49e33da56758f21","modified":1714100842478},{"_id":"source/_posts/mfa.md","hash":"13306922ee3043abf2dc43733c1d3b71d6e44b70","modified":1732170191011},{"_id":"source/_posts/k8s-helm.md","hash":"7d95c728a51be2354d84d3707104ab0267715ffc","modified":1733985051694},{"_id":"source/_posts/organization-internal-loss.md","hash":"b157730ebdda6cfd58233ff8ec9d9bfed27d37b1","modified":1714100795957},{"_id":"source/_posts/quic.md","hash":"f69a826a8a6c38e5269bff4127f55bb5dce9f6df","modified":1724379707402},{"_id":"source/_posts/proxy.md","hash":"fbe68bb5c014a73c809edf55bd34ac75f88dc814","modified":1718931872131},{"_id":"source/_posts/rspack.md","hash":"4b4159395b0e9406b8725c33f7bacf93669f95ec","modified":1732869205589},{"_id":"source/_posts/rabbitmq-quorum.md","hash":"01529732ac69c5892cb1c977a36b8093fed2fe84","modified":1720857305748},{"_id":"source/_posts/redis-interview-1.md","hash":"951b57d41f67b3f9287684d1808c63e0ab08023d","modified":1714102286087},{"_id":"source/_posts/docker-2.md","hash":"a75951a67f13186efc0b09411b6255a83af11df5","modified":1720444768360},{"_id":"source/_posts/stream-output.md","hash":"77b7564dd2485195558714d2f3e694ab455b7fd5","modified":1731490817137},{"_id":"source/_posts/rabbitmq-basic.md","hash":"9d43ee83b6448cbc3cfd9e77099ab1ee31027684","modified":1720615377682},{"_id":"source/_posts/sticky-packet.md","hash":"e71dbd0f9ac05830a8921dda3ec1ea5e8723069c","modified":1724999441472},{"_id":"source/_posts/hello-world-bak.md1","hash":"1e16dbc0dbf8b18e83f47dbbdffd0d1f27cfe955","modified":1710398484836},{"_id":"source/images/daemonset/nodes.png","hash":"9ddeb9b6441cfee33edce7aa99af8058c7a291b1","modified":1722586074002},{"_id":"source/images/daemonset/daemonset-1.png","hash":"30bd683b3eba29092f63bb3c3d1b3742a94706e4","modified":1722562440090},{"_id":"source/images/daemonset/DaemonSets.png","hash":"b2d8cb6e9f9a3246d70a6c4f1fa6656c6128eb67","modified":1722580496257},{"_id":"source/images/dead-message/bg.jpg","hash":"e0de32bdd097eeb58f534882e876a282606db679","modified":1716366165441},{"_id":"source/_posts/similar-image-search.md","hash":"80b6ecb4440b108c26f92fd41d4f1d326f88eba5","modified":1717774298746},{"_id":"source/images/daemonset/daemonset-pods.png","hash":"ffc713e43daebc3db7fbcde65c154bfc0c4e5148","modified":1722586245355},{"_id":"source/images/dead-message/delay_comsuption_1.png","hash":"c093bbb3f975f40087d037aa56b8fd32ed866332","modified":1716627815685},{"_id":"source/images/dead-message/delay_comsuption_2.png","hash":"f9b57ebe4ba7cefabad08a139f92e619fd1aae8f","modified":1716627676317},{"_id":"source/images/dead-message/dead-letter-3.png","hash":"d8017b10c2efd5448993b92f0a35783e4d0b71f7","modified":1716626485267},{"_id":"source/_posts/web-rtc.md","hash":"750a7ee5daf2b557581431e8f07a6d75cec4cc4f","modified":1734418398657},{"_id":"source/images/docker-1/bg.png","hash":"e3b82c04b261788b6c333288578220dad894e135","modified":1720252982915},{"_id":"source/images/dump/crash.jpeg","hash":"e25f4327f9073e01e8b1a3e13c209ca732880e15","modified":1714290837084},{"_id":"source/images/dump/windbg_3.png","hash":"47fa0c7ac253a9a44eef9bc6d5dce90d96445ba2","modified":1715068901454},{"_id":"source/images/encrypt-hash-signature/rsa.png","hash":"d3754f8c7d483647dd81f6faae4f4b185aabef55","modified":1730878691786},{"_id":"source/images/encrypt-hash-signature/md5.png","hash":"fad0964bd0a818545e9ba11fea2835793a6e8625","modified":1730878089744},{"_id":"source/images/docker-layer/filesystem.png","hash":"969d25d9599c4bcc72ee3403e1805d7ad7a874e6","modified":1723428032741},{"_id":"source/images/docker-layer/layers.png","hash":"cf95861f382cab38dfcb0864099633592e85fc50","modified":1723432713503},{"_id":"source/images/docker-layer/tree.png","hash":"8650756f7321bd4e7a53e0525f3e42411b7d51b7","modified":1723443628297},{"_id":"source/images/docker-layer/merged.png","hash":"a35d1d9111feb7ed81e3279ef2f1f5c9bb8951d6","modified":1723443249117},{"_id":"source/images/docker-layer/ls_upper.png","hash":"aa190ff2fa11cfcf0c125e79b71e9b5d161358a5","modified":1723443838820},{"_id":"source/images/http/TCP-connection-1.png","hash":"588cade2c5e791bee0f282a6290889ba15c3a039","modified":1711091658444},{"_id":"source/images/http/handshake-1.png","hash":"698f25b0696249dbbadbf1b71ea5e3e48b57348e","modified":1711100170452},{"_id":"source/images/http/http-request.png","hash":"4d29675c37a4cc0df885db03cff820aa3f98080c","modified":1710926387387},{"_id":"source/images/http/perisitent-connection.png","hash":"0e16961aaa4851908823dccfa904d3f4f6989c08","modified":1711092222874},{"_id":"source/images/http/curl-header.png","hash":"e5c4a20f54045759a1a29f7f35a344d45ee51ecb","modified":1711013282028},{"_id":"source/images/helm/Helmcharts.png","hash":"8f3934f4b82bb99d9889f3c147a6f5e328aa94ee","modified":1733986204951},{"_id":"source/images/http/http-keep-alive-header.png","hash":"d2b1f6ccc2903ffbd4308627c2562b42c80a2cb7","modified":1711435826469},{"_id":"source/images/helm/new-helm.png","hash":"0e80788d40b1e71fda030c40b348d3eec4cb1971","modified":1733899062841},{"_id":"source/images/helm/helm3-arch.png","hash":"a7b8a99dc3aad21a3d999cf55649b83ece440b2e","modified":1733902937390},{"_id":"source/images/garnet/client.png","hash":"4889111b6b22a0f07ed3e80b70ee4e1e99c8045e","modified":1712652420303},{"_id":"source/images/garnet/compare1.png","hash":"ed8a21697688433ffe376d2a4ccaa7ec53c667ff","modified":1712648062046},{"_id":"source/images/garnet/connect.png","hash":"82d4fc4511b032c7c797018845ca40d83ac7aa9d","modified":1712650225409},{"_id":"source/images/garnet/custom-command.png","hash":"bea263307a51c77205885ace2c3060272e444339","modified":1712736760989},{"_id":"source/images/garnet/running.png","hash":"3253e7a14adf9509baead2613151f614a0012ab5","modified":1712567881514},{"_id":"source/images/garnet/compatible.png","hash":"1714c1d5f1c6fd0421b4594015595976b5fd4ee4","modified":1712567994543},{"_id":"source/images/https/bg.jpg","hash":"9424b491fdae5f8c91344596469c3980217e2206","modified":1712821936174},{"_id":"source/images/https/ca.png","hash":"a3f65f3b7f108a2e18c61d13c3024d761586a9ca","modified":1712826407187},{"_id":"source/images/https/handshake.png","hash":"9d2b92013eb6b78a0f3b84855a383b29962da2ba","modified":1713152131440},{"_id":"source/images/https/security.png","hash":"e040846f476100e1ac38f67dec1fc9735978fc9f","modified":1713148972216},{"_id":"source/_posts/log.md","hash":"8f96cc04dba4260efe314cbb2def15234798a71a","modified":1735200386992},{"_id":"source/images/https/expire.png","hash":"801009fef98fa9d46a677f153f097e6476c139e2","modified":1712824416637},{"_id":"source/images/log/bad.png","hash":"8096161c7245cf56a0becfacf784179d9251ddc6","modified":1734570885990},{"_id":"source/images/log/confident.png","hash":"59601ad4b3d8c43998ca4d4c0384e1072c8bd3c9","modified":1734576785302},{"_id":"source/images/mfa/bg.png","hash":"cbedc017c425e8db16698c5e162a5171e6a6f27f","modified":1732170553537},{"_id":"source/images/internal-loss/depressed.jpg","hash":"8ff19e979ef211030d79fc29eca3bef0ed42f9e9","modified":1711678444570},{"_id":"source/images/mfa/github.png","hash":"a19a0b7ebdcb4c8e17a7e3fa11f87a2d0540c99f","modified":1732157808898},{"_id":"source/images/mfa/web.png","hash":"951c2f74e5cecb877194458272a6c2220f8423f1","modified":1732157561158},{"_id":"source/images/mfa/run.png","hash":"a7e3121b6cd448b1d6d6955e0ccbbd43c5af8cb8","modified":1732157597417},{"_id":"source/images/image-search/bg.jpg","hash":"a02f0b66241373b0fb83610977010c41297c6985","modified":1718069912767},{"_id":"source/images/image-search/process.png","hash":"c1f5c3452b606dc8a510d9b3a5a24b330eff06eb","modified":1717772066200},{"_id":"source/images/proxy/transparent-proxy.png","hash":"e2bc2ee06dbfa33170ec3120277f21f4e3e503f9","modified":1718890992387},{"_id":"source/images/image-search/qdrant.png","hash":"0c42f079a8b35f9fe8da6c3b3cf3180e9d603c62","modified":1717773798375},{"_id":"source/images/js-signal/EventTarget.png","hash":"818561377792246188fd5e247e0de485c99b889e","modified":1730776254380},{"_id":"source/images/proxy/forward-proxy.png","hash":"49892dfa05b23599732f106b70b44fa95bc2eaa5","modified":1718888217801},{"_id":"source/images/proxy/reverse-proxy.png","hash":"57444303e4d4327cd1ebaedd3d954dfcf2486b69","modified":1718888319294},{"_id":"source/images/proxy/bg.jpg","hash":"c884b6efad5351ee2996fe0d18715fb27f7b3749","modified":1718931303461},{"_id":"source/images/js-signal/EventTarget2.png","hash":"58db529e086abb315e24f6738d871e776e72f9c6","modified":1730777763048},{"_id":"source/images/js-signal/EventTarget3.png","hash":"e5f9ea6836e53d2a388a09cf54190253f5d4a467","modified":1730788409397},{"_id":"source/images/rabbitmq-basic/channel2.png","hash":"f09e7365fd1026393f0b89777406570fbb1be70b","modified":1720580479287},{"_id":"source/images/rabbitmq-basic/channel1.png","hash":"fcde762d9619fe15b3fbdbe32455dfee9214dee0","modified":1720580078238},{"_id":"source/images/rabbitmq-basic/direct-exchange.svg","hash":"e1e7e8648d3c479c2b4223af6be07e434ea62730","modified":1720612845887},{"_id":"source/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","hash":"ec548510fb86ab373be5decbb3f65896813d048b","modified":1720517279179},{"_id":"source/images/rabbitmq-basic/fanout-exchange.svg","hash":"5e14973b4eba3986a1805c585260d34e781c512a","modified":1720612870539},{"_id":"source/images/rabbitmq-basic/main.png","hash":"e45cabff6e1cc9ea8477412977a49277b9656faa","modified":1720530900322},{"_id":"source/images/rabbitmq-basic/fanout.png","hash":"6458eb591f42ff61e67364d480c4b2c0dc1ff3bf","modified":1720524567852},{"_id":"source/images/rabbitmq-quarum/stream_error2.png","hash":"0d84d8d3ae357383925c86c728d865ce461bce8b","modified":1720855694734},{"_id":"source/images/rabbitmq-quarum/quarum2.png","hash":"7c88c03d166aee001257f3fe29918c29ff0df8bb","modified":1720680123566},{"_id":"source/images/rabbitmq-quarum/normal.png","hash":"7a81405dc9d73b0a7cdff3b685c35853bad1cb1a","modified":1720679165151},{"_id":"source/images/rabbitmq-quarum/quarum1.png","hash":"e24787c731793ab83bc335c08dcf21060babd92d","modified":1720704401188},{"_id":"source/images/rabbitmq-quarum/stream_error1.png","hash":"ce4c9e1a9a9da1cb4278e2e74be852611c8c265d","modified":1720855445532},{"_id":"source/images/redis-interview/memory.png","hash":"37fadd91ec8573c6c30ec5fd32562f2c3d22d5a9","modified":1714031983730},{"_id":"source/images/redis-interview/cache-penetration.png","hash":"17f21e18052f40f20189a31c4bfbf749a1dedcbc","modified":1714100540904},{"_id":"source/images/redis-interview/recruitment.png","hash":"9da7eff910bfb50b7f11618614003b6153e71d98","modified":1713425715760},{"_id":"source/images/quic/head_of_line_blocking.png","hash":"2203cca89e72b24f13cc9774fb78ee64927f32ea","modified":1723801376313},{"_id":"source/images/rspack/result1.png","hash":"a9520839c7ee5c932364c29354b20e80001b531c","modified":1732866474263},{"_id":"source/images/sticky-packet/sender-sticky.png","hash":"199862fcf0175fe9b9acca3c698c58482dd123c5","modified":1724987423202},{"_id":"source/images/quic/quic-logo.png","hash":"f2cf0868ef61bfe597981193c314327741c5a48e","modified":1724382247911},{"_id":"source/images/sticky-packet/bg.jpg","hash":"9a73ba1e1dfa83d5e79399fe25745e9c90915762","modified":1724999655551},{"_id":"source/images/sticky-packet/solve-server-sticky.png","hash":"0833d4fd870412068dc5b3515a60e9f078bd0ae9","modified":1724990256799},{"_id":"source/images/sticky-packet/server-sticky.png","hash":"8a7a47f695c9d74f4bebb7cf444d221e59bc8923","modified":1724988818136},{"_id":"source/images/sticky-packet/solve-sender-sticky.png","hash":"9060a5391d9fe9f8a5b49dbda8ef182d7690e0c5","modified":1724998588917},{"_id":"source/images/webrtc/bg.png","hash":"9ba29395c41cce47b769f3623ae2fac7390ca226","modified":1734489675642},{"_id":"source/images/webrtc/server.png","hash":"71034110834293ac533faba16cb15b2d62f7c6ec","modified":1734400685422},{"_id":"source/images/webrtc/connections.png","hash":"3f79caaf253bb208eb221aba617064d3985f2314","modified":1734403965091},{"_id":"source/images/webrtc/webrtc-overview.svg","hash":"46b2ff10a8f0316759ab8cf1b8e6e2e64380da23","modified":1734405333222},{"_id":"source/images/stream-output/gzip.png","hash":"bebbc7498d81a46696636a49aa736063466f090a","modified":1731488916979},{"_id":"source/images/task-completion-source/pause-2.png","hash":"f681d83790b004e1703e18560c2f7d2db0cd6d01","modified":1717658059375},{"_id":"source/images/task-completion-source/pause-1.png","hash":"14d301e1283ad280dd8ea0525be0e5c38531ef74","modified":1717658041988},{"_id":"source/images/task-completion-source/bg.jpg","hash":"762d9571bdc71e36879c00907cb524e825980694","modified":1718067987009},{"_id":"source/images/dead-message/dead-letter-2.jpg","hash":"424a4237b4485e845ed3e9e6e74ee1f34485d196","modified":1716542966790},{"_id":"source/images/dump/bg.png","hash":"32c7ad31ef1117233e7691e74198041f62870e63","modified":1714290251488},{"_id":"source/images/docker-1/configurations.png","hash":"c6f58a834400b5d6fff7c76249562888a908304c","modified":1720252449460},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","hash":"7b141675f4bd37c8d65a63b5d22612430b945720","modified":1716621402662},{"_id":"source/images/docker-1/multi-env.png","hash":"a8aa3cdee473ee5987c28a30c4def6b06b1c4708","modified":1720253343754},{"_id":"source/images/encrypt-hash-signature/certificate.png","hash":"107871901480c47bdf9fbc41a0d51511c78498e5","modified":1730875039053},{"_id":"source/images/dump/windbg_4.png","hash":"5618b95c756aab451803e23e9c0f77b5fa94e6b4","modified":1715069009388},{"_id":"source/images/http/auto-disconnect.png","hash":"6eb07b19f5350b86e32c41503abdef786d1cc8a3","modified":1711368567428},{"_id":"source/images/http/handshake-2.png","hash":"f50dd3fab7ff21a20cd91622aefb077b7ec74b89","modified":1711353457535},{"_id":"source/images/http/timeout-auto-disconnect.png","hash":"87f74686dc596abb5be91260a40dcf38ed3d0d17","modified":1711433208748},{"_id":"source/images/http/request-methods.png","hash":"5914a2642fc3c771aaddbb5a4db79d020c75ba27","modified":1710917201189},{"_id":"source/images/helm/lens-helm.png","hash":"fda441250c1bc5e52beed094d8b976c0d877bd37","modified":1733905363051},{"_id":"source/images/docker-2/inspect3.png","hash":"e8523ef78b9823458520eb25300303381b046a8e","modified":1720441204166},{"_id":"source/images/garnet/1.png","hash":"0d8a64004413ec34a334cce4925372781b3c88b0","modified":1712566365601},{"_id":"source/images/garnet/log.png","hash":"0c32a044823dd2b85353c2816c9109c9df0626b4","modified":1712721260633},{"_id":"source/images/https/client-hello.png","hash":"65039f3b5656ce343d9c36842642aedef464f9d1","modified":1712827328350},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","hash":"f637ac12cf901b7e557077687482f7232bbc2a72","modified":1711685199687},{"_id":"source/images/internal-loss/996.jpg","hash":"d712414d1167ea1a5790683d549a3dbf56cc3c8c","modified":1711684344049},{"_id":"source/images/log/long.png","hash":"08675894c527af3804511fedea61148084e98500","modified":1734579843735},{"_id":"source/images/rabbitmq-basic/rabbitmq-headers-exchange.svg","hash":"b9983fdc354c45500fcfe57e9f78ab4cb88a2c4d","modified":1720612881431},{"_id":"source/images/rabbitmq-basic/topic-exchange.svg","hash":"ed3868a0efc180866dca5c7ba33cb6797ad96bc5","modified":1720612864235},{"_id":"source/images/rabbitmq-quarum/stream_offset.png","hash":"156f277e1c766644c8704892454397fc113f153d","modified":1720856674850},{"_id":"source/images/redis-interview/cache-breakdown.png","hash":"de31f8ba0958f9428c1148746206f8351fa1bf18","modified":1714100525728},{"_id":"source/images/redis-interview/cache-avalanche.png","hash":"8bcdb1787aa12c08febeb8c2324cf7fa9c6d3c02","modified":1714100497420},{"_id":"source/images/quic/quic.png","hash":"5a459deaef952ec228d3515dfdbf47048fc05c5c","modified":1724379367865},{"_id":"source/images/quic/handshake.png","hash":"38daab0f33947a35e7caacf41e3e2979cc854b89","modified":1723797528048},{"_id":"source/images/quic/tcp.png","hash":"1fba23e6486468abf1e4baa60d8a2cf85c5685cf","modified":1724377517189},{"_id":"source/images/dump/windbg_2.png","hash":"e55722d89679167f37e0b851a53e27ae989663f8","modified":1714439116512},{"_id":"source/images/http/auto-disconnect2.png","hash":"d96b55fe2a3d138263e29ec9ba3a171b78eaf003","modified":1711356920847},{"_id":"source/images/rabbitmq-basic/default-exchange.png","hash":"da48c3eae865c3758c2998b9234193ef1c52e26c","modified":1720515775722},{"_id":"source/images/rspack/tools.png","hash":"8074e78f7fd5fa877f317422f5dd1ac5b947823c","modified":1732869166096},{"_id":"source/images/rspack/bg.png","hash":"2b32b38f48f915b04be88f6cbf31bae0cbcc7fb2","modified":1732868708252},{"_id":"source/images/stream-output/sse-communication.png","hash":"274d518fb1af551094f0493daa37e69e6579c458","modified":1731490255089},{"_id":"source/images/docker-2/before.png","hash":"4d6df539061278c5a371d63bbf494a54ac390588","modified":1720419780264},{"_id":"source/images/dump/windbg_1.png","hash":"fec01b96435a46269b0a241c8feb13764458b0e9","modified":1714438955774},{"_id":"source/images/helm/lens-pod.png","hash":"770434a233f77381b1c4a98cf49ad068a325ce69","modified":1733905400785},{"_id":"source/images/https/encrypted.png","hash":"51f01f7c79cbb8e5ace366b423a46c677483d4f3","modified":1712827358003},{"_id":"source/images/stream-output/regular-http-communication.png","hash":"ace2e8bcb78fbd9f288105ea5c821a45625bde95","modified":1731490232699},{"_id":"source/images/daemonset/bg.png","hash":"b1603478da28b1f0e9b0f1e54d6eca8e30537b4b","modified":1722579353097},{"_id":"source/images/docker-2/after.png","hash":"2aa4ca9b53dc8a4270e3174115fcf96887185f64","modified":1720439019007},{"_id":"source/images/https/cipher-suites.png","hash":"e9faeff8e36d3efd82a5a0800c85a8e23d6ebf56","modified":1713149632927},{"_id":"source/images/https/negotiated-cipher-suite.png","hash":"32d7a6f6ad24e6c5755d2ba2626e0ba71520fd50","modified":1713149675775},{"_id":"source/images/redis-interview/bg.png","hash":"e5be0650aa2343b4a62218b58ebae10c4f4b9ba6","modified":1714101428369},{"_id":"source/images/js-signal/switch-theme.gif","hash":"8e8f0c1a5add7925ac6f7f5931d43a6f829373b7","modified":1730790295869},{"_id":"source/images/hello-bg.png","hash":"f70f2a6805ceb4ab1175e391c03923b7264bc431","modified":1705386424945},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688482306000},{"_id":"source/images/webrtc/1_kDeCUgDd-T-KLvSH4sTiLw.png","hash":"774ac8a3865a67d0ef56cc6104d6fb86a908d9a6","modified":1734074915610},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1688482306000},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1688482306000},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1688482306000},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1688482306000},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1688482306000},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1688482306000},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1688482306000},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1688482306000},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1688482306000},{"_id":"themes/archer/_config.yml","hash":"bf3d3444da07f4901d77f3455af63aeea406d8f8","modified":1723520595061},{"_id":"themes/archer/package.json","hash":"1177cb27ab8e279681f1e53c8f0f8735238fde8d","modified":1730794844406},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1688482306000},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1688482306000},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1688482306000},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1688482306000},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1688482306000},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1688482306000},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1711010720209},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1688482306000},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1688482306000},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1688482306000},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1688482306000},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1688482306000},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1688482306000},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1688482306000},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1688482306000},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"2afd877a9ae9509622a6163094ae27df17e36184","modified":1723102105116},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"f4b8e36a8ae882f3b1e194811b0c5a370913270f","modified":1725011450243},{"_id":"themes/archer/layout/layout.ejs","hash":"23235793df01cf129ae747293172dab307e2b9ac","modified":1725011322544},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1688482306000},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1688482306000},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1688482306000},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1688482306000},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1688482306000},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1688482306000},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1688482306000},{"_id":"themes/archer/source/assets/wechat_qr.jpg","hash":"20763d666624facc585e34645018deadb343b4b5","modified":1705482083315},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1688482306000},{"_id":"themes/archer/source/avatar/Jason.jpg","hash":"0eae332ea91f9e04b54f35d2ed1b17b5b37aee64","modified":1710397722571},{"_id":"themes/archer/source/assets/favicon_bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1688482306000},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1688482306000},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1688482306000},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1688482306000},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1688482306000},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1688482306000},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1688482306000},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1688482306000},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1688482306000},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1688482306000},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1688482306000},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1688482306000},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1688482306000},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1688482306000},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1688482306000},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1688482306000},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1688482306000},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1688482306000},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1688482306000},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1688482306000},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1688482306000},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1688482306000},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1688482306000},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1688482306000},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1688482306000},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1688482306000},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1688482306000},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1688482306000},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1688482306000},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1688482306000},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1688482306000},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1688482306000},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1688482306000},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1688482306000},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1688482306000},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1688482306000},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1688482306000},{"_id":"themes/archer/source/assets/favicon.ico","hash":"c136618e070daf370da961ac730973293a088b9e","modified":1710382119333},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1688482306000},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1688482306000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1688482306000},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1688482306000},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1688482306000},{"_id":"source/images/https/ca2.png","hash":"e71ae267fc6a9eda8943e4881e2f408b0a84055f","modified":1712827074795},{"_id":"source/images/js-signal/responsive.gif","hash":"32b125a785deeae5ffac981705d6f896369e0f1b","modified":1730450652968},{"_id":"source/images/docker-2/inspect1.png","hash":"e818b04708ae3c4ffa2ca0e3e890c5d2d4c0bb05","modified":1720441093812},{"_id":"source/images/docker-2/inspect2.png","hash":"30515858e2dddad39c76f016c55a02af8f639856","modified":1720441069919},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1688482306000},{"_id":"source/images/image-search/images.png","hash":"b2a77e00a2290543613f0df77f8c30337c91f441","modified":1717681798910},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1688482306000},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1688482306000},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1688482306000},{"_id":"themes/archer/package-lock.json","hash":"cb1c9f2f15fd88ac0b48014097d4386b8daf4ac6","modified":1735097136225},{"_id":"source/images/stream-output/result.gif","hash":"e6611131cf12bea45d6d4a548ac9142efc2dfe86","modified":1731404086880},{"_id":"source/images/image-search/search.gif","hash":"eb44e6dcab6b4292eb95ef63cbf64035ed01c878","modified":1717770772367},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1688482306000},{"_id":"source/images/stream-output/gpt-1.gif","hash":"764ea283c2613f6d12d84b4d1b38499b5ca565c5","modified":1731402848535},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1688482306000},{"_id":"source/images/stream-output/4a7aa-203zt.gif","hash":"67c0872a27bfb8d50f5f85e7a3f6f44fffec18bd","modified":1731034592330},{"_id":"source/images/rabbitmq-basic/fanout.mp4","hash":"132a8c24996e91d19467bff53d9fb453c609cb79","modified":1720611325113},{"_id":"source/images/rabbitmq-basic/16elk-ujaxc.gif","hash":"0b01075739b5d1b96d35a878bf55ff2575b50d41","modified":1720527427526},{"_id":"source/images/stream-output/sse.gif","hash":"5471fd5fefe89682d0187a3ccb7fd33044ce3359","modified":1731034795193},{"_id":"source/images/rabbitmq-basic/vro2s-b2mub.gif","hash":"70b8ce43edd1599dd11a8c8dd529c26405323082","modified":1720612469268},{"_id":"source/_posts/parallelism.md","hash":"86a4d802b4eb8a1ce9e35778c85e6ebc9c42103f","modified":1736317267620},{"_id":"source/images/parallelism/concurrency-result.png","hash":"3db8a207e5188e010d44c58ddea64fd71311ed2f","modified":1736240554152},{"_id":"source/images/parallelism/concurrency-vs-parallelism-2.png","hash":"4fd6173862df3c1b067d5bf7d819a6d2ca75dc40","modified":1736240672832},{"_id":"source/images/parallelism/concurrency-vs-parallelism-1.png","hash":"8f4fb3314f80e0c6a82f33064db84c05c7ffa478","modified":1736240660873},{"_id":"source/images/parallelism/parallelism-result.png","hash":"a5aa85c57c2f095da285c016b954b31b61f873f2","modified":1736240471813},{"_id":"source/images/log/whoami.jpg","hash":"c2770cfe797d0874caa175eb1f1a0ec681fd6735","modified":1735199209307},{"_id":"source/images/parallelism/concurrency-vs-parallelism-3.png","hash":"eda6c6fe8b20152b8d712f46a76baa5d27ec46ed","modified":1736240684542},{"_id":"source/images/log/bg.png","hash":"1d1fd20fa466aeec5cfb6f9e71322c1132fbf2fe","modified":1735201402107},{"_id":"source/images/parallelism/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1736269704686},{"_id":"source/_posts/docker-log.md","hash":"6277ec78715ac2c07b778aba5c34eed1abc451d1","modified":1738831963934},{"_id":"source/images/docker-log/log2.png","hash":"16057d65bce504bc50c9df4e556234a035f0d3a3","modified":1738807895677},{"_id":"source/images/parallelism/bg.jpg","hash":"4f40fcea3cee377e56d906645ff5fb2ed9aabc4e","modified":1736324992675},{"_id":"source/images/docker-log/log1.png","hash":"79ec752acb8d7a533e6e5747096b6bd54bcc17fe","modified":1738807140322},{"_id":"source/images/docker-log/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1738853895906},{"_id":"source/_posts/deepseek-1.md","hash":"8426d1d9e4d7b5f25986c5e0df7da09c93b05c7d","modified":1738915229981},{"_id":"source/images/deepseek-1/download.png","hash":"0a6d5cbaa8b0b86e005028706f149c8106a53699","modified":1738911122666},{"_id":"source/images/deepseek-1/deepseek-models.png","hash":"d668dcfc63c26f25272b0fc517eddd359a1f5ba7","modified":1738899736949},{"_id":"source/images/docker-log/log3.png","hash":"6b51a12688a7acf913c6883b6a7526bf6d1b90d9","modified":1738827287697},{"_id":"source/images/deepseek-1/late.jpg","hash":"d48b1789f7cd24eac8a3618b0154f76d26fb255a","modified":1738897669658},{"_id":"source/images/deepseek-1/chatbox-setting2.png","hash":"084982a7f7ba9b139e24f32fb9c3aa9af8a35ef5","modified":1738914777220},{"_id":"source/images/deepseek-1/chatbox-setting.png","hash":"85d3323cf19f5532bbdbd77c11038c630ff04e01","modified":1738914750350},{"_id":"source/images/docker-log/log4.png","hash":"e014e11d1fada994b4cc720ff713f971a2a0283e","modified":1738827357024},{"_id":"source/images/deepseek-1/chatbox-setting4.png","hash":"b0bca8108e2617764eb33327a786901ac0c2623c","modified":1738915149697},{"_id":"source/images/deepseek-1/models.png","hash":"13d4b90b4fe8b5ddf880ecc8a552a8cc7270f64e","modified":1738899518057},{"_id":"source/images/deepseek-1/env_var.png","hash":"eb7e7f64e4b36d2a26042653fbc7dd51f6a89840","modified":1738913934713},{"_id":"source/images/deepseek-1/PageAssist.png","hash":"e6c457aed24d226c1e14cc3713d01aa2aa0bf2c9","modified":1738919852130},{"_id":"source/images/deepseek-1/chatboxai.png","hash":"4c1480c05a3f8278167c75283c6fdc6a20823033","modified":1738914427827},{"_id":"source/images/docker-log/log5.png","hash":"b63fe108723f011bcd4cfbb5f0342e053ad04e61","modified":1738831913419},{"_id":"source/images/docker-log/bg.png","hash":"f2af0b61e769c240a2d901b15f092fece99082b2","modified":1738834078837},{"_id":"source/images/deepseek-1/pulling.png","hash":"fe9c99ee0055aec3042453f712d2922d8d4588c0","modified":1738899189346},{"_id":"source/images/deepseek-1/pull.png","hash":"3366a7b8808b638d21ec89e0428f34dc3dcc39fb","modified":1738899057503},{"_id":"source/images/deepseek-1/success.png","hash":"b333b1cd1c7f4caf5cc2f667692b258a6be21631","modified":1739148944344}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"深入解析消息队列中的死信队列","date":"2024-05-22T07:37:54.000Z","_content":"\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","source":"_posts/dead-message.md","raw":"---\ntitle: 深入解析消息队列中的死信队列\ndate: 2024-05-22 15:37:54\ntags:\n---\n\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","slug":"dead-message","published":1,"updated":"2024-05-25T09:23:07.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihlw0000m8p13zxt6ptn","content":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n"},{"title":"Docker隐藏在细节中的技术基础","date":"2024-07-05T11:59:06.000Z","_content":"## 引言\nDocker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。\n\n开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转[Docker教程](https://www.runoob.com/docker/docker-tutorial.html)\n\n## 为什么需要Docker\n![multi-envs](/images/docker-1/multi-env.png)\n软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？\n\n用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。\n\n如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：\"它在我的机器上是正常的呀\"，言下之意就是，其他机器很可能跑不了。\n\n环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。\n\n## 虚拟机与容器：理解深层次差异\n### 资源隔离与共享\n+ 虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。\n+ 容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。\n\n### 常见误区：容器的隔离性\n很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。\n\n## 文件系统与存储卷：隐形的性能瓶颈\n### Union File System\nDocker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。\n\n### 联合文件系统的分层结构\n联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。\n\n### 分层文件系统与写操作\n在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：\n\n1. 读取原始文件：从只读层读取文件内容。\n2. 复制到可写层：将读取的文件内容复制到可写层。\n3. 修改文件：在可写层中修改文件内容。\n\n### 性能下降的原因\n1. 写时复制操作\n每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I/O操作的开销，尤其是在频繁写入或修改大量文件时。\n\n2. 层次结构复杂性\n分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。\n\n3. 合并视图的开销\n联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。\n\n\n### 实际案例：大量文件写入操作\n如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。\n\n在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。\n\n```dockerfile\n# Dockerfile 示例\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nVOLUME /app/data\nCMD [\"python\", \"app.py\"]\n```\n\n在docker-compose.yml中配置卷挂载：\n\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    volumes:\n      - ./data:/app/data\n```\n\n## 网络与安全：看不见的陷阱\n### 网络模式选择\nDocker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。\n\n### 安全隐患：默认桥接网络\n默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。\n\n```bash\n# 创建用户自定义桥接网络\ndocker network create --driver bridge my_bridge_network\n\n# 启动容器时指定网络\ndocker run --network my_bridge_network my_app\n```\n\n## 镜像管理：隐形的资源浪费\n### 镜像层叠与大小控制\nDocker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。\n\n### 实践建议：定期清理\n定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n\n# 清理未使用的卷\ndocker volume prune\n\n# 清理未使用的网络\ndocker network prune\n```\n\n## 日志管理：忽视的存储负担\n### 日志驱动与存储策略\nDocker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。\n\n### 实践建议：日志轮转与外部存储\n配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n或者将日志发送到外部系统，如ELK堆栈：\n\n```json\n{\n  \"log-driver\": \"gelf\",\n  \"log-opts\": {\n    \"gelf-address\": \"udp://logstash:12201\"\n  }\n}\n```\n\n## 结语\n通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。\n\n***\n\n希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/docker-1.md","raw":"---\ntitle: Docker隐藏在细节中的技术基础\ndate: 2024-07-05 19:59:06\ntags:\n---\n## 引言\nDocker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。\n\n开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转[Docker教程](https://www.runoob.com/docker/docker-tutorial.html)\n\n## 为什么需要Docker\n![multi-envs](/images/docker-1/multi-env.png)\n软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？\n\n用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。\n\n如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：\"它在我的机器上是正常的呀\"，言下之意就是，其他机器很可能跑不了。\n\n环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。\n\n## 虚拟机与容器：理解深层次差异\n### 资源隔离与共享\n+ 虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。\n+ 容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。\n\n### 常见误区：容器的隔离性\n很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。\n\n## 文件系统与存储卷：隐形的性能瓶颈\n### Union File System\nDocker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。\n\n### 联合文件系统的分层结构\n联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。\n\n### 分层文件系统与写操作\n在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：\n\n1. 读取原始文件：从只读层读取文件内容。\n2. 复制到可写层：将读取的文件内容复制到可写层。\n3. 修改文件：在可写层中修改文件内容。\n\n### 性能下降的原因\n1. 写时复制操作\n每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I/O操作的开销，尤其是在频繁写入或修改大量文件时。\n\n2. 层次结构复杂性\n分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。\n\n3. 合并视图的开销\n联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。\n\n\n### 实际案例：大量文件写入操作\n如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。\n\n在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。\n\n```dockerfile\n# Dockerfile 示例\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nVOLUME /app/data\nCMD [\"python\", \"app.py\"]\n```\n\n在docker-compose.yml中配置卷挂载：\n\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    volumes:\n      - ./data:/app/data\n```\n\n## 网络与安全：看不见的陷阱\n### 网络模式选择\nDocker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。\n\n### 安全隐患：默认桥接网络\n默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。\n\n```bash\n# 创建用户自定义桥接网络\ndocker network create --driver bridge my_bridge_network\n\n# 启动容器时指定网络\ndocker run --network my_bridge_network my_app\n```\n\n## 镜像管理：隐形的资源浪费\n### 镜像层叠与大小控制\nDocker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。\n\n### 实践建议：定期清理\n定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n\n# 清理未使用的卷\ndocker volume prune\n\n# 清理未使用的网络\ndocker network prune\n```\n\n## 日志管理：忽视的存储负担\n### 日志驱动与存储策略\nDocker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。\n\n### 实践建议：日志轮转与外部存储\n配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n或者将日志发送到外部系统，如ELK堆栈：\n\n```json\n{\n  \"log-driver\": \"gelf\",\n  \"log-opts\": {\n    \"gelf-address\": \"udp://logstash:12201\"\n  }\n}\n```\n\n## 结语\n通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。\n\n***\n\n希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！","slug":"docker-1","published":1,"updated":"2024-07-06T08:46:28.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihme0001m8p1f0klhmcw","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Docker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。</p>\n<p>开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转<a href=\"https://www.runoob.com/docker/docker-tutorial.html\">Docker教程</a></p>\n<h2 id=\"为什么需要Docker\"><a href=\"#为什么需要Docker\" class=\"headerlink\" title=\"为什么需要Docker\"></a>为什么需要Docker</h2><p><img src=\"/images/docker-1/multi-env.png\" alt=\"multi-envs\"><br>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？</p>\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。</p>\n<p>如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：”它在我的机器上是正常的呀”，言下之意就是，其他机器很可能跑不了。</p>\n<p>环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n<h2 id=\"虚拟机与容器：理解深层次差异\"><a href=\"#虚拟机与容器：理解深层次差异\" class=\"headerlink\" title=\"虚拟机与容器：理解深层次差异\"></a>虚拟机与容器：理解深层次差异</h2><h3 id=\"资源隔离与共享\"><a href=\"#资源隔离与共享\" class=\"headerlink\" title=\"资源隔离与共享\"></a>资源隔离与共享</h3><ul>\n<li>虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。</li>\n<li>容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。</li>\n</ul>\n<h3 id=\"常见误区：容器的隔离性\"><a href=\"#常见误区：容器的隔离性\" class=\"headerlink\" title=\"常见误区：容器的隔离性\"></a>常见误区：容器的隔离性</h3><p>很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。</p>\n<h2 id=\"文件系统与存储卷：隐形的性能瓶颈\"><a href=\"#文件系统与存储卷：隐形的性能瓶颈\" class=\"headerlink\" title=\"文件系统与存储卷：隐形的性能瓶颈\"></a>文件系统与存储卷：隐形的性能瓶颈</h2><h3 id=\"Union-File-System\"><a href=\"#Union-File-System\" class=\"headerlink\" title=\"Union File System\"></a>Union File System</h3><p>Docker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。</p>\n<h3 id=\"联合文件系统的分层结构\"><a href=\"#联合文件系统的分层结构\" class=\"headerlink\" title=\"联合文件系统的分层结构\"></a>联合文件系统的分层结构</h3><p>联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。</p>\n<h3 id=\"分层文件系统与写操作\"><a href=\"#分层文件系统与写操作\" class=\"headerlink\" title=\"分层文件系统与写操作\"></a>分层文件系统与写操作</h3><p>在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：</p>\n<ol>\n<li>读取原始文件：从只读层读取文件内容。</li>\n<li>复制到可写层：将读取的文件内容复制到可写层。</li>\n<li>修改文件：在可写层中修改文件内容。</li>\n</ol>\n<h3 id=\"性能下降的原因\"><a href=\"#性能下降的原因\" class=\"headerlink\" title=\"性能下降的原因\"></a>性能下降的原因</h3><ol>\n<li><p>写时复制操作<br>每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I&#x2F;O操作的开销，尤其是在频繁写入或修改大量文件时。</p>\n</li>\n<li><p>层次结构复杂性<br>分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。</p>\n</li>\n<li><p>合并视图的开销<br>联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。</p>\n</li>\n</ol>\n<h3 id=\"实际案例：大量文件写入操作\"><a href=\"#实际案例：大量文件写入操作\" class=\"headerlink\" title=\"实际案例：大量文件写入操作\"></a>实际案例：大量文件写入操作</h3><p>如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。</p>\n<p>在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile 示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/data</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>在docker-compose.yml中配置卷挂载：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data:/app/data</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络与安全：看不见的陷阱\"><a href=\"#网络与安全：看不见的陷阱\" class=\"headerlink\" title=\"网络与安全：看不见的陷阱\"></a>网络与安全：看不见的陷阱</h2><h3 id=\"网络模式选择\"><a href=\"#网络模式选择\" class=\"headerlink\" title=\"网络模式选择\"></a>网络模式选择</h3><p>Docker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。</p>\n<h3 id=\"安全隐患：默认桥接网络\"><a href=\"#安全隐患：默认桥接网络\" class=\"headerlink\" title=\"安全隐患：默认桥接网络\"></a>安全隐患：默认桥接网络</h3><p>默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户自定义桥接网络</span></span><br><span class=\"line\">docker network create --driver bridge my_bridge_network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时指定网络</span></span><br><span class=\"line\">docker run --network my_bridge_network my_app</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"镜像管理：隐形的资源浪费\"><a href=\"#镜像管理：隐形的资源浪费\" class=\"headerlink\" title=\"镜像管理：隐形的资源浪费\"></a>镜像管理：隐形的资源浪费</h2><h3 id=\"镜像层叠与大小控制\"><a href=\"#镜像层叠与大小控制\" class=\"headerlink\" title=\"镜像层叠与大小控制\"></a>镜像层叠与大小控制</h3><p>Docker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。</p>\n<h3 id=\"实践建议：定期清理\"><a href=\"#实践建议：定期清理\" class=\"headerlink\" title=\"实践建议：定期清理\"></a>实践建议：定期清理</h3><p>定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的卷</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的网络</span></span><br><span class=\"line\">docker network prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志管理：忽视的存储负担\"><a href=\"#日志管理：忽视的存储负担\" class=\"headerlink\" title=\"日志管理：忽视的存储负担\"></a>日志管理：忽视的存储负担</h2><h3 id=\"日志驱动与存储策略\"><a href=\"#日志驱动与存储策略\" class=\"headerlink\" title=\"日志驱动与存储策略\"></a>日志驱动与存储策略</h3><p>Docker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。</p>\n<h3 id=\"实践建议：日志轮转与外部存储\"><a href=\"#实践建议：日志轮转与外部存储\" class=\"headerlink\" title=\"实践建议：日志轮转与外部存储\"></a>实践建议：日志轮转与外部存储</h3><p>配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>或者将日志发送到外部系统，如ELK堆栈：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gelf&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;gelf-address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;udp://logstash:12201&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。</p>\n<hr>\n<p>希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Docker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。</p>\n<p>开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转<a href=\"https://www.runoob.com/docker/docker-tutorial.html\">Docker教程</a></p>\n<h2 id=\"为什么需要Docker\"><a href=\"#为什么需要Docker\" class=\"headerlink\" title=\"为什么需要Docker\"></a>为什么需要Docker</h2><p><img src=\"/images/docker-1/multi-env.png\" alt=\"multi-envs\"><br>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？</p>\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。</p>\n<p>如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：”它在我的机器上是正常的呀”，言下之意就是，其他机器很可能跑不了。</p>\n<p>环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n<h2 id=\"虚拟机与容器：理解深层次差异\"><a href=\"#虚拟机与容器：理解深层次差异\" class=\"headerlink\" title=\"虚拟机与容器：理解深层次差异\"></a>虚拟机与容器：理解深层次差异</h2><h3 id=\"资源隔离与共享\"><a href=\"#资源隔离与共享\" class=\"headerlink\" title=\"资源隔离与共享\"></a>资源隔离与共享</h3><ul>\n<li>虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。</li>\n<li>容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。</li>\n</ul>\n<h3 id=\"常见误区：容器的隔离性\"><a href=\"#常见误区：容器的隔离性\" class=\"headerlink\" title=\"常见误区：容器的隔离性\"></a>常见误区：容器的隔离性</h3><p>很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。</p>\n<h2 id=\"文件系统与存储卷：隐形的性能瓶颈\"><a href=\"#文件系统与存储卷：隐形的性能瓶颈\" class=\"headerlink\" title=\"文件系统与存储卷：隐形的性能瓶颈\"></a>文件系统与存储卷：隐形的性能瓶颈</h2><h3 id=\"Union-File-System\"><a href=\"#Union-File-System\" class=\"headerlink\" title=\"Union File System\"></a>Union File System</h3><p>Docker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。</p>\n<h3 id=\"联合文件系统的分层结构\"><a href=\"#联合文件系统的分层结构\" class=\"headerlink\" title=\"联合文件系统的分层结构\"></a>联合文件系统的分层结构</h3><p>联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。</p>\n<h3 id=\"分层文件系统与写操作\"><a href=\"#分层文件系统与写操作\" class=\"headerlink\" title=\"分层文件系统与写操作\"></a>分层文件系统与写操作</h3><p>在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：</p>\n<ol>\n<li>读取原始文件：从只读层读取文件内容。</li>\n<li>复制到可写层：将读取的文件内容复制到可写层。</li>\n<li>修改文件：在可写层中修改文件内容。</li>\n</ol>\n<h3 id=\"性能下降的原因\"><a href=\"#性能下降的原因\" class=\"headerlink\" title=\"性能下降的原因\"></a>性能下降的原因</h3><ol>\n<li><p>写时复制操作<br>每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I&#x2F;O操作的开销，尤其是在频繁写入或修改大量文件时。</p>\n</li>\n<li><p>层次结构复杂性<br>分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。</p>\n</li>\n<li><p>合并视图的开销<br>联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。</p>\n</li>\n</ol>\n<h3 id=\"实际案例：大量文件写入操作\"><a href=\"#实际案例：大量文件写入操作\" class=\"headerlink\" title=\"实际案例：大量文件写入操作\"></a>实际案例：大量文件写入操作</h3><p>如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。</p>\n<p>在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile 示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/data</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>在docker-compose.yml中配置卷挂载：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data:/app/data</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络与安全：看不见的陷阱\"><a href=\"#网络与安全：看不见的陷阱\" class=\"headerlink\" title=\"网络与安全：看不见的陷阱\"></a>网络与安全：看不见的陷阱</h2><h3 id=\"网络模式选择\"><a href=\"#网络模式选择\" class=\"headerlink\" title=\"网络模式选择\"></a>网络模式选择</h3><p>Docker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。</p>\n<h3 id=\"安全隐患：默认桥接网络\"><a href=\"#安全隐患：默认桥接网络\" class=\"headerlink\" title=\"安全隐患：默认桥接网络\"></a>安全隐患：默认桥接网络</h3><p>默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户自定义桥接网络</span></span><br><span class=\"line\">docker network create --driver bridge my_bridge_network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时指定网络</span></span><br><span class=\"line\">docker run --network my_bridge_network my_app</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"镜像管理：隐形的资源浪费\"><a href=\"#镜像管理：隐形的资源浪费\" class=\"headerlink\" title=\"镜像管理：隐形的资源浪费\"></a>镜像管理：隐形的资源浪费</h2><h3 id=\"镜像层叠与大小控制\"><a href=\"#镜像层叠与大小控制\" class=\"headerlink\" title=\"镜像层叠与大小控制\"></a>镜像层叠与大小控制</h3><p>Docker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。</p>\n<h3 id=\"实践建议：定期清理\"><a href=\"#实践建议：定期清理\" class=\"headerlink\" title=\"实践建议：定期清理\"></a>实践建议：定期清理</h3><p>定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的卷</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的网络</span></span><br><span class=\"line\">docker network prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志管理：忽视的存储负担\"><a href=\"#日志管理：忽视的存储负担\" class=\"headerlink\" title=\"日志管理：忽视的存储负担\"></a>日志管理：忽视的存储负担</h2><h3 id=\"日志驱动与存储策略\"><a href=\"#日志驱动与存储策略\" class=\"headerlink\" title=\"日志驱动与存储策略\"></a>日志驱动与存储策略</h3><p>Docker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。</p>\n<h3 id=\"实践建议：日志轮转与外部存储\"><a href=\"#实践建议：日志轮转与外部存储\" class=\"headerlink\" title=\"实践建议：日志轮转与外部存储\"></a>实践建议：日志轮转与外部存储</h3><p>配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>或者将日志发送到外部系统，如ELK堆栈：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gelf&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;gelf-address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;udp://logstash:12201&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。</p>\n<hr>\n<p>希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"深入理解容器镜像层","date":"2024-08-08T06:58:18.000Z","_content":"\n之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！\n\n容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。\n\n# 构建分层图像\n创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：\n```\nFROM alpine\nRUN echo \"hello\" > /usr/file1.txt\nCOPY requirements.txt /usr/file2.txt\nRUN rm -rf /usr/file1.txt\n```\n在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。\n\n让我们逐步了解一种可能的实施方法的示例。\n\n1. FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示/img/layer1。\n\n2. 创建第二个目录/img/layer2。从/img/layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入/img/layer2/usr/file1.txt。这是第二层。\n\n3. 创建第三个目录/img/layer3。从img/layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。\n\n4. 最后，创建第四个目录/img/layer4。从img/layer3中拷贝所有内容。下一个命令删除消息文件img/layer4/usr/file1.txt。这是第四层。\n\n要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。\n\n继续我们的例子，压缩文件将包含：\n\n|文件|内容|\n|  ----  | ----  |\n|layer1.tar.gz|\t精简的linux基础环境|\n|layer2.tar.gz|\t包含/usr/file1.txt|\n|layer3.tar.gz|\t包含/usr/file2.txt（因为file1.txt未被修改）|\n|layer4.tar.gz|\t包含/usr/.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。|\n\n以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。\n\n为了使结果可重现，还需要一件事---一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。\n\n引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY --link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。\n\n# 快照\n在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。\n\n创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。\n\n使用我们之前的例子：\n\n1. 初始层，FROM alpine基础的linux环境；\n\n2. 创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含/work/file1.txt 的目录。这是第一个提交的快照。\n\n3. 创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含/work/file1.txt和/work/file2.txt的目录。这是第二个已提交的快照。\n\n4. 创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 /work/.wh.file1.txt，并删除/work/file1.txt。这样就只剩下/work/file2.txt。这是第三个已提交的快照。\n\n5. 由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。\n\n如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：\n\n```\n \"RootFS\": {\n    \"Type\": \"layers\",\n    \"Layers\": [\n        \"sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07\",\n        \"sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091\",\n        \"sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e\",\n        \"sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399\"\n    ]\n},\n``` \n\n实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。\n\n# 叠加层\n用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容\n![文件系统](/images/docker-layer/filesystem.png)\n\n\n看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？\n\n在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。\n\n每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。\n\n如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。\n\n这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100= 30GB 的文件。并且需要占用 30GB 的磁盘空间。\n\n当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。\n\n\n这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。\n\n事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。\n\n在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。\n\n虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。\n\n## 测试与分析\n下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：\n\n1. 创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）\n```\nmkdir /mytmpfs\nmount -t tmpfs tmpfs /mytmpfs\n```\n\n2. 为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。\n```\nsudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录\nsudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上\nsudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录\nsudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录\n```\n\n3. 为实验创建一些文件。\n```\ncd /mytmpfs\necho hello > lowerdir/hello.txt\necho \"delete me\" > lowerdir/delete-me.txt\necho message > upperdir/upper-message.txt\n```\n4. 将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork\n```\nmount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged\n```\n\n5. 查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：\n![merged](/images/docker-layer/merged.png)\n```\nrm -rf merged/delete-me.txt\necho \"I'm new one\" > merged/new.txt\necho world >> merged/hello.txt\n```\n6. 正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：\n![directory tree](/images/docker-layer/tree.png)\n\n当你在 merged 目录中执行 rm -rf merged/delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。\n   \n\n## 最终结果：\n\nupperdir/ 的文件结构：\n\n执行ls -l upperdir 可以看到如下结果\n![directory tree](/images/docker-layer/ls_upper.png)\n\n+ delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。\n+ hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。\n+ new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。\n+ upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。\n\n可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。\n\n\n希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/docker-layer.md","raw":"---\ntitle: 深入理解容器镜像层\ndate: 2024-08-08 14:58:18\ntags:\n---\n\n之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！\n\n容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。\n\n# 构建分层图像\n创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：\n```\nFROM alpine\nRUN echo \"hello\" > /usr/file1.txt\nCOPY requirements.txt /usr/file2.txt\nRUN rm -rf /usr/file1.txt\n```\n在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。\n\n让我们逐步了解一种可能的实施方法的示例。\n\n1. FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示/img/layer1。\n\n2. 创建第二个目录/img/layer2。从/img/layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入/img/layer2/usr/file1.txt。这是第二层。\n\n3. 创建第三个目录/img/layer3。从img/layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。\n\n4. 最后，创建第四个目录/img/layer4。从img/layer3中拷贝所有内容。下一个命令删除消息文件img/layer4/usr/file1.txt。这是第四层。\n\n要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。\n\n继续我们的例子，压缩文件将包含：\n\n|文件|内容|\n|  ----  | ----  |\n|layer1.tar.gz|\t精简的linux基础环境|\n|layer2.tar.gz|\t包含/usr/file1.txt|\n|layer3.tar.gz|\t包含/usr/file2.txt（因为file1.txt未被修改）|\n|layer4.tar.gz|\t包含/usr/.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。|\n\n以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。\n\n为了使结果可重现，还需要一件事---一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。\n\n引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY --link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。\n\n# 快照\n在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。\n\n创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。\n\n使用我们之前的例子：\n\n1. 初始层，FROM alpine基础的linux环境；\n\n2. 创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含/work/file1.txt 的目录。这是第一个提交的快照。\n\n3. 创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含/work/file1.txt和/work/file2.txt的目录。这是第二个已提交的快照。\n\n4. 创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 /work/.wh.file1.txt，并删除/work/file1.txt。这样就只剩下/work/file2.txt。这是第三个已提交的快照。\n\n5. 由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。\n\n如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：\n\n```\n \"RootFS\": {\n    \"Type\": \"layers\",\n    \"Layers\": [\n        \"sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07\",\n        \"sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091\",\n        \"sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e\",\n        \"sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399\"\n    ]\n},\n``` \n\n实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。\n\n# 叠加层\n用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容\n![文件系统](/images/docker-layer/filesystem.png)\n\n\n看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？\n\n在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。\n\n每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。\n\n如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。\n\n这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100= 30GB 的文件。并且需要占用 30GB 的磁盘空间。\n\n当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。\n\n\n这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。\n\n事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。\n\n在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。\n\n虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。\n\n## 测试与分析\n下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：\n\n1. 创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）\n```\nmkdir /mytmpfs\nmount -t tmpfs tmpfs /mytmpfs\n```\n\n2. 为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。\n```\nsudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录\nsudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上\nsudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录\nsudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录\n```\n\n3. 为实验创建一些文件。\n```\ncd /mytmpfs\necho hello > lowerdir/hello.txt\necho \"delete me\" > lowerdir/delete-me.txt\necho message > upperdir/upper-message.txt\n```\n4. 将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork\n```\nmount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged\n```\n\n5. 查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：\n![merged](/images/docker-layer/merged.png)\n```\nrm -rf merged/delete-me.txt\necho \"I'm new one\" > merged/new.txt\necho world >> merged/hello.txt\n```\n6. 正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：\n![directory tree](/images/docker-layer/tree.png)\n\n当你在 merged 目录中执行 rm -rf merged/delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。\n   \n\n## 最终结果：\n\nupperdir/ 的文件结构：\n\n执行ls -l upperdir 可以看到如下结果\n![directory tree](/images/docker-layer/ls_upper.png)\n\n+ delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。\n+ hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。\n+ new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。\n+ upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。\n\n可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。\n\n\n希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"docker-layer","published":1,"updated":"2024-08-12T07:41:01.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmf0002m8p14npw205n","content":"<p>之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！</p>\n<p>容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。</p>\n<h1 id=\"构建分层图像\"><a href=\"#构建分层图像\" class=\"headerlink\" title=\"构建分层图像\"></a>构建分层图像</h1><p>创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine</span><br><span class=\"line\">RUN echo &quot;hello&quot; &gt; /usr/file1.txt</span><br><span class=\"line\">COPY requirements.txt /usr/file2.txt</span><br><span class=\"line\">RUN rm -rf /usr/file1.txt</span><br></pre></td></tr></table></figure>\n<p>在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。</p>\n<p>让我们逐步了解一种可能的实施方法的示例。</p>\n<ol>\n<li><p>FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示&#x2F;img&#x2F;layer1。</p>\n</li>\n<li><p>创建第二个目录&#x2F;img&#x2F;layer2。从&#x2F;img&#x2F;layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入&#x2F;img&#x2F;layer2&#x2F;usr&#x2F;file1.txt。这是第二层。</p>\n</li>\n<li><p>创建第三个目录&#x2F;img&#x2F;layer3。从img&#x2F;layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。</p>\n</li>\n<li><p>最后，创建第四个目录&#x2F;img&#x2F;layer4。从img&#x2F;layer3中拷贝所有内容。下一个命令删除消息文件img&#x2F;layer4&#x2F;usr&#x2F;file1.txt。这是第四层。</p>\n</li>\n</ol>\n<p>要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。</p>\n<p>继续我们的例子，压缩文件将包含：</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layer1.tar.gz</td>\n<td>精简的linux基础环境</td>\n</tr>\n<tr>\n<td>layer2.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file1.txt</td>\n</tr>\n<tr>\n<td>layer3.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file2.txt（因为file1.txt未被修改）</td>\n</tr>\n<tr>\n<td>layer4.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。</td>\n</tr>\n</tbody></table>\n<p>以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。</p>\n<p>为了使结果可重现，还需要一件事—一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。</p>\n<p>引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY –link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。</p>\n<h1 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h1><p>在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。</p>\n<p>创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。</p>\n<p>使用我们之前的例子：</p>\n<ol>\n<li><p>初始层，FROM alpine基础的linux环境；</p>\n</li>\n<li><p>创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含&#x2F;work&#x2F;file1.txt 的目录。这是第一个提交的快照。</p>\n</li>\n<li><p>创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含&#x2F;work&#x2F;file1.txt和&#x2F;work&#x2F;file2.txt的目录。这是第二个已提交的快照。</p>\n</li>\n<li><p>创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 &#x2F;work&#x2F;.wh.file1.txt，并删除&#x2F;work&#x2F;file1.txt。这样就只剩下&#x2F;work&#x2F;file2.txt。这是第三个已提交的快照。</p>\n</li>\n<li><p>由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。</p>\n</li>\n</ol>\n<p>如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;RootFS&quot;: &#123;</span><br><span class=\"line\">    &quot;Type&quot;: &quot;layers&quot;,</span><br><span class=\"line\">    &quot;Layers&quot;: [</span><br><span class=\"line\">        &quot;sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07&quot;,</span><br><span class=\"line\">        &quot;sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091&quot;,</span><br><span class=\"line\">        &quot;sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e&quot;,</span><br><span class=\"line\">        &quot;sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。</p>\n<h1 id=\"叠加层\"><a href=\"#叠加层\" class=\"headerlink\" title=\"叠加层\"></a>叠加层</h1><p>用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容<br><img src=\"/images/docker-layer/filesystem.png\" alt=\"文件系统\"></p>\n<p>看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？</p>\n<p>在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。</p>\n<p>每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。</p>\n<p>如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。</p>\n<p>这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100&#x3D; 30GB 的文件。并且需要占用 30GB 的磁盘空间。</p>\n<p>当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。</p>\n<p>这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。</p>\n<p>事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。</p>\n<p>在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。</p>\n<p>虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。</p>\n<h2 id=\"测试与分析\"><a href=\"#测试与分析\" class=\"headerlink\" title=\"测试与分析\"></a>测试与分析</h2><p>下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：</p>\n<ol>\n<li><p>创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /mytmpfs</span><br><span class=\"line\">mount -t tmpfs tmpfs /mytmpfs</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为实验创建一些文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /mytmpfs</span><br><span class=\"line\">echo hello &gt; lowerdir/hello.txt</span><br><span class=\"line\">echo &quot;delete me&quot; &gt; lowerdir/delete-me.txt</span><br><span class=\"line\">echo message &gt; upperdir/upper-message.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：<br><img src=\"/images/docker-layer/merged.png\" alt=\"merged\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf merged/delete-me.txt</span><br><span class=\"line\">echo &quot;I&#x27;m new one&quot; &gt; merged/new.txt</span><br><span class=\"line\">echo world &gt;&gt; merged/hello.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：<br><img src=\"/images/docker-layer/tree.png\" alt=\"directory tree\"></p>\n</li>\n</ol>\n<p>当你在 merged 目录中执行 rm -rf merged&#x2F;delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。</p>\n<h2 id=\"最终结果：\"><a href=\"#最终结果：\" class=\"headerlink\" title=\"最终结果：\"></a>最终结果：</h2><p>upperdir&#x2F; 的文件结构：</p>\n<p>执行ls -l upperdir 可以看到如下结果<br><img src=\"/images/docker-layer/ls_upper.png\" alt=\"directory tree\"></p>\n<ul>\n<li>delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。</li>\n<li>hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。</li>\n<li>new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。</li>\n<li>upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。</li>\n</ul>\n<p>可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。</p>\n<p>希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！</p>\n<p>容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。</p>\n<h1 id=\"构建分层图像\"><a href=\"#构建分层图像\" class=\"headerlink\" title=\"构建分层图像\"></a>构建分层图像</h1><p>创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine</span><br><span class=\"line\">RUN echo &quot;hello&quot; &gt; /usr/file1.txt</span><br><span class=\"line\">COPY requirements.txt /usr/file2.txt</span><br><span class=\"line\">RUN rm -rf /usr/file1.txt</span><br></pre></td></tr></table></figure>\n<p>在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。</p>\n<p>让我们逐步了解一种可能的实施方法的示例。</p>\n<ol>\n<li><p>FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示&#x2F;img&#x2F;layer1。</p>\n</li>\n<li><p>创建第二个目录&#x2F;img&#x2F;layer2。从&#x2F;img&#x2F;layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入&#x2F;img&#x2F;layer2&#x2F;usr&#x2F;file1.txt。这是第二层。</p>\n</li>\n<li><p>创建第三个目录&#x2F;img&#x2F;layer3。从img&#x2F;layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。</p>\n</li>\n<li><p>最后，创建第四个目录&#x2F;img&#x2F;layer4。从img&#x2F;layer3中拷贝所有内容。下一个命令删除消息文件img&#x2F;layer4&#x2F;usr&#x2F;file1.txt。这是第四层。</p>\n</li>\n</ol>\n<p>要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。</p>\n<p>继续我们的例子，压缩文件将包含：</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layer1.tar.gz</td>\n<td>精简的linux基础环境</td>\n</tr>\n<tr>\n<td>layer2.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file1.txt</td>\n</tr>\n<tr>\n<td>layer3.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file2.txt（因为file1.txt未被修改）</td>\n</tr>\n<tr>\n<td>layer4.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。</td>\n</tr>\n</tbody></table>\n<p>以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。</p>\n<p>为了使结果可重现，还需要一件事—一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。</p>\n<p>引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY –link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。</p>\n<h1 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h1><p>在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。</p>\n<p>创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。</p>\n<p>使用我们之前的例子：</p>\n<ol>\n<li><p>初始层，FROM alpine基础的linux环境；</p>\n</li>\n<li><p>创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含&#x2F;work&#x2F;file1.txt 的目录。这是第一个提交的快照。</p>\n</li>\n<li><p>创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含&#x2F;work&#x2F;file1.txt和&#x2F;work&#x2F;file2.txt的目录。这是第二个已提交的快照。</p>\n</li>\n<li><p>创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 &#x2F;work&#x2F;.wh.file1.txt，并删除&#x2F;work&#x2F;file1.txt。这样就只剩下&#x2F;work&#x2F;file2.txt。这是第三个已提交的快照。</p>\n</li>\n<li><p>由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。</p>\n</li>\n</ol>\n<p>如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;RootFS&quot;: &#123;</span><br><span class=\"line\">    &quot;Type&quot;: &quot;layers&quot;,</span><br><span class=\"line\">    &quot;Layers&quot;: [</span><br><span class=\"line\">        &quot;sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07&quot;,</span><br><span class=\"line\">        &quot;sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091&quot;,</span><br><span class=\"line\">        &quot;sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e&quot;,</span><br><span class=\"line\">        &quot;sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。</p>\n<h1 id=\"叠加层\"><a href=\"#叠加层\" class=\"headerlink\" title=\"叠加层\"></a>叠加层</h1><p>用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容<br><img src=\"/images/docker-layer/filesystem.png\" alt=\"文件系统\"></p>\n<p>看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？</p>\n<p>在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。</p>\n<p>每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。</p>\n<p>如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。</p>\n<p>这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100&#x3D; 30GB 的文件。并且需要占用 30GB 的磁盘空间。</p>\n<p>当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。</p>\n<p>这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。</p>\n<p>事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。</p>\n<p>在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。</p>\n<p>虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。</p>\n<h2 id=\"测试与分析\"><a href=\"#测试与分析\" class=\"headerlink\" title=\"测试与分析\"></a>测试与分析</h2><p>下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：</p>\n<ol>\n<li><p>创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /mytmpfs</span><br><span class=\"line\">mount -t tmpfs tmpfs /mytmpfs</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为实验创建一些文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /mytmpfs</span><br><span class=\"line\">echo hello &gt; lowerdir/hello.txt</span><br><span class=\"line\">echo &quot;delete me&quot; &gt; lowerdir/delete-me.txt</span><br><span class=\"line\">echo message &gt; upperdir/upper-message.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：<br><img src=\"/images/docker-layer/merged.png\" alt=\"merged\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf merged/delete-me.txt</span><br><span class=\"line\">echo &quot;I&#x27;m new one&quot; &gt; merged/new.txt</span><br><span class=\"line\">echo world &gt;&gt; merged/hello.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：<br><img src=\"/images/docker-layer/tree.png\" alt=\"directory tree\"></p>\n</li>\n</ol>\n<p>当你在 merged 目录中执行 rm -rf merged&#x2F;delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。</p>\n<h2 id=\"最终结果：\"><a href=\"#最终结果：\" class=\"headerlink\" title=\"最终结果：\"></a>最终结果：</h2><p>upperdir&#x2F; 的文件结构：</p>\n<p>执行ls -l upperdir 可以看到如下结果<br><img src=\"/images/docker-layer/ls_upper.png\" alt=\"directory tree\"></p>\n<ul>\n<li>delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。</li>\n<li>hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。</li>\n<li>new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。</li>\n<li>upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。</li>\n</ul>\n<p>可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。</p>\n<p>希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"Dump分析入门指南","date":"2024-04-28T06:18:14.000Z","_content":"\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","source":"_posts/dump.md","raw":"---\ntitle: Dump分析入门指南\ndate: 2024-04-28 14:18:14\ntags: dump 性能 异常\n---\n\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","slug":"dump","published":1,"updated":"2024-05-08T08:37:58.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmf0003m8p1gu8u9eal","content":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n"},{"title":"C# 学习笔记： TaskCompletionSource","date":"2024-05-30T00:52:16.000Z","published":1,"_content":"\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/TaskCompletionSource.md","raw":"---\ntitle: C# 学习笔记： TaskCompletionSource\ndate: 2024-05-30 08:52:16\npublished: true\ntags:\n---\n\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"TaskCompletionSource","updated":"2024-06-06T07:22:36.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmg0004m8p1ajtw6mgu","content":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"Kubernetes DaemonSet – 它是什么以及如何使用","date":"2024-08-01T00:54:53.000Z","_content":"\n当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。\n\n# 什么是 DaemonSet？\n![daemonset](/images/daemonset/DaemonSets.png)\n\nDaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。\n\nDaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。\n\n# DaemonSet 的工作原理\n\nDaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。\n\n此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。\n\nDaemonSet 的工作原理非常简单直观：\n\n+ Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。\n\n+ Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。\n\n+ 更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。\n\n# 常见用途\n\nDaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：\n\n1. 日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。\n\n> 由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。\n\n2. 网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。\n\n> 说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。\n    ![daemonset-1](/images/daemonset/daemonset-1.png)\n\n3. 存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。\n\n# 实战探索\n\n随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。\n\n前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 \n\n### 背景和挑战\n\n容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：\n\n+ 分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。\n+ 高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。\n+ 数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。\n\n模拟环境总共3个node，一个master和两个工作节点。\n\n![节点](/images/daemonset/nodes.png)\n\n我们希望能够把我们的监控程序部署在每个工作节点中。\n\n### 架构设计\n我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。\n\n1. 监控数据生成和收集\n\n    自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。\n\n    数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。\n\n2. 数据传输和安全性保障\n\n    安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。\n\n3. 云端存储和管理\n\n    数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。\n\n4. 数据分析和可视化\n\n    数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。\n\n    可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应\n\n### Kubernetes部署\n1、DaemonSet 配置文件\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: acr/txclientx:5.24.10729.10\n        ports:\n        - containerPort: 80  # 如果你的应用有服务端口，请替换为实际端口\n        env:\n        - name: KhGuid\n          value: \"xxx\"\n        - name: TxCloudSite_Url\n          value: \"https://domain.com\"\n        - name: HttpJsonWriter_Target_Url\n          value: \"http://domain.com/v20/api/loggate/save/{datatype}\"\n        - name: NebulaFides_Url\n          value: \"http://domain.com\"\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"200Mi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"400Mi\"\n\n```\n2、部署到Kubernetes集群\n```bash\nkubectl apply -f agent-daemonset.yaml\n```\n\n3、部署结果\n我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序\n![监控pod](/images/daemonset/daemonset-pods.png)\n\n\n# 结语\n\n通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。","source":"_posts/daemonset.md","raw":"---\ntitle: Kubernetes DaemonSet – 它是什么以及如何使用\ndate: 2024-08-01 08:54:53\ntags:\n---\n\n当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。\n\n# 什么是 DaemonSet？\n![daemonset](/images/daemonset/DaemonSets.png)\n\nDaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。\n\nDaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。\n\n# DaemonSet 的工作原理\n\nDaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。\n\n此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。\n\nDaemonSet 的工作原理非常简单直观：\n\n+ Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。\n\n+ Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。\n\n+ 更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。\n\n# 常见用途\n\nDaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：\n\n1. 日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。\n\n> 由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。\n\n2. 网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。\n\n> 说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。\n    ![daemonset-1](/images/daemonset/daemonset-1.png)\n\n3. 存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。\n\n# 实战探索\n\n随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。\n\n前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 \n\n### 背景和挑战\n\n容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：\n\n+ 分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。\n+ 高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。\n+ 数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。\n\n模拟环境总共3个node，一个master和两个工作节点。\n\n![节点](/images/daemonset/nodes.png)\n\n我们希望能够把我们的监控程序部署在每个工作节点中。\n\n### 架构设计\n我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。\n\n1. 监控数据生成和收集\n\n    自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。\n\n    数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。\n\n2. 数据传输和安全性保障\n\n    安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。\n\n3. 云端存储和管理\n\n    数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。\n\n4. 数据分析和可视化\n\n    数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。\n\n    可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应\n\n### Kubernetes部署\n1、DaemonSet 配置文件\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: acr/txclientx:5.24.10729.10\n        ports:\n        - containerPort: 80  # 如果你的应用有服务端口，请替换为实际端口\n        env:\n        - name: KhGuid\n          value: \"xxx\"\n        - name: TxCloudSite_Url\n          value: \"https://domain.com\"\n        - name: HttpJsonWriter_Target_Url\n          value: \"http://domain.com/v20/api/loggate/save/{datatype}\"\n        - name: NebulaFides_Url\n          value: \"http://domain.com\"\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"200Mi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"400Mi\"\n\n```\n2、部署到Kubernetes集群\n```bash\nkubectl apply -f agent-daemonset.yaml\n```\n\n3、部署结果\n我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序\n![监控pod](/images/daemonset/daemonset-pods.png)\n\n\n# 结语\n\n通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。","slug":"daemonset","published":1,"updated":"2024-08-02T10:01:08.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmh0006m8p13odd2rsk","content":"<p>当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。</p>\n<h1 id=\"什么是-DaemonSet？\"><a href=\"#什么是-DaemonSet？\" class=\"headerlink\" title=\"什么是 DaemonSet？\"></a>什么是 DaemonSet？</h1><p><img src=\"/images/daemonset/DaemonSets.png\" alt=\"daemonset\"></p>\n<p>DaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。</p>\n<p>DaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。</p>\n<h1 id=\"DaemonSet-的工作原理\"><a href=\"#DaemonSet-的工作原理\" class=\"headerlink\" title=\"DaemonSet 的工作原理\"></a>DaemonSet 的工作原理</h1><p>DaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。</p>\n<p>此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。</p>\n<p>DaemonSet 的工作原理非常简单直观：</p>\n<ul>\n<li><p>Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。</p>\n</li>\n<li><p>Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。</p>\n</li>\n<li><p>更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。</p>\n</li>\n</ul>\n<h1 id=\"常见用途\"><a href=\"#常见用途\" class=\"headerlink\" title=\"常见用途\"></a>常见用途</h1><p>DaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：</p>\n<ol>\n<li>日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。</li>\n</ol>\n<blockquote>\n<p>由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。</p>\n</blockquote>\n<ol start=\"2\">\n<li>网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。</li>\n</ol>\n<blockquote>\n<p>说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。<br>    <img src=\"/images/daemonset/daemonset-1.png\" alt=\"daemonset-1\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。</li>\n</ol>\n<h1 id=\"实战探索\"><a href=\"#实战探索\" class=\"headerlink\" title=\"实战探索\"></a>实战探索</h1><p>随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。</p>\n<p>前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 </p>\n<h3 id=\"背景和挑战\"><a href=\"#背景和挑战\" class=\"headerlink\" title=\"背景和挑战\"></a>背景和挑战</h3><p>容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：</p>\n<ul>\n<li>分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。</li>\n<li>高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。</li>\n<li>数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。</li>\n</ul>\n<p>模拟环境总共3个node，一个master和两个工作节点。</p>\n<p><img src=\"/images/daemonset/nodes.png\" alt=\"节点\"></p>\n<p>我们希望能够把我们的监控程序部署在每个工作节点中。</p>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。</p>\n<ol>\n<li><p>监控数据生成和收集</p>\n<p> 自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。</p>\n<p> 数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。</p>\n</li>\n<li><p>数据传输和安全性保障</p>\n<p> 安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。</p>\n</li>\n<li><p>云端存储和管理</p>\n<p> 数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。</p>\n</li>\n<li><p>数据分析和可视化</p>\n<p> 数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。</p>\n<p> 可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应</p>\n</li>\n</ol>\n<h3 id=\"Kubernetes部署\"><a href=\"#Kubernetes部署\" class=\"headerlink\" title=\"Kubernetes部署\"></a>Kubernetes部署</h3><p>1、DaemonSet 配置文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">acr/txclientx:5.24.10729.10</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 如果你的应用有服务端口，请替换为实际端口</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxCloudSite_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">HttpJsonWriter_Target_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com/v20/api/loggate/save/&#123;datatype&#125;&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">NebulaFides_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">resources:</span></span><br><span class=\"line\">          <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;100m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;200Mi&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">limits:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;200m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;400Mi&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、部署到Kubernetes集群</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f agent-daemonset.yaml</span><br></pre></td></tr></table></figure>\n\n<p>3、部署结果<br>我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序<br><img src=\"/images/daemonset/daemonset-pods.png\" alt=\"监控pod\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。</p>\n<h1 id=\"什么是-DaemonSet？\"><a href=\"#什么是-DaemonSet？\" class=\"headerlink\" title=\"什么是 DaemonSet？\"></a>什么是 DaemonSet？</h1><p><img src=\"/images/daemonset/DaemonSets.png\" alt=\"daemonset\"></p>\n<p>DaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。</p>\n<p>DaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。</p>\n<h1 id=\"DaemonSet-的工作原理\"><a href=\"#DaemonSet-的工作原理\" class=\"headerlink\" title=\"DaemonSet 的工作原理\"></a>DaemonSet 的工作原理</h1><p>DaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。</p>\n<p>此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。</p>\n<p>DaemonSet 的工作原理非常简单直观：</p>\n<ul>\n<li><p>Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。</p>\n</li>\n<li><p>Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。</p>\n</li>\n<li><p>更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。</p>\n</li>\n</ul>\n<h1 id=\"常见用途\"><a href=\"#常见用途\" class=\"headerlink\" title=\"常见用途\"></a>常见用途</h1><p>DaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：</p>\n<ol>\n<li>日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。</li>\n</ol>\n<blockquote>\n<p>由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。</p>\n</blockquote>\n<ol start=\"2\">\n<li>网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。</li>\n</ol>\n<blockquote>\n<p>说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。<br>    <img src=\"/images/daemonset/daemonset-1.png\" alt=\"daemonset-1\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。</li>\n</ol>\n<h1 id=\"实战探索\"><a href=\"#实战探索\" class=\"headerlink\" title=\"实战探索\"></a>实战探索</h1><p>随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。</p>\n<p>前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 </p>\n<h3 id=\"背景和挑战\"><a href=\"#背景和挑战\" class=\"headerlink\" title=\"背景和挑战\"></a>背景和挑战</h3><p>容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：</p>\n<ul>\n<li>分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。</li>\n<li>高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。</li>\n<li>数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。</li>\n</ul>\n<p>模拟环境总共3个node，一个master和两个工作节点。</p>\n<p><img src=\"/images/daemonset/nodes.png\" alt=\"节点\"></p>\n<p>我们希望能够把我们的监控程序部署在每个工作节点中。</p>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。</p>\n<ol>\n<li><p>监控数据生成和收集</p>\n<p> 自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。</p>\n<p> 数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。</p>\n</li>\n<li><p>数据传输和安全性保障</p>\n<p> 安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。</p>\n</li>\n<li><p>云端存储和管理</p>\n<p> 数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。</p>\n</li>\n<li><p>数据分析和可视化</p>\n<p> 数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。</p>\n<p> 可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应</p>\n</li>\n</ol>\n<h3 id=\"Kubernetes部署\"><a href=\"#Kubernetes部署\" class=\"headerlink\" title=\"Kubernetes部署\"></a>Kubernetes部署</h3><p>1、DaemonSet 配置文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">acr/txclientx:5.24.10729.10</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 如果你的应用有服务端口，请替换为实际端口</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxCloudSite_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">HttpJsonWriter_Target_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com/v20/api/loggate/save/&#123;datatype&#125;&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">NebulaFides_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">resources:</span></span><br><span class=\"line\">          <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;100m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;200Mi&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">limits:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;200m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;400Mi&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、部署到Kubernetes集群</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f agent-daemonset.yaml</span><br></pre></td></tr></table></figure>\n\n<p>3、部署结果<br>我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序<br><img src=\"/images/daemonset/daemonset-pods.png\" alt=\"监控pod\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。</p>\n"},{"title":"Docker镜像构建优化","date":"2024-07-08T01:20:55.000Z","_content":"\n# 引言\n在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。\n\n# Dockerfile中的层定义\n在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。\n\n```dockerfile\n# 每一条指令都会创建一个新层\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\nCMD [\"python\", \"app.py\"]\n```\n上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。\n\n\n在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：\n\n1. 新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。\n\n2. 修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。\n\n3. 删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。\n\n4. 文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。\n\n为了更具体地说明，下面是一个示例Dockerfile及其解释：\n\n```dockerfile\nFROM ubuntu:20.04\n\n# 第一层\nRUN apt-get update && apt-get install -y curl\n\n# 第二层\nRUN echo \"Hello, World!\" > /hello.txt\n\n# 第三层\nRUN chmod 644 /hello.txt\n```\n在这个示例中，每个RUN指令都会创建一个新的层：\n\n1. 第一层：RUN apt-get update && apt-get install -y curl：\n- 这一层包含了更新包索引文件和安装curl工具所做的所有更改。\n- 新增了curl工具的相关文件和目录。\n- 修改了包管理器的状态文件。\n2. 第二层：RUN echo \"Hello, World!\" > /hello.txt：\n- 这一层包含了创建/hello.txt文件并向其中写入\"Hello, World!\"的操作。\n- 新增了文件/hello.txt。\n\n3. 第三层：RUN chmod 644 /hello.txt：\n- 这一层包含了对文件/hello.txt的权限更改。\n- 修改了文件/hello.txt的权限信息。\n\n每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。\n\n# 层带来的好处\nDocker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。\n\n## 层的重用机制\n层的重用主要是通过以下几个步骤实现的：\n\n1. 层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。\n\n2. 层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。\n\n3. 层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。\n\n## 层的重用示例\n假设我们有一个简单的 Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"python\", \"app.py\"]\n```\n为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容\n```\n# requirements.txt 示例\nflask\nrequests\n```\n根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR /app、COPY . . 和 CMD [\"python\", \"app.py\"]）由于没有变化，可以直接从缓存中重用。\n\n构建完镜像以后，让我们inspect一下镜像\n![inspect1](/images/docker-2/inspect1.png)![inspect2](/images/docker-2/inspect2.png)\n\n我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。\n![inspect3](/images/docker-2/inspect3.png)\n\n\n# 层数多带来的问题\n层数多会导致以下几个问题：\n\n1. 镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。\n2. 构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。\n3. 性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I/O操作的开销。\n\n# 减少Dockerfile层数的方法\n合并指令\n将多个指令合并到一个RUN指令中，可以显著减少层数。例如：\n\n```dockerfile\n# 将多个RUN指令合并到一个\nRUN apt-get update && \\\n    apt-get install -y package1 package2 && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n```\n\n减少临时文件\n在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：\n\n```dockerfile\n# 使用多行命令避免临时文件\nRUN wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination\n```\n使用.dockerignore\n类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。\n\n```dockerignore\n# .dockerignore 文件示例\nnode_modules\n.git\n.tmp\n```\n\n# 实际案例：优化一个Dockerfile\n原始Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nRUN apt-get update\nRUN apt-get install -y curl\nRUN apt-get clean\nCMD [\"python\", \"app.py\"]\n```\n优化后的Dockerfile：\n\n```dockerfile\n# 优化后的Dockerfile，减少层数\nFROM python:3.8-slim\n\nWORKDIR /app\n\n# 合并COPY和RUN指令\nCOPY requirements.txt ./\nRUN apt-get update && \\\n    apt-get install -y curl && \\\n    pip install -r requirements.txt && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n\n# 使用.dockerignore忽略不必要的文件\nCOPY . .\n\nCMD [\"python\", \"app.py\"]\n```\n我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。\n![优化dockerfile](/images/docker-2/after.png)\n\n\n# 其他优化技巧\n## 使用多阶段构建\n多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。\n通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。\n\n```dockerfile\n# 多阶段构建示例\nFROM net8-sdk AS build\nWORKDIR /app\n# 拷贝项目文件并还原依赖项\nCOPY . .\n# 构建发布版本\nRUN dotnet publish \"src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj\" -c Release -o /app/publish\n\n# 设置运行时镜像\nFROM net8-runtime\nWORKDIR /app\n# 从构建镜像阶段复制发布的文件到运行时镜像\nCOPY --from=build /app/publish .\n\nEXPOSE 80\nENTRYPOINT [\"dotnet\", \"Uranus.DatacenterMH.dll\"]\n```\n\n\n## 定期清理镜像和容器\n定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n```\n\n结语\n通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/docker-2.md","raw":"---\ntitle: Docker镜像构建优化\ndate: 2024-07-08 09:20:55\ntags:\n---\n\n# 引言\n在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。\n\n# Dockerfile中的层定义\n在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。\n\n```dockerfile\n# 每一条指令都会创建一个新层\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\nCMD [\"python\", \"app.py\"]\n```\n上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。\n\n\n在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：\n\n1. 新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。\n\n2. 修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。\n\n3. 删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。\n\n4. 文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。\n\n为了更具体地说明，下面是一个示例Dockerfile及其解释：\n\n```dockerfile\nFROM ubuntu:20.04\n\n# 第一层\nRUN apt-get update && apt-get install -y curl\n\n# 第二层\nRUN echo \"Hello, World!\" > /hello.txt\n\n# 第三层\nRUN chmod 644 /hello.txt\n```\n在这个示例中，每个RUN指令都会创建一个新的层：\n\n1. 第一层：RUN apt-get update && apt-get install -y curl：\n- 这一层包含了更新包索引文件和安装curl工具所做的所有更改。\n- 新增了curl工具的相关文件和目录。\n- 修改了包管理器的状态文件。\n2. 第二层：RUN echo \"Hello, World!\" > /hello.txt：\n- 这一层包含了创建/hello.txt文件并向其中写入\"Hello, World!\"的操作。\n- 新增了文件/hello.txt。\n\n3. 第三层：RUN chmod 644 /hello.txt：\n- 这一层包含了对文件/hello.txt的权限更改。\n- 修改了文件/hello.txt的权限信息。\n\n每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。\n\n# 层带来的好处\nDocker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。\n\n## 层的重用机制\n层的重用主要是通过以下几个步骤实现的：\n\n1. 层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。\n\n2. 层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。\n\n3. 层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。\n\n## 层的重用示例\n假设我们有一个简单的 Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"python\", \"app.py\"]\n```\n为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容\n```\n# requirements.txt 示例\nflask\nrequests\n```\n根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR /app、COPY . . 和 CMD [\"python\", \"app.py\"]）由于没有变化，可以直接从缓存中重用。\n\n构建完镜像以后，让我们inspect一下镜像\n![inspect1](/images/docker-2/inspect1.png)![inspect2](/images/docker-2/inspect2.png)\n\n我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。\n![inspect3](/images/docker-2/inspect3.png)\n\n\n# 层数多带来的问题\n层数多会导致以下几个问题：\n\n1. 镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。\n2. 构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。\n3. 性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I/O操作的开销。\n\n# 减少Dockerfile层数的方法\n合并指令\n将多个指令合并到一个RUN指令中，可以显著减少层数。例如：\n\n```dockerfile\n# 将多个RUN指令合并到一个\nRUN apt-get update && \\\n    apt-get install -y package1 package2 && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n```\n\n减少临时文件\n在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：\n\n```dockerfile\n# 使用多行命令避免临时文件\nRUN wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination\n```\n使用.dockerignore\n类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。\n\n```dockerignore\n# .dockerignore 文件示例\nnode_modules\n.git\n.tmp\n```\n\n# 实际案例：优化一个Dockerfile\n原始Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nRUN apt-get update\nRUN apt-get install -y curl\nRUN apt-get clean\nCMD [\"python\", \"app.py\"]\n```\n优化后的Dockerfile：\n\n```dockerfile\n# 优化后的Dockerfile，减少层数\nFROM python:3.8-slim\n\nWORKDIR /app\n\n# 合并COPY和RUN指令\nCOPY requirements.txt ./\nRUN apt-get update && \\\n    apt-get install -y curl && \\\n    pip install -r requirements.txt && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n\n# 使用.dockerignore忽略不必要的文件\nCOPY . .\n\nCMD [\"python\", \"app.py\"]\n```\n我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。\n![优化dockerfile](/images/docker-2/after.png)\n\n\n# 其他优化技巧\n## 使用多阶段构建\n多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。\n通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。\n\n```dockerfile\n# 多阶段构建示例\nFROM net8-sdk AS build\nWORKDIR /app\n# 拷贝项目文件并还原依赖项\nCOPY . .\n# 构建发布版本\nRUN dotnet publish \"src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj\" -c Release -o /app/publish\n\n# 设置运行时镜像\nFROM net8-runtime\nWORKDIR /app\n# 从构建镜像阶段复制发布的文件到运行时镜像\nCOPY --from=build /app/publish .\n\nEXPOSE 80\nENTRYPOINT [\"dotnet\", \"Uranus.DatacenterMH.dll\"]\n```\n\n\n## 定期清理镜像和容器\n定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n```\n\n结语\n通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","slug":"docker-2","published":1,"updated":"2024-07-08T13:19:28.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmh0007m8p1e5ejctkv","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。</p>\n<h1 id=\"Dockerfile中的层定义\"><a href=\"#Dockerfile中的层定义\" class=\"headerlink\" title=\"Dockerfile中的层定义\"></a>Dockerfile中的层定义</h1><p>在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 每一条指令都会创建一个新层</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。</p>\n<p>在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：</p>\n<ol>\n<li><p>新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。</p>\n</li>\n<li><p>修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。</p>\n</li>\n<li><p>删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。</p>\n</li>\n<li><p>文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。</p>\n</li>\n</ol>\n<p>为了更具体地说明，下面是一个示例Dockerfile及其解释：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">20.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span> &gt; /hello.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">chmod</span> 644 /hello.txt</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，每个RUN指令都会创建一个新的层：</p>\n<ol>\n<li>第一层：RUN apt-get update &amp;&amp; apt-get install -y curl：</li>\n</ol>\n<ul>\n<li>这一层包含了更新包索引文件和安装curl工具所做的所有更改。</li>\n<li>新增了curl工具的相关文件和目录。</li>\n<li>修改了包管理器的状态文件。</li>\n</ul>\n<ol start=\"2\">\n<li>第二层：RUN echo “Hello, World!” &gt; &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了创建&#x2F;hello.txt文件并向其中写入”Hello, World!”的操作。</li>\n<li>新增了文件&#x2F;hello.txt。</li>\n</ul>\n<ol start=\"3\">\n<li>第三层：RUN chmod 644 &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了对文件&#x2F;hello.txt的权限更改。</li>\n<li>修改了文件&#x2F;hello.txt的权限信息。</li>\n</ul>\n<p>每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。</p>\n<h1 id=\"层带来的好处\"><a href=\"#层带来的好处\" class=\"headerlink\" title=\"层带来的好处\"></a>层带来的好处</h1><p>Docker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。</p>\n<h2 id=\"层的重用机制\"><a href=\"#层的重用机制\" class=\"headerlink\" title=\"层的重用机制\"></a>层的重用机制</h2><p>层的重用主要是通过以下几个步骤实现的：</p>\n<ol>\n<li><p>层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。</p>\n</li>\n<li><p>层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。</p>\n</li>\n<li><p>层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。</p>\n</li>\n</ol>\n<h2 id=\"层的重用示例\"><a href=\"#层的重用示例\" class=\"headerlink\" title=\"层的重用示例\"></a>层的重用示例</h2><p>假设我们有一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># requirements.txt 示例</span><br><span class=\"line\">flask</span><br><span class=\"line\">requests</span><br></pre></td></tr></table></figure>\n<p>根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR &#x2F;app、COPY . . 和 CMD [“python”, “app.py”]）由于没有变化，可以直接从缓存中重用。</p>\n<p>构建完镜像以后，让我们inspect一下镜像<br><img src=\"/images/docker-2/inspect1.png\" alt=\"inspect1\"><img src=\"/images/docker-2/inspect2.png\" alt=\"inspect2\"></p>\n<p>我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。<br><img src=\"/images/docker-2/inspect3.png\" alt=\"inspect3\"></p>\n<h1 id=\"层数多带来的问题\"><a href=\"#层数多带来的问题\" class=\"headerlink\" title=\"层数多带来的问题\"></a>层数多带来的问题</h1><p>层数多会导致以下几个问题：</p>\n<ol>\n<li>镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。</li>\n<li>构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。</li>\n<li>性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I&#x2F;O操作的开销。</li>\n</ol>\n<h1 id=\"减少Dockerfile层数的方法\"><a href=\"#减少Dockerfile层数的方法\" class=\"headerlink\" title=\"减少Dockerfile层数的方法\"></a>减少Dockerfile层数的方法</h1><p>合并指令<br>将多个指令合并到一个RUN指令中，可以显著减少层数。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将多个RUN指令合并到一个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y package1 package2 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>\n\n<p>减少临时文件<br>在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用多行命令避免临时文件</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination</span></span><br></pre></td></tr></table></figure>\n<p>使用.dockerignore<br>类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .dockerignore 文件示例</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">.git</span><br><span class=\"line\">.tmp</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际案例：优化一个Dockerfile\"><a href=\"#实际案例：优化一个Dockerfile\" class=\"headerlink\" title=\"实际案例：优化一个Dockerfile\"></a>实际案例：优化一个Dockerfile</h1><p>原始Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get clean</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>优化后的Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 优化后的Dockerfile，减少层数</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并COPY和RUN指令</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y curl &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    pip install -r requirements.txt &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用.dockerignore忽略不必要的文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。<br><img src=\"/images/docker-2/after.png\" alt=\"优化dockerfile\"></p>\n<h1 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h1><h2 id=\"使用多阶段构建\"><a href=\"#使用多阶段构建\" class=\"headerlink\" title=\"使用多阶段构建\"></a>使用多阶段构建</h2><p>多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。<br>通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多阶段构建示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-sdk AS build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 拷贝项目文件并还原依赖项</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"comment\"># 构建发布版本</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> dotnet publish <span class=\"string\">&quot;src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj&quot;</span> -c Release -o /app/publish</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-runtime</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 从构建镜像阶段复制发布的文件到运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /app/publish .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;dotnet&quot;</span>, <span class=\"string\">&quot;Uranus.DatacenterMH.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"定期清理镜像和容器\"><a href=\"#定期清理镜像和容器\" class=\"headerlink\" title=\"定期清理镜像和容器\"></a>定期清理镜像和容器</h2><p>定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>结语<br>通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。</p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。</p>\n<h1 id=\"Dockerfile中的层定义\"><a href=\"#Dockerfile中的层定义\" class=\"headerlink\" title=\"Dockerfile中的层定义\"></a>Dockerfile中的层定义</h1><p>在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 每一条指令都会创建一个新层</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。</p>\n<p>在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：</p>\n<ol>\n<li><p>新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。</p>\n</li>\n<li><p>修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。</p>\n</li>\n<li><p>删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。</p>\n</li>\n<li><p>文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。</p>\n</li>\n</ol>\n<p>为了更具体地说明，下面是一个示例Dockerfile及其解释：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">20.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span> &gt; /hello.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">chmod</span> 644 /hello.txt</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，每个RUN指令都会创建一个新的层：</p>\n<ol>\n<li>第一层：RUN apt-get update &amp;&amp; apt-get install -y curl：</li>\n</ol>\n<ul>\n<li>这一层包含了更新包索引文件和安装curl工具所做的所有更改。</li>\n<li>新增了curl工具的相关文件和目录。</li>\n<li>修改了包管理器的状态文件。</li>\n</ul>\n<ol start=\"2\">\n<li>第二层：RUN echo “Hello, World!” &gt; &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了创建&#x2F;hello.txt文件并向其中写入”Hello, World!”的操作。</li>\n<li>新增了文件&#x2F;hello.txt。</li>\n</ul>\n<ol start=\"3\">\n<li>第三层：RUN chmod 644 &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了对文件&#x2F;hello.txt的权限更改。</li>\n<li>修改了文件&#x2F;hello.txt的权限信息。</li>\n</ul>\n<p>每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。</p>\n<h1 id=\"层带来的好处\"><a href=\"#层带来的好处\" class=\"headerlink\" title=\"层带来的好处\"></a>层带来的好处</h1><p>Docker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。</p>\n<h2 id=\"层的重用机制\"><a href=\"#层的重用机制\" class=\"headerlink\" title=\"层的重用机制\"></a>层的重用机制</h2><p>层的重用主要是通过以下几个步骤实现的：</p>\n<ol>\n<li><p>层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。</p>\n</li>\n<li><p>层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。</p>\n</li>\n<li><p>层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。</p>\n</li>\n</ol>\n<h2 id=\"层的重用示例\"><a href=\"#层的重用示例\" class=\"headerlink\" title=\"层的重用示例\"></a>层的重用示例</h2><p>假设我们有一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># requirements.txt 示例</span><br><span class=\"line\">flask</span><br><span class=\"line\">requests</span><br></pre></td></tr></table></figure>\n<p>根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR &#x2F;app、COPY . . 和 CMD [“python”, “app.py”]）由于没有变化，可以直接从缓存中重用。</p>\n<p>构建完镜像以后，让我们inspect一下镜像<br><img src=\"/images/docker-2/inspect1.png\" alt=\"inspect1\"><img src=\"/images/docker-2/inspect2.png\" alt=\"inspect2\"></p>\n<p>我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。<br><img src=\"/images/docker-2/inspect3.png\" alt=\"inspect3\"></p>\n<h1 id=\"层数多带来的问题\"><a href=\"#层数多带来的问题\" class=\"headerlink\" title=\"层数多带来的问题\"></a>层数多带来的问题</h1><p>层数多会导致以下几个问题：</p>\n<ol>\n<li>镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。</li>\n<li>构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。</li>\n<li>性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I&#x2F;O操作的开销。</li>\n</ol>\n<h1 id=\"减少Dockerfile层数的方法\"><a href=\"#减少Dockerfile层数的方法\" class=\"headerlink\" title=\"减少Dockerfile层数的方法\"></a>减少Dockerfile层数的方法</h1><p>合并指令<br>将多个指令合并到一个RUN指令中，可以显著减少层数。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将多个RUN指令合并到一个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y package1 package2 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>\n\n<p>减少临时文件<br>在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用多行命令避免临时文件</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination</span></span><br></pre></td></tr></table></figure>\n<p>使用.dockerignore<br>类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .dockerignore 文件示例</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">.git</span><br><span class=\"line\">.tmp</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际案例：优化一个Dockerfile\"><a href=\"#实际案例：优化一个Dockerfile\" class=\"headerlink\" title=\"实际案例：优化一个Dockerfile\"></a>实际案例：优化一个Dockerfile</h1><p>原始Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get clean</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>优化后的Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 优化后的Dockerfile，减少层数</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并COPY和RUN指令</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y curl &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    pip install -r requirements.txt &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用.dockerignore忽略不必要的文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。<br><img src=\"/images/docker-2/after.png\" alt=\"优化dockerfile\"></p>\n<h1 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h1><h2 id=\"使用多阶段构建\"><a href=\"#使用多阶段构建\" class=\"headerlink\" title=\"使用多阶段构建\"></a>使用多阶段构建</h2><p>多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。<br>通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多阶段构建示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-sdk AS build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 拷贝项目文件并还原依赖项</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"comment\"># 构建发布版本</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> dotnet publish <span class=\"string\">&quot;src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj&quot;</span> -c Release -o /app/publish</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-runtime</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 从构建镜像阶段复制发布的文件到运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /app/publish .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;dotnet&quot;</span>, <span class=\"string\">&quot;Uranus.DatacenterMH.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"定期清理镜像和容器\"><a href=\"#定期清理镜像和容器\" class=\"headerlink\" title=\"定期清理镜像和容器\"></a>定期清理镜像和容器</h2><p>定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>结语<br>通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。</p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"欢迎来到 ITProHub！","_content":"![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/hello-world.md","raw":"---\ntitle: 欢迎来到 ITProHub！\n---\n![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"hello-world","published":1,"date":"2024-03-13T07:54:13.172Z","updated":"2024-04-26T03:07:16.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmi0008m8p1coeu3jbp","content":"<p><img src=\"/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"深入理解 HTTP Connection 头","date":"2024-03-19T08:11:52.000Z","_content":"HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/http.md","raw":"---\ntitle: 深入理解 HTTP Connection 头\ndate: 2024-03-19 16:11:52\ntags: http http协议 Connection\n---\nHTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"http","published":1,"updated":"2024-04-26T03:06:44.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmi000am8p139hzcz0o","content":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"加密、哈希与签名：基本原理与区别解析","date":"2024-11-06T03:19:23.000Z","_content":"\n*前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！*\n***\n\n在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。\n\n# 1. 什么是加密？\n![签名](./images/encrypt-hash-signature/rsa.png)\n## 基本原理\n加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。\n\n加密有两种常见的类型：\n\n+ 对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。\n\n+ 非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。\n\n## 应用场景\n+ 数据保密性：在通信过程中保护数据不被窃取。\n+ HTTPS：通过 SSL/TLS 协议加密 web 请求和响应，确保数据的安全传输。\n+ 加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。\n\n# 2. 什么是哈希？\n![签名](./images/encrypt-hash-signature/md5.png)\n## 基本原理\n哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。\n\n哈希的关键特性包括：\n\n+ 固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。\n+ 碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。\n+ 单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。\n## 应用场景\n+ 数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。\n+ 密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。\n+ 数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。\n\n# 3. 什么是数字签名？\n![签名](./images/encrypt-hash-signature/certificate.png)\n## 基本原理\n数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。\n\n## 应用场景\n+ 身份验证：用于确保消息发送者的身份。\n+ 数据完整性：确保数据在传输过程中没有被篡改。\n+ 电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。\n\n# 4. 加密、哈希与签名的区别\n虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。\n\n|特性|加密|哈希|签名|\n|---|---|---|---|\n|目的|保证数据保密性|确保数据完整性|确保数据来源和完整性\n|是否可逆|可逆（通过密钥解密）|不可逆|可验证（但不可逆）\n|涉及的密钥|对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥|不涉及密钥|使用私钥生成签名，公钥验证签名|\n|应用场景|保护数据隐私|校验数据是否被篡改|确保数据未被篡改且来源可信|\n|输出形式|密文（加密后的数据）|固定长度的哈希值|数字签名（通过私钥加密的哈希值）|\n\n## 关键区别总结\n1. 加密 是为了保护数据的机密性，使数据只能由授权方读取。\n2. 哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。\n3. 签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。\n\n# 5. 加密、哈希与签名的综合应用\n在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：\n\n- 加密 用于加密传输的数据，保护数据的隐私。\n- 哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。\n- 签名 用于验证服务器的身份，确保与合法服务器进行通信。\n\n在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。\n\n# 结语\n加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。\n\n----\n\n希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！","source":"_posts/encrypt-hash-signature.md","raw":"---\ntitle: 加密、哈希与签名：基本原理与区别解析\ndate: 2024-11-06 11:19:23\ntags:\n---\n\n*前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！*\n***\n\n在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。\n\n# 1. 什么是加密？\n![签名](./images/encrypt-hash-signature/rsa.png)\n## 基本原理\n加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。\n\n加密有两种常见的类型：\n\n+ 对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。\n\n+ 非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。\n\n## 应用场景\n+ 数据保密性：在通信过程中保护数据不被窃取。\n+ HTTPS：通过 SSL/TLS 协议加密 web 请求和响应，确保数据的安全传输。\n+ 加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。\n\n# 2. 什么是哈希？\n![签名](./images/encrypt-hash-signature/md5.png)\n## 基本原理\n哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。\n\n哈希的关键特性包括：\n\n+ 固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。\n+ 碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。\n+ 单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。\n## 应用场景\n+ 数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。\n+ 密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。\n+ 数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。\n\n# 3. 什么是数字签名？\n![签名](./images/encrypt-hash-signature/certificate.png)\n## 基本原理\n数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。\n\n## 应用场景\n+ 身份验证：用于确保消息发送者的身份。\n+ 数据完整性：确保数据在传输过程中没有被篡改。\n+ 电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。\n\n# 4. 加密、哈希与签名的区别\n虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。\n\n|特性|加密|哈希|签名|\n|---|---|---|---|\n|目的|保证数据保密性|确保数据完整性|确保数据来源和完整性\n|是否可逆|可逆（通过密钥解密）|不可逆|可验证（但不可逆）\n|涉及的密钥|对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥|不涉及密钥|使用私钥生成签名，公钥验证签名|\n|应用场景|保护数据隐私|校验数据是否被篡改|确保数据未被篡改且来源可信|\n|输出形式|密文（加密后的数据）|固定长度的哈希值|数字签名（通过私钥加密的哈希值）|\n\n## 关键区别总结\n1. 加密 是为了保护数据的机密性，使数据只能由授权方读取。\n2. 哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。\n3. 签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。\n\n# 5. 加密、哈希与签名的综合应用\n在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：\n\n- 加密 用于加密传输的数据，保护数据的隐私。\n- 哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。\n- 签名 用于验证服务器的身份，确保与合法服务器进行通信。\n\n在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。\n\n# 结语\n加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。\n\n----\n\n希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！","slug":"encrypt-hash-signature","published":1,"updated":"2024-11-06T07:38:33.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmj000bm8p15xej5xa6","content":"<p><em>前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！</em></p>\n<hr>\n<p>在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。</p>\n<h1 id=\"1-什么是加密？\"><a href=\"#1-什么是加密？\" class=\"headerlink\" title=\"1. 什么是加密？\"></a>1. 什么是加密？</h1><p><img src=\"/./images/encrypt-hash-signature/rsa.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。</p>\n<p>加密有两种常见的类型：</p>\n<ul>\n<li><p>对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。</p>\n</li>\n<li><p>非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。</p>\n</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据保密性：在通信过程中保护数据不被窃取。</li>\n<li>HTTPS：通过 SSL&#x2F;TLS 协议加密 web 请求和响应，确保数据的安全传输。</li>\n<li>加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。</li>\n</ul>\n<h1 id=\"2-什么是哈希？\"><a href=\"#2-什么是哈希？\" class=\"headerlink\" title=\"2. 什么是哈希？\"></a>2. 什么是哈希？</h1><p><img src=\"/./images/encrypt-hash-signature/md5.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-1\"><a href=\"#基本原理-1\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。</p>\n<p>哈希的关键特性包括：</p>\n<ul>\n<li>固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。</li>\n<li>碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。</li>\n<li>单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。</li>\n</ul>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。</li>\n<li>密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。</li>\n<li>数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。</li>\n</ul>\n<h1 id=\"3-什么是数字签名？\"><a href=\"#3-什么是数字签名？\" class=\"headerlink\" title=\"3. 什么是数字签名？\"></a>3. 什么是数字签名？</h1><p><img src=\"/./images/encrypt-hash-signature/certificate.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-2\"><a href=\"#基本原理-2\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。</p>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>身份验证：用于确保消息发送者的身份。</li>\n<li>数据完整性：确保数据在传输过程中没有被篡改。</li>\n<li>电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。</li>\n</ul>\n<h1 id=\"4-加密、哈希与签名的区别\"><a href=\"#4-加密、哈希与签名的区别\" class=\"headerlink\" title=\"4. 加密、哈希与签名的区别\"></a>4. 加密、哈希与签名的区别</h1><p>虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>加密</th>\n<th>哈希</th>\n<th>签名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>目的</td>\n<td>保证数据保密性</td>\n<td>确保数据完整性</td>\n<td>确保数据来源和完整性</td>\n</tr>\n<tr>\n<td>是否可逆</td>\n<td>可逆（通过密钥解密）</td>\n<td>不可逆</td>\n<td>可验证（但不可逆）</td>\n</tr>\n<tr>\n<td>涉及的密钥</td>\n<td>对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥</td>\n<td>不涉及密钥</td>\n<td>使用私钥生成签名，公钥验证签名</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>保护数据隐私</td>\n<td>校验数据是否被篡改</td>\n<td>确保数据未被篡改且来源可信</td>\n</tr>\n<tr>\n<td>输出形式</td>\n<td>密文（加密后的数据）</td>\n<td>固定长度的哈希值</td>\n<td>数字签名（通过私钥加密的哈希值）</td>\n</tr>\n</tbody></table>\n<h2 id=\"关键区别总结\"><a href=\"#关键区别总结\" class=\"headerlink\" title=\"关键区别总结\"></a>关键区别总结</h2><ol>\n<li>加密 是为了保护数据的机密性，使数据只能由授权方读取。</li>\n<li>哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。</li>\n<li>签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。</li>\n</ol>\n<h1 id=\"5-加密、哈希与签名的综合应用\"><a href=\"#5-加密、哈希与签名的综合应用\" class=\"headerlink\" title=\"5. 加密、哈希与签名的综合应用\"></a>5. 加密、哈希与签名的综合应用</h1><p>在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：</p>\n<ul>\n<li>加密 用于加密传输的数据，保护数据的隐私。</li>\n<li>哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。</li>\n<li>签名 用于验证服务器的身份，确保与合法服务器进行通信。</li>\n</ul>\n<p>在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。</p>\n<hr>\n<p>希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！</em></p>\n<hr>\n<p>在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。</p>\n<h1 id=\"1-什么是加密？\"><a href=\"#1-什么是加密？\" class=\"headerlink\" title=\"1. 什么是加密？\"></a>1. 什么是加密？</h1><p><img src=\"/./images/encrypt-hash-signature/rsa.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。</p>\n<p>加密有两种常见的类型：</p>\n<ul>\n<li><p>对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。</p>\n</li>\n<li><p>非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。</p>\n</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据保密性：在通信过程中保护数据不被窃取。</li>\n<li>HTTPS：通过 SSL&#x2F;TLS 协议加密 web 请求和响应，确保数据的安全传输。</li>\n<li>加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。</li>\n</ul>\n<h1 id=\"2-什么是哈希？\"><a href=\"#2-什么是哈希？\" class=\"headerlink\" title=\"2. 什么是哈希？\"></a>2. 什么是哈希？</h1><p><img src=\"/./images/encrypt-hash-signature/md5.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-1\"><a href=\"#基本原理-1\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。</p>\n<p>哈希的关键特性包括：</p>\n<ul>\n<li>固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。</li>\n<li>碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。</li>\n<li>单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。</li>\n</ul>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。</li>\n<li>密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。</li>\n<li>数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。</li>\n</ul>\n<h1 id=\"3-什么是数字签名？\"><a href=\"#3-什么是数字签名？\" class=\"headerlink\" title=\"3. 什么是数字签名？\"></a>3. 什么是数字签名？</h1><p><img src=\"/./images/encrypt-hash-signature/certificate.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-2\"><a href=\"#基本原理-2\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。</p>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>身份验证：用于确保消息发送者的身份。</li>\n<li>数据完整性：确保数据在传输过程中没有被篡改。</li>\n<li>电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。</li>\n</ul>\n<h1 id=\"4-加密、哈希与签名的区别\"><a href=\"#4-加密、哈希与签名的区别\" class=\"headerlink\" title=\"4. 加密、哈希与签名的区别\"></a>4. 加密、哈希与签名的区别</h1><p>虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>加密</th>\n<th>哈希</th>\n<th>签名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>目的</td>\n<td>保证数据保密性</td>\n<td>确保数据完整性</td>\n<td>确保数据来源和完整性</td>\n</tr>\n<tr>\n<td>是否可逆</td>\n<td>可逆（通过密钥解密）</td>\n<td>不可逆</td>\n<td>可验证（但不可逆）</td>\n</tr>\n<tr>\n<td>涉及的密钥</td>\n<td>对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥</td>\n<td>不涉及密钥</td>\n<td>使用私钥生成签名，公钥验证签名</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>保护数据隐私</td>\n<td>校验数据是否被篡改</td>\n<td>确保数据未被篡改且来源可信</td>\n</tr>\n<tr>\n<td>输出形式</td>\n<td>密文（加密后的数据）</td>\n<td>固定长度的哈希值</td>\n<td>数字签名（通过私钥加密的哈希值）</td>\n</tr>\n</tbody></table>\n<h2 id=\"关键区别总结\"><a href=\"#关键区别总结\" class=\"headerlink\" title=\"关键区别总结\"></a>关键区别总结</h2><ol>\n<li>加密 是为了保护数据的机密性，使数据只能由授权方读取。</li>\n<li>哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。</li>\n<li>签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。</li>\n</ol>\n<h1 id=\"5-加密、哈希与签名的综合应用\"><a href=\"#5-加密、哈希与签名的综合应用\" class=\"headerlink\" title=\"5. 加密、哈希与签名的综合应用\"></a>5. 加密、哈希与签名的综合应用</h1><p>在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：</p>\n<ul>\n<li>加密 用于加密传输的数据，保护数据的隐私。</li>\n<li>哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。</li>\n<li>签名 用于验证服务器的身份，确保与合法服务器进行通信。</li>\n</ul>\n<p>在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。</p>\n<hr>\n<p>希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！</p>\n"},{"title":"JavaScript 信号：如何将响应式功能带到普通 Web 开发中","date":"2024-10-30T08:06:01.000Z","_content":"在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。\n\n# 信号是什么？\n信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。\n\n## 举个例子\n如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用\n```javascript\nimport { h } from 'preact';\nimport { signal, computed } from '@preact/signals';\nimport style from './style.css';\n\nconst username = signal('');\nconst password = signal('');\nconst message = computed(() => `用户名：${username.value} / 密码：${password.value}`);\nconst Test = ({ user }) => {\n\tconst submitForm = () => {\n\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<h2>用户注册</h2>\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tplaceholder=\"用户名\"\n\t\t\t\tonInput={(e) => username.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<input\n\t\t\t\ttype=\"password\"\n\t\t\t\tplaceholder=\"密码\"\n\t\t\t\tonInput={(e) => password.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<button onClick={submitForm}>提交</button>\n\t\t\t<p>{message}</p>\n\t\t</div>\n\t);\n};\n\nexport default Test;\n```\n运行上面preact的例子，我们可以看到如下效果\n![效果](./images/js-signal/responsive.gif)\n\n# 从零开始实现信号\n虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n}\n\n\nconst signal = new Signal('Initial Value');\nconsole.log(signal.value);\nsignal.addEventListener('change', (event) => {\n    console.log(`信号的新值是：${event.detail}`);\n});\n\nsignal.value = 'Updated Value'; // 输出：信号的新值是：Updated Value\nsignal.value = 'Another Value'; // 输出：信号的新值是：Another Value\n```\n这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：\n\n![效果](./images/js-signal/EventTarget.png)\n这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。\n\n# 增强功能：更简洁的 API\n我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n```\n现在，我们可以通过 effect 来简化代码：\n\n```javascript\nconst signal = new Signal('Initial Value');\nsignal.effect(() => console.log(`信号的新值是：${signal.value}`)); \nsignal.value = 'Updated Value'; \n```\n在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。\n![效果](./images/js-signal/EventTarget2.png)\n\n# 计算信号：依赖多个信号的计算\n有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n\n\nclass ComputedSignal extends Signal {\n    constructor(calculateFn, deps) {\n        super(calculateFn(...deps));\n        this.deps = deps;\n\n        deps.forEach(dep => {\n            dep.addEventListener('change', () => {\n                this.value = calculateFn(...deps);\n            });\n        });\n    }\n}\n\nconst name = new Signal('Thor');\nconst surname = new Signal('Odinson');\n\nconst fullName = new ComputedSignal((first, last) => `${first} ${last}`, [name, surname]);\n\nfullName.addEventListener('change', () => {\n    console.log(`计算后的全名是：${fullName.value}`);\n});\n\nname.value = 'Bruce'; // 输出：计算后的全名是：Bruce Odinson\nsurname.value = 'Banner'; // 输出：计算后的全名是：Bruce Banner\n```\n在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。\n![效果](./images/js-signal/EventTarget3.png)\n\n# 将信号与 Web 组件结合使用\n信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n}\n\ncustomElements.define('theme-switcher', class extends HTMLElement {\n    constructor() {\n        super();\n        this.darkThemeSignal = new Signal(false); // 默认为亮色主题\n    }\n\n    connectedCallback() {\n        // 创建主题切换按钮\n        this.innerHTML = `\n            <button id=\"light\">亮色主题</button>\n            <button id=\"dark\">暗色主题</button>\n            <p>当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}</p>\n        `;\n\n        // 获取按钮元素\n        const lightButton = this.querySelector('#light');\n        const darkButton = this.querySelector('#dark');\n        const statusText = this.querySelector('p');\n\n        // 监听按钮点击事件，切换主题\n        lightButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = false; // 切换到亮色主题\n        });\n\n        darkButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = true; // 切换到暗色主题\n        });\n\n        // 监听信号变化，更新主题\n        this.darkThemeSignal.effect(() => {\n            document.body.style.backgroundColor = this.darkThemeSignal.value ? 'black' : 'white';\n            document.body.style.color = this.darkThemeSignal.value ? 'white' : 'black';\n            statusText.textContent = `当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}`;\n        });\n    }\n});\n```\n这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。\n![切换主题](./images/js-signal/switch-theme.gif)\n\n# vue？\n通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。\n\n# 结语\n信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！","source":"_posts/js-signal.md","raw":"---\ntitle: JavaScript 信号：如何将响应式功能带到普通 Web 开发中\ndate: 2024-10-30 16:06:01\ntags:\n---\n在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。\n\n# 信号是什么？\n信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。\n\n## 举个例子\n如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用\n```javascript\nimport { h } from 'preact';\nimport { signal, computed } from '@preact/signals';\nimport style from './style.css';\n\nconst username = signal('');\nconst password = signal('');\nconst message = computed(() => `用户名：${username.value} / 密码：${password.value}`);\nconst Test = ({ user }) => {\n\tconst submitForm = () => {\n\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<h2>用户注册</h2>\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tplaceholder=\"用户名\"\n\t\t\t\tonInput={(e) => username.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<input\n\t\t\t\ttype=\"password\"\n\t\t\t\tplaceholder=\"密码\"\n\t\t\t\tonInput={(e) => password.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<button onClick={submitForm}>提交</button>\n\t\t\t<p>{message}</p>\n\t\t</div>\n\t);\n};\n\nexport default Test;\n```\n运行上面preact的例子，我们可以看到如下效果\n![效果](./images/js-signal/responsive.gif)\n\n# 从零开始实现信号\n虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n}\n\n\nconst signal = new Signal('Initial Value');\nconsole.log(signal.value);\nsignal.addEventListener('change', (event) => {\n    console.log(`信号的新值是：${event.detail}`);\n});\n\nsignal.value = 'Updated Value'; // 输出：信号的新值是：Updated Value\nsignal.value = 'Another Value'; // 输出：信号的新值是：Another Value\n```\n这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：\n\n![效果](./images/js-signal/EventTarget.png)\n这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。\n\n# 增强功能：更简洁的 API\n我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n```\n现在，我们可以通过 effect 来简化代码：\n\n```javascript\nconst signal = new Signal('Initial Value');\nsignal.effect(() => console.log(`信号的新值是：${signal.value}`)); \nsignal.value = 'Updated Value'; \n```\n在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。\n![效果](./images/js-signal/EventTarget2.png)\n\n# 计算信号：依赖多个信号的计算\n有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n\n\nclass ComputedSignal extends Signal {\n    constructor(calculateFn, deps) {\n        super(calculateFn(...deps));\n        this.deps = deps;\n\n        deps.forEach(dep => {\n            dep.addEventListener('change', () => {\n                this.value = calculateFn(...deps);\n            });\n        });\n    }\n}\n\nconst name = new Signal('Thor');\nconst surname = new Signal('Odinson');\n\nconst fullName = new ComputedSignal((first, last) => `${first} ${last}`, [name, surname]);\n\nfullName.addEventListener('change', () => {\n    console.log(`计算后的全名是：${fullName.value}`);\n});\n\nname.value = 'Bruce'; // 输出：计算后的全名是：Bruce Odinson\nsurname.value = 'Banner'; // 输出：计算后的全名是：Bruce Banner\n```\n在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。\n![效果](./images/js-signal/EventTarget3.png)\n\n# 将信号与 Web 组件结合使用\n信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n}\n\ncustomElements.define('theme-switcher', class extends HTMLElement {\n    constructor() {\n        super();\n        this.darkThemeSignal = new Signal(false); // 默认为亮色主题\n    }\n\n    connectedCallback() {\n        // 创建主题切换按钮\n        this.innerHTML = `\n            <button id=\"light\">亮色主题</button>\n            <button id=\"dark\">暗色主题</button>\n            <p>当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}</p>\n        `;\n\n        // 获取按钮元素\n        const lightButton = this.querySelector('#light');\n        const darkButton = this.querySelector('#dark');\n        const statusText = this.querySelector('p');\n\n        // 监听按钮点击事件，切换主题\n        lightButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = false; // 切换到亮色主题\n        });\n\n        darkButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = true; // 切换到暗色主题\n        });\n\n        // 监听信号变化，更新主题\n        this.darkThemeSignal.effect(() => {\n            document.body.style.backgroundColor = this.darkThemeSignal.value ? 'black' : 'white';\n            document.body.style.color = this.darkThemeSignal.value ? 'white' : 'black';\n            statusText.textContent = `当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}`;\n        });\n    }\n});\n```\n这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。\n![切换主题](./images/js-signal/switch-theme.gif)\n\n# vue？\n通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。\n\n# 结语\n信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！","slug":"js-signal","published":1,"updated":"2024-11-05T07:08:38.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmj000dm8p17awofnob","content":"<p>在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。</p>\n<h1 id=\"信号是什么？\"><a href=\"#信号是什么？\" class=\"headerlink\" title=\"信号是什么？\"></a>信号是什么？</h1><p>信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。</p>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; h &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;preact&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; signal, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@preact/signals&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./style.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> username = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> password = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> <span class=\"string\">`用户名：<span class=\"subst\">$&#123;username.value&#125;</span> / 密码：<span class=\"subst\">$&#123;password.value&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Test</span> = (<span class=\"params\">&#123; user &#125;</span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"title function_\">submitForm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>用户注册<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;用户名&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> username.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;密码&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> password.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;submitForm&#125;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;message&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Test</span>;</span><br></pre></td></tr></table></figure>\n<p>运行上面preact的例子，我们可以看到如下效果<br><img src=\"/./images/js-signal/responsive.gif\" alt=\"效果\"></p>\n<h1 id=\"从零开始实现信号\"><a href=\"#从零开始实现信号\" class=\"headerlink\" title=\"从零开始实现信号\"></a>从零开始实现信号</h1><p>虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(signal.<span class=\"property\">value</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;event.detail&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Updated Value</span></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Another Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Another Value</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：</p>\n<p><img src=\"/./images/js-signal/EventTarget.png\" alt=\"效果\"><br>这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。</p>\n<h1 id=\"增强功能：更简洁的-API\"><a href=\"#增强功能：更简洁的-API\" class=\"headerlink\" title=\"增强功能：更简洁的 API\"></a>增强功能：更简洁的 API</h1><p>我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以通过 effect 来简化代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;signal.value&#125;</span>`</span>)); </span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<p>在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。<br><img src=\"/./images/js-signal/EventTarget2.png\" alt=\"效果\"></p>\n<h1 id=\"计算信号：依赖多个信号的计算\"><a href=\"#计算信号：依赖多个信号的计算\" class=\"headerlink\" title=\"计算信号：依赖多个信号的计算\"></a>计算信号：依赖多个信号的计算</h1><p>有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputedSignal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Signal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">calculateFn, deps</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(<span class=\"title function_\">calculateFn</span>(...deps));</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">deps</span> = deps;</span><br><span class=\"line\"></span><br><span class=\"line\">        deps.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">dep</span> =&gt;</span> &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"title function_\">calculateFn</span>(...deps);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Thor&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> surname = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Odinson&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fullName = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedSignal</span>(<span class=\"function\">(<span class=\"params\">first, last</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>`</span>, [name, surname]);</span><br><span class=\"line\"></span><br><span class=\"line\">fullName.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`计算后的全名是：<span class=\"subst\">$&#123;fullName.value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">name.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Bruce&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Odinson</span></span><br><span class=\"line\">surname.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Banner&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Banner</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。<br><img src=\"/./images/js-signal/EventTarget3.png\" alt=\"效果\"></p>\n<h1 id=\"将信号与-Web-组件结合使用\"><a href=\"#将信号与-Web-组件结合使用\" class=\"headerlink\" title=\"将信号与 Web 组件结合使用\"></a>将信号与 Web 组件结合使用</h1><p>信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;theme-switcher&#x27;</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">HTMLElement</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// 默认为亮色主题</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建主题切换按钮</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;light&quot;&gt;亮色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;dark&quot;&gt;暗色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;p&gt;当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取按钮元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> lightButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#light&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> darkButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#dark&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> statusText = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听按钮点击事件，切换主题</span></span><br><span class=\"line\">        lightButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">false</span>; <span class=\"comment\">// 切换到亮色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        darkButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 切换到暗色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听信号变化，更新主题</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;black&#x27;</span> : <span class=\"string\">&#x27;white&#x27;</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;white&#x27;</span> : <span class=\"string\">&#x27;black&#x27;</span>;</span><br><span class=\"line\">            statusText.<span class=\"property\">textContent</span> = <span class=\"string\">`当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>`</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。<br><img src=\"/./images/js-signal/switch-theme.gif\" alt=\"切换主题\"></p>\n<h1 id=\"vue？\"><a href=\"#vue？\" class=\"headerlink\" title=\"vue？\"></a>vue？</h1><p>通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。</p>\n<h1 id=\"信号是什么？\"><a href=\"#信号是什么？\" class=\"headerlink\" title=\"信号是什么？\"></a>信号是什么？</h1><p>信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。</p>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; h &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;preact&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; signal, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@preact/signals&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./style.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> username = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> password = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> <span class=\"string\">`用户名：<span class=\"subst\">$&#123;username.value&#125;</span> / 密码：<span class=\"subst\">$&#123;password.value&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Test</span> = (<span class=\"params\">&#123; user &#125;</span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"title function_\">submitForm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>用户注册<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;用户名&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> username.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;密码&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> password.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;submitForm&#125;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;message&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Test</span>;</span><br></pre></td></tr></table></figure>\n<p>运行上面preact的例子，我们可以看到如下效果<br><img src=\"/./images/js-signal/responsive.gif\" alt=\"效果\"></p>\n<h1 id=\"从零开始实现信号\"><a href=\"#从零开始实现信号\" class=\"headerlink\" title=\"从零开始实现信号\"></a>从零开始实现信号</h1><p>虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(signal.<span class=\"property\">value</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;event.detail&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Updated Value</span></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Another Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Another Value</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：</p>\n<p><img src=\"/./images/js-signal/EventTarget.png\" alt=\"效果\"><br>这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。</p>\n<h1 id=\"增强功能：更简洁的-API\"><a href=\"#增强功能：更简洁的-API\" class=\"headerlink\" title=\"增强功能：更简洁的 API\"></a>增强功能：更简洁的 API</h1><p>我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以通过 effect 来简化代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;signal.value&#125;</span>`</span>)); </span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<p>在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。<br><img src=\"/./images/js-signal/EventTarget2.png\" alt=\"效果\"></p>\n<h1 id=\"计算信号：依赖多个信号的计算\"><a href=\"#计算信号：依赖多个信号的计算\" class=\"headerlink\" title=\"计算信号：依赖多个信号的计算\"></a>计算信号：依赖多个信号的计算</h1><p>有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputedSignal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Signal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">calculateFn, deps</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(<span class=\"title function_\">calculateFn</span>(...deps));</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">deps</span> = deps;</span><br><span class=\"line\"></span><br><span class=\"line\">        deps.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">dep</span> =&gt;</span> &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"title function_\">calculateFn</span>(...deps);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Thor&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> surname = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Odinson&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fullName = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedSignal</span>(<span class=\"function\">(<span class=\"params\">first, last</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>`</span>, [name, surname]);</span><br><span class=\"line\"></span><br><span class=\"line\">fullName.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`计算后的全名是：<span class=\"subst\">$&#123;fullName.value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">name.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Bruce&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Odinson</span></span><br><span class=\"line\">surname.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Banner&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Banner</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。<br><img src=\"/./images/js-signal/EventTarget3.png\" alt=\"效果\"></p>\n<h1 id=\"将信号与-Web-组件结合使用\"><a href=\"#将信号与-Web-组件结合使用\" class=\"headerlink\" title=\"将信号与 Web 组件结合使用\"></a>将信号与 Web 组件结合使用</h1><p>信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;theme-switcher&#x27;</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">HTMLElement</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// 默认为亮色主题</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建主题切换按钮</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;light&quot;&gt;亮色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;dark&quot;&gt;暗色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;p&gt;当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取按钮元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> lightButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#light&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> darkButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#dark&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> statusText = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听按钮点击事件，切换主题</span></span><br><span class=\"line\">        lightButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">false</span>; <span class=\"comment\">// 切换到亮色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        darkButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 切换到暗色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听信号变化，更新主题</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;black&#x27;</span> : <span class=\"string\">&#x27;white&#x27;</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;white&#x27;</span> : <span class=\"string\">&#x27;black&#x27;</span>;</span><br><span class=\"line\">            statusText.<span class=\"property\">textContent</span> = <span class=\"string\">`当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>`</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。<br><img src=\"/./images/js-signal/switch-theme.gif\" alt=\"切换主题\"></p>\n<h1 id=\"vue？\"><a href=\"#vue？\" class=\"headerlink\" title=\"vue？\"></a>vue？</h1><p>通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！</p>\n"},{"title":"HTTPS的工作原理以及安装","date":"2024-04-11T07:36:46.000Z","_content":"\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/https.md","raw":"---\ntitle: HTTPS的工作原理以及安装\ndate: 2024-04-11 15:36:46\ntags: https http ssl tls\n---\n\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"https","published":1,"updated":"2024-04-26T03:06:40.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmk000em8p18grse4qr","content":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Garnet，缓存的新选择！","date":"2024-04-07T07:24:24.000Z","_content":"\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/garnet.md","raw":"---\ntitle: Garnet，缓存的新选择！\ndate: 2024-04-07 15:24:24\ntags: Garnet 缓存 微软\n---\n\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"garnet","published":1,"updated":"2024-04-26T03:07:22.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmk000fm8p190owcnim","content":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Kubernetes 分享：如何使用 Helm 优化 Kubernetes 应用部署","date":"2024-12-11T06:22:16.000Z","_content":"\n在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。\n\n今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。\n\n# 什么是 Helm 和 Helm Chart？\n![architecture](./images/helm/helm3-arch.png)\n1. Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。\n\n2. Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。\n\n# 为什么要使用 Helm Chart？\n在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：\n\n- 简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。\n- 模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。\n- 版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。\n- 共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。\n\n# Helm Chart 结构\n一个典型的 Helm Chart 包含以下几个关键部分：\n![helm](./images/helm/new-helm.png)\n\n1. Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。\n2. values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。\n3. templates/目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。\n4. charts/目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。\n5. README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。\n\n# 创建一个简单的 Helm Chart\n假设我们要创建一个监控程序部署 Helm Chart，并且采用[DaemonSet](/2024/08/01/daemonset/)方式部署，步骤如下：\n\n1. 创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：\n\n```bash\nhelm create txclient\n```\n这将生成一个包含上述结构的基本 Chart。\n\n2. 修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：\n\n```yaml\nreplicaCount: 1\n\nimage:\n  repository: xxx/txclientx\n  tag: 5.24.11203.10\n  pullPolicy: IfNotPresent\n\nservice:\n  enabled: false\n\ndaemonset:\n  enabled: true\n  containers:\n    - name: txclient\n      image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"\n      ports:\n        - containerPort: 80  # 你程序暴露的端口，可以根据实际情况调整\n\nresources: {}\n```\n3. 修改模板文件： 在 templates/daemonset.yaml 中，替换其中的变量为模板形式：\n\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"    \n        env:\n        - name: KhGuid\n          value: \"xxxxxxx\"\n        - name: TxClient_DatabusUrl\n          value: \"https://xxx.com\"\n\n```\n4. 安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：\n\n```bash\nhelm install txclient /helm/txclient\n```\n这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：\n![lens](./images/helm/lens-helm.png)\n可以看到在两个node里面都有一个pod运行起来了。\n![lens](./images/helm/lens-pod.png)\n\n# 实用技巧与最佳实践\n1. 使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。\n\n   - 传入外部配置文件：\n\n    ```bash\n    helm install my-release ./my-chart -f custom-values.yaml\n    ```\n    - 使用 --set 传递单个值：\n    ```bash\n    helm install my-release ./my-chart --set image.tag=v1.2.3\n    ```\n   这种方式对于修改特定的单个配置项非常有用。\n2. Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。\n\n3. 多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。\n\n   如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。\n\n    ```bash\n    helm install my-release ./my-chart -f values-prod.yaml\n    helm install my-release ./my-chart -f values-dev.yaml\n    ```\n\n4. 自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。\n\n5. 调试和测试\n   - 调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。\n\n    ```bash\n    helm template my-release ./my-chart -f values.yaml\n    ```\n    这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。\n\n   - 测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。\n\n    ```bash\n    helm test my-release\n    ```\n\n# 结语\nHelm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。","source":"_posts/k8s-helm.md","raw":"---\ntitle: Kubernetes 分享：如何使用 Helm 优化 Kubernetes 应用部署\ndate: 2024-12-11 14:22:16\ntags:\n---\n\n在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。\n\n今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。\n\n# 什么是 Helm 和 Helm Chart？\n![architecture](./images/helm/helm3-arch.png)\n1. Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。\n\n2. Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。\n\n# 为什么要使用 Helm Chart？\n在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：\n\n- 简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。\n- 模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。\n- 版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。\n- 共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。\n\n# Helm Chart 结构\n一个典型的 Helm Chart 包含以下几个关键部分：\n![helm](./images/helm/new-helm.png)\n\n1. Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。\n2. values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。\n3. templates/目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。\n4. charts/目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。\n5. README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。\n\n# 创建一个简单的 Helm Chart\n假设我们要创建一个监控程序部署 Helm Chart，并且采用[DaemonSet](/2024/08/01/daemonset/)方式部署，步骤如下：\n\n1. 创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：\n\n```bash\nhelm create txclient\n```\n这将生成一个包含上述结构的基本 Chart。\n\n2. 修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：\n\n```yaml\nreplicaCount: 1\n\nimage:\n  repository: xxx/txclientx\n  tag: 5.24.11203.10\n  pullPolicy: IfNotPresent\n\nservice:\n  enabled: false\n\ndaemonset:\n  enabled: true\n  containers:\n    - name: txclient\n      image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"\n      ports:\n        - containerPort: 80  # 你程序暴露的端口，可以根据实际情况调整\n\nresources: {}\n```\n3. 修改模板文件： 在 templates/daemonset.yaml 中，替换其中的变量为模板形式：\n\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"    \n        env:\n        - name: KhGuid\n          value: \"xxxxxxx\"\n        - name: TxClient_DatabusUrl\n          value: \"https://xxx.com\"\n\n```\n4. 安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：\n\n```bash\nhelm install txclient /helm/txclient\n```\n这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：\n![lens](./images/helm/lens-helm.png)\n可以看到在两个node里面都有一个pod运行起来了。\n![lens](./images/helm/lens-pod.png)\n\n# 实用技巧与最佳实践\n1. 使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。\n\n   - 传入外部配置文件：\n\n    ```bash\n    helm install my-release ./my-chart -f custom-values.yaml\n    ```\n    - 使用 --set 传递单个值：\n    ```bash\n    helm install my-release ./my-chart --set image.tag=v1.2.3\n    ```\n   这种方式对于修改特定的单个配置项非常有用。\n2. Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。\n\n3. 多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。\n\n   如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。\n\n    ```bash\n    helm install my-release ./my-chart -f values-prod.yaml\n    helm install my-release ./my-chart -f values-dev.yaml\n    ```\n\n4. 自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。\n\n5. 调试和测试\n   - 调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。\n\n    ```bash\n    helm template my-release ./my-chart -f values.yaml\n    ```\n    这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。\n\n   - 测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。\n\n    ```bash\n    helm test my-release\n    ```\n\n# 结语\nHelm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。","slug":"k8s-helm","published":1,"updated":"2024-12-12T06:30:51.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihml000im8p16uwj4v6t","content":"<p>在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。</p>\n<p>今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。</p>\n<h1 id=\"什么是-Helm-和-Helm-Chart？\"><a href=\"#什么是-Helm-和-Helm-Chart？\" class=\"headerlink\" title=\"什么是 Helm 和 Helm Chart？\"></a>什么是 Helm 和 Helm Chart？</h1><p><img src=\"/./images/helm/helm3-arch.png\" alt=\"architecture\"></p>\n<ol>\n<li><p>Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。</p>\n</li>\n<li><p>Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。</p>\n</li>\n</ol>\n<h1 id=\"为什么要使用-Helm-Chart？\"><a href=\"#为什么要使用-Helm-Chart？\" class=\"headerlink\" title=\"为什么要使用 Helm Chart？\"></a>为什么要使用 Helm Chart？</h1><p>在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：</p>\n<ul>\n<li>简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。</li>\n<li>模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。</li>\n<li>版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。</li>\n<li>共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。</li>\n</ul>\n<h1 id=\"Helm-Chart-结构\"><a href=\"#Helm-Chart-结构\" class=\"headerlink\" title=\"Helm Chart 结构\"></a>Helm Chart 结构</h1><p>一个典型的 Helm Chart 包含以下几个关键部分：<br><img src=\"/./images/helm/new-helm.png\" alt=\"helm\"></p>\n<ol>\n<li>Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。</li>\n<li>values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。</li>\n<li>templates&#x2F;目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。</li>\n<li>charts&#x2F;目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。</li>\n<li>README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。</li>\n</ol>\n<h1 id=\"创建一个简单的-Helm-Chart\"><a href=\"#创建一个简单的-Helm-Chart\" class=\"headerlink\" title=\"创建一个简单的 Helm Chart\"></a>创建一个简单的 Helm Chart</h1><p>假设我们要创建一个监控程序部署 Helm Chart，并且采用<a href=\"/2024/08/01/daemonset/\">DaemonSet</a>方式部署，步骤如下：</p>\n<ol>\n<li>创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm create txclient</span><br></pre></td></tr></table></figure>\n<p>这将生成一个包含上述结构的基本 Chart。</p>\n<ol start=\"2\">\n<li>修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">replicaCount:</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">image:</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span> <span class=\"string\">xxx/txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">tag:</span> <span class=\"number\">5.24</span><span class=\"number\">.11203</span><span class=\"number\">.10</span></span><br><span class=\"line\">  <span class=\"attr\">pullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">service:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">daemonset:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclient</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 你程序暴露的端口，可以根据实际情况调整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">resources:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>修改模板文件： 在 templates&#x2F;daemonset.yaml 中，替换其中的变量为模板形式：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span>    </span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxxxxxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxClient_DatabusUrl</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://xxx.com&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install txclient /helm/txclient</span><br></pre></td></tr></table></figure>\n<p>这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：<br><img src=\"/./images/helm/lens-helm.png\" alt=\"lens\"><br>可以看到在两个node里面都有一个pod运行起来了。<br><img src=\"/./images/helm/lens-pod.png\" alt=\"lens\"></p>\n<h1 id=\"实用技巧与最佳实践\"><a href=\"#实用技巧与最佳实践\" class=\"headerlink\" title=\"实用技巧与最佳实践\"></a>实用技巧与最佳实践</h1><ol>\n<li><p>使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。</p>\n<ul>\n<li>传入外部配置文件：</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f custom-values.yaml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 –set 传递单个值： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart --<span class=\"built_in\">set</span> image.tag=v1.2.3</span><br></pre></td></tr></table></figure>\n这种方式对于修改特定的单个配置项非常有用。</li>\n</ul>\n</li>\n<li><p>Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。</p>\n</li>\n<li><p>多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。</p>\n<p>如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f values-prod.yaml</span><br><span class=\"line\">helm install my-release ./my-chart -f values-dev.yaml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。</p>\n</li>\n<li><p>调试和测试</p>\n<ul>\n<li>调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm template my-release ./my-chart -f values.yaml</span><br></pre></td></tr></table></figure>\n<p> 这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。</p>\n<ul>\n<li>测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm <span class=\"built_in\">test</span> my-release</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Helm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。</p>\n<p>今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。</p>\n<h1 id=\"什么是-Helm-和-Helm-Chart？\"><a href=\"#什么是-Helm-和-Helm-Chart？\" class=\"headerlink\" title=\"什么是 Helm 和 Helm Chart？\"></a>什么是 Helm 和 Helm Chart？</h1><p><img src=\"/./images/helm/helm3-arch.png\" alt=\"architecture\"></p>\n<ol>\n<li><p>Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。</p>\n</li>\n<li><p>Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。</p>\n</li>\n</ol>\n<h1 id=\"为什么要使用-Helm-Chart？\"><a href=\"#为什么要使用-Helm-Chart？\" class=\"headerlink\" title=\"为什么要使用 Helm Chart？\"></a>为什么要使用 Helm Chart？</h1><p>在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：</p>\n<ul>\n<li>简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。</li>\n<li>模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。</li>\n<li>版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。</li>\n<li>共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。</li>\n</ul>\n<h1 id=\"Helm-Chart-结构\"><a href=\"#Helm-Chart-结构\" class=\"headerlink\" title=\"Helm Chart 结构\"></a>Helm Chart 结构</h1><p>一个典型的 Helm Chart 包含以下几个关键部分：<br><img src=\"/./images/helm/new-helm.png\" alt=\"helm\"></p>\n<ol>\n<li>Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。</li>\n<li>values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。</li>\n<li>templates&#x2F;目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。</li>\n<li>charts&#x2F;目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。</li>\n<li>README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。</li>\n</ol>\n<h1 id=\"创建一个简单的-Helm-Chart\"><a href=\"#创建一个简单的-Helm-Chart\" class=\"headerlink\" title=\"创建一个简单的 Helm Chart\"></a>创建一个简单的 Helm Chart</h1><p>假设我们要创建一个监控程序部署 Helm Chart，并且采用<a href=\"/2024/08/01/daemonset/\">DaemonSet</a>方式部署，步骤如下：</p>\n<ol>\n<li>创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm create txclient</span><br></pre></td></tr></table></figure>\n<p>这将生成一个包含上述结构的基本 Chart。</p>\n<ol start=\"2\">\n<li>修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">replicaCount:</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">image:</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span> <span class=\"string\">xxx/txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">tag:</span> <span class=\"number\">5.24</span><span class=\"number\">.11203</span><span class=\"number\">.10</span></span><br><span class=\"line\">  <span class=\"attr\">pullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">service:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">daemonset:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclient</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 你程序暴露的端口，可以根据实际情况调整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">resources:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>修改模板文件： 在 templates&#x2F;daemonset.yaml 中，替换其中的变量为模板形式：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span>    </span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxxxxxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxClient_DatabusUrl</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://xxx.com&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install txclient /helm/txclient</span><br></pre></td></tr></table></figure>\n<p>这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：<br><img src=\"/./images/helm/lens-helm.png\" alt=\"lens\"><br>可以看到在两个node里面都有一个pod运行起来了。<br><img src=\"/./images/helm/lens-pod.png\" alt=\"lens\"></p>\n<h1 id=\"实用技巧与最佳实践\"><a href=\"#实用技巧与最佳实践\" class=\"headerlink\" title=\"实用技巧与最佳实践\"></a>实用技巧与最佳实践</h1><ol>\n<li><p>使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。</p>\n<ul>\n<li>传入外部配置文件：</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f custom-values.yaml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 –set 传递单个值： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart --<span class=\"built_in\">set</span> image.tag=v1.2.3</span><br></pre></td></tr></table></figure>\n这种方式对于修改特定的单个配置项非常有用。</li>\n</ul>\n</li>\n<li><p>Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。</p>\n</li>\n<li><p>多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。</p>\n<p>如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f values-prod.yaml</span><br><span class=\"line\">helm install my-release ./my-chart -f values-dev.yaml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。</p>\n</li>\n<li><p>调试和测试</p>\n<ul>\n<li>调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm template my-release ./my-chart -f values.yaml</span><br></pre></td></tr></table></figure>\n<p> 这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。</p>\n<ul>\n<li>测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm <span class=\"built_in\">test</span> my-release</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Helm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。</p>\n"},{"title":"代理服务解析：正向代理、反向代理和透明代理","date":"2024-06-20T02:06:56.000Z","_content":"\n在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。\n\n然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。\n\n# 什么是代理服务器？\n代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。\n\n# 正向代理\n## 定义\n正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。\n\n## 工作原理\n![正向代理](/images/proxy/forward-proxy.png)\n1. 客户端向代理服务器发送请求。\n2. 代理服务器向目标服务器转发请求。\n3. 目标服务器响应代理服务器。\n4. 代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。\n2. 缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。\n3. 匿名性：隐藏客户端的真实IP地址，保护隐私。\n\n## 示例代码\n```\n# 简单的正向代理示例（Python）\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport requests\n\nclass Proxy(BaseHTTPRequestHandler):\n    def do_GET(self):\n        url = self.path[1:]\n        response = requests.get(url)\n        self.send_response(response.status_code)\n        self.send_header('Content-type', response.headers['Content-Type'])\n        self.end_headers()\n        self.wfile.write(response.content)\n\nif __name__ == \"__main__\":\n    server = HTTPServer(('localhost', 8080), Proxy)\n    print(\"Starting proxy server on port 8080\")\n    server.serve_forever()\n\n```\n\n# 反向代理\n## 定义\n反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。\n\n尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。\n反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。\n\n## 反向代理和正向代理的相似之处\n正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。\n正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。\n正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。\n也可以使用相同的软件来配置正向和反向代理。\n\n例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。\n\n## 工作原理\n![反向代理](/images/proxy/reverse-proxy.png)\n1. 客户端向反向代理服务器发送请求。\n2. 反向代理服务器向内部服务器转发请求。\n3. 内部服务器响应反向代理服务器。\n4. 反向代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。\n2. 安全性：隐藏内部服务器的IP地址，增加安全性。\n3. SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。\n\n## 示例\n```\n# Nginx 反向代理配置示例\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend_server;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n\n# 透明代理\n## 定义\n透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。\n\n透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。\n\n透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。\n\n## 工作原理\n![反向代理](/images/proxy/transparent-proxy.png)\n1. 客户端向目标服务器发送请求。\n2. 透明代理截获并转发请求。\n3. 目标服务器响应请求。\n4. 透明代理截获并转发响应。\n\n## 应用场景\n1. 监控和过滤：用于网络监控、过滤和记录网络流量。\n2. 缓存：透明代理缓存常用内容，提高访问速度。\n3. 访问控制：控制对特定网站或服务的访问。\n\n## 示例代码\n```shell\n# 使用iptables设置透明代理\n# 假设代理服务器IP为192.168.1.1，目标端口为8080\niptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080\niptables -t nat -A POSTROUTING -j MASQUERADE\n```\n\n# 总结\n代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。","source":"_posts/proxy.md","raw":"---\ntitle: 代理服务解析：正向代理、反向代理和透明代理\ndate: 2024-06-20 10:06:56\ntags:\n---\n\n在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。\n\n然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。\n\n# 什么是代理服务器？\n代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。\n\n# 正向代理\n## 定义\n正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。\n\n## 工作原理\n![正向代理](/images/proxy/forward-proxy.png)\n1. 客户端向代理服务器发送请求。\n2. 代理服务器向目标服务器转发请求。\n3. 目标服务器响应代理服务器。\n4. 代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。\n2. 缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。\n3. 匿名性：隐藏客户端的真实IP地址，保护隐私。\n\n## 示例代码\n```\n# 简单的正向代理示例（Python）\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport requests\n\nclass Proxy(BaseHTTPRequestHandler):\n    def do_GET(self):\n        url = self.path[1:]\n        response = requests.get(url)\n        self.send_response(response.status_code)\n        self.send_header('Content-type', response.headers['Content-Type'])\n        self.end_headers()\n        self.wfile.write(response.content)\n\nif __name__ == \"__main__\":\n    server = HTTPServer(('localhost', 8080), Proxy)\n    print(\"Starting proxy server on port 8080\")\n    server.serve_forever()\n\n```\n\n# 反向代理\n## 定义\n反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。\n\n尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。\n反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。\n\n## 反向代理和正向代理的相似之处\n正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。\n正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。\n正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。\n也可以使用相同的软件来配置正向和反向代理。\n\n例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。\n\n## 工作原理\n![反向代理](/images/proxy/reverse-proxy.png)\n1. 客户端向反向代理服务器发送请求。\n2. 反向代理服务器向内部服务器转发请求。\n3. 内部服务器响应反向代理服务器。\n4. 反向代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。\n2. 安全性：隐藏内部服务器的IP地址，增加安全性。\n3. SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。\n\n## 示例\n```\n# Nginx 反向代理配置示例\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend_server;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n\n# 透明代理\n## 定义\n透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。\n\n透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。\n\n透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。\n\n## 工作原理\n![反向代理](/images/proxy/transparent-proxy.png)\n1. 客户端向目标服务器发送请求。\n2. 透明代理截获并转发请求。\n3. 目标服务器响应请求。\n4. 透明代理截获并转发响应。\n\n## 应用场景\n1. 监控和过滤：用于网络监控、过滤和记录网络流量。\n2. 缓存：透明代理缓存常用内容，提高访问速度。\n3. 访问控制：控制对特定网站或服务的访问。\n\n## 示例代码\n```shell\n# 使用iptables设置透明代理\n# 假设代理服务器IP为192.168.1.1，目标端口为8080\niptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080\niptables -t nat -A POSTROUTING -j MASQUERADE\n```\n\n# 总结\n代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。","slug":"proxy","published":1,"updated":"2024-06-21T01:04:32.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihml000jm8p1a7k27kmh","content":"<p>在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。</p>\n<p>然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。</p>\n<h1 id=\"什么是代理服务器？\"><a href=\"#什么是代理服务器？\" class=\"headerlink\" title=\"什么是代理服务器？\"></a>什么是代理服务器？</h1><p>代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。</p>\n<h1 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/forward-proxy.png\" alt=\"正向代理\"></p>\n<ol>\n<li>客户端向代理服务器发送请求。</li>\n<li>代理服务器向目标服务器转发请求。</li>\n<li>目标服务器响应代理服务器。</li>\n<li>代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。</li>\n<li>缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。</li>\n<li>匿名性：隐藏客户端的真实IP地址，保护隐私。</li>\n</ol>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 简单的正向代理示例（Python）</span><br><span class=\"line\">from http.server import BaseHTTPRequestHandler, HTTPServer</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy(BaseHTTPRequestHandler):</span><br><span class=\"line\">    def do_GET(self):</span><br><span class=\"line\">        url = self.path[1:]</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\">        self.send_response(response.status_code)</span><br><span class=\"line\">        self.send_header(&#x27;Content-type&#x27;, response.headers[&#x27;Content-Type&#x27;])</span><br><span class=\"line\">        self.end_headers()</span><br><span class=\"line\">        self.wfile.write(response.content)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    server = HTTPServer((&#x27;localhost&#x27;, 8080), Proxy)</span><br><span class=\"line\">    print(&quot;Starting proxy server on port 8080&quot;)</span><br><span class=\"line\">    server.serve_forever()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。</p>\n<p>尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。<br>反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。</p>\n<h2 id=\"反向代理和正向代理的相似之处\"><a href=\"#反向代理和正向代理的相似之处\" class=\"headerlink\" title=\"反向代理和正向代理的相似之处\"></a>反向代理和正向代理的相似之处</h2><p>正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。<br>正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。<br>正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。<br>也可以使用相同的软件来配置正向和反向代理。</p>\n<p>例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。</p>\n<h2 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/reverse-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向反向代理服务器发送请求。</li>\n<li>反向代理服务器向内部服务器转发请求。</li>\n<li>内部服务器响应反向代理服务器。</li>\n<li>反向代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。</li>\n<li>安全性：隐藏内部服务器的IP地址，增加安全性。</li>\n<li>SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Nginx 反向代理配置示例</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://backend_server;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。</p>\n<p>透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。</p>\n<p>透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。</p>\n<h2 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/transparent-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向目标服务器发送请求。</li>\n<li>透明代理截获并转发请求。</li>\n<li>目标服务器响应请求。</li>\n<li>透明代理截获并转发响应。</li>\n</ol>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>监控和过滤：用于网络监控、过滤和记录网络流量。</li>\n<li>缓存：透明代理缓存常用内容，提高访问速度。</li>\n<li>访问控制：控制对特定网站或服务的访问。</li>\n</ol>\n<h2 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用iptables设置透明代理</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">假设代理服务器IP为192.168.1.1，目标端口为8080</span></span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。</p>\n<p>然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。</p>\n<h1 id=\"什么是代理服务器？\"><a href=\"#什么是代理服务器？\" class=\"headerlink\" title=\"什么是代理服务器？\"></a>什么是代理服务器？</h1><p>代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。</p>\n<h1 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/forward-proxy.png\" alt=\"正向代理\"></p>\n<ol>\n<li>客户端向代理服务器发送请求。</li>\n<li>代理服务器向目标服务器转发请求。</li>\n<li>目标服务器响应代理服务器。</li>\n<li>代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。</li>\n<li>缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。</li>\n<li>匿名性：隐藏客户端的真实IP地址，保护隐私。</li>\n</ol>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 简单的正向代理示例（Python）</span><br><span class=\"line\">from http.server import BaseHTTPRequestHandler, HTTPServer</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy(BaseHTTPRequestHandler):</span><br><span class=\"line\">    def do_GET(self):</span><br><span class=\"line\">        url = self.path[1:]</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\">        self.send_response(response.status_code)</span><br><span class=\"line\">        self.send_header(&#x27;Content-type&#x27;, response.headers[&#x27;Content-Type&#x27;])</span><br><span class=\"line\">        self.end_headers()</span><br><span class=\"line\">        self.wfile.write(response.content)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    server = HTTPServer((&#x27;localhost&#x27;, 8080), Proxy)</span><br><span class=\"line\">    print(&quot;Starting proxy server on port 8080&quot;)</span><br><span class=\"line\">    server.serve_forever()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。</p>\n<p>尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。<br>反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。</p>\n<h2 id=\"反向代理和正向代理的相似之处\"><a href=\"#反向代理和正向代理的相似之处\" class=\"headerlink\" title=\"反向代理和正向代理的相似之处\"></a>反向代理和正向代理的相似之处</h2><p>正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。<br>正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。<br>正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。<br>也可以使用相同的软件来配置正向和反向代理。</p>\n<p>例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。</p>\n<h2 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/reverse-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向反向代理服务器发送请求。</li>\n<li>反向代理服务器向内部服务器转发请求。</li>\n<li>内部服务器响应反向代理服务器。</li>\n<li>反向代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。</li>\n<li>安全性：隐藏内部服务器的IP地址，增加安全性。</li>\n<li>SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Nginx 反向代理配置示例</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://backend_server;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。</p>\n<p>透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。</p>\n<p>透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。</p>\n<h2 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/images/proxy/transparent-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向目标服务器发送请求。</li>\n<li>透明代理截获并转发请求。</li>\n<li>目标服务器响应请求。</li>\n<li>透明代理截获并转发响应。</li>\n</ol>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>监控和过滤：用于网络监控、过滤和记录网络流量。</li>\n<li>缓存：透明代理缓存常用内容，提高访问速度。</li>\n<li>访问控制：控制对特定网站或服务的访问。</li>\n</ol>\n<h2 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用iptables设置透明代理</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">假设代理服务器IP为192.168.1.1，目标端口为8080</span></span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。</p>\n"},{"title":"组织发展致命杀手：内耗","date":"2024-03-28T09:49:50.000Z","_content":"\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/organization-internal-loss.md","raw":"---\ntitle: 组织发展致命杀手：内耗\ndate: 2024-03-28 17:49:50\ntags: 组织 内耗\n---\n\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"organization-internal-loss","published":1,"updated":"2024-04-26T03:06:35.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihml000km8p1eq3bex5s","content":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"深入解读 MFA 和 TOTP 的实现原理与应用","date":"2024-11-20T06:56:26.000Z","_content":"# 前言\n前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。\n所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。\n![web](/images/mfa/web.png)\n终于不用掏手机了。。。\n\n提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。\n![github](/images/mfa/github.png)\n\n\n现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。\n\n----\n\n# 什么是 MFA 和 TOTP？\n## MFA（多因素认证）\n多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：\n\n1. 知识因素：用户知道的内容，如密码或 PIN。\n2. 拥有因素：用户拥有的内容，如手机、硬件令牌。\n3. 生物因素：用户本身的特性，如指纹、面部识别。\n通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。\n\n## TOTP（基于时间的一次性密码）\nTOTP 是一种动态生成的密码，基于：\n\n- 共享密钥：系统和用户共享的一个随机密钥。\n- 时间步长：通常为 30 秒，密码每 30 秒更新一次。\nTOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。\n\n# TOTP 的工作原理\n标准流程\n1. 共享密钥的生成与分发：\n\n    - 系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。\n    - 用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。\n2. 时间步计算：\n\n    - 当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。\n3. HMAC 运算：\n\n    - 使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。\n4. 动态截取：\n\n    - 从哈希值中动态截取 4 字节数据，确保结果随机性。\n5. 生成动态密码：\n\n    - 将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。\n6. 验证：\n\n    - 系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。\n\n# TOTP密钥的保护\n根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：\n1. 减少密钥泄露的风险\n    - 单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。\n    - 防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。\n\n2. 补救措施\n由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：\n\n    + 备用验证方法：\n        - 提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。\n        - 提供其他备选验证方式（如短信验证、电子邮件验证）。\n    + 重新绑定机制：\n        - 用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。\n        - 一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。\n\n\n# TOTP 的实现原理\n以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。\n\n1. Base32 解码\nTOTP 密钥通常使用 Base32 编码，需先解码为原始字节。\n\n```csharp\nstatic byte[] Base32Decode(string base32)\n{\n    // 示例解码实现\n    const string base32Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n    base32 = base32.TrimEnd('=').ToUpper();\n    List<byte> bytes = new List<byte>();\n\n    int buffer = 0, bitsLeft = 0;\n    foreach (char c in base32)\n    {\n        if (!base32Chars.Contains(c))\n            throw new FormatException(\"Invalid Base32 character.\");\n        buffer = (buffer << 5) | base32Chars.IndexOf(c);\n        bitsLeft += 5;\n\n        if (bitsLeft >= 8)\n        {\n            bytes.Add((byte)(buffer >> (bitsLeft - 8)));\n            bitsLeft -= 8;\n        }\n    }\n\n    return bytes.ToArray();\n}\n```\n2. 获取计数器值\n计数器值通过当前时间计算得出，单位为 30 秒。\n\n```csharp\nlong GetCounter()\n{\n    return DateTimeOffset.UtcNow.ToUnixTimeSeconds() / 30;\n}\n\nbyte[] GetCounterBytes(long counter)\n{\n    byte[] bytes = BitConverter.GetBytes(counter);\n    if (BitConverter.IsLittleEndian)\n        Array.Reverse(bytes); // 转换为大端序\n    return bytes;\n}\n```\n3. HMAC 计算与动态截取\n使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。\n\n```csharp\nstring GenerateTOTP(string secretKey, int passwordLength = 6)\n{\n    byte[] keyBytes = Base32Decode(secretKey);\n    long counter = GetCounter();\n    byte[] counterBytes = GetCounterBytes(counter);\n\n    using var hmac = new HMACSHA1(keyBytes);\n    byte[] hash = hmac.ComputeHash(counterBytes);\n\n    // 动态截取\n    int offset = hash[^1] & 0x0F;\n    int binaryCode = ((hash[offset] & 0x7F) << 24) |\n                     ((hash[offset + 1] & 0xFF) << 16) |\n                     ((hash[offset + 2] & 0xFF) << 8) |\n                     (hash[offset + 3] & 0xFF);\n\n    int otp = binaryCode % (int)Math.Pow(10, passwordLength);\n    return otp.ToString(new string('0', passwordLength)); // 补齐前导零\n}\n```\n4. 示例完整调用\n以下代码生成一个 6 位动态密码。\n\n```csharp\nstring secretKey = \"xxxxxxxxxxx\"; // Base32 编码的密钥\nstring totp = GenerateTOTP(secretKey);\nConsole.WriteLine($\"当前 TOTP 动态密码为: {totp}\");\n```\n![示例完整调用](/images/mfa/run.png)\n# TOTP 的实际应用\n常见场景\n- 账户登录保护：结合密码一起验证，提高安全性。\n- 交易确认：确保关键操作的合法性。\n- 设备绑定：保护设备认证过程。\n\n主流实现工具\n- 手机应用：Google Authenticator、Microsoft Authenticator。\n- 服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。\n\n# TOTP 的优缺点\n优点\n1. 安全性高：密码定期更新，短时间内有效。\n2. 易用性好：无需额外硬件，使用手机即可。\n3. 实现简单：基于开源算法和规范，易于集成。\n\n缺点\n1. 时间同步要求：客户端与服务器需时间一致。\n2. 丢失风险：若用户丢失密钥或设备，可能导致无法验证。\n\n# 总结\nTOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！\n在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？\n\n欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊","source":"_posts/mfa.md","raw":"---\ntitle: 深入解读 MFA 和 TOTP 的实现原理与应用\ndate: 2024-11-20 14:56:26\ntags:\n---\n# 前言\n前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。\n所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。\n![web](/images/mfa/web.png)\n终于不用掏手机了。。。\n\n提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。\n![github](/images/mfa/github.png)\n\n\n现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。\n\n----\n\n# 什么是 MFA 和 TOTP？\n## MFA（多因素认证）\n多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：\n\n1. 知识因素：用户知道的内容，如密码或 PIN。\n2. 拥有因素：用户拥有的内容，如手机、硬件令牌。\n3. 生物因素：用户本身的特性，如指纹、面部识别。\n通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。\n\n## TOTP（基于时间的一次性密码）\nTOTP 是一种动态生成的密码，基于：\n\n- 共享密钥：系统和用户共享的一个随机密钥。\n- 时间步长：通常为 30 秒，密码每 30 秒更新一次。\nTOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。\n\n# TOTP 的工作原理\n标准流程\n1. 共享密钥的生成与分发：\n\n    - 系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。\n    - 用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。\n2. 时间步计算：\n\n    - 当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。\n3. HMAC 运算：\n\n    - 使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。\n4. 动态截取：\n\n    - 从哈希值中动态截取 4 字节数据，确保结果随机性。\n5. 生成动态密码：\n\n    - 将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。\n6. 验证：\n\n    - 系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。\n\n# TOTP密钥的保护\n根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：\n1. 减少密钥泄露的风险\n    - 单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。\n    - 防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。\n\n2. 补救措施\n由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：\n\n    + 备用验证方法：\n        - 提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。\n        - 提供其他备选验证方式（如短信验证、电子邮件验证）。\n    + 重新绑定机制：\n        - 用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。\n        - 一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。\n\n\n# TOTP 的实现原理\n以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。\n\n1. Base32 解码\nTOTP 密钥通常使用 Base32 编码，需先解码为原始字节。\n\n```csharp\nstatic byte[] Base32Decode(string base32)\n{\n    // 示例解码实现\n    const string base32Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n    base32 = base32.TrimEnd('=').ToUpper();\n    List<byte> bytes = new List<byte>();\n\n    int buffer = 0, bitsLeft = 0;\n    foreach (char c in base32)\n    {\n        if (!base32Chars.Contains(c))\n            throw new FormatException(\"Invalid Base32 character.\");\n        buffer = (buffer << 5) | base32Chars.IndexOf(c);\n        bitsLeft += 5;\n\n        if (bitsLeft >= 8)\n        {\n            bytes.Add((byte)(buffer >> (bitsLeft - 8)));\n            bitsLeft -= 8;\n        }\n    }\n\n    return bytes.ToArray();\n}\n```\n2. 获取计数器值\n计数器值通过当前时间计算得出，单位为 30 秒。\n\n```csharp\nlong GetCounter()\n{\n    return DateTimeOffset.UtcNow.ToUnixTimeSeconds() / 30;\n}\n\nbyte[] GetCounterBytes(long counter)\n{\n    byte[] bytes = BitConverter.GetBytes(counter);\n    if (BitConverter.IsLittleEndian)\n        Array.Reverse(bytes); // 转换为大端序\n    return bytes;\n}\n```\n3. HMAC 计算与动态截取\n使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。\n\n```csharp\nstring GenerateTOTP(string secretKey, int passwordLength = 6)\n{\n    byte[] keyBytes = Base32Decode(secretKey);\n    long counter = GetCounter();\n    byte[] counterBytes = GetCounterBytes(counter);\n\n    using var hmac = new HMACSHA1(keyBytes);\n    byte[] hash = hmac.ComputeHash(counterBytes);\n\n    // 动态截取\n    int offset = hash[^1] & 0x0F;\n    int binaryCode = ((hash[offset] & 0x7F) << 24) |\n                     ((hash[offset + 1] & 0xFF) << 16) |\n                     ((hash[offset + 2] & 0xFF) << 8) |\n                     (hash[offset + 3] & 0xFF);\n\n    int otp = binaryCode % (int)Math.Pow(10, passwordLength);\n    return otp.ToString(new string('0', passwordLength)); // 补齐前导零\n}\n```\n4. 示例完整调用\n以下代码生成一个 6 位动态密码。\n\n```csharp\nstring secretKey = \"xxxxxxxxxxx\"; // Base32 编码的密钥\nstring totp = GenerateTOTP(secretKey);\nConsole.WriteLine($\"当前 TOTP 动态密码为: {totp}\");\n```\n![示例完整调用](/images/mfa/run.png)\n# TOTP 的实际应用\n常见场景\n- 账户登录保护：结合密码一起验证，提高安全性。\n- 交易确认：确保关键操作的合法性。\n- 设备绑定：保护设备认证过程。\n\n主流实现工具\n- 手机应用：Google Authenticator、Microsoft Authenticator。\n- 服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。\n\n# TOTP 的优缺点\n优点\n1. 安全性高：密码定期更新，短时间内有效。\n2. 易用性好：无需额外硬件，使用手机即可。\n3. 实现简单：基于开源算法和规范，易于集成。\n\n缺点\n1. 时间同步要求：客户端与服务器需时间一致。\n2. 丢失风险：若用户丢失密钥或设备，可能导致无法验证。\n\n# 总结\nTOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！\n在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？\n\n欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊","slug":"mfa","published":1,"updated":"2024-11-21T06:23:11.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmm000nm8p17p3w5fg1","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。<br>所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。<br><img src=\"/images/mfa/web.png\" alt=\"web\"><br>终于不用掏手机了。。。</p>\n<p>提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。<br><img src=\"/images/mfa/github.png\" alt=\"github\"></p>\n<p>现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。</p>\n<hr>\n<h1 id=\"什么是-MFA-和-TOTP？\"><a href=\"#什么是-MFA-和-TOTP？\" class=\"headerlink\" title=\"什么是 MFA 和 TOTP？\"></a>什么是 MFA 和 TOTP？</h1><h2 id=\"MFA（多因素认证）\"><a href=\"#MFA（多因素认证）\" class=\"headerlink\" title=\"MFA（多因素认证）\"></a>MFA（多因素认证）</h2><p>多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：</p>\n<ol>\n<li>知识因素：用户知道的内容，如密码或 PIN。</li>\n<li>拥有因素：用户拥有的内容，如手机、硬件令牌。</li>\n<li>生物因素：用户本身的特性，如指纹、面部识别。<br>通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。</li>\n</ol>\n<h2 id=\"TOTP（基于时间的一次性密码）\"><a href=\"#TOTP（基于时间的一次性密码）\" class=\"headerlink\" title=\"TOTP（基于时间的一次性密码）\"></a>TOTP（基于时间的一次性密码）</h2><p>TOTP 是一种动态生成的密码，基于：</p>\n<ul>\n<li>共享密钥：系统和用户共享的一个随机密钥。</li>\n<li>时间步长：通常为 30 秒，密码每 30 秒更新一次。<br>TOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。</li>\n</ul>\n<h1 id=\"TOTP-的工作原理\"><a href=\"#TOTP-的工作原理\" class=\"headerlink\" title=\"TOTP 的工作原理\"></a>TOTP 的工作原理</h1><p>标准流程</p>\n<ol>\n<li><p>共享密钥的生成与分发：</p>\n<ul>\n<li>系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。</li>\n<li>用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。</li>\n</ul>\n</li>\n<li><p>时间步计算：</p>\n<ul>\n<li>当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。</li>\n</ul>\n</li>\n<li><p>HMAC 运算：</p>\n<ul>\n<li>使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。</li>\n</ul>\n</li>\n<li><p>动态截取：</p>\n<ul>\n<li>从哈希值中动态截取 4 字节数据，确保结果随机性。</li>\n</ul>\n</li>\n<li><p>生成动态密码：</p>\n<ul>\n<li>将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。</li>\n</ul>\n</li>\n<li><p>验证：</p>\n<ul>\n<li>系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP密钥的保护\"><a href=\"#TOTP密钥的保护\" class=\"headerlink\" title=\"TOTP密钥的保护\"></a>TOTP密钥的保护</h1><p>根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：</p>\n<ol>\n<li><p>减少密钥泄露的风险</p>\n<ul>\n<li>单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。</li>\n<li>防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。</li>\n</ul>\n</li>\n<li><p>补救措施<br>由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：</p>\n<ul>\n<li>备用验证方法：<ul>\n<li>提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。</li>\n<li>提供其他备选验证方式（如短信验证、电子邮件验证）。</li>\n</ul>\n</li>\n<li>重新绑定机制：<ul>\n<li>用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。</li>\n<li>一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP-的实现原理\"><a href=\"#TOTP-的实现原理\" class=\"headerlink\" title=\"TOTP 的实现原理\"></a>TOTP 的实现原理</h1><p>以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。</p>\n<ol>\n<li>Base32 解码<br>TOTP 密钥通常使用 Base32 编码，需先解码为原始字节。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">byte</span>[] <span class=\"title\">Base32Decode</span>(<span class=\"params\"><span class=\"built_in\">string</span> base32</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例解码实现</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> base32Chars = <span class=\"string\">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;</span><br><span class=\"line\">    base32 = base32.TrimEnd(<span class=\"string\">&#x27;=&#x27;</span>).ToUpper();</span><br><span class=\"line\">    List&lt;<span class=\"built_in\">byte</span>&gt; bytes = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">byte</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> buffer = <span class=\"number\">0</span>, bitsLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> base32)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!base32Chars.Contains(c))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">&quot;Invalid Base32 character.&quot;</span>);</span><br><span class=\"line\">        buffer = (buffer &lt;&lt; <span class=\"number\">5</span>) | base32Chars.IndexOf(c);</span><br><span class=\"line\">        bitsLeft += <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitsLeft &gt;= <span class=\"number\">8</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bytes.Add((<span class=\"built_in\">byte</span>)(buffer &gt;&gt; (bitsLeft - <span class=\"number\">8</span>)));</span><br><span class=\"line\">            bitsLeft -= <span class=\"number\">8</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes.ToArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>获取计数器值<br>计数器值通过当前时间计算得出，单位为 30 秒。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">long</span> <span class=\"title\">GetCounter</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DateTimeOffset.UtcNow.ToUnixTimeSeconds() / <span class=\"number\">30</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">byte</span>[] <span class=\"title\">GetCounterBytes</span>(<span class=\"params\"><span class=\"built_in\">long</span> counter</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] bytes = BitConverter.GetBytes(counter);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BitConverter.IsLittleEndian)</span><br><span class=\"line\">        Array.Reverse(bytes); <span class=\"comment\">// 转换为大端序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>HMAC 计算与动态截取<br>使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">GenerateTOTP</span>(<span class=\"params\"><span class=\"built_in\">string</span> secretKey, <span class=\"built_in\">int</span> passwordLength = <span class=\"number\">6</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] keyBytes = Base32Decode(secretKey);</span><br><span class=\"line\">    <span class=\"built_in\">long</span> counter = GetCounter();</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] counterBytes = GetCounterBytes(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> hmac = <span class=\"keyword\">new</span> HMACSHA1(keyBytes);</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] hash = hmac.ComputeHash(counterBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动态截取</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> offset = hash[^<span class=\"number\">1</span>] &amp; <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> binaryCode = ((hash[offset] &amp; <span class=\"number\">0x7F</span>) &lt;&lt; <span class=\"number\">24</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span>) |</span><br><span class=\"line\">                     (hash[offset + <span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> otp = binaryCode % (<span class=\"built_in\">int</span>)Math.Pow(<span class=\"number\">10</span>, passwordLength);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otp.ToString(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">&#x27;0&#x27;</span>, passwordLength)); <span class=\"comment\">// 补齐前导零</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>示例完整调用<br>以下代码生成一个 6 位动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> secretKey = <span class=\"string\">&quot;xxxxxxxxxxx&quot;</span>; <span class=\"comment\">// Base32 编码的密钥</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> totp = GenerateTOTP(secretKey);</span><br><span class=\"line\">Console.WriteLine(<span class=\"string\">$&quot;当前 TOTP 动态密码为: <span class=\"subst\">&#123;totp&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/mfa/run.png\" alt=\"示例完整调用\"></p>\n<h1 id=\"TOTP-的实际应用\"><a href=\"#TOTP-的实际应用\" class=\"headerlink\" title=\"TOTP 的实际应用\"></a>TOTP 的实际应用</h1><p>常见场景</p>\n<ul>\n<li>账户登录保护：结合密码一起验证，提高安全性。</li>\n<li>交易确认：确保关键操作的合法性。</li>\n<li>设备绑定：保护设备认证过程。</li>\n</ul>\n<p>主流实现工具</p>\n<ul>\n<li>手机应用：Google Authenticator、Microsoft Authenticator。</li>\n<li>服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。</li>\n</ul>\n<h1 id=\"TOTP-的优缺点\"><a href=\"#TOTP-的优缺点\" class=\"headerlink\" title=\"TOTP 的优缺点\"></a>TOTP 的优缺点</h1><p>优点</p>\n<ol>\n<li>安全性高：密码定期更新，短时间内有效。</li>\n<li>易用性好：无需额外硬件，使用手机即可。</li>\n<li>实现简单：基于开源算法和规范，易于集成。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>时间同步要求：客户端与服务器需时间一致。</li>\n<li>丢失风险：若用户丢失密钥或设备，可能导致无法验证。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！<br>在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？</p>\n<p>欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。<br>所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。<br><img src=\"/images/mfa/web.png\" alt=\"web\"><br>终于不用掏手机了。。。</p>\n<p>提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。<br><img src=\"/images/mfa/github.png\" alt=\"github\"></p>\n<p>现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。</p>\n<hr>\n<h1 id=\"什么是-MFA-和-TOTP？\"><a href=\"#什么是-MFA-和-TOTP？\" class=\"headerlink\" title=\"什么是 MFA 和 TOTP？\"></a>什么是 MFA 和 TOTP？</h1><h2 id=\"MFA（多因素认证）\"><a href=\"#MFA（多因素认证）\" class=\"headerlink\" title=\"MFA（多因素认证）\"></a>MFA（多因素认证）</h2><p>多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：</p>\n<ol>\n<li>知识因素：用户知道的内容，如密码或 PIN。</li>\n<li>拥有因素：用户拥有的内容，如手机、硬件令牌。</li>\n<li>生物因素：用户本身的特性，如指纹、面部识别。<br>通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。</li>\n</ol>\n<h2 id=\"TOTP（基于时间的一次性密码）\"><a href=\"#TOTP（基于时间的一次性密码）\" class=\"headerlink\" title=\"TOTP（基于时间的一次性密码）\"></a>TOTP（基于时间的一次性密码）</h2><p>TOTP 是一种动态生成的密码，基于：</p>\n<ul>\n<li>共享密钥：系统和用户共享的一个随机密钥。</li>\n<li>时间步长：通常为 30 秒，密码每 30 秒更新一次。<br>TOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。</li>\n</ul>\n<h1 id=\"TOTP-的工作原理\"><a href=\"#TOTP-的工作原理\" class=\"headerlink\" title=\"TOTP 的工作原理\"></a>TOTP 的工作原理</h1><p>标准流程</p>\n<ol>\n<li><p>共享密钥的生成与分发：</p>\n<ul>\n<li>系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。</li>\n<li>用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。</li>\n</ul>\n</li>\n<li><p>时间步计算：</p>\n<ul>\n<li>当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。</li>\n</ul>\n</li>\n<li><p>HMAC 运算：</p>\n<ul>\n<li>使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。</li>\n</ul>\n</li>\n<li><p>动态截取：</p>\n<ul>\n<li>从哈希值中动态截取 4 字节数据，确保结果随机性。</li>\n</ul>\n</li>\n<li><p>生成动态密码：</p>\n<ul>\n<li>将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。</li>\n</ul>\n</li>\n<li><p>验证：</p>\n<ul>\n<li>系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP密钥的保护\"><a href=\"#TOTP密钥的保护\" class=\"headerlink\" title=\"TOTP密钥的保护\"></a>TOTP密钥的保护</h1><p>根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：</p>\n<ol>\n<li><p>减少密钥泄露的风险</p>\n<ul>\n<li>单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。</li>\n<li>防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。</li>\n</ul>\n</li>\n<li><p>补救措施<br>由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：</p>\n<ul>\n<li>备用验证方法：<ul>\n<li>提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。</li>\n<li>提供其他备选验证方式（如短信验证、电子邮件验证）。</li>\n</ul>\n</li>\n<li>重新绑定机制：<ul>\n<li>用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。</li>\n<li>一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP-的实现原理\"><a href=\"#TOTP-的实现原理\" class=\"headerlink\" title=\"TOTP 的实现原理\"></a>TOTP 的实现原理</h1><p>以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。</p>\n<ol>\n<li>Base32 解码<br>TOTP 密钥通常使用 Base32 编码，需先解码为原始字节。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">byte</span>[] <span class=\"title\">Base32Decode</span>(<span class=\"params\"><span class=\"built_in\">string</span> base32</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例解码实现</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> base32Chars = <span class=\"string\">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;</span><br><span class=\"line\">    base32 = base32.TrimEnd(<span class=\"string\">&#x27;=&#x27;</span>).ToUpper();</span><br><span class=\"line\">    List&lt;<span class=\"built_in\">byte</span>&gt; bytes = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">byte</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> buffer = <span class=\"number\">0</span>, bitsLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> base32)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!base32Chars.Contains(c))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">&quot;Invalid Base32 character.&quot;</span>);</span><br><span class=\"line\">        buffer = (buffer &lt;&lt; <span class=\"number\">5</span>) | base32Chars.IndexOf(c);</span><br><span class=\"line\">        bitsLeft += <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitsLeft &gt;= <span class=\"number\">8</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bytes.Add((<span class=\"built_in\">byte</span>)(buffer &gt;&gt; (bitsLeft - <span class=\"number\">8</span>)));</span><br><span class=\"line\">            bitsLeft -= <span class=\"number\">8</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes.ToArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>获取计数器值<br>计数器值通过当前时间计算得出，单位为 30 秒。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">long</span> <span class=\"title\">GetCounter</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DateTimeOffset.UtcNow.ToUnixTimeSeconds() / <span class=\"number\">30</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">byte</span>[] <span class=\"title\">GetCounterBytes</span>(<span class=\"params\"><span class=\"built_in\">long</span> counter</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] bytes = BitConverter.GetBytes(counter);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BitConverter.IsLittleEndian)</span><br><span class=\"line\">        Array.Reverse(bytes); <span class=\"comment\">// 转换为大端序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>HMAC 计算与动态截取<br>使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">GenerateTOTP</span>(<span class=\"params\"><span class=\"built_in\">string</span> secretKey, <span class=\"built_in\">int</span> passwordLength = <span class=\"number\">6</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] keyBytes = Base32Decode(secretKey);</span><br><span class=\"line\">    <span class=\"built_in\">long</span> counter = GetCounter();</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] counterBytes = GetCounterBytes(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> hmac = <span class=\"keyword\">new</span> HMACSHA1(keyBytes);</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] hash = hmac.ComputeHash(counterBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动态截取</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> offset = hash[^<span class=\"number\">1</span>] &amp; <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> binaryCode = ((hash[offset] &amp; <span class=\"number\">0x7F</span>) &lt;&lt; <span class=\"number\">24</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span>) |</span><br><span class=\"line\">                     (hash[offset + <span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> otp = binaryCode % (<span class=\"built_in\">int</span>)Math.Pow(<span class=\"number\">10</span>, passwordLength);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otp.ToString(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">&#x27;0&#x27;</span>, passwordLength)); <span class=\"comment\">// 补齐前导零</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>示例完整调用<br>以下代码生成一个 6 位动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> secretKey = <span class=\"string\">&quot;xxxxxxxxxxx&quot;</span>; <span class=\"comment\">// Base32 编码的密钥</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> totp = GenerateTOTP(secretKey);</span><br><span class=\"line\">Console.WriteLine(<span class=\"string\">$&quot;当前 TOTP 动态密码为: <span class=\"subst\">&#123;totp&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/mfa/run.png\" alt=\"示例完整调用\"></p>\n<h1 id=\"TOTP-的实际应用\"><a href=\"#TOTP-的实际应用\" class=\"headerlink\" title=\"TOTP 的实际应用\"></a>TOTP 的实际应用</h1><p>常见场景</p>\n<ul>\n<li>账户登录保护：结合密码一起验证，提高安全性。</li>\n<li>交易确认：确保关键操作的合法性。</li>\n<li>设备绑定：保护设备认证过程。</li>\n</ul>\n<p>主流实现工具</p>\n<ul>\n<li>手机应用：Google Authenticator、Microsoft Authenticator。</li>\n<li>服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。</li>\n</ul>\n<h1 id=\"TOTP-的优缺点\"><a href=\"#TOTP-的优缺点\" class=\"headerlink\" title=\"TOTP 的优缺点\"></a>TOTP 的优缺点</h1><p>优点</p>\n<ol>\n<li>安全性高：密码定期更新，短时间内有效。</li>\n<li>易用性好：无需额外硬件，使用手机即可。</li>\n<li>实现简单：基于开源算法和规范，易于集成。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>时间同步要求：客户端与服务器需时间一致。</li>\n<li>丢失风险：若用户丢失密钥或设备，可能导致无法验证。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！<br>在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？</p>\n<p>欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊</p>\n"},{"title":"QUIC:被寄予厚望的下一代互联网传输协议","date":"2024-08-16T08:45:11.000Z","_content":"HTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。\n\n为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP/2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP/3的底层协议。\n\n本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能\n\n\n# 为什么选择QUIC？\n\n传统的HTTP/2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：\n\n1. 连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。\n![三次握手](/images/http/TCP-connection-1.png)<center>(图片来源网络)</center>\n\n2. 队头阻塞（Head-of-Line Blocking）：虽然HTTP/2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。\n\n    >HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。\n\n![队头阻塞](/images/quic/head_of_line_blocking.png)<center>(图片来源网络)</center>\n\nQUIC通过以下方式解决了这些问题：\n\n1. 更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。\n2. 内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。\n3. 多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。\n4. 更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。\n\n# QUIC协议的核心特性\n\n1. UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。\n \n    > 你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。\n\n2. 多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。\n\n3. 连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。\n\n4. 内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。\n\n5. 拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。\n\n# 与TCP的对比\n|特性|\tTCP |\tQUIC |\n|--|--|--|\n|传输层|\t基于TCP|\t基于UDP|\n|多路复用|\t受限于TCP的队头阻塞|\t无队头阻塞的多路复用|\n|加密|\t可选（如TLS）|\t内置TLS 1.3|\n|握手时间|\t至少需要一个RTT|\t最低0-RTT|\n|连接迁移|\t不支持 |\t支持|\n|实时性|\t表现较差，适合可靠传输|\t表现优秀，适合低延迟传输|\n\n# QUIC建立连接\n在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。\n![handshake](/images/quic/handshake.png)\n\n## 简单流程图总结：\n\n1. ClientHello -> 客户端发起握手请求，包含支持的加密算法和其他参数。\n2. ServerHello -> 服务器回应，选择加密算法，并发送证书。\n3. Certificate -> 服务器发送证书并验证身份。\n4. Finished -> 双方确认加密密钥和握手完成。\n5. 开始加密通信 -> 使用QUIC加密数据流开始实际数据传输。\n\n## 为什么需要多次消息交换：\n\n+ 身份验证：客户端需要验证服务器身份，防止中间人攻击。\n+ 密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。\n+ 加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。\n\nQUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。\n\n# 测试连接迁移\n上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。\n\n为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：\n```\nserver {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    listen 443 quic reuseport;\n    listen [::]:443 quic reuseport;\n\n    http2 on;\n    server_name itprohub.site www.itprohub.site;\n\n    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;\n    ssl_certificate_key /etc/ssh/itprohub.site.key;\n\n    # 配置 QUIC 相关的 HTTP/3 选项\n    #add_header Alt-Svc 'h3=\":443\"; ma=86400';  # HTTP/3 ALPN\n\n    ssl_protocols TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    ssl_ciphers \"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256\";  # 适用于 TLS 1.3 的推荐套件\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。\n```\nsudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap\n```\n最后我们用wireshark 分析抓包文件\n\nTCP如下：\n![TCP](/images/quic/tcp.png)\n\nQUIC如下：\n![QUIC](/images/quic/quic.png)\n\n对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。\n\nQUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。\n\n具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。\n\n# QUIC协议的应用场景\n\n1. 视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。\n\n2. 实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。\n\n3. 移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。\n\n4. Web浏览：HTTP/3已经逐步取代HTTP/2成为新的Web传输标准。QUIC作为HTTP/3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。\n\n# QUIC的挑战\n\n尽管QUIC有许多优势，但它也面临一些挑战：\n\n1. UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。\n\n2. 兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。\n\n3. 复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。\n\n\n# 总结\n\n随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP/3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。\n\nQUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。\n\n----\n\n这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！","source":"_posts/quic.md","raw":"---\ntitle: QUIC:被寄予厚望的下一代互联网传输协议\ndate: 2024-08-16 16:45:11\ntags:\n---\nHTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。\n\n为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP/2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP/3的底层协议。\n\n本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能\n\n\n# 为什么选择QUIC？\n\n传统的HTTP/2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：\n\n1. 连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。\n![三次握手](/images/http/TCP-connection-1.png)<center>(图片来源网络)</center>\n\n2. 队头阻塞（Head-of-Line Blocking）：虽然HTTP/2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。\n\n    >HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。\n\n![队头阻塞](/images/quic/head_of_line_blocking.png)<center>(图片来源网络)</center>\n\nQUIC通过以下方式解决了这些问题：\n\n1. 更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。\n2. 内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。\n3. 多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。\n4. 更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。\n\n# QUIC协议的核心特性\n\n1. UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。\n \n    > 你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。\n\n2. 多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。\n\n3. 连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。\n\n4. 内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。\n\n5. 拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。\n\n# 与TCP的对比\n|特性|\tTCP |\tQUIC |\n|--|--|--|\n|传输层|\t基于TCP|\t基于UDP|\n|多路复用|\t受限于TCP的队头阻塞|\t无队头阻塞的多路复用|\n|加密|\t可选（如TLS）|\t内置TLS 1.3|\n|握手时间|\t至少需要一个RTT|\t最低0-RTT|\n|连接迁移|\t不支持 |\t支持|\n|实时性|\t表现较差，适合可靠传输|\t表现优秀，适合低延迟传输|\n\n# QUIC建立连接\n在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。\n![handshake](/images/quic/handshake.png)\n\n## 简单流程图总结：\n\n1. ClientHello -> 客户端发起握手请求，包含支持的加密算法和其他参数。\n2. ServerHello -> 服务器回应，选择加密算法，并发送证书。\n3. Certificate -> 服务器发送证书并验证身份。\n4. Finished -> 双方确认加密密钥和握手完成。\n5. 开始加密通信 -> 使用QUIC加密数据流开始实际数据传输。\n\n## 为什么需要多次消息交换：\n\n+ 身份验证：客户端需要验证服务器身份，防止中间人攻击。\n+ 密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。\n+ 加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。\n\nQUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。\n\n# 测试连接迁移\n上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。\n\n为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：\n```\nserver {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    listen 443 quic reuseport;\n    listen [::]:443 quic reuseport;\n\n    http2 on;\n    server_name itprohub.site www.itprohub.site;\n\n    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;\n    ssl_certificate_key /etc/ssh/itprohub.site.key;\n\n    # 配置 QUIC 相关的 HTTP/3 选项\n    #add_header Alt-Svc 'h3=\":443\"; ma=86400';  # HTTP/3 ALPN\n\n    ssl_protocols TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    ssl_ciphers \"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256\";  # 适用于 TLS 1.3 的推荐套件\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。\n```\nsudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap\n```\n最后我们用wireshark 分析抓包文件\n\nTCP如下：\n![TCP](/images/quic/tcp.png)\n\nQUIC如下：\n![QUIC](/images/quic/quic.png)\n\n对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。\n\nQUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。\n\n具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。\n\n# QUIC协议的应用场景\n\n1. 视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。\n\n2. 实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。\n\n3. 移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。\n\n4. Web浏览：HTTP/3已经逐步取代HTTP/2成为新的Web传输标准。QUIC作为HTTP/3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。\n\n# QUIC的挑战\n\n尽管QUIC有许多优势，但它也面临一些挑战：\n\n1. UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。\n\n2. 兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。\n\n3. 复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。\n\n\n# 总结\n\n随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP/3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。\n\nQUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。\n\n----\n\n这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！","slug":"quic","published":1,"updated":"2024-08-23T02:21:47.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmm000om8p132gtd0ly","content":"<p>HTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。</p>\n<p>为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP&#x2F;2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP&#x2F;3的底层协议。</p>\n<p>本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能</p>\n<h1 id=\"为什么选择QUIC？\"><a href=\"#为什么选择QUIC？\" class=\"headerlink\" title=\"为什么选择QUIC？\"></a>为什么选择QUIC？</h1><p>传统的HTTP&#x2F;2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：</p>\n<ol>\n<li><p>连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。<br><img src=\"/images/http/TCP-connection-1.png\" alt=\"三次握手\"><center>(图片来源网络)</center></p>\n</li>\n<li><p>队头阻塞（Head-of-Line Blocking）：虽然HTTP&#x2F;2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。</p>\n<blockquote>\n<p>HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/quic/head_of_line_blocking.png\" alt=\"队头阻塞\"><center>(图片来源网络)</center></p>\n<p>QUIC通过以下方式解决了这些问题：</p>\n<ol>\n<li>更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。</li>\n<li>内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。</li>\n<li>多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。</li>\n<li>更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。</li>\n</ol>\n<h1 id=\"QUIC协议的核心特性\"><a href=\"#QUIC协议的核心特性\" class=\"headerlink\" title=\"QUIC协议的核心特性\"></a>QUIC协议的核心特性</h1><ol>\n<li><p>UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。</p>\n<blockquote>\n<p>你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。</p>\n</blockquote>\n</li>\n<li><p>多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。</p>\n</li>\n<li><p>连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。</p>\n</li>\n<li><p>内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。</p>\n</li>\n<li><p>拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。</p>\n</li>\n</ol>\n<h1 id=\"与TCP的对比\"><a href=\"#与TCP的对比\" class=\"headerlink\" title=\"与TCP的对比\"></a>与TCP的对比</h1><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TCP</th>\n<th>QUIC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输层</td>\n<td>基于TCP</td>\n<td>基于UDP</td>\n</tr>\n<tr>\n<td>多路复用</td>\n<td>受限于TCP的队头阻塞</td>\n<td>无队头阻塞的多路复用</td>\n</tr>\n<tr>\n<td>加密</td>\n<td>可选（如TLS）</td>\n<td>内置TLS 1.3</td>\n</tr>\n<tr>\n<td>握手时间</td>\n<td>至少需要一个RTT</td>\n<td>最低0-RTT</td>\n</tr>\n<tr>\n<td>连接迁移</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>实时性</td>\n<td>表现较差，适合可靠传输</td>\n<td>表现优秀，适合低延迟传输</td>\n</tr>\n</tbody></table>\n<h1 id=\"QUIC建立连接\"><a href=\"#QUIC建立连接\" class=\"headerlink\" title=\"QUIC建立连接\"></a>QUIC建立连接</h1><p>在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。<br><img src=\"/images/quic/handshake.png\" alt=\"handshake\"></p>\n<h2 id=\"简单流程图总结：\"><a href=\"#简单流程图总结：\" class=\"headerlink\" title=\"简单流程图总结：\"></a>简单流程图总结：</h2><ol>\n<li>ClientHello -&gt; 客户端发起握手请求，包含支持的加密算法和其他参数。</li>\n<li>ServerHello -&gt; 服务器回应，选择加密算法，并发送证书。</li>\n<li>Certificate -&gt; 服务器发送证书并验证身份。</li>\n<li>Finished -&gt; 双方确认加密密钥和握手完成。</li>\n<li>开始加密通信 -&gt; 使用QUIC加密数据流开始实际数据传输。</li>\n</ol>\n<h2 id=\"为什么需要多次消息交换：\"><a href=\"#为什么需要多次消息交换：\" class=\"headerlink\" title=\"为什么需要多次消息交换：\"></a>为什么需要多次消息交换：</h2><ul>\n<li>身份验证：客户端需要验证服务器身份，防止中间人攻击。</li>\n<li>密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。</li>\n<li>加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。</li>\n</ul>\n<p>QUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。</p>\n<h1 id=\"测试连接迁移\"><a href=\"#测试连接迁移\" class=\"headerlink\" title=\"测试连接迁移\"></a>测试连接迁移</h1><p>上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。</p>\n<p>为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    listen [::]:443 ssl;</span><br><span class=\"line\">    listen 443 quic reuseport;</span><br><span class=\"line\">    listen [::]:443 quic reuseport;</span><br><span class=\"line\"></span><br><span class=\"line\">    http2 on;</span><br><span class=\"line\">    server_name itprohub.site www.itprohub.site;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;</span><br><span class=\"line\">    ssl_certificate_key /etc/ssh/itprohub.site.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 配置 QUIC 相关的 HTTP/3 选项</span><br><span class=\"line\">    #add_header Alt-Svc &#x27;h3=&quot;:443&quot;; ma=86400&#x27;;  # HTTP/3 ALPN</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1.3;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    ssl_ciphers &quot;TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256&quot;;  # 适用于 TLS 1.3 的推荐套件</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_timeout 10m;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap</span><br></pre></td></tr></table></figure>\n<p>最后我们用wireshark 分析抓包文件</p>\n<p>TCP如下：<br><img src=\"/images/quic/tcp.png\" alt=\"TCP\"></p>\n<p>QUIC如下：<br><img src=\"/images/quic/quic.png\" alt=\"QUIC\"></p>\n<p>对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。</p>\n<p>QUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。</p>\n<p>具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。</p>\n<h1 id=\"QUIC协议的应用场景\"><a href=\"#QUIC协议的应用场景\" class=\"headerlink\" title=\"QUIC协议的应用场景\"></a>QUIC协议的应用场景</h1><ol>\n<li><p>视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。</p>\n</li>\n<li><p>实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。</p>\n</li>\n<li><p>移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。</p>\n</li>\n<li><p>Web浏览：HTTP&#x2F;3已经逐步取代HTTP&#x2F;2成为新的Web传输标准。QUIC作为HTTP&#x2F;3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。</p>\n</li>\n</ol>\n<h1 id=\"QUIC的挑战\"><a href=\"#QUIC的挑战\" class=\"headerlink\" title=\"QUIC的挑战\"></a>QUIC的挑战</h1><p>尽管QUIC有许多优势，但它也面临一些挑战：</p>\n<ol>\n<li><p>UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。</p>\n</li>\n<li><p>兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。</p>\n</li>\n<li><p>复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP&#x2F;3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。</p>\n<p>QUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。</p>\n<hr>\n<p>这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。</p>\n<p>为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP&#x2F;2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP&#x2F;3的底层协议。</p>\n<p>本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能</p>\n<h1 id=\"为什么选择QUIC？\"><a href=\"#为什么选择QUIC？\" class=\"headerlink\" title=\"为什么选择QUIC？\"></a>为什么选择QUIC？</h1><p>传统的HTTP&#x2F;2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：</p>\n<ol>\n<li><p>连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。<br><img src=\"/images/http/TCP-connection-1.png\" alt=\"三次握手\"><center>(图片来源网络)</center></p>\n</li>\n<li><p>队头阻塞（Head-of-Line Blocking）：虽然HTTP&#x2F;2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。</p>\n<blockquote>\n<p>HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/images/quic/head_of_line_blocking.png\" alt=\"队头阻塞\"><center>(图片来源网络)</center></p>\n<p>QUIC通过以下方式解决了这些问题：</p>\n<ol>\n<li>更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。</li>\n<li>内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。</li>\n<li>多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。</li>\n<li>更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。</li>\n</ol>\n<h1 id=\"QUIC协议的核心特性\"><a href=\"#QUIC协议的核心特性\" class=\"headerlink\" title=\"QUIC协议的核心特性\"></a>QUIC协议的核心特性</h1><ol>\n<li><p>UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。</p>\n<blockquote>\n<p>你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。</p>\n</blockquote>\n</li>\n<li><p>多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。</p>\n</li>\n<li><p>连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。</p>\n</li>\n<li><p>内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。</p>\n</li>\n<li><p>拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。</p>\n</li>\n</ol>\n<h1 id=\"与TCP的对比\"><a href=\"#与TCP的对比\" class=\"headerlink\" title=\"与TCP的对比\"></a>与TCP的对比</h1><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TCP</th>\n<th>QUIC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输层</td>\n<td>基于TCP</td>\n<td>基于UDP</td>\n</tr>\n<tr>\n<td>多路复用</td>\n<td>受限于TCP的队头阻塞</td>\n<td>无队头阻塞的多路复用</td>\n</tr>\n<tr>\n<td>加密</td>\n<td>可选（如TLS）</td>\n<td>内置TLS 1.3</td>\n</tr>\n<tr>\n<td>握手时间</td>\n<td>至少需要一个RTT</td>\n<td>最低0-RTT</td>\n</tr>\n<tr>\n<td>连接迁移</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>实时性</td>\n<td>表现较差，适合可靠传输</td>\n<td>表现优秀，适合低延迟传输</td>\n</tr>\n</tbody></table>\n<h1 id=\"QUIC建立连接\"><a href=\"#QUIC建立连接\" class=\"headerlink\" title=\"QUIC建立连接\"></a>QUIC建立连接</h1><p>在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。<br><img src=\"/images/quic/handshake.png\" alt=\"handshake\"></p>\n<h2 id=\"简单流程图总结：\"><a href=\"#简单流程图总结：\" class=\"headerlink\" title=\"简单流程图总结：\"></a>简单流程图总结：</h2><ol>\n<li>ClientHello -&gt; 客户端发起握手请求，包含支持的加密算法和其他参数。</li>\n<li>ServerHello -&gt; 服务器回应，选择加密算法，并发送证书。</li>\n<li>Certificate -&gt; 服务器发送证书并验证身份。</li>\n<li>Finished -&gt; 双方确认加密密钥和握手完成。</li>\n<li>开始加密通信 -&gt; 使用QUIC加密数据流开始实际数据传输。</li>\n</ol>\n<h2 id=\"为什么需要多次消息交换：\"><a href=\"#为什么需要多次消息交换：\" class=\"headerlink\" title=\"为什么需要多次消息交换：\"></a>为什么需要多次消息交换：</h2><ul>\n<li>身份验证：客户端需要验证服务器身份，防止中间人攻击。</li>\n<li>密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。</li>\n<li>加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。</li>\n</ul>\n<p>QUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。</p>\n<h1 id=\"测试连接迁移\"><a href=\"#测试连接迁移\" class=\"headerlink\" title=\"测试连接迁移\"></a>测试连接迁移</h1><p>上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。</p>\n<p>为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    listen [::]:443 ssl;</span><br><span class=\"line\">    listen 443 quic reuseport;</span><br><span class=\"line\">    listen [::]:443 quic reuseport;</span><br><span class=\"line\"></span><br><span class=\"line\">    http2 on;</span><br><span class=\"line\">    server_name itprohub.site www.itprohub.site;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;</span><br><span class=\"line\">    ssl_certificate_key /etc/ssh/itprohub.site.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 配置 QUIC 相关的 HTTP/3 选项</span><br><span class=\"line\">    #add_header Alt-Svc &#x27;h3=&quot;:443&quot;; ma=86400&#x27;;  # HTTP/3 ALPN</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1.3;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    ssl_ciphers &quot;TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256&quot;;  # 适用于 TLS 1.3 的推荐套件</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_timeout 10m;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap</span><br></pre></td></tr></table></figure>\n<p>最后我们用wireshark 分析抓包文件</p>\n<p>TCP如下：<br><img src=\"/images/quic/tcp.png\" alt=\"TCP\"></p>\n<p>QUIC如下：<br><img src=\"/images/quic/quic.png\" alt=\"QUIC\"></p>\n<p>对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。</p>\n<p>QUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。</p>\n<p>具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。</p>\n<h1 id=\"QUIC协议的应用场景\"><a href=\"#QUIC协议的应用场景\" class=\"headerlink\" title=\"QUIC协议的应用场景\"></a>QUIC协议的应用场景</h1><ol>\n<li><p>视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。</p>\n</li>\n<li><p>实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。</p>\n</li>\n<li><p>移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。</p>\n</li>\n<li><p>Web浏览：HTTP&#x2F;3已经逐步取代HTTP&#x2F;2成为新的Web传输标准。QUIC作为HTTP&#x2F;3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。</p>\n</li>\n</ol>\n<h1 id=\"QUIC的挑战\"><a href=\"#QUIC的挑战\" class=\"headerlink\" title=\"QUIC的挑战\"></a>QUIC的挑战</h1><p>尽管QUIC有许多优势，但它也面临一些挑战：</p>\n<ol>\n<li><p>UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。</p>\n</li>\n<li><p>兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。</p>\n</li>\n<li><p>复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP&#x2F;3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。</p>\n<p>QUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。</p>\n<hr>\n<p>这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！</p>\n"},{"title":"深入理解 RabbitMQ 中的基础概念","date":"2024-07-09T08:28:36.000Z","_content":"\nRabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。\n\n# 标准 RabbitMQ 消息流\n1. 生产者向交易所发布一条消息。\n2. 交换机收到消息并且负责消息的路由。\n3. 必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。\n4. 消息一直留在队列中，直到被消费者处理。\n5. 消费者处理该消息。\n![mq-flow](/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg)\n\n# 1. 核心概念\n## 1.1 broker\n简单来说 Broker 就是消息队列服务器实体。\n\n我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：\n\n+ 磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失\n+ 内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。\n## 1.2 Channel\nChannel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。\n\nChannel 信道是生产者/消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。\n\n在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务\n\n### 为什么使用 Channel 而不是直接使用 TCP 连接？\n1. 性能：\n   - 创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。\n   - TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。\n   - Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。\n\n2. 独立性：\n   - 每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。\n   - 这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。\n\n3. 资源复用：\n   - 通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。\n   - 使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。\n\n下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。\n![一个channel对应一个connection](/images/rabbitmq-basic/channel1.png)\n```CSharp\nvar factory = new ConnectionFactory() {\n    HostName = \"127.0.0.1\"\n};\nstring clientProvidedName = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})-Subscriber\";\n\n// 创建一个 TCP 连接\nvar connection = factory.CreateConnection(clientProvidedName);\nstring consumerTag = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})\";\n\n// 在同一个连接上创建第一个 Channel\nvar channel1 = connection.CreateModel();\nvar queueName1 = \"TestMQ.Rabbit.WeChat\";\n\nvar consumer1 = new EventingBasicConsumer(channel1);\nconsumer1.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel1.BasicConsume(queue: queueName1, autoAck: true, consumerTag, consumer: consumer1);\n\n// 在同一个连接上创建第二个 Channel\nvar channel2 = connection.CreateModel();\nvar queueName2 = \"TestMQ.Rabbit.Email\";\n\nvar consumer2 = new EventingBasicConsumer(channel2);\nconsumer2.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel2.BasicConsume(queue: queueName2, autoAck: true, consumerTag, consumer: consumer2);\n```\n![一个channel对应一个connection](/images/rabbitmq-basic/channel2.png)\n\n## 1.3 Exchange\nExchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：\n\n+ Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。\n+ Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。\n+ Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。\n+ Headers Exchange：根据消息头属性来路由消息，而不是路由键。\n## 1.4 Queue\nQueue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。\n\n## 1.5 Vhost（Virtual Host）\nvhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。\n\n\n### 作用和好处\n1. 资源隔离：\n   - 独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。\n   - 安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。\n2.多租户支持：\n   - 隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。\n3. 环境隔离：\n   - 开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。\n4. 简化管理：\n   - 组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。\n\n\n上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange\n![默认交换机](/images/rabbitmq-basic/default-exchange.png)\n\n## 1.6 Routing Key\nRouting Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。\n\n### Exchange 类型与 RoutingKey、BindingKey 的关系\n不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：\n\n1. Direct Exchange：\n   - 交换机将消息路由到 RoutingKey 精确匹配的队列。\n   - 例如，RoutingKey 为 \"orange\" 的消息只会路由到绑定了 BindingKey 为 \"orange\" 的队列。\n    ![direct exchange](/images/rabbitmq-basic/direct-exchange.svg)\n2. Topic Exchange：\n   - 交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。\n   - RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。\n   - 例如，RoutingKey 为 \"user.update.info\" 的消息可以匹配 BindingKey 为 \"user.*.info\" 或 \"user.#\"。\n![direct exchange](/images/rabbitmq-basic/topic-exchange.svg)\n3. Fanout Exchange：\n   - 交换机将消息广播到所有绑定的队列，忽略 RoutingKey。\n   - 在这种情况下，BindingKey 不被使用。\n![direct exchange](/images/rabbitmq-basic/fanout-exchange.svg)\n下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。\n   ![fanout](/images/rabbitmq-basic/vro2s-b2mub.gif)\n4. Headers Exchange：\n   - 交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。\n   - BindingKey 在这种交换机类型中不被使用。\n![direct exchange](/images/rabbitmq-basic/rabbitmq-headers-exchange.svg)\n\n由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。\n\n\n# 3. 使用场景\n虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧\n\n## 3.1 负载均衡\n在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。\n\n## 3.2 异步处理\n将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。\n\n## 3.3 日志系统\n使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。\n\n# 4. 结论\nRabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。\n\n\n参考文档\n[RabbitMq经典队列](https://www.rabbitmq.com/docs/classic-queues)\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/rabbitmq-basic.md","raw":"---\ntitle: 深入理解 RabbitMQ 中的基础概念\ndate: 2024-07-09 16:28:36\ntags:\n---\n\nRabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。\n\n# 标准 RabbitMQ 消息流\n1. 生产者向交易所发布一条消息。\n2. 交换机收到消息并且负责消息的路由。\n3. 必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。\n4. 消息一直留在队列中，直到被消费者处理。\n5. 消费者处理该消息。\n![mq-flow](/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg)\n\n# 1. 核心概念\n## 1.1 broker\n简单来说 Broker 就是消息队列服务器实体。\n\n我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：\n\n+ 磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失\n+ 内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。\n## 1.2 Channel\nChannel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。\n\nChannel 信道是生产者/消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。\n\n在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务\n\n### 为什么使用 Channel 而不是直接使用 TCP 连接？\n1. 性能：\n   - 创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。\n   - TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。\n   - Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。\n\n2. 独立性：\n   - 每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。\n   - 这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。\n\n3. 资源复用：\n   - 通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。\n   - 使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。\n\n下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。\n![一个channel对应一个connection](/images/rabbitmq-basic/channel1.png)\n```CSharp\nvar factory = new ConnectionFactory() {\n    HostName = \"127.0.0.1\"\n};\nstring clientProvidedName = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})-Subscriber\";\n\n// 创建一个 TCP 连接\nvar connection = factory.CreateConnection(clientProvidedName);\nstring consumerTag = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})\";\n\n// 在同一个连接上创建第一个 Channel\nvar channel1 = connection.CreateModel();\nvar queueName1 = \"TestMQ.Rabbit.WeChat\";\n\nvar consumer1 = new EventingBasicConsumer(channel1);\nconsumer1.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel1.BasicConsume(queue: queueName1, autoAck: true, consumerTag, consumer: consumer1);\n\n// 在同一个连接上创建第二个 Channel\nvar channel2 = connection.CreateModel();\nvar queueName2 = \"TestMQ.Rabbit.Email\";\n\nvar consumer2 = new EventingBasicConsumer(channel2);\nconsumer2.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel2.BasicConsume(queue: queueName2, autoAck: true, consumerTag, consumer: consumer2);\n```\n![一个channel对应一个connection](/images/rabbitmq-basic/channel2.png)\n\n## 1.3 Exchange\nExchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：\n\n+ Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。\n+ Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。\n+ Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。\n+ Headers Exchange：根据消息头属性来路由消息，而不是路由键。\n## 1.4 Queue\nQueue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。\n\n## 1.5 Vhost（Virtual Host）\nvhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。\n\n\n### 作用和好处\n1. 资源隔离：\n   - 独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。\n   - 安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。\n2.多租户支持：\n   - 隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。\n3. 环境隔离：\n   - 开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。\n4. 简化管理：\n   - 组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。\n\n\n上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange\n![默认交换机](/images/rabbitmq-basic/default-exchange.png)\n\n## 1.6 Routing Key\nRouting Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。\n\n### Exchange 类型与 RoutingKey、BindingKey 的关系\n不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：\n\n1. Direct Exchange：\n   - 交换机将消息路由到 RoutingKey 精确匹配的队列。\n   - 例如，RoutingKey 为 \"orange\" 的消息只会路由到绑定了 BindingKey 为 \"orange\" 的队列。\n    ![direct exchange](/images/rabbitmq-basic/direct-exchange.svg)\n2. Topic Exchange：\n   - 交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。\n   - RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。\n   - 例如，RoutingKey 为 \"user.update.info\" 的消息可以匹配 BindingKey 为 \"user.*.info\" 或 \"user.#\"。\n![direct exchange](/images/rabbitmq-basic/topic-exchange.svg)\n3. Fanout Exchange：\n   - 交换机将消息广播到所有绑定的队列，忽略 RoutingKey。\n   - 在这种情况下，BindingKey 不被使用。\n![direct exchange](/images/rabbitmq-basic/fanout-exchange.svg)\n下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。\n   ![fanout](/images/rabbitmq-basic/vro2s-b2mub.gif)\n4. Headers Exchange：\n   - 交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。\n   - BindingKey 在这种交换机类型中不被使用。\n![direct exchange](/images/rabbitmq-basic/rabbitmq-headers-exchange.svg)\n\n由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。\n\n\n# 3. 使用场景\n虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧\n\n## 3.1 负载均衡\n在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。\n\n## 3.2 异步处理\n将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。\n\n## 3.3 日志系统\n使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。\n\n# 4. 结论\nRabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。\n\n\n参考文档\n[RabbitMq经典队列](https://www.rabbitmq.com/docs/classic-queues)\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","slug":"rabbitmq-basic","published":1,"updated":"2024-07-10T12:42:57.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmm000qm8p14byv63bm","content":"<p>RabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。</p>\n<h1 id=\"标准-RabbitMQ-消息流\"><a href=\"#标准-RabbitMQ-消息流\" class=\"headerlink\" title=\"标准 RabbitMQ 消息流\"></a>标准 RabbitMQ 消息流</h1><ol>\n<li>生产者向交易所发布一条消息。</li>\n<li>交换机收到消息并且负责消息的路由。</li>\n<li>必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。</li>\n<li>消息一直留在队列中，直到被消费者处理。</li>\n<li>消费者处理该消息。<br><img src=\"/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg\" alt=\"mq-flow\"></li>\n</ol>\n<h1 id=\"1-核心概念\"><a href=\"#1-核心概念\" class=\"headerlink\" title=\"1. 核心概念\"></a>1. 核心概念</h1><h2 id=\"1-1-broker\"><a href=\"#1-1-broker\" class=\"headerlink\" title=\"1.1 broker\"></a>1.1 broker</h2><p>简单来说 Broker 就是消息队列服务器实体。</p>\n<p>我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：</p>\n<ul>\n<li>磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失</li>\n<li>内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。</li>\n</ul>\n<h2 id=\"1-2-Channel\"><a href=\"#1-2-Channel\" class=\"headerlink\" title=\"1.2 Channel\"></a>1.2 Channel</h2><p>Channel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。</p>\n<p>Channel 信道是生产者&#x2F;消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。</p>\n<p>在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务</p>\n<h3 id=\"为什么使用-Channel-而不是直接使用-TCP-连接？\"><a href=\"#为什么使用-Channel-而不是直接使用-TCP-连接？\" class=\"headerlink\" title=\"为什么使用 Channel 而不是直接使用 TCP 连接？\"></a>为什么使用 Channel 而不是直接使用 TCP 连接？</h3><ol>\n<li><p>性能：</p>\n<ul>\n<li>创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。</li>\n<li>TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。</li>\n<li>Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。</li>\n</ul>\n</li>\n<li><p>独立性：</p>\n<ul>\n<li>每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。</li>\n<li>这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。</li>\n</ul>\n</li>\n<li><p>资源复用：</p>\n<ul>\n<li>通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。</li>\n<li>使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。</li>\n</ul>\n</li>\n</ol>\n<p>下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。<br><img src=\"/images/rabbitmq-basic/channel1.png\" alt=\"一个channel对应一个connection\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123;</span><br><span class=\"line\">    HostName = <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> clientProvidedName = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)-Subscriber&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = factory.CreateConnection(clientProvidedName);</span><br><span class=\"line\"><span class=\"built_in\">string</span> consumerTag = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第一个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel1 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName1 = <span class=\"string\">&quot;TestMQ.Rabbit.WeChat&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer1 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel1);</span><br><span class=\"line\">consumer1.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel1.BasicConsume(queue: queueName1, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第二个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel2 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName2 = <span class=\"string\">&quot;TestMQ.Rabbit.Email&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer2 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel2);</span><br><span class=\"line\">consumer2.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel2.BasicConsume(queue: queueName2, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rabbitmq-basic/channel2.png\" alt=\"一个channel对应一个connection\"></p>\n<h2 id=\"1-3-Exchange\"><a href=\"#1-3-Exchange\" class=\"headerlink\" title=\"1.3 Exchange\"></a>1.3 Exchange</h2><p>Exchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：</p>\n<ul>\n<li>Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。</li>\n<li>Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。</li>\n<li>Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。</li>\n<li>Headers Exchange：根据消息头属性来路由消息，而不是路由键。</li>\n</ul>\n<h2 id=\"1-4-Queue\"><a href=\"#1-4-Queue\" class=\"headerlink\" title=\"1.4 Queue\"></a>1.4 Queue</h2><p>Queue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。</p>\n<h2 id=\"1-5-Vhost（Virtual-Host）\"><a href=\"#1-5-Vhost（Virtual-Host）\" class=\"headerlink\" title=\"1.5 Vhost（Virtual Host）\"></a>1.5 Vhost（Virtual Host）</h2><p>vhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。</p>\n<h3 id=\"作用和好处\"><a href=\"#作用和好处\" class=\"headerlink\" title=\"作用和好处\"></a>作用和好处</h3><ol>\n<li>资源隔离：<ul>\n<li>独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。</li>\n<li>安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。<br>2.多租户支持：</li>\n<li>隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。</li>\n</ul>\n</li>\n<li>环境隔离：<ul>\n<li>开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。</li>\n</ul>\n</li>\n<li>简化管理：<ul>\n<li>组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。</li>\n</ul>\n</li>\n</ol>\n<p>上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange<br><img src=\"/images/rabbitmq-basic/default-exchange.png\" alt=\"默认交换机\"></p>\n<h2 id=\"1-6-Routing-Key\"><a href=\"#1-6-Routing-Key\" class=\"headerlink\" title=\"1.6 Routing Key\"></a>1.6 Routing Key</h2><p>Routing Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。</p>\n<h3 id=\"Exchange-类型与-RoutingKey、BindingKey-的关系\"><a href=\"#Exchange-类型与-RoutingKey、BindingKey-的关系\" class=\"headerlink\" title=\"Exchange 类型与 RoutingKey、BindingKey 的关系\"></a>Exchange 类型与 RoutingKey、BindingKey 的关系</h3><p>不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：</p>\n<ol>\n<li>Direct Exchange：<ul>\n<li>交换机将消息路由到 RoutingKey 精确匹配的队列。</li>\n<li>例如，RoutingKey 为 “orange” 的消息只会路由到绑定了 BindingKey 为 “orange” 的队列。<br> <img src=\"/images/rabbitmq-basic/direct-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Topic Exchange：<ul>\n<li>交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。</li>\n<li>RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。</li>\n<li>例如，RoutingKey 为 “user.update.info” 的消息可以匹配 BindingKey 为 “user.*.info” 或 “user.#”。<br><img src=\"/images/rabbitmq-basic/topic-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Fanout Exchange：<ul>\n<li>交换机将消息广播到所有绑定的队列，忽略 RoutingKey。</li>\n<li>在这种情况下，BindingKey 不被使用。<br><img src=\"/images/rabbitmq-basic/fanout-exchange.svg\" alt=\"direct exchange\"><br>下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。<br><img src=\"/images/rabbitmq-basic/vro2s-b2mub.gif\" alt=\"fanout\"></li>\n</ul>\n</li>\n<li>Headers Exchange：<ul>\n<li>交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。</li>\n<li>BindingKey 在这种交换机类型中不被使用。<br><img src=\"/images/rabbitmq-basic/rabbitmq-headers-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n</ol>\n<p>由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。</p>\n<h1 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h1><p>虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧</p>\n<h2 id=\"3-1-负载均衡\"><a href=\"#3-1-负载均衡\" class=\"headerlink\" title=\"3.1 负载均衡\"></a>3.1 负载均衡</h2><p>在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。</p>\n<h2 id=\"3-2-异步处理\"><a href=\"#3-2-异步处理\" class=\"headerlink\" title=\"3.2 异步处理\"></a>3.2 异步处理</h2><p>将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。</p>\n<h2 id=\"3-3-日志系统\"><a href=\"#3-3-日志系统\" class=\"headerlink\" title=\"3.3 日志系统\"></a>3.3 日志系统</h2><p>使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4. 结论\"></a>4. 结论</h1><p>RabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/classic-queues\">RabbitMq经典队列</a></p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>RabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。</p>\n<h1 id=\"标准-RabbitMQ-消息流\"><a href=\"#标准-RabbitMQ-消息流\" class=\"headerlink\" title=\"标准 RabbitMQ 消息流\"></a>标准 RabbitMQ 消息流</h1><ol>\n<li>生产者向交易所发布一条消息。</li>\n<li>交换机收到消息并且负责消息的路由。</li>\n<li>必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。</li>\n<li>消息一直留在队列中，直到被消费者处理。</li>\n<li>消费者处理该消息。<br><img src=\"/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg\" alt=\"mq-flow\"></li>\n</ol>\n<h1 id=\"1-核心概念\"><a href=\"#1-核心概念\" class=\"headerlink\" title=\"1. 核心概念\"></a>1. 核心概念</h1><h2 id=\"1-1-broker\"><a href=\"#1-1-broker\" class=\"headerlink\" title=\"1.1 broker\"></a>1.1 broker</h2><p>简单来说 Broker 就是消息队列服务器实体。</p>\n<p>我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：</p>\n<ul>\n<li>磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失</li>\n<li>内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。</li>\n</ul>\n<h2 id=\"1-2-Channel\"><a href=\"#1-2-Channel\" class=\"headerlink\" title=\"1.2 Channel\"></a>1.2 Channel</h2><p>Channel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。</p>\n<p>Channel 信道是生产者&#x2F;消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。</p>\n<p>在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务</p>\n<h3 id=\"为什么使用-Channel-而不是直接使用-TCP-连接？\"><a href=\"#为什么使用-Channel-而不是直接使用-TCP-连接？\" class=\"headerlink\" title=\"为什么使用 Channel 而不是直接使用 TCP 连接？\"></a>为什么使用 Channel 而不是直接使用 TCP 连接？</h3><ol>\n<li><p>性能：</p>\n<ul>\n<li>创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。</li>\n<li>TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。</li>\n<li>Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。</li>\n</ul>\n</li>\n<li><p>独立性：</p>\n<ul>\n<li>每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。</li>\n<li>这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。</li>\n</ul>\n</li>\n<li><p>资源复用：</p>\n<ul>\n<li>通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。</li>\n<li>使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。</li>\n</ul>\n</li>\n</ol>\n<p>下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。<br><img src=\"/images/rabbitmq-basic/channel1.png\" alt=\"一个channel对应一个connection\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123;</span><br><span class=\"line\">    HostName = <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> clientProvidedName = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)-Subscriber&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = factory.CreateConnection(clientProvidedName);</span><br><span class=\"line\"><span class=\"built_in\">string</span> consumerTag = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第一个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel1 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName1 = <span class=\"string\">&quot;TestMQ.Rabbit.WeChat&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer1 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel1);</span><br><span class=\"line\">consumer1.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel1.BasicConsume(queue: queueName1, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第二个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel2 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName2 = <span class=\"string\">&quot;TestMQ.Rabbit.Email&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer2 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel2);</span><br><span class=\"line\">consumer2.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel2.BasicConsume(queue: queueName2, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rabbitmq-basic/channel2.png\" alt=\"一个channel对应一个connection\"></p>\n<h2 id=\"1-3-Exchange\"><a href=\"#1-3-Exchange\" class=\"headerlink\" title=\"1.3 Exchange\"></a>1.3 Exchange</h2><p>Exchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：</p>\n<ul>\n<li>Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。</li>\n<li>Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。</li>\n<li>Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。</li>\n<li>Headers Exchange：根据消息头属性来路由消息，而不是路由键。</li>\n</ul>\n<h2 id=\"1-4-Queue\"><a href=\"#1-4-Queue\" class=\"headerlink\" title=\"1.4 Queue\"></a>1.4 Queue</h2><p>Queue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。</p>\n<h2 id=\"1-5-Vhost（Virtual-Host）\"><a href=\"#1-5-Vhost（Virtual-Host）\" class=\"headerlink\" title=\"1.5 Vhost（Virtual Host）\"></a>1.5 Vhost（Virtual Host）</h2><p>vhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。</p>\n<h3 id=\"作用和好处\"><a href=\"#作用和好处\" class=\"headerlink\" title=\"作用和好处\"></a>作用和好处</h3><ol>\n<li>资源隔离：<ul>\n<li>独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。</li>\n<li>安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。<br>2.多租户支持：</li>\n<li>隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。</li>\n</ul>\n</li>\n<li>环境隔离：<ul>\n<li>开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。</li>\n</ul>\n</li>\n<li>简化管理：<ul>\n<li>组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。</li>\n</ul>\n</li>\n</ol>\n<p>上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange<br><img src=\"/images/rabbitmq-basic/default-exchange.png\" alt=\"默认交换机\"></p>\n<h2 id=\"1-6-Routing-Key\"><a href=\"#1-6-Routing-Key\" class=\"headerlink\" title=\"1.6 Routing Key\"></a>1.6 Routing Key</h2><p>Routing Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。</p>\n<h3 id=\"Exchange-类型与-RoutingKey、BindingKey-的关系\"><a href=\"#Exchange-类型与-RoutingKey、BindingKey-的关系\" class=\"headerlink\" title=\"Exchange 类型与 RoutingKey、BindingKey 的关系\"></a>Exchange 类型与 RoutingKey、BindingKey 的关系</h3><p>不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：</p>\n<ol>\n<li>Direct Exchange：<ul>\n<li>交换机将消息路由到 RoutingKey 精确匹配的队列。</li>\n<li>例如，RoutingKey 为 “orange” 的消息只会路由到绑定了 BindingKey 为 “orange” 的队列。<br> <img src=\"/images/rabbitmq-basic/direct-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Topic Exchange：<ul>\n<li>交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。</li>\n<li>RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。</li>\n<li>例如，RoutingKey 为 “user.update.info” 的消息可以匹配 BindingKey 为 “user.*.info” 或 “user.#”。<br><img src=\"/images/rabbitmq-basic/topic-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Fanout Exchange：<ul>\n<li>交换机将消息广播到所有绑定的队列，忽略 RoutingKey。</li>\n<li>在这种情况下，BindingKey 不被使用。<br><img src=\"/images/rabbitmq-basic/fanout-exchange.svg\" alt=\"direct exchange\"><br>下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。<br><img src=\"/images/rabbitmq-basic/vro2s-b2mub.gif\" alt=\"fanout\"></li>\n</ul>\n</li>\n<li>Headers Exchange：<ul>\n<li>交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。</li>\n<li>BindingKey 在这种交换机类型中不被使用。<br><img src=\"/images/rabbitmq-basic/rabbitmq-headers-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n</ol>\n<p>由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。</p>\n<h1 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h1><p>虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧</p>\n<h2 id=\"3-1-负载均衡\"><a href=\"#3-1-负载均衡\" class=\"headerlink\" title=\"3.1 负载均衡\"></a>3.1 负载均衡</h2><p>在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。</p>\n<h2 id=\"3-2-异步处理\"><a href=\"#3-2-异步处理\" class=\"headerlink\" title=\"3.2 异步处理\"></a>3.2 异步处理</h2><p>将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。</p>\n<h2 id=\"3-3-日志系统\"><a href=\"#3-3-日志系统\" class=\"headerlink\" title=\"3.3 日志系统\"></a>3.3 日志系统</h2><p>使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4. 结论\"></a>4. 结论</h1><p>RabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/classic-queues\">RabbitMq经典队列</a></p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"RabbitMQ之三种队列之间的区别及如何选型","date":"2024-07-11T02:36:12.000Z","_content":"\nRabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。\n\n# 经典队列（Classic Queues）\n## 简介：\n经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。\n\n## 特点：\n\n+ 存储机制：消息存储在磁盘或内存中，支持持久化。\n+ 消息传递：一旦消息被消费者确认，消息会从队列中删除。\n+ 性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。\n+ 高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。\n## 适用场景：\n\n适合大多数常规消息传递场景，如任务调度、事件通知等。\n当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。\n\n# 仲裁队列（Quorum Queues）\n## 简介：\n仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。\n\n## 特点：\n\n- 存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。\n- 高可用性：天然支持高可用性，通过多节点复制实现数据冗余。\n- 数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。\n- 性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。\n\n## 适用场景：\n\n- 适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。\n- 在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。\n\n## 注意事项\n1. 仲裁队列只能声明为持久的\n仲裁队列只能被声明为持久的，否则会引发以下错误消息：\n：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效\n\nQuorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。\n\n2. 仲裁队列的消息默认就是持久化的\n对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。\n\n下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。\n![重启前](/images/rabbitmq-quarum/quarum1.png)\n然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。\n![重启后](/images/rabbitmq-quarum/quarum2.png)\n\n## 仲裁队列 VS 经典队列\n\n### 数据一致性\n仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。\n\n### 数据可靠性\n仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。\n\n# 流式队列（Stream Queues）\n流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。\n\n## 特点：\n+ 存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。\n+ 高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。\n+ 数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。\n+ 订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。\n\n## 什么是消息回放和重复消费？\n消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。\n\n重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。\n\n```CSharp\npublic void InitStreamMQ()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n    // 声明流式队列\n    var args = new Dictionary<string, object> { { \"x-queue-type\", \"stream\" } };\n    channel.QueueDeclare(queue: \"stream_queue\", durable: true, exclusive: false, autoDelete: false, arguments: args);\n    channel.QueueBind(queue: \"stream_queue\", exchange: \"amq.direct\", routingKey: \"stream_queue\");\n}\n\n\n[ActionTitle(Name = \"订阅队列\")]\n[Route(\"subscribe\")]\npublic void SubscribeQuorumMessage()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", VirtualHost = \"/\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n\n    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);\n    // 设置消费者，从指定的偏移量消费消息\n    var consumer = new EventingBasicConsumer(channel);\n    consumer.Received += (model, ea) => {\n        var body = ea.Body.ToArray();\n        var message = Encoding.UTF8.GetString(body);\n        Console.WriteLine(\" [x] Received {0}\", message);\n    };\n\n    /**\n     * x-stream-offset的可选值有以下几种：\n        first: 从日志队列中第一个可消费的消息开始消费\n        last: 消费消息日志中最后一个消息\n        next: 相当于不指定offset，消费不到消息。\n        Offset: 一个数字型的偏移量\n        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)\n     */\n    var args = new Dictionary<string, object> { { \"x-stream-offset\", 2 } };\n    channel.BasicConsume(queue: \"stream_queue\", autoAck: false, arguments: args, consumer: consumer);\n}\n\n```\n这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.\n![offset](/images/rabbitmq-quarum/stream_offset.png)\n\n## 流式队列的工作原理\n流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。\n\n## 适用场景：\n\n+ 适用于实时数据分析、日志处理、实时监控等场景。\n+ 在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。\n\n## PS\n1. Auto-Ack 必须为 false\n在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。\n![aoto ack](/images/rabbitmq-quarum/stream_error2.png)\n\n2. 必须设置prefetchCount\n流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用\n![prefetchCount](/images/rabbitmq-quarum/stream_error1.png)\n\n3. durable必须设置为true\n与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。\n\n\n# 选型建议\n在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：\n\n1. 经典队列：\n   - 适合大多数常规的消息传递需求。\n   - 需要较高的性能和可靠性，但不需要特别高的数据一致性要求。\n2. 仲裁队列：\n   - 适用于对数据一致性和高可用性要求较高的场景。\n   - 需要确保消息不丢失且能够在多节点间保持数据一致性。\n3. 流式队列：\n   - 适合处理大规模实时数据流和高吞吐量的场景。\n   - 需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。\n\n# 总结\n通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。\n\n参考文档\n[Quorum Queues](https://www.rabbitmq.com/docs/quorum-queues)","source":"_posts/rabbitmq-quorum.md","raw":"---\ntitle: RabbitMQ之三种队列之间的区别及如何选型\ndate: 2024-07-11 10:36:12\ntags:\n---\n\nRabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。\n\n# 经典队列（Classic Queues）\n## 简介：\n经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。\n\n## 特点：\n\n+ 存储机制：消息存储在磁盘或内存中，支持持久化。\n+ 消息传递：一旦消息被消费者确认，消息会从队列中删除。\n+ 性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。\n+ 高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。\n## 适用场景：\n\n适合大多数常规消息传递场景，如任务调度、事件通知等。\n当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。\n\n# 仲裁队列（Quorum Queues）\n## 简介：\n仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。\n\n## 特点：\n\n- 存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。\n- 高可用性：天然支持高可用性，通过多节点复制实现数据冗余。\n- 数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。\n- 性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。\n\n## 适用场景：\n\n- 适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。\n- 在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。\n\n## 注意事项\n1. 仲裁队列只能声明为持久的\n仲裁队列只能被声明为持久的，否则会引发以下错误消息：\n：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效\n\nQuorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。\n\n2. 仲裁队列的消息默认就是持久化的\n对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。\n\n下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。\n![重启前](/images/rabbitmq-quarum/quarum1.png)\n然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。\n![重启后](/images/rabbitmq-quarum/quarum2.png)\n\n## 仲裁队列 VS 经典队列\n\n### 数据一致性\n仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。\n\n### 数据可靠性\n仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。\n\n# 流式队列（Stream Queues）\n流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。\n\n## 特点：\n+ 存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。\n+ 高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。\n+ 数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。\n+ 订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。\n\n## 什么是消息回放和重复消费？\n消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。\n\n重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。\n\n```CSharp\npublic void InitStreamMQ()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n    // 声明流式队列\n    var args = new Dictionary<string, object> { { \"x-queue-type\", \"stream\" } };\n    channel.QueueDeclare(queue: \"stream_queue\", durable: true, exclusive: false, autoDelete: false, arguments: args);\n    channel.QueueBind(queue: \"stream_queue\", exchange: \"amq.direct\", routingKey: \"stream_queue\");\n}\n\n\n[ActionTitle(Name = \"订阅队列\")]\n[Route(\"subscribe\")]\npublic void SubscribeQuorumMessage()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", VirtualHost = \"/\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n\n    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);\n    // 设置消费者，从指定的偏移量消费消息\n    var consumer = new EventingBasicConsumer(channel);\n    consumer.Received += (model, ea) => {\n        var body = ea.Body.ToArray();\n        var message = Encoding.UTF8.GetString(body);\n        Console.WriteLine(\" [x] Received {0}\", message);\n    };\n\n    /**\n     * x-stream-offset的可选值有以下几种：\n        first: 从日志队列中第一个可消费的消息开始消费\n        last: 消费消息日志中最后一个消息\n        next: 相当于不指定offset，消费不到消息。\n        Offset: 一个数字型的偏移量\n        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)\n     */\n    var args = new Dictionary<string, object> { { \"x-stream-offset\", 2 } };\n    channel.BasicConsume(queue: \"stream_queue\", autoAck: false, arguments: args, consumer: consumer);\n}\n\n```\n这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.\n![offset](/images/rabbitmq-quarum/stream_offset.png)\n\n## 流式队列的工作原理\n流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。\n\n## 适用场景：\n\n+ 适用于实时数据分析、日志处理、实时监控等场景。\n+ 在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。\n\n## PS\n1. Auto-Ack 必须为 false\n在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。\n![aoto ack](/images/rabbitmq-quarum/stream_error2.png)\n\n2. 必须设置prefetchCount\n流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用\n![prefetchCount](/images/rabbitmq-quarum/stream_error1.png)\n\n3. durable必须设置为true\n与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。\n\n\n# 选型建议\n在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：\n\n1. 经典队列：\n   - 适合大多数常规的消息传递需求。\n   - 需要较高的性能和可靠性，但不需要特别高的数据一致性要求。\n2. 仲裁队列：\n   - 适用于对数据一致性和高可用性要求较高的场景。\n   - 需要确保消息不丢失且能够在多节点间保持数据一致性。\n3. 流式队列：\n   - 适合处理大规模实时数据流和高吞吐量的场景。\n   - 需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。\n\n# 总结\n通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。\n\n参考文档\n[Quorum Queues](https://www.rabbitmq.com/docs/quorum-queues)","slug":"rabbitmq-quorum","published":1,"updated":"2024-07-13T07:55:05.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmn000sm8p16otr9tx5","content":"<p>RabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。</p>\n<h1 id=\"经典队列（Classic-Queues）\"><a href=\"#经典队列（Classic-Queues）\" class=\"headerlink\" title=\"经典队列（Classic Queues）\"></a>经典队列（Classic Queues）</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在磁盘或内存中，支持持久化。</li>\n<li>消息传递：一旦消息被消费者确认，消息会从队列中删除。</li>\n<li>性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。</li>\n<li>高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。</li>\n</ul>\n<h2 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><p>适合大多数常规消息传递场景，如任务调度、事件通知等。<br>当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。</p>\n<h1 id=\"仲裁队列（Quorum-Queues）\"><a href=\"#仲裁队列（Quorum-Queues）\" class=\"headerlink\" title=\"仲裁队列（Quorum Queues）\"></a>仲裁队列（Quorum Queues）</h1><h2 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。</p>\n<h2 id=\"特点：-1\"><a href=\"#特点：-1\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。</li>\n<li>高可用性：天然支持高可用性，通过多节点复制实现数据冗余。</li>\n<li>数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。</li>\n<li>性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。</li>\n</ul>\n<h2 id=\"适用场景：-1\"><a href=\"#适用场景：-1\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。</li>\n<li>在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>仲裁队列只能声明为持久的<br>仲裁队列只能被声明为持久的，否则会引发以下错误消息：<br>：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效</li>\n</ol>\n<p>Quorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。</p>\n<ol start=\"2\">\n<li>仲裁队列的消息默认就是持久化的<br>对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。</li>\n</ol>\n<p>下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。<br><img src=\"/images/rabbitmq-quarum/quarum1.png\" alt=\"重启前\"><br>然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。<br><img src=\"/images/rabbitmq-quarum/quarum2.png\" alt=\"重启后\"></p>\n<h2 id=\"仲裁队列-VS-经典队列\"><a href=\"#仲裁队列-VS-经典队列\" class=\"headerlink\" title=\"仲裁队列 VS 经典队列\"></a>仲裁队列 VS 经典队列</h2><h3 id=\"数据一致性\"><a href=\"#数据一致性\" class=\"headerlink\" title=\"数据一致性\"></a>数据一致性</h3><p>仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。</p>\n<h3 id=\"数据可靠性\"><a href=\"#数据可靠性\" class=\"headerlink\" title=\"数据可靠性\"></a>数据可靠性</h3><p>仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。</p>\n<h1 id=\"流式队列（Stream-Queues）\"><a href=\"#流式队列（Stream-Queues）\" class=\"headerlink\" title=\"流式队列（Stream Queues）\"></a>流式队列（Stream Queues）</h1><p>流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。</p>\n<h2 id=\"特点：-2\"><a href=\"#特点：-2\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。</li>\n<li>高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。</li>\n<li>数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。</li>\n<li>订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。</li>\n</ul>\n<h2 id=\"什么是消息回放和重复消费？\"><a href=\"#什么是消息回放和重复消费？\" class=\"headerlink\" title=\"什么是消息回放和重复消费？\"></a>什么是消息回放和重复消费？</h2><p>消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。</p>\n<p>重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InitStreamMQ</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\">    <span class=\"comment\">// 声明流式队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-queue-type&quot;</span>, <span class=\"string\">&quot;stream&quot;</span> &#125; &#125;;</span><br><span class=\"line\">    channel.QueueDeclare(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, durable: <span class=\"literal\">true</span>, exclusive: <span class=\"literal\">false</span>, autoDelete: <span class=\"literal\">false</span>, arguments: args);</span><br><span class=\"line\">    channel.QueueBind(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, exchange: <span class=\"string\">&quot;amq.direct&quot;</span>, routingKey: <span class=\"string\">&quot;stream_queue&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;订阅队列&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;subscribe&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SubscribeQuorumMessage</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, VirtualHost = <span class=\"string\">&quot;/&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.BasicQos(prefetchSize: <span class=\"number\">0</span>, prefetchCount: <span class=\"number\">1</span>, <span class=\"keyword\">global</span>: <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置消费者，从指定的偏移量消费消息</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">    consumer.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * x-stream-offset的可选值有以下几种：</span></span><br><span class=\"line\"><span class=\"comment\">        first: 从日志队列中第一个可消费的消息开始消费</span></span><br><span class=\"line\"><span class=\"comment\">        last: 消费消息日志中最后一个消息</span></span><br><span class=\"line\"><span class=\"comment\">        next: 相当于不指定offset，消费不到消息。</span></span><br><span class=\"line\"><span class=\"comment\">        Offset: 一个数字型的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-stream-offset&quot;</span>, <span class=\"number\">2</span> &#125; &#125;;</span><br><span class=\"line\">    channel.BasicConsume(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, arguments: args, consumer: consumer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.<br><img src=\"/images/rabbitmq-quarum/stream_offset.png\" alt=\"offset\"></p>\n<h2 id=\"流式队列的工作原理\"><a href=\"#流式队列的工作原理\" class=\"headerlink\" title=\"流式队列的工作原理\"></a>流式队列的工作原理</h2><p>流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。</p>\n<h2 id=\"适用场景：-2\"><a href=\"#适用场景：-2\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于实时数据分析、日志处理、实时监控等场景。</li>\n<li>在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。</li>\n</ul>\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><ol>\n<li><p>Auto-Ack 必须为 false<br>在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。<br><img src=\"/images/rabbitmq-quarum/stream_error2.png\" alt=\"aoto ack\"></p>\n</li>\n<li><p>必须设置prefetchCount<br>流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用<br><img src=\"/images/rabbitmq-quarum/stream_error1.png\" alt=\"prefetchCount\"></p>\n</li>\n<li><p>durable必须设置为true<br>与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。</p>\n</li>\n</ol>\n<h1 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h1><p>在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：</p>\n<ol>\n<li>经典队列：<ul>\n<li>适合大多数常规的消息传递需求。</li>\n<li>需要较高的性能和可靠性，但不需要特别高的数据一致性要求。</li>\n</ul>\n</li>\n<li>仲裁队列：<ul>\n<li>适用于对数据一致性和高可用性要求较高的场景。</li>\n<li>需要确保消息不丢失且能够在多节点间保持数据一致性。</li>\n</ul>\n</li>\n<li>流式队列：<ul>\n<li>适合处理大规模实时数据流和高吞吐量的场景。</li>\n<li>需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/quorum-queues\">Quorum Queues</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>RabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。</p>\n<h1 id=\"经典队列（Classic-Queues）\"><a href=\"#经典队列（Classic-Queues）\" class=\"headerlink\" title=\"经典队列（Classic Queues）\"></a>经典队列（Classic Queues）</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在磁盘或内存中，支持持久化。</li>\n<li>消息传递：一旦消息被消费者确认，消息会从队列中删除。</li>\n<li>性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。</li>\n<li>高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。</li>\n</ul>\n<h2 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><p>适合大多数常规消息传递场景，如任务调度、事件通知等。<br>当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。</p>\n<h1 id=\"仲裁队列（Quorum-Queues）\"><a href=\"#仲裁队列（Quorum-Queues）\" class=\"headerlink\" title=\"仲裁队列（Quorum Queues）\"></a>仲裁队列（Quorum Queues）</h1><h2 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。</p>\n<h2 id=\"特点：-1\"><a href=\"#特点：-1\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。</li>\n<li>高可用性：天然支持高可用性，通过多节点复制实现数据冗余。</li>\n<li>数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。</li>\n<li>性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。</li>\n</ul>\n<h2 id=\"适用场景：-1\"><a href=\"#适用场景：-1\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。</li>\n<li>在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>仲裁队列只能声明为持久的<br>仲裁队列只能被声明为持久的，否则会引发以下错误消息：<br>：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效</li>\n</ol>\n<p>Quorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。</p>\n<ol start=\"2\">\n<li>仲裁队列的消息默认就是持久化的<br>对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。</li>\n</ol>\n<p>下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。<br><img src=\"/images/rabbitmq-quarum/quarum1.png\" alt=\"重启前\"><br>然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。<br><img src=\"/images/rabbitmq-quarum/quarum2.png\" alt=\"重启后\"></p>\n<h2 id=\"仲裁队列-VS-经典队列\"><a href=\"#仲裁队列-VS-经典队列\" class=\"headerlink\" title=\"仲裁队列 VS 经典队列\"></a>仲裁队列 VS 经典队列</h2><h3 id=\"数据一致性\"><a href=\"#数据一致性\" class=\"headerlink\" title=\"数据一致性\"></a>数据一致性</h3><p>仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。</p>\n<h3 id=\"数据可靠性\"><a href=\"#数据可靠性\" class=\"headerlink\" title=\"数据可靠性\"></a>数据可靠性</h3><p>仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。</p>\n<h1 id=\"流式队列（Stream-Queues）\"><a href=\"#流式队列（Stream-Queues）\" class=\"headerlink\" title=\"流式队列（Stream Queues）\"></a>流式队列（Stream Queues）</h1><p>流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。</p>\n<h2 id=\"特点：-2\"><a href=\"#特点：-2\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。</li>\n<li>高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。</li>\n<li>数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。</li>\n<li>订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。</li>\n</ul>\n<h2 id=\"什么是消息回放和重复消费？\"><a href=\"#什么是消息回放和重复消费？\" class=\"headerlink\" title=\"什么是消息回放和重复消费？\"></a>什么是消息回放和重复消费？</h2><p>消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。</p>\n<p>重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InitStreamMQ</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\">    <span class=\"comment\">// 声明流式队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-queue-type&quot;</span>, <span class=\"string\">&quot;stream&quot;</span> &#125; &#125;;</span><br><span class=\"line\">    channel.QueueDeclare(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, durable: <span class=\"literal\">true</span>, exclusive: <span class=\"literal\">false</span>, autoDelete: <span class=\"literal\">false</span>, arguments: args);</span><br><span class=\"line\">    channel.QueueBind(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, exchange: <span class=\"string\">&quot;amq.direct&quot;</span>, routingKey: <span class=\"string\">&quot;stream_queue&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;订阅队列&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;subscribe&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SubscribeQuorumMessage</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, VirtualHost = <span class=\"string\">&quot;/&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.BasicQos(prefetchSize: <span class=\"number\">0</span>, prefetchCount: <span class=\"number\">1</span>, <span class=\"keyword\">global</span>: <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置消费者，从指定的偏移量消费消息</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">    consumer.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * x-stream-offset的可选值有以下几种：</span></span><br><span class=\"line\"><span class=\"comment\">        first: 从日志队列中第一个可消费的消息开始消费</span></span><br><span class=\"line\"><span class=\"comment\">        last: 消费消息日志中最后一个消息</span></span><br><span class=\"line\"><span class=\"comment\">        next: 相当于不指定offset，消费不到消息。</span></span><br><span class=\"line\"><span class=\"comment\">        Offset: 一个数字型的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-stream-offset&quot;</span>, <span class=\"number\">2</span> &#125; &#125;;</span><br><span class=\"line\">    channel.BasicConsume(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, arguments: args, consumer: consumer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.<br><img src=\"/images/rabbitmq-quarum/stream_offset.png\" alt=\"offset\"></p>\n<h2 id=\"流式队列的工作原理\"><a href=\"#流式队列的工作原理\" class=\"headerlink\" title=\"流式队列的工作原理\"></a>流式队列的工作原理</h2><p>流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。</p>\n<h2 id=\"适用场景：-2\"><a href=\"#适用场景：-2\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于实时数据分析、日志处理、实时监控等场景。</li>\n<li>在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。</li>\n</ul>\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><ol>\n<li><p>Auto-Ack 必须为 false<br>在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。<br><img src=\"/images/rabbitmq-quarum/stream_error2.png\" alt=\"aoto ack\"></p>\n</li>\n<li><p>必须设置prefetchCount<br>流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用<br><img src=\"/images/rabbitmq-quarum/stream_error1.png\" alt=\"prefetchCount\"></p>\n</li>\n<li><p>durable必须设置为true<br>与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。</p>\n</li>\n</ol>\n<h1 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h1><p>在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：</p>\n<ol>\n<li>经典队列：<ul>\n<li>适合大多数常规的消息传递需求。</li>\n<li>需要较高的性能和可靠性，但不需要特别高的数据一致性要求。</li>\n</ul>\n</li>\n<li>仲裁队列：<ul>\n<li>适用于对数据一致性和高可用性要求较高的场景。</li>\n<li>需要确保消息不丢失且能够在多节点间保持数据一致性。</li>\n</ul>\n</li>\n<li>流式队列：<ul>\n<li>适合处理大规模实时数据流和高吞吐量的场景。</li>\n<li>需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/quorum-queues\">Quorum Queues</a></p>\n"},{"title":"Rspack：一个新一代的 JavaScript 打包工具","date":"2024-11-29T07:50:26.000Z","_content":"\n在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。\n\n在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。\n\n![background](./images/rspack/bg.png)\n\n# 什么是 Rspack？\nRspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。\n\nRspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。\n\n# Rspack 的核心特点\n1. 更快的构建速度\nRspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。\n\n2. 基于 Rust 的高性能编译\nRspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。\n\n3. 高效的代码拆分\nRspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。\n\n4. 灵活的配置\n与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。\n\n说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。\nRspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。\nRspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。\n\n# 示例：使用 Rspack 构建一个简单的项目\n既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。\n这里我们直接采用官方Vue2的示例进行测试[参考示例](https://github.com/rspack-contrib/rspack-examples)。\n\nrspack.config.js\n```\nconst rspack = require('@rspack/core');\nconst { VueLoaderPlugin } = require('vue-loader');\n\n/** @type {import('@rspack/cli').Configuration} */\nconst config = {\n  context: __dirname,\n  entry: {\n    main: './src/main.js',\n  },\n  experiments: {\n    css: true,\n  },\n  devServer: {\n    historyApiFallback: true,\n  },\n  devtool: false,\n  plugins: [\n    new VueLoaderPlugin(),\n    new rspack.HtmlRspackPlugin({\n      template: './index.html',\n    }),\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        use: [\n          {\n            loader: 'vue-loader',\n            options: {\n              experimentalInlineMatchResource: true,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        loader: 'less-loader',\n        type: 'css',\n      },\n      {\n        test: /\\.svg$/,\n        type: 'asset/resource',\n      },\n    ],\n  },\n};\nmodule.exports = config;\n```\nwebpack.config.js\n```\nconst {VueLoaderPlugin} = require(\"vue-loader\");\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst config = {\n    context: __dirname,\n    entry: {\n        main: './src/main.js',\n    },\n    experiments: {\n        css: true,\n    },\n    devServer: {\n        historyApiFallback: true,\n    },\n    devtool: false,\n    plugins: [\n        new VueLoaderPlugin(),\n        new HtmlWebpackPlugin({ template: './index.html' }),\n    ],\n    module: {\n        rules: [\n            {\n                test: /\\.vue$/,\n                use: [\n                    {\n                        loader: 'vue-loader',\n                        options: {\n                            experimentalInlineMatchResource: true,\n                        },\n                    },\n                ],\n            },\n            {\n                test: /\\.less$/,\n                loader: 'less-loader',\n                type: 'css',\n            },\n            {\n                test: /\\.svg$/,\n                type: 'asset/resource',\n            },\n        ],\n    },\n};\nmodule.exports = config;\n```\n在wsl里面，分别执行以下命令进行构建：\n```\ntime npx rspack --config rspack.config.js --mode production\n```\n最后我们简单对比一下时间：\n![时间对比](./images/rspack/result1.png)\n\n# Rspack 的优点：对比 Webpack\n1. 构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。\n\n2. 内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。\n\n3. 智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。\n\n4. 灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。\n\n    >由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。\n\n    ![工具栈](./images/rspack/tools.png)\n\n# 结语\nRspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。\n\n如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。\n\n这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。\n\n","source":"_posts/rspack.md","raw":"---\ntitle: Rspack：一个新一代的 JavaScript 打包工具\ndate: 2024-11-29 15:50:26\ntags:\n---\n\n在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。\n\n在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。\n\n![background](./images/rspack/bg.png)\n\n# 什么是 Rspack？\nRspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。\n\nRspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。\n\n# Rspack 的核心特点\n1. 更快的构建速度\nRspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。\n\n2. 基于 Rust 的高性能编译\nRspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。\n\n3. 高效的代码拆分\nRspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。\n\n4. 灵活的配置\n与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。\n\n说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。\nRspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。\nRspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。\n\n# 示例：使用 Rspack 构建一个简单的项目\n既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。\n这里我们直接采用官方Vue2的示例进行测试[参考示例](https://github.com/rspack-contrib/rspack-examples)。\n\nrspack.config.js\n```\nconst rspack = require('@rspack/core');\nconst { VueLoaderPlugin } = require('vue-loader');\n\n/** @type {import('@rspack/cli').Configuration} */\nconst config = {\n  context: __dirname,\n  entry: {\n    main: './src/main.js',\n  },\n  experiments: {\n    css: true,\n  },\n  devServer: {\n    historyApiFallback: true,\n  },\n  devtool: false,\n  plugins: [\n    new VueLoaderPlugin(),\n    new rspack.HtmlRspackPlugin({\n      template: './index.html',\n    }),\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        use: [\n          {\n            loader: 'vue-loader',\n            options: {\n              experimentalInlineMatchResource: true,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        loader: 'less-loader',\n        type: 'css',\n      },\n      {\n        test: /\\.svg$/,\n        type: 'asset/resource',\n      },\n    ],\n  },\n};\nmodule.exports = config;\n```\nwebpack.config.js\n```\nconst {VueLoaderPlugin} = require(\"vue-loader\");\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst config = {\n    context: __dirname,\n    entry: {\n        main: './src/main.js',\n    },\n    experiments: {\n        css: true,\n    },\n    devServer: {\n        historyApiFallback: true,\n    },\n    devtool: false,\n    plugins: [\n        new VueLoaderPlugin(),\n        new HtmlWebpackPlugin({ template: './index.html' }),\n    ],\n    module: {\n        rules: [\n            {\n                test: /\\.vue$/,\n                use: [\n                    {\n                        loader: 'vue-loader',\n                        options: {\n                            experimentalInlineMatchResource: true,\n                        },\n                    },\n                ],\n            },\n            {\n                test: /\\.less$/,\n                loader: 'less-loader',\n                type: 'css',\n            },\n            {\n                test: /\\.svg$/,\n                type: 'asset/resource',\n            },\n        ],\n    },\n};\nmodule.exports = config;\n```\n在wsl里面，分别执行以下命令进行构建：\n```\ntime npx rspack --config rspack.config.js --mode production\n```\n最后我们简单对比一下时间：\n![时间对比](./images/rspack/result1.png)\n\n# Rspack 的优点：对比 Webpack\n1. 构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。\n\n2. 内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。\n\n3. 智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。\n\n4. 灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。\n\n    >由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。\n\n    ![工具栈](./images/rspack/tools.png)\n\n# 结语\nRspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。\n\n如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。\n\n这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。\n\n","slug":"rspack","published":1,"updated":"2024-11-29T08:33:25.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmn000tm8p1hp492y3g","content":"<p>在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。</p>\n<p>在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。</p>\n<p><img src=\"/./images/rspack/bg.png\" alt=\"background\"></p>\n<h1 id=\"什么是-Rspack？\"><a href=\"#什么是-Rspack？\" class=\"headerlink\" title=\"什么是 Rspack？\"></a>什么是 Rspack？</h1><p>Rspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。</p>\n<p>Rspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。</p>\n<h1 id=\"Rspack-的核心特点\"><a href=\"#Rspack-的核心特点\" class=\"headerlink\" title=\"Rspack 的核心特点\"></a>Rspack 的核心特点</h1><ol>\n<li><p>更快的构建速度<br>Rspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。</p>\n</li>\n<li><p>基于 Rust 的高性能编译<br>Rspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。</p>\n</li>\n<li><p>高效的代码拆分<br>Rspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。</p>\n</li>\n<li><p>灵活的配置<br>与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。</p>\n</li>\n</ol>\n<p>说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。<br>Rspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。<br>Rspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。</p>\n<h1 id=\"示例：使用-Rspack-构建一个简单的项目\"><a href=\"#示例：使用-Rspack-构建一个简单的项目\" class=\"headerlink\" title=\"示例：使用 Rspack 构建一个简单的项目\"></a>示例：使用 Rspack 构建一个简单的项目</h1><p>既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。<br>这里我们直接采用官方Vue2的示例进行测试<a href=\"https://github.com/rspack-contrib/rspack-examples\">参考示例</a>。</p>\n<p>rspack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const rspack = require(&#x27;@rspack/core&#x27;);</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/** @type &#123;import(&#x27;@rspack/cli&#x27;).Configuration&#125; */</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">  context: __dirname,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  experiments: &#123;</span><br><span class=\"line\">    css: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    historyApiFallback: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: false,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new VueLoaderPlugin(),</span><br><span class=\"line\">    new rspack.HtmlRspackPlugin(&#123;</span><br><span class=\"line\">      template: &#x27;./index.html&#x27;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              experimentalInlineMatchResource: true,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.less$/,</span><br><span class=\"line\">        loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">        type: &#x27;css&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.svg$/,</span><br><span class=\"line\">        type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;VueLoaderPlugin&#125; = require(&quot;vue-loader&quot;);</span><br><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">    context: __dirname,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    experiments: &#123;</span><br><span class=\"line\">        css: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        historyApiFallback: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: false,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        new VueLoaderPlugin(),</span><br><span class=\"line\">        new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27; &#125;),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.vue$/,</span><br><span class=\"line\">                use: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">                        options: &#123;</span><br><span class=\"line\">                            experimentalInlineMatchResource: true,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                ],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.less$/,</span><br><span class=\"line\">                loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">                type: &#x27;css&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.svg$/,</span><br><span class=\"line\">                type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>在wsl里面，分别执行以下命令进行构建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time npx rspack --config rspack.config.js --mode production</span><br></pre></td></tr></table></figure>\n<p>最后我们简单对比一下时间：<br><img src=\"/./images/rspack/result1.png\" alt=\"时间对比\"></p>\n<h1 id=\"Rspack-的优点：对比-Webpack\"><a href=\"#Rspack-的优点：对比-Webpack\" class=\"headerlink\" title=\"Rspack 的优点：对比 Webpack\"></a>Rspack 的优点：对比 Webpack</h1><ol>\n<li><p>构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。</p>\n</li>\n<li><p>内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。</p>\n</li>\n<li><p>智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。</p>\n</li>\n<li><p>灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。</p>\n<blockquote>\n<p>由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。</p>\n</blockquote>\n<p> <img src=\"/./images/rspack/tools.png\" alt=\"工具栈\"></p>\n</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Rspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。</p>\n<p>如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。</p>\n<p>这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。</p>\n<p>在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。</p>\n<p><img src=\"/./images/rspack/bg.png\" alt=\"background\"></p>\n<h1 id=\"什么是-Rspack？\"><a href=\"#什么是-Rspack？\" class=\"headerlink\" title=\"什么是 Rspack？\"></a>什么是 Rspack？</h1><p>Rspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。</p>\n<p>Rspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。</p>\n<h1 id=\"Rspack-的核心特点\"><a href=\"#Rspack-的核心特点\" class=\"headerlink\" title=\"Rspack 的核心特点\"></a>Rspack 的核心特点</h1><ol>\n<li><p>更快的构建速度<br>Rspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。</p>\n</li>\n<li><p>基于 Rust 的高性能编译<br>Rspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。</p>\n</li>\n<li><p>高效的代码拆分<br>Rspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。</p>\n</li>\n<li><p>灵活的配置<br>与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。</p>\n</li>\n</ol>\n<p>说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。<br>Rspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。<br>Rspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。</p>\n<h1 id=\"示例：使用-Rspack-构建一个简单的项目\"><a href=\"#示例：使用-Rspack-构建一个简单的项目\" class=\"headerlink\" title=\"示例：使用 Rspack 构建一个简单的项目\"></a>示例：使用 Rspack 构建一个简单的项目</h1><p>既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。<br>这里我们直接采用官方Vue2的示例进行测试<a href=\"https://github.com/rspack-contrib/rspack-examples\">参考示例</a>。</p>\n<p>rspack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const rspack = require(&#x27;@rspack/core&#x27;);</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/** @type &#123;import(&#x27;@rspack/cli&#x27;).Configuration&#125; */</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">  context: __dirname,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  experiments: &#123;</span><br><span class=\"line\">    css: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    historyApiFallback: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: false,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new VueLoaderPlugin(),</span><br><span class=\"line\">    new rspack.HtmlRspackPlugin(&#123;</span><br><span class=\"line\">      template: &#x27;./index.html&#x27;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              experimentalInlineMatchResource: true,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.less$/,</span><br><span class=\"line\">        loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">        type: &#x27;css&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.svg$/,</span><br><span class=\"line\">        type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;VueLoaderPlugin&#125; = require(&quot;vue-loader&quot;);</span><br><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">    context: __dirname,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    experiments: &#123;</span><br><span class=\"line\">        css: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        historyApiFallback: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: false,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        new VueLoaderPlugin(),</span><br><span class=\"line\">        new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27; &#125;),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.vue$/,</span><br><span class=\"line\">                use: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">                        options: &#123;</span><br><span class=\"line\">                            experimentalInlineMatchResource: true,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                ],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.less$/,</span><br><span class=\"line\">                loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">                type: &#x27;css&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.svg$/,</span><br><span class=\"line\">                type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>在wsl里面，分别执行以下命令进行构建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time npx rspack --config rspack.config.js --mode production</span><br></pre></td></tr></table></figure>\n<p>最后我们简单对比一下时间：<br><img src=\"/./images/rspack/result1.png\" alt=\"时间对比\"></p>\n<h1 id=\"Rspack-的优点：对比-Webpack\"><a href=\"#Rspack-的优点：对比-Webpack\" class=\"headerlink\" title=\"Rspack 的优点：对比 Webpack\"></a>Rspack 的优点：对比 Webpack</h1><ol>\n<li><p>构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。</p>\n</li>\n<li><p>内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。</p>\n</li>\n<li><p>智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。</p>\n</li>\n<li><p>灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。</p>\n<blockquote>\n<p>由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。</p>\n</blockquote>\n<p> <img src=\"/./images/rspack/tools.png\" alt=\"工具栈\"></p>\n</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Rspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。</p>\n<p>如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。</p>\n<p>这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。</p>\n"},{"title":"Redis成长记 - Redis的陷阱（一）","date":"2024-04-18T07:09:28.000Z","_content":"相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/redis-interview-1.md","raw":"---\ntitle: Redis成长记 - Redis的陷阱（一）\ndate: 2024-04-18 15:09:28\ntags: redis 面试 求职\n---\n相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"redis-interview-1","published":1,"updated":"2024-04-26T03:31:26.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmn000vm8p15a6th0co","content":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"从零开始搭建自己的相似图片搜索引擎","date":"2024-05-30T08:02:51.000Z","_content":"\n之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。\n功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。\n\n本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n![流程](/images/image-search/process.png)\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。\n从WB获取图片，保存到本地，那么我们第一步就算是完成了。\n\n  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。\n\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n# 嵌入\n这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。\n\n我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B/32 变体。\n详细的文档可以参考[《clip》](https://github.com/openai/CLIP)\n```python\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\n\n# 创建或获取一个集合\ncollection_name = 'image_vectors'\n\n# 遍历图片文件夹中的所有图片\nfor image_name in os.listdir(source_folder):\n    image_path = os.path.join(source_folder, image_name)\n    \n    # 确保文件是图片\n    if os.path.isfile(image_path) and image_name.lower().endswith(('png', 'jpg', 'jpeg', 'bmp', 'gif')):\n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 搜索相似结果\n        point = rest.PointStruct(\n            id=point_id,\n            vector=image_features,\n            payload={'file_name': image_name}\n        )\n        \n        # 将向量存储到Qdrant\n\n        # TODO 移动图片到目标文件夹        \n```\n做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。\n![图片](/images/image-search/qdrant.png)\n\n# 前端页面\n既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。\n所以我们的主要实现步骤有一下几个：\n1. 上传图片；\n2. 计算图片向量；\n3. 搜索相似图片；\n4. 返回相似图片；\n\n为了快速兑现功能，这里我也直接用python实现了一个简单的demo\n```python\napp = Flask(__name__)\nUPLOAD_FOLDER = 'uploads'\nCLIPPED_FOLDER = 'image_scraper/images/clipped'\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\ncollection_name = 'image_vectors'\n\n# 检查集合是否存在，如果不存在则创建\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return \"No file part\", 400\n    file = request.files['file']\n    if file.filename == '':\n        return \"No selected file\", 400\n    if file and allowed_file(file.filename):\n        \n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 在Qdrant中搜索相似图片\n        search_result = qdrant_client.search(\n            collection_name=collection_name,\n            query_vector=image_features,\n            limit=5  # 设置返回的结果数量\n        )\n\n        # 获取相似图片的文件名\n        similar_images = [hit.payload['file_name'] for hit in search_result]\n        \n        return render_template('result.html', images=similar_images)\n    return \"File not allowed\", 400\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n```\n\n\n最终的结果，大功告成！\n![图片](/images/image-search/search.gif)\n\n# 总结\n通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。\n\n这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。\n\n希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/similar-image-search.md","raw":"---\ntitle: 从零开始搭建自己的相似图片搜索引擎\ndate: 2024-05-30 16:02:51\ntags:\n---\n\n之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。\n功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。\n\n本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n![流程](/images/image-search/process.png)\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。\n从WB获取图片，保存到本地，那么我们第一步就算是完成了。\n\n  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。\n\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n# 嵌入\n这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。\n\n我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B/32 变体。\n详细的文档可以参考[《clip》](https://github.com/openai/CLIP)\n```python\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\n\n# 创建或获取一个集合\ncollection_name = 'image_vectors'\n\n# 遍历图片文件夹中的所有图片\nfor image_name in os.listdir(source_folder):\n    image_path = os.path.join(source_folder, image_name)\n    \n    # 确保文件是图片\n    if os.path.isfile(image_path) and image_name.lower().endswith(('png', 'jpg', 'jpeg', 'bmp', 'gif')):\n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 搜索相似结果\n        point = rest.PointStruct(\n            id=point_id,\n            vector=image_features,\n            payload={'file_name': image_name}\n        )\n        \n        # 将向量存储到Qdrant\n\n        # TODO 移动图片到目标文件夹        \n```\n做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。\n![图片](/images/image-search/qdrant.png)\n\n# 前端页面\n既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。\n所以我们的主要实现步骤有一下几个：\n1. 上传图片；\n2. 计算图片向量；\n3. 搜索相似图片；\n4. 返回相似图片；\n\n为了快速兑现功能，这里我也直接用python实现了一个简单的demo\n```python\napp = Flask(__name__)\nUPLOAD_FOLDER = 'uploads'\nCLIPPED_FOLDER = 'image_scraper/images/clipped'\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\ncollection_name = 'image_vectors'\n\n# 检查集合是否存在，如果不存在则创建\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return \"No file part\", 400\n    file = request.files['file']\n    if file.filename == '':\n        return \"No selected file\", 400\n    if file and allowed_file(file.filename):\n        \n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 在Qdrant中搜索相似图片\n        search_result = qdrant_client.search(\n            collection_name=collection_name,\n            query_vector=image_features,\n            limit=5  # 设置返回的结果数量\n        )\n\n        # 获取相似图片的文件名\n        similar_images = [hit.payload['file_name'] for hit in search_result]\n        \n        return render_template('result.html', images=similar_images)\n    return \"File not allowed\", 400\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n```\n\n\n最终的结果，大功告成！\n![图片](/images/image-search/search.gif)\n\n# 总结\n通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。\n\n这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。\n\n希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"similar-image-search","published":1,"updated":"2024-06-07T15:31:38.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmn000wm8p18k2u9w27","content":"<p>之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。<br>功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。</p>\n<p>本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；<br><img src=\"/images/image-search/process.png\" alt=\"流程\"></li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。<br>从WB获取图片，保存到本地，那么我们第一步就算是完成了。</p>\n<p>  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。</p>\n<p>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/images/image-search/images.png\" alt=\"图片\"></p>\n<h1 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h1><p>这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。</p>\n<p>我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B&#x2F;32 变体。<br>详细的文档可以参考<a href=\"https://github.com/openai/CLIP\">《clip》</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建或获取一个集合</span></span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历图片文件夹中的所有图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> image_name <span class=\"keyword\">in</span> os.listdir(source_folder):</span><br><span class=\"line\">    image_path = os.path.join(source_folder, image_name)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 确保文件是图片</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.isfile(image_path) <span class=\"keyword\">and</span> image_name.lower().endswith((<span class=\"string\">&#x27;png&#x27;</span>, <span class=\"string\">&#x27;jpg&#x27;</span>, <span class=\"string\">&#x27;jpeg&#x27;</span>, <span class=\"string\">&#x27;bmp&#x27;</span>, <span class=\"string\">&#x27;gif&#x27;</span>)):</span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 搜索相似结果</span></span><br><span class=\"line\">        point = rest.PointStruct(</span><br><span class=\"line\">            <span class=\"built_in\">id</span>=point_id,</span><br><span class=\"line\">            vector=image_features,</span><br><span class=\"line\">            payload=&#123;<span class=\"string\">&#x27;file_name&#x27;</span>: image_name&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将向量存储到Qdrant</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># TODO 移动图片到目标文件夹        </span></span><br></pre></td></tr></table></figure>\n<p>做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。<br><img src=\"/images/image-search/qdrant.png\" alt=\"图片\"></p>\n<h1 id=\"前端页面\"><a href=\"#前端页面\" class=\"headerlink\" title=\"前端页面\"></a>前端页面</h1><p>既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。<br>所以我们的主要实现步骤有一下几个：</p>\n<ol>\n<li>上传图片；</li>\n<li>计算图片向量；</li>\n<li>搜索相似图片；</li>\n<li>返回相似图片；</li>\n</ol>\n<p>为了快速兑现功能，这里我也直接用python实现了一个简单的demo</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">UPLOAD_FOLDER = <span class=\"string\">&#x27;uploads&#x27;</span></span><br><span class=\"line\">CLIPPED_FOLDER = <span class=\"string\">&#x27;image_scraper/images/clipped&#x27;</span></span><br><span class=\"line\">os.makedirs(UPLOAD_FOLDER, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查集合是否存在，如果不存在则创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;index.html&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/upload&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_file</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;file&#x27;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.files:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No file part&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    file = request.files[<span class=\"string\">&#x27;file&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.filename == <span class=\"string\">&#x27;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No selected file&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> file <span class=\"keyword\">and</span> allowed_file(file.filename):</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 在Qdrant中搜索相似图片</span></span><br><span class=\"line\">        search_result = qdrant_client.search(</span><br><span class=\"line\">            collection_name=collection_name,</span><br><span class=\"line\">            query_vector=image_features,</span><br><span class=\"line\">            limit=<span class=\"number\">5</span>  <span class=\"comment\"># 设置返回的结果数量</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取相似图片的文件名</span></span><br><span class=\"line\">        similar_images = [hit.payload[<span class=\"string\">&#x27;file_name&#x27;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;result.html&#x27;</span>, images=similar_images)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;File not allowed&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>最终的结果，大功告成！<br><img src=\"/images/image-search/search.gif\" alt=\"图片\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。</p>\n<p>这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。</p>\n<p>希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。<br>功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。</p>\n<p>本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；<br><img src=\"/images/image-search/process.png\" alt=\"流程\"></li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。<br>从WB获取图片，保存到本地，那么我们第一步就算是完成了。</p>\n<p>  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。</p>\n<p>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/images/image-search/images.png\" alt=\"图片\"></p>\n<h1 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h1><p>这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。</p>\n<p>我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B&#x2F;32 变体。<br>详细的文档可以参考<a href=\"https://github.com/openai/CLIP\">《clip》</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建或获取一个集合</span></span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历图片文件夹中的所有图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> image_name <span class=\"keyword\">in</span> os.listdir(source_folder):</span><br><span class=\"line\">    image_path = os.path.join(source_folder, image_name)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 确保文件是图片</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.isfile(image_path) <span class=\"keyword\">and</span> image_name.lower().endswith((<span class=\"string\">&#x27;png&#x27;</span>, <span class=\"string\">&#x27;jpg&#x27;</span>, <span class=\"string\">&#x27;jpeg&#x27;</span>, <span class=\"string\">&#x27;bmp&#x27;</span>, <span class=\"string\">&#x27;gif&#x27;</span>)):</span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 搜索相似结果</span></span><br><span class=\"line\">        point = rest.PointStruct(</span><br><span class=\"line\">            <span class=\"built_in\">id</span>=point_id,</span><br><span class=\"line\">            vector=image_features,</span><br><span class=\"line\">            payload=&#123;<span class=\"string\">&#x27;file_name&#x27;</span>: image_name&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将向量存储到Qdrant</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># TODO 移动图片到目标文件夹        </span></span><br></pre></td></tr></table></figure>\n<p>做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。<br><img src=\"/images/image-search/qdrant.png\" alt=\"图片\"></p>\n<h1 id=\"前端页面\"><a href=\"#前端页面\" class=\"headerlink\" title=\"前端页面\"></a>前端页面</h1><p>既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。<br>所以我们的主要实现步骤有一下几个：</p>\n<ol>\n<li>上传图片；</li>\n<li>计算图片向量；</li>\n<li>搜索相似图片；</li>\n<li>返回相似图片；</li>\n</ol>\n<p>为了快速兑现功能，这里我也直接用python实现了一个简单的demo</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">UPLOAD_FOLDER = <span class=\"string\">&#x27;uploads&#x27;</span></span><br><span class=\"line\">CLIPPED_FOLDER = <span class=\"string\">&#x27;image_scraper/images/clipped&#x27;</span></span><br><span class=\"line\">os.makedirs(UPLOAD_FOLDER, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查集合是否存在，如果不存在则创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;index.html&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/upload&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_file</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;file&#x27;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.files:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No file part&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    file = request.files[<span class=\"string\">&#x27;file&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.filename == <span class=\"string\">&#x27;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No selected file&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> file <span class=\"keyword\">and</span> allowed_file(file.filename):</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 在Qdrant中搜索相似图片</span></span><br><span class=\"line\">        search_result = qdrant_client.search(</span><br><span class=\"line\">            collection_name=collection_name,</span><br><span class=\"line\">            query_vector=image_features,</span><br><span class=\"line\">            limit=<span class=\"number\">5</span>  <span class=\"comment\"># 设置返回的结果数量</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取相似图片的文件名</span></span><br><span class=\"line\">        similar_images = [hit.payload[<span class=\"string\">&#x27;file_name&#x27;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;result.html&#x27;</span>, images=similar_images)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;File not allowed&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>最终的结果，大功告成！<br><img src=\"/images/image-search/search.gif\" alt=\"图片\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。</p>\n<p>这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。</p>\n<p>希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"深入探讨 TCP 粘包现象：问题、原因与解决方案","date":"2024-08-28T07:04:04.000Z","_content":"在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。\n\n# 什么是 TCP 粘包？\n\nTCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。\n\n举个简单的例子，假设客户端连续发送两条消息 \"Hello\" 和 \"World\"，由于粘包现象，接收端可能会一次性接收到 \"HelloWorld\"，而不是分开接收到 \"Hello\" 和 \"World\" 两条消息。\n\n# TCP 粘包的成因\n\n要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：\n\n1. TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。\n\n2. Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。\n\n3. 接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。\n\n# 如何解决 TCP 粘包问题\n\n粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：\n\n1. 定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。\n\n2. 分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。\n\n3. 消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。\n\n## HTTP有粘包问题么？\n众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？\n\nHTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：\n\n### 消息的明确边界\n\n+ Content-Length 头部\n    > HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。\n\n+ Chunked Transfer-Encoding\n    > 对于无法提前确定内容长度的情况，HTTP/1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。    \n\n\n# 示例代码\n\n下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法\n## 发送方粘包\n\n服务端代码\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[1024];\n        int bytesRead = stream.Read(buffer, 0, buffer.Length);\n        string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n\n        Console.WriteLine(\"Received Data:\\r\\n \" + receivedData);\n    }\n    listener.Stop();\n\n    Console.ReadLine();\n}\n```\n客户端代码\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string[] messages = { \"Message 1\\r\\n\", \"Message 2\\r\\n\", \"Message 3\\r\\n\" };\n\n        foreach( var msg in messages ) {\n            byte[] data = Encoding.UTF8.GetBytes(msg);\n            stream.Write(data, 0, data.Length);\n        }\n\n        Console.WriteLine(\"Messages sent.\");\n    }\n\n    Console.ReadLine();\n}\n```\n运行效果如下\n![发送方粘包](/images/sticky-packet/sender-sticky.png)\n在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。\n\n### 解决方案：使用消息长度前缀\n客户端代码：\n```C#\n static void Main(string[] args)\n {\n     using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n     using( NetworkStream stream = client.GetStream() ) {\n         string[] messages = { \"Message 1\", \"Message 2\", \"Message 3\" };\n\n         foreach( var msg in messages ) {\n             byte[] messageData = Encoding.UTF8.GetBytes(msg);\n             byte[] lengthPrefix = BitConverter.GetBytes(messageData.Length);\n\n             // 发送长度前缀\n             stream.Write(lengthPrefix, 0, lengthPrefix.Length);\n             // 发送实际消息\n             stream.Write(messageData, 0, messageData.Length);\n         }\n\n         Console.ReadLine();\n     }\n }\n```\n运行效果如下：\n![解决发送方粘包](/images/sticky-packet/solve-sender-sticky.png)\n\n\n## 接收方粘包\n服务端代码:\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20]; // 小缓冲区，故意分多次接收\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            Console.WriteLine(\"Receive: \" + part );\n\n            if( bytesRead < buffer.Length )\n                break; // 假设消息的最后一部分已经接收完\n        }\n\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n客户端代码:\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string message = \"This is a longer message that may be split across multiple packets.\";\n        byte[] data = Encoding.UTF8.GetBytes(message);\n        stream.Write(data, 0, data.Length);\n\n        Console.WriteLine(\"Message sent.\");\n    }\n    Console.ReadLine();\n}\n```\n\n运行效果\n![接收方粘包](/images/sticky-packet/server-sticky.png)\n\n### 解决方案：实现一个消息缓冲机制\n\n接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server start... \");\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20];\n        StringBuilder completeMessage = new StringBuilder();\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            // 每次接收数据并追加到消息缓冲区\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            completeMessage.Append(part);\n\n            // 假设消息以特定结束符结束，判断完整消息的逻辑\n            if( completeMessage.ToString().Contains(\"...\") ) // 示例中的结束符\n            {\n                break;\n            }\n        }\n        Console.WriteLine(\"Complete Message: \" + completeMessage.ToString());\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n效果如下：\n![解决接收方粘包](/images/sticky-packet/solve-server-sticky.png)\n\n# 总结\n\nTCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。\n\n希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！","source":"_posts/sticky-packet.md","raw":"---\ntitle: 深入探讨 TCP 粘包现象：问题、原因与解决方案\ndate: 2024-08-28 15:04:04\ntags:\n---\n在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。\n\n# 什么是 TCP 粘包？\n\nTCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。\n\n举个简单的例子，假设客户端连续发送两条消息 \"Hello\" 和 \"World\"，由于粘包现象，接收端可能会一次性接收到 \"HelloWorld\"，而不是分开接收到 \"Hello\" 和 \"World\" 两条消息。\n\n# TCP 粘包的成因\n\n要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：\n\n1. TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。\n\n2. Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。\n\n3. 接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。\n\n# 如何解决 TCP 粘包问题\n\n粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：\n\n1. 定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。\n\n2. 分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。\n\n3. 消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。\n\n## HTTP有粘包问题么？\n众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？\n\nHTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：\n\n### 消息的明确边界\n\n+ Content-Length 头部\n    > HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。\n\n+ Chunked Transfer-Encoding\n    > 对于无法提前确定内容长度的情况，HTTP/1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。    \n\n\n# 示例代码\n\n下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法\n## 发送方粘包\n\n服务端代码\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[1024];\n        int bytesRead = stream.Read(buffer, 0, buffer.Length);\n        string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n\n        Console.WriteLine(\"Received Data:\\r\\n \" + receivedData);\n    }\n    listener.Stop();\n\n    Console.ReadLine();\n}\n```\n客户端代码\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string[] messages = { \"Message 1\\r\\n\", \"Message 2\\r\\n\", \"Message 3\\r\\n\" };\n\n        foreach( var msg in messages ) {\n            byte[] data = Encoding.UTF8.GetBytes(msg);\n            stream.Write(data, 0, data.Length);\n        }\n\n        Console.WriteLine(\"Messages sent.\");\n    }\n\n    Console.ReadLine();\n}\n```\n运行效果如下\n![发送方粘包](/images/sticky-packet/sender-sticky.png)\n在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。\n\n### 解决方案：使用消息长度前缀\n客户端代码：\n```C#\n static void Main(string[] args)\n {\n     using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n     using( NetworkStream stream = client.GetStream() ) {\n         string[] messages = { \"Message 1\", \"Message 2\", \"Message 3\" };\n\n         foreach( var msg in messages ) {\n             byte[] messageData = Encoding.UTF8.GetBytes(msg);\n             byte[] lengthPrefix = BitConverter.GetBytes(messageData.Length);\n\n             // 发送长度前缀\n             stream.Write(lengthPrefix, 0, lengthPrefix.Length);\n             // 发送实际消息\n             stream.Write(messageData, 0, messageData.Length);\n         }\n\n         Console.ReadLine();\n     }\n }\n```\n运行效果如下：\n![解决发送方粘包](/images/sticky-packet/solve-sender-sticky.png)\n\n\n## 接收方粘包\n服务端代码:\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20]; // 小缓冲区，故意分多次接收\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            Console.WriteLine(\"Receive: \" + part );\n\n            if( bytesRead < buffer.Length )\n                break; // 假设消息的最后一部分已经接收完\n        }\n\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n客户端代码:\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string message = \"This is a longer message that may be split across multiple packets.\";\n        byte[] data = Encoding.UTF8.GetBytes(message);\n        stream.Write(data, 0, data.Length);\n\n        Console.WriteLine(\"Message sent.\");\n    }\n    Console.ReadLine();\n}\n```\n\n运行效果\n![接收方粘包](/images/sticky-packet/server-sticky.png)\n\n### 解决方案：实现一个消息缓冲机制\n\n接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server start... \");\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20];\n        StringBuilder completeMessage = new StringBuilder();\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            // 每次接收数据并追加到消息缓冲区\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            completeMessage.Append(part);\n\n            // 假设消息以特定结束符结束，判断完整消息的逻辑\n            if( completeMessage.ToString().Contains(\"...\") ) // 示例中的结束符\n            {\n                break;\n            }\n        }\n        Console.WriteLine(\"Complete Message: \" + completeMessage.ToString());\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n效果如下：\n![解决接收方粘包](/images/sticky-packet/solve-server-sticky.png)\n\n# 总结\n\nTCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。\n\n希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！","slug":"sticky-packet","published":1,"updated":"2024-08-30T06:30:41.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmn000ym8p1flc51pjx","content":"<p>在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。</p>\n<h1 id=\"什么是-TCP-粘包？\"><a href=\"#什么是-TCP-粘包？\" class=\"headerlink\" title=\"什么是 TCP 粘包？\"></a>什么是 TCP 粘包？</h1><p>TCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。</p>\n<p>举个简单的例子，假设客户端连续发送两条消息 “Hello” 和 “World”，由于粘包现象，接收端可能会一次性接收到 “HelloWorld”，而不是分开接收到 “Hello” 和 “World” 两条消息。</p>\n<h1 id=\"TCP-粘包的成因\"><a href=\"#TCP-粘包的成因\" class=\"headerlink\" title=\"TCP 粘包的成因\"></a>TCP 粘包的成因</h1><p>要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：</p>\n<ol>\n<li><p>TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。</p>\n</li>\n<li><p>Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。</p>\n</li>\n<li><p>接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。</p>\n</li>\n</ol>\n<h1 id=\"如何解决-TCP-粘包问题\"><a href=\"#如何解决-TCP-粘包问题\" class=\"headerlink\" title=\"如何解决 TCP 粘包问题\"></a>如何解决 TCP 粘包问题</h1><p>粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：</p>\n<ol>\n<li><p>定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。</p>\n</li>\n<li><p>分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。</p>\n</li>\n<li><p>消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。</p>\n</li>\n</ol>\n<h2 id=\"HTTP有粘包问题么？\"><a href=\"#HTTP有粘包问题么？\" class=\"headerlink\" title=\"HTTP有粘包问题么？\"></a>HTTP有粘包问题么？</h2><p>众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？</p>\n<p>HTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：</p>\n<h3 id=\"消息的明确边界\"><a href=\"#消息的明确边界\" class=\"headerlink\" title=\"消息的明确边界\"></a>消息的明确边界</h3><ul>\n<li><p>Content-Length 头部</p>\n<blockquote>\n<p>HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。</p>\n</blockquote>\n</li>\n<li><p>Chunked Transfer-Encoding</p>\n<blockquote>\n<p>对于无法提前确定内容长度的情况，HTTP&#x2F;1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法</p>\n<h2 id=\"发送方粘包\"><a href=\"#发送方粘包\" class=\"headerlink\" title=\"发送方粘包\"></a>发送方粘包</h2><p>服务端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> receivedData = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Received Data:\\r\\n &quot;</span> + receivedData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 2\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 3\\r\\n&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Messages sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下<br><img src=\"/images/sticky-packet/sender-sticky.png\" alt=\"发送方粘包\"><br>在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。</p>\n<h3 id=\"解决方案：使用消息长度前缀\"><a href=\"#解决方案：使用消息长度前缀\" class=\"headerlink\" title=\"解决方案：使用消息长度前缀\"></a>解决方案：使用消息长度前缀</h3><p>客户端代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1&quot;</span>, <span class=\"string\">&quot;Message 2&quot;</span>, <span class=\"string\">&quot;Message 3&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] messageData = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] lengthPrefix = BitConverter.GetBytes(messageData.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 发送长度前缀</span></span><br><span class=\"line\">            stream.Write(lengthPrefix, <span class=\"number\">0</span>, lengthPrefix.Length);</span><br><span class=\"line\">            <span class=\"comment\">// 发送实际消息</span></span><br><span class=\"line\">            stream.Write(messageData, <span class=\"number\">0</span>, messageData.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.ReadLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下：<br><img src=\"/images/sticky-packet/solve-sender-sticky.png\" alt=\"解决发送方粘包\"></p>\n<h2 id=\"接收方粘包\"><a href=\"#接收方粘包\" class=\"headerlink\" title=\"接收方粘包\"></a>接收方粘包</h2><p>服务端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>]; <span class=\"comment\">// 小缓冲区，故意分多次接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">&quot;Receive: &quot;</span> + part );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( bytesRead &lt; buffer.Length )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>; <span class=\"comment\">// 假设消息的最后一部分已经接收完</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> message = <span class=\"string\">&quot;This is a longer message that may be split across multiple packets.&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(message);</span><br><span class=\"line\">        stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Message sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行效果<br><img src=\"/images/sticky-packet/server-sticky.png\" alt=\"接收方粘包\"></p>\n<h3 id=\"解决方案：实现一个消息缓冲机制\"><a href=\"#解决方案：实现一个消息缓冲机制\" class=\"headerlink\" title=\"解决方案：实现一个消息缓冲机制\"></a>解决方案：实现一个消息缓冲机制</h3><p>接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server start... &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>];</span><br><span class=\"line\">        StringBuilder completeMessage = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每次接收数据并追加到消息缓冲区</span></span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            completeMessage.Append(part);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 假设消息以特定结束符结束，判断完整消息的逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( completeMessage.ToString().Contains(<span class=\"string\">&quot;...&quot;</span>) ) <span class=\"comment\">// 示例中的结束符</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Complete Message: &quot;</span> + completeMessage.ToString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下：<br><img src=\"/images/sticky-packet/solve-server-sticky.png\" alt=\"解决接收方粘包\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。</p>\n<p>希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。</p>\n<h1 id=\"什么是-TCP-粘包？\"><a href=\"#什么是-TCP-粘包？\" class=\"headerlink\" title=\"什么是 TCP 粘包？\"></a>什么是 TCP 粘包？</h1><p>TCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。</p>\n<p>举个简单的例子，假设客户端连续发送两条消息 “Hello” 和 “World”，由于粘包现象，接收端可能会一次性接收到 “HelloWorld”，而不是分开接收到 “Hello” 和 “World” 两条消息。</p>\n<h1 id=\"TCP-粘包的成因\"><a href=\"#TCP-粘包的成因\" class=\"headerlink\" title=\"TCP 粘包的成因\"></a>TCP 粘包的成因</h1><p>要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：</p>\n<ol>\n<li><p>TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。</p>\n</li>\n<li><p>Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。</p>\n</li>\n<li><p>接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。</p>\n</li>\n</ol>\n<h1 id=\"如何解决-TCP-粘包问题\"><a href=\"#如何解决-TCP-粘包问题\" class=\"headerlink\" title=\"如何解决 TCP 粘包问题\"></a>如何解决 TCP 粘包问题</h1><p>粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：</p>\n<ol>\n<li><p>定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。</p>\n</li>\n<li><p>分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。</p>\n</li>\n<li><p>消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。</p>\n</li>\n</ol>\n<h2 id=\"HTTP有粘包问题么？\"><a href=\"#HTTP有粘包问题么？\" class=\"headerlink\" title=\"HTTP有粘包问题么？\"></a>HTTP有粘包问题么？</h2><p>众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？</p>\n<p>HTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：</p>\n<h3 id=\"消息的明确边界\"><a href=\"#消息的明确边界\" class=\"headerlink\" title=\"消息的明确边界\"></a>消息的明确边界</h3><ul>\n<li><p>Content-Length 头部</p>\n<blockquote>\n<p>HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。</p>\n</blockquote>\n</li>\n<li><p>Chunked Transfer-Encoding</p>\n<blockquote>\n<p>对于无法提前确定内容长度的情况，HTTP&#x2F;1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法</p>\n<h2 id=\"发送方粘包\"><a href=\"#发送方粘包\" class=\"headerlink\" title=\"发送方粘包\"></a>发送方粘包</h2><p>服务端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> receivedData = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Received Data:\\r\\n &quot;</span> + receivedData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 2\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 3\\r\\n&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Messages sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下<br><img src=\"/images/sticky-packet/sender-sticky.png\" alt=\"发送方粘包\"><br>在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。</p>\n<h3 id=\"解决方案：使用消息长度前缀\"><a href=\"#解决方案：使用消息长度前缀\" class=\"headerlink\" title=\"解决方案：使用消息长度前缀\"></a>解决方案：使用消息长度前缀</h3><p>客户端代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1&quot;</span>, <span class=\"string\">&quot;Message 2&quot;</span>, <span class=\"string\">&quot;Message 3&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] messageData = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] lengthPrefix = BitConverter.GetBytes(messageData.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 发送长度前缀</span></span><br><span class=\"line\">            stream.Write(lengthPrefix, <span class=\"number\">0</span>, lengthPrefix.Length);</span><br><span class=\"line\">            <span class=\"comment\">// 发送实际消息</span></span><br><span class=\"line\">            stream.Write(messageData, <span class=\"number\">0</span>, messageData.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.ReadLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下：<br><img src=\"/images/sticky-packet/solve-sender-sticky.png\" alt=\"解决发送方粘包\"></p>\n<h2 id=\"接收方粘包\"><a href=\"#接收方粘包\" class=\"headerlink\" title=\"接收方粘包\"></a>接收方粘包</h2><p>服务端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>]; <span class=\"comment\">// 小缓冲区，故意分多次接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">&quot;Receive: &quot;</span> + part );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( bytesRead &lt; buffer.Length )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>; <span class=\"comment\">// 假设消息的最后一部分已经接收完</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> message = <span class=\"string\">&quot;This is a longer message that may be split across multiple packets.&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(message);</span><br><span class=\"line\">        stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Message sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行效果<br><img src=\"/images/sticky-packet/server-sticky.png\" alt=\"接收方粘包\"></p>\n<h3 id=\"解决方案：实现一个消息缓冲机制\"><a href=\"#解决方案：实现一个消息缓冲机制\" class=\"headerlink\" title=\"解决方案：实现一个消息缓冲机制\"></a>解决方案：实现一个消息缓冲机制</h3><p>接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server start... &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>];</span><br><span class=\"line\">        StringBuilder completeMessage = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每次接收数据并追加到消息缓冲区</span></span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            completeMessage.Append(part);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 假设消息以特定结束符结束，判断完整消息的逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( completeMessage.ToString().Contains(<span class=\"string\">&quot;...&quot;</span>) ) <span class=\"comment\">// 示例中的结束符</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Complete Message: &quot;</span> + completeMessage.ToString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下：<br><img src=\"/images/sticky-packet/solve-server-sticky.png\" alt=\"解决接收方粘包\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。</p>\n<p>希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！</p>\n"},{"title":"解读大型语言模型（LLM）API：了解流式输出的工作原理","date":"2024-11-08T02:09:20.000Z","_content":"\n最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。\n\n![gpt](./images/stream-output/gpt-1.gif)\n\n在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。\n\n----\n\n# 什么是流式输出？\n流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。\n\n传统的API 通常会一次性返回所有数据，然后客户端一次性接收。\n![normal](./images/stream-output/regular-http-communication.png)\n\n流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。\n![stream](./images/stream-output/sse-communication.png)\n\n流式输出通常用于以下几种场景：\n\n- 实时数据更新，例如股票行情、社交媒体的实时消息流。\n- 大数据处理，例如长时间查询或计算的结果逐步传输。\n- 节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。\n\n## 流式 API 的优势\n流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：\n\n+ 实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。\n+ 渐进式加载：减少等待时间，提升交互性。\n+ 流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。\n\n# 流式输出的实现方式\n在具体实现流式输出时，常用的技术包括：\n\n+ HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。\n\n+ Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。\n\n+ WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。\n\n<font color=\"#dd0000\">本文主要讲解SSE的实现。</font>\n\n# SSE数据格式\nServer-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。\n\n![sse](./images/stream-output/sse.gif)\n\n1. SSE 格式的基本结构\nSSE 使用 Content-Type: text/event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：\n\n- data：表示事件的主要数据内容，数据可以是单行或多行。\n- id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。\n- event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。\n- retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。\n2. SSE 数据格式示例\n在每条事件中，字段通过换行分隔，格式如下：\n\n```plaintext\nevent: custom-event\nid: 1\nretry: 5000\ndata: {\"message\": \"Hello, World!\"}\n```\n\n- event：自定义事件名为 custom-event。\n- id：该事件的唯一标识符为 1。\n- retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。\n- data：该事件的主要数据部分为 JSON 字符串 {\"message\": \"Hello, World!\"}。\n每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。\n\n3. 多行数据\ndata 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：\n\n```plaintext\ndata: {\"message\": \"Part 1 of the message\"}\n\ndata: {\"message\": \"Part 2 of the message\"}\n\ndata: {\"message\": \"Part 3 of the message\"}\n```\n\n在客户端收到时，这两行会被拼接成一条数据。\n\n# 示例：使用SSE实现流式输出\n\n 1. 后端实现\n后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：\n```C#\n[HttpPost, HttpGet]\n[ActionTitle(Name = \"聊天\")]\n[Route(\"chat\")]\npublic async Task Completions([FromBody] ChatDto chatDto)\n{\n    Response.ContentType = \"text/event-stream\";\n\n    await foreach( var message in GetStreamingResponseAsync(chatDto.Input) ) {\n        var data = $\"data: {message}\\n\\n\";\n        Console.Write(data);\n        var bytes = Encoding.UTF8.GetBytes(data);\n        await Response.Body.WriteAsync(bytes);\n        await Response.Body.FlushAsync();\n        await Task.Delay(100);\n    }\n}\n\npublic static async IAsyncEnumerable<string> GetStreamingResponseAsync(string userInput)\n{\n    // 随机获取一个配置\n    GptConfig gptConfig = new GptConfig() { \n        ApiKey = \"your-api-key\",\n        Version = \"2023-03-15-preview\"\n    };\n\n    HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, $\"URL_ADDRESS\");\n    request.Headers.Add(\"api-key\", gptConfig.ApiKey);\n\n    var requestBody = new {\n        messages = new[]\n        {\n            new { role = \"user\", content = userInput }\n        },       \n        stream = true\n    };\n\n    var jsonRequestBody = JsonSerializer.Serialize(requestBody);\n    request.Content = new StringContent(jsonRequestBody, Encoding.UTF8, \"application/json\");\n\n    using HttpClient httpClient = new HttpClient();\n\n    using( var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) {\n        response.EnsureSuccessStatusCode();\n        var responseStream = await response.Content.ReadAsStreamAsync();\n\n        using( var reader = new StreamReader(responseStream) ) {\n            while( !reader.EndOfStream ) {\n                var line = await reader.ReadLineAsync();\n                if( !string.IsNullOrWhiteSpace(line) && line.StartsWith(\"data:\") ) {\n                    var jsonData = line.Substring(5).Trim();\n                    if( jsonData == \"[DONE]\" )\n                        break;\n\n                    var data = JsonSerializer.Deserialize<JsonElement>(jsonData);\n\n                    // 检查是否包含 content 字段，避免报错\n                    if( data.TryGetProperty(\"choices\", out var choices) &&\n                        choices[0].TryGetProperty(\"delta\", out var delta) &&\n                        delta.TryGetProperty(\"content\", out var content) ) {\n                        yield return content.GetString();\n                    }\n                }\n            }\n        }\n    }\n\n}\n```\n\n 2. 前端实现\n在前端，我们可以使用 vue3来实现。以下是一个简单的示例：\n```javascript\nchat() {\n    fetch(`/v20/openai/chat`, {\n      method: 'POST',\n      body: JSON.stringify({ input: this.input }),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then((res) => {\n      const reader = res.body.getReader();\n\n      this.handleReadStream(reader)\n    }).finally(() => {\n      this.input = ''\n    })\n\n},\n// 流式对话\nhandleReadStream(stream) {\n  stream.read().then(({ done, value }) => {\n    if (done) {\n      return\n    }\n    const data = new TextDecoder().decode(value)\n    if (!data) {\n      return\n    }\n\n    this.message += data.replaceAll('data: ', '')\n    // 强制 Vue 渲染更新\n    this.$nextTick(() => {\n      console.log(\"Stream updated\");\n    });\n    // 递归处理流\n    this.handleReadStream(stream)\n  })\n},\n```\n 3. 实现效果\n![chat](./images/stream-output/result.gif)\n\n需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。\n![gzip](./images/stream-output/gzip.png)\n```\ndevServer: {\n    port: 9588,\n    compress: false,\n    allowedHosts: \"all\",\n    proxy: {\n      'v20': { target: 'http://localhost:2222', changeOrigin: true },\n    }\n  }\n```\n\n# 结论\n流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。","source":"_posts/stream-output.md","raw":"---\ntitle: 解读大型语言模型（LLM）API：了解流式输出的工作原理\ndate: 2024-11-08 10:09:20\ntags:\n---\n\n最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。\n\n![gpt](./images/stream-output/gpt-1.gif)\n\n在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。\n\n----\n\n# 什么是流式输出？\n流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。\n\n传统的API 通常会一次性返回所有数据，然后客户端一次性接收。\n![normal](./images/stream-output/regular-http-communication.png)\n\n流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。\n![stream](./images/stream-output/sse-communication.png)\n\n流式输出通常用于以下几种场景：\n\n- 实时数据更新，例如股票行情、社交媒体的实时消息流。\n- 大数据处理，例如长时间查询或计算的结果逐步传输。\n- 节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。\n\n## 流式 API 的优势\n流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：\n\n+ 实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。\n+ 渐进式加载：减少等待时间，提升交互性。\n+ 流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。\n\n# 流式输出的实现方式\n在具体实现流式输出时，常用的技术包括：\n\n+ HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。\n\n+ Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。\n\n+ WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。\n\n<font color=\"#dd0000\">本文主要讲解SSE的实现。</font>\n\n# SSE数据格式\nServer-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。\n\n![sse](./images/stream-output/sse.gif)\n\n1. SSE 格式的基本结构\nSSE 使用 Content-Type: text/event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：\n\n- data：表示事件的主要数据内容，数据可以是单行或多行。\n- id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。\n- event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。\n- retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。\n2. SSE 数据格式示例\n在每条事件中，字段通过换行分隔，格式如下：\n\n```plaintext\nevent: custom-event\nid: 1\nretry: 5000\ndata: {\"message\": \"Hello, World!\"}\n```\n\n- event：自定义事件名为 custom-event。\n- id：该事件的唯一标识符为 1。\n- retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。\n- data：该事件的主要数据部分为 JSON 字符串 {\"message\": \"Hello, World!\"}。\n每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。\n\n3. 多行数据\ndata 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：\n\n```plaintext\ndata: {\"message\": \"Part 1 of the message\"}\n\ndata: {\"message\": \"Part 2 of the message\"}\n\ndata: {\"message\": \"Part 3 of the message\"}\n```\n\n在客户端收到时，这两行会被拼接成一条数据。\n\n# 示例：使用SSE实现流式输出\n\n 1. 后端实现\n后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：\n```C#\n[HttpPost, HttpGet]\n[ActionTitle(Name = \"聊天\")]\n[Route(\"chat\")]\npublic async Task Completions([FromBody] ChatDto chatDto)\n{\n    Response.ContentType = \"text/event-stream\";\n\n    await foreach( var message in GetStreamingResponseAsync(chatDto.Input) ) {\n        var data = $\"data: {message}\\n\\n\";\n        Console.Write(data);\n        var bytes = Encoding.UTF8.GetBytes(data);\n        await Response.Body.WriteAsync(bytes);\n        await Response.Body.FlushAsync();\n        await Task.Delay(100);\n    }\n}\n\npublic static async IAsyncEnumerable<string> GetStreamingResponseAsync(string userInput)\n{\n    // 随机获取一个配置\n    GptConfig gptConfig = new GptConfig() { \n        ApiKey = \"your-api-key\",\n        Version = \"2023-03-15-preview\"\n    };\n\n    HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, $\"URL_ADDRESS\");\n    request.Headers.Add(\"api-key\", gptConfig.ApiKey);\n\n    var requestBody = new {\n        messages = new[]\n        {\n            new { role = \"user\", content = userInput }\n        },       \n        stream = true\n    };\n\n    var jsonRequestBody = JsonSerializer.Serialize(requestBody);\n    request.Content = new StringContent(jsonRequestBody, Encoding.UTF8, \"application/json\");\n\n    using HttpClient httpClient = new HttpClient();\n\n    using( var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) {\n        response.EnsureSuccessStatusCode();\n        var responseStream = await response.Content.ReadAsStreamAsync();\n\n        using( var reader = new StreamReader(responseStream) ) {\n            while( !reader.EndOfStream ) {\n                var line = await reader.ReadLineAsync();\n                if( !string.IsNullOrWhiteSpace(line) && line.StartsWith(\"data:\") ) {\n                    var jsonData = line.Substring(5).Trim();\n                    if( jsonData == \"[DONE]\" )\n                        break;\n\n                    var data = JsonSerializer.Deserialize<JsonElement>(jsonData);\n\n                    // 检查是否包含 content 字段，避免报错\n                    if( data.TryGetProperty(\"choices\", out var choices) &&\n                        choices[0].TryGetProperty(\"delta\", out var delta) &&\n                        delta.TryGetProperty(\"content\", out var content) ) {\n                        yield return content.GetString();\n                    }\n                }\n            }\n        }\n    }\n\n}\n```\n\n 2. 前端实现\n在前端，我们可以使用 vue3来实现。以下是一个简单的示例：\n```javascript\nchat() {\n    fetch(`/v20/openai/chat`, {\n      method: 'POST',\n      body: JSON.stringify({ input: this.input }),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then((res) => {\n      const reader = res.body.getReader();\n\n      this.handleReadStream(reader)\n    }).finally(() => {\n      this.input = ''\n    })\n\n},\n// 流式对话\nhandleReadStream(stream) {\n  stream.read().then(({ done, value }) => {\n    if (done) {\n      return\n    }\n    const data = new TextDecoder().decode(value)\n    if (!data) {\n      return\n    }\n\n    this.message += data.replaceAll('data: ', '')\n    // 强制 Vue 渲染更新\n    this.$nextTick(() => {\n      console.log(\"Stream updated\");\n    });\n    // 递归处理流\n    this.handleReadStream(stream)\n  })\n},\n```\n 3. 实现效果\n![chat](./images/stream-output/result.gif)\n\n需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。\n![gzip](./images/stream-output/gzip.png)\n```\ndevServer: {\n    port: 9588,\n    compress: false,\n    allowedHosts: \"all\",\n    proxy: {\n      'v20': { target: 'http://localhost:2222', changeOrigin: true },\n    }\n  }\n```\n\n# 结论\n流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。","slug":"stream-output","published":1,"updated":"2024-11-13T09:40:17.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmo0010m8p12co98cez","content":"<p>最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。</p>\n<p><img src=\"/./images/stream-output/gpt-1.gif\" alt=\"gpt\"></p>\n<p>在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。</p>\n<hr>\n<h1 id=\"什么是流式输出？\"><a href=\"#什么是流式输出？\" class=\"headerlink\" title=\"什么是流式输出？\"></a>什么是流式输出？</h1><p>流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。</p>\n<p>传统的API 通常会一次性返回所有数据，然后客户端一次性接收。<br><img src=\"/./images/stream-output/regular-http-communication.png\" alt=\"normal\"></p>\n<p>流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。<br><img src=\"/./images/stream-output/sse-communication.png\" alt=\"stream\"></p>\n<p>流式输出通常用于以下几种场景：</p>\n<ul>\n<li>实时数据更新，例如股票行情、社交媒体的实时消息流。</li>\n<li>大数据处理，例如长时间查询或计算的结果逐步传输。</li>\n<li>节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。</li>\n</ul>\n<h2 id=\"流式-API-的优势\"><a href=\"#流式-API-的优势\" class=\"headerlink\" title=\"流式 API 的优势\"></a>流式 API 的优势</h2><p>流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：</p>\n<ul>\n<li>实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。</li>\n<li>渐进式加载：减少等待时间，提升交互性。</li>\n<li>流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。</li>\n</ul>\n<h1 id=\"流式输出的实现方式\"><a href=\"#流式输出的实现方式\" class=\"headerlink\" title=\"流式输出的实现方式\"></a>流式输出的实现方式</h1><p>在具体实现流式输出时，常用的技术包括：</p>\n<ul>\n<li><p>HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。</p>\n</li>\n<li><p>Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。</p>\n</li>\n<li><p>WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。</p>\n</li>\n</ul>\n<p><font color=\"#dd0000\">本文主要讲解SSE的实现。</font></p>\n<h1 id=\"SSE数据格式\"><a href=\"#SSE数据格式\" class=\"headerlink\" title=\"SSE数据格式\"></a>SSE数据格式</h1><p>Server-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。</p>\n<p><img src=\"/./images/stream-output/sse.gif\" alt=\"sse\"></p>\n<ol>\n<li>SSE 格式的基本结构<br>SSE 使用 Content-Type: text&#x2F;event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：</li>\n</ol>\n<ul>\n<li>data：表示事件的主要数据内容，数据可以是单行或多行。</li>\n<li>id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。</li>\n<li>event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。</li>\n<li>retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。</li>\n</ul>\n<ol start=\"2\">\n<li>SSE 数据格式示例<br>在每条事件中，字段通过换行分隔，格式如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event: custom-event</span><br><span class=\"line\">id: 1</span><br><span class=\"line\">retry: 5000</span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Hello, World!&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>event：自定义事件名为 custom-event。</li>\n<li>id：该事件的唯一标识符为 1。</li>\n<li>retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。</li>\n<li>data：该事件的主要数据部分为 JSON 字符串 {“message”: “Hello, World!”}。<br>每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。</li>\n</ul>\n<ol start=\"3\">\n<li>多行数据<br>data 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 1 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 2 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 3 of the message&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在客户端收到时，这两行会被拼接成一条数据。</p>\n<h1 id=\"示例：使用SSE实现流式输出\"><a href=\"#示例：使用SSE实现流式输出\" class=\"headerlink\" title=\"示例：使用SSE实现流式输出\"></a>示例：使用SSE实现流式输出</h1><ol>\n<li><p>后端实现<br>后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpPost, HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;聊天&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;chat&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Completions</span>(<span class=\"params\">[FromBody] ChatDto chatDto</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.ContentType = <span class=\"string\">&quot;text/event-stream&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">foreach</span>( <span class=\"function\"><span class=\"keyword\">var</span> message <span class=\"keyword\">in</span> <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\">chatDto.Input</span>) )</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = <span class=\"string\">$&quot;data: <span class=\"subst\">&#123;message&#125;</span>\\n\\n&quot;</span>;</span><br><span class=\"line\">        Console.Write(data);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bytes = Encoding.UTF8.GetBytes(data);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.WriteAsync(bytes);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.FlushAsync();</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> IAsyncEnumerable&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\"><span class=\"built_in\">string</span> userInput</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机获取一个配置</span></span><br><span class=\"line\">    GptConfig gptConfig = <span class=\"keyword\">new</span> GptConfig() &#123; </span><br><span class=\"line\">        ApiKey = <span class=\"string\">&quot;your-api-key&quot;</span>,</span><br><span class=\"line\">        Version = <span class=\"string\">&quot;2023-03-15-preview&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpRequestMessage request = <span class=\"keyword\">new</span> HttpRequestMessage(HttpMethod.Post, <span class=\"string\">$&quot;URL_ADDRESS&quot;</span>);</span><br><span class=\"line\">    request.Headers.Add(<span class=\"string\">&quot;api-key&quot;</span>, gptConfig.ApiKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> requestBody = <span class=\"keyword\">new</span> &#123;</span><br><span class=\"line\">        messages = <span class=\"keyword\">new</span>[]</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> &#123; role = <span class=\"string\">&quot;user&quot;</span>, content = userInput &#125;</span><br><span class=\"line\">        &#125;,       </span><br><span class=\"line\">        stream = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonRequestBody = JsonSerializer.Serialize(requestBody);</span><br><span class=\"line\">    request.Content = <span class=\"keyword\">new</span> StringContent(jsonRequestBody, Encoding.UTF8, <span class=\"string\">&quot;application/json&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> HttpClient httpClient = <span class=\"keyword\">new</span> HttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> response = <span class=\"keyword\">await</span> httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) &#123;</span><br><span class=\"line\">        response.EnsureSuccessStatusCode();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> responseStream = <span class=\"keyword\">await</span> response.Content.ReadAsStreamAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> StreamReader(responseStream) ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( !reader.EndOfStream ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> line = <span class=\"keyword\">await</span> reader.ReadLineAsync();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( !<span class=\"built_in\">string</span>.IsNullOrWhiteSpace(line) &amp;&amp; line.StartsWith(<span class=\"string\">&quot;data:&quot;</span>) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> jsonData = line.Substring(<span class=\"number\">5</span>).Trim();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( jsonData == <span class=\"string\">&quot;[DONE]&quot;</span> )</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> data = JsonSerializer.Deserialize&lt;JsonElement&gt;(jsonData);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 检查是否包含 content 字段，避免报错</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( data.TryGetProperty(<span class=\"string\">&quot;choices&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> choices) &amp;&amp;</span><br><span class=\"line\">                        choices[<span class=\"number\">0</span>].TryGetProperty(<span class=\"string\">&quot;delta&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> delta) &amp;&amp;</span><br><span class=\"line\">                        delta.TryGetProperty(<span class=\"string\">&quot;content&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> content) ) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> content.GetString();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前端实现<br>在前端，我们可以使用 vue3来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">chat</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"string\">`/v20/openai/chat`</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(&#123; <span class=\"attr\">input</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> &#125;),</span><br><span class=\"line\">      <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reader = res.<span class=\"property\">body</span>.<span class=\"title function_\">getReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(reader)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"comment\">// 流式对话</span></span><br><span class=\"line\"><span class=\"title function_\">handleReadStream</span>(<span class=\"params\">stream</span>) &#123;</span><br><span class=\"line\">  stream.<span class=\"title function_\">read</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">&#123; done, value &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">new</span> <span class=\"title class_\">TextDecoder</span>().<span class=\"title function_\">decode</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> += data.<span class=\"title function_\">replaceAll</span>(<span class=\"string\">&#x27;data: &#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 强制 Vue 渲染更新</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Stream updated&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 递归处理流</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(stream)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p>实现效果<br><img src=\"/./images/stream-output/result.gif\" alt=\"chat\"></p>\n</li>\n</ol>\n<p>需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。<br><img src=\"/./images/stream-output/gzip.png\" alt=\"gzip\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    port: 9588,</span><br><span class=\"line\">    compress: false,</span><br><span class=\"line\">    allowedHosts: &quot;all&quot;,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &#x27;v20&#x27;: &#123; target: &#x27;http://localhost:2222&#x27;, changeOrigin: true &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。</p>\n<p><img src=\"/./images/stream-output/gpt-1.gif\" alt=\"gpt\"></p>\n<p>在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。</p>\n<hr>\n<h1 id=\"什么是流式输出？\"><a href=\"#什么是流式输出？\" class=\"headerlink\" title=\"什么是流式输出？\"></a>什么是流式输出？</h1><p>流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。</p>\n<p>传统的API 通常会一次性返回所有数据，然后客户端一次性接收。<br><img src=\"/./images/stream-output/regular-http-communication.png\" alt=\"normal\"></p>\n<p>流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。<br><img src=\"/./images/stream-output/sse-communication.png\" alt=\"stream\"></p>\n<p>流式输出通常用于以下几种场景：</p>\n<ul>\n<li>实时数据更新，例如股票行情、社交媒体的实时消息流。</li>\n<li>大数据处理，例如长时间查询或计算的结果逐步传输。</li>\n<li>节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。</li>\n</ul>\n<h2 id=\"流式-API-的优势\"><a href=\"#流式-API-的优势\" class=\"headerlink\" title=\"流式 API 的优势\"></a>流式 API 的优势</h2><p>流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：</p>\n<ul>\n<li>实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。</li>\n<li>渐进式加载：减少等待时间，提升交互性。</li>\n<li>流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。</li>\n</ul>\n<h1 id=\"流式输出的实现方式\"><a href=\"#流式输出的实现方式\" class=\"headerlink\" title=\"流式输出的实现方式\"></a>流式输出的实现方式</h1><p>在具体实现流式输出时，常用的技术包括：</p>\n<ul>\n<li><p>HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。</p>\n</li>\n<li><p>Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。</p>\n</li>\n<li><p>WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。</p>\n</li>\n</ul>\n<p><font color=\"#dd0000\">本文主要讲解SSE的实现。</font></p>\n<h1 id=\"SSE数据格式\"><a href=\"#SSE数据格式\" class=\"headerlink\" title=\"SSE数据格式\"></a>SSE数据格式</h1><p>Server-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。</p>\n<p><img src=\"/./images/stream-output/sse.gif\" alt=\"sse\"></p>\n<ol>\n<li>SSE 格式的基本结构<br>SSE 使用 Content-Type: text&#x2F;event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：</li>\n</ol>\n<ul>\n<li>data：表示事件的主要数据内容，数据可以是单行或多行。</li>\n<li>id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。</li>\n<li>event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。</li>\n<li>retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。</li>\n</ul>\n<ol start=\"2\">\n<li>SSE 数据格式示例<br>在每条事件中，字段通过换行分隔，格式如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event: custom-event</span><br><span class=\"line\">id: 1</span><br><span class=\"line\">retry: 5000</span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Hello, World!&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>event：自定义事件名为 custom-event。</li>\n<li>id：该事件的唯一标识符为 1。</li>\n<li>retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。</li>\n<li>data：该事件的主要数据部分为 JSON 字符串 {“message”: “Hello, World!”}。<br>每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。</li>\n</ul>\n<ol start=\"3\">\n<li>多行数据<br>data 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 1 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 2 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 3 of the message&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在客户端收到时，这两行会被拼接成一条数据。</p>\n<h1 id=\"示例：使用SSE实现流式输出\"><a href=\"#示例：使用SSE实现流式输出\" class=\"headerlink\" title=\"示例：使用SSE实现流式输出\"></a>示例：使用SSE实现流式输出</h1><ol>\n<li><p>后端实现<br>后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpPost, HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;聊天&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;chat&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Completions</span>(<span class=\"params\">[FromBody] ChatDto chatDto</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.ContentType = <span class=\"string\">&quot;text/event-stream&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">foreach</span>( <span class=\"function\"><span class=\"keyword\">var</span> message <span class=\"keyword\">in</span> <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\">chatDto.Input</span>) )</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = <span class=\"string\">$&quot;data: <span class=\"subst\">&#123;message&#125;</span>\\n\\n&quot;</span>;</span><br><span class=\"line\">        Console.Write(data);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bytes = Encoding.UTF8.GetBytes(data);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.WriteAsync(bytes);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.FlushAsync();</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> IAsyncEnumerable&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\"><span class=\"built_in\">string</span> userInput</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机获取一个配置</span></span><br><span class=\"line\">    GptConfig gptConfig = <span class=\"keyword\">new</span> GptConfig() &#123; </span><br><span class=\"line\">        ApiKey = <span class=\"string\">&quot;your-api-key&quot;</span>,</span><br><span class=\"line\">        Version = <span class=\"string\">&quot;2023-03-15-preview&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpRequestMessage request = <span class=\"keyword\">new</span> HttpRequestMessage(HttpMethod.Post, <span class=\"string\">$&quot;URL_ADDRESS&quot;</span>);</span><br><span class=\"line\">    request.Headers.Add(<span class=\"string\">&quot;api-key&quot;</span>, gptConfig.ApiKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> requestBody = <span class=\"keyword\">new</span> &#123;</span><br><span class=\"line\">        messages = <span class=\"keyword\">new</span>[]</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> &#123; role = <span class=\"string\">&quot;user&quot;</span>, content = userInput &#125;</span><br><span class=\"line\">        &#125;,       </span><br><span class=\"line\">        stream = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonRequestBody = JsonSerializer.Serialize(requestBody);</span><br><span class=\"line\">    request.Content = <span class=\"keyword\">new</span> StringContent(jsonRequestBody, Encoding.UTF8, <span class=\"string\">&quot;application/json&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> HttpClient httpClient = <span class=\"keyword\">new</span> HttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> response = <span class=\"keyword\">await</span> httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) &#123;</span><br><span class=\"line\">        response.EnsureSuccessStatusCode();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> responseStream = <span class=\"keyword\">await</span> response.Content.ReadAsStreamAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> StreamReader(responseStream) ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( !reader.EndOfStream ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> line = <span class=\"keyword\">await</span> reader.ReadLineAsync();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( !<span class=\"built_in\">string</span>.IsNullOrWhiteSpace(line) &amp;&amp; line.StartsWith(<span class=\"string\">&quot;data:&quot;</span>) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> jsonData = line.Substring(<span class=\"number\">5</span>).Trim();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( jsonData == <span class=\"string\">&quot;[DONE]&quot;</span> )</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> data = JsonSerializer.Deserialize&lt;JsonElement&gt;(jsonData);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 检查是否包含 content 字段，避免报错</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( data.TryGetProperty(<span class=\"string\">&quot;choices&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> choices) &amp;&amp;</span><br><span class=\"line\">                        choices[<span class=\"number\">0</span>].TryGetProperty(<span class=\"string\">&quot;delta&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> delta) &amp;&amp;</span><br><span class=\"line\">                        delta.TryGetProperty(<span class=\"string\">&quot;content&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> content) ) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> content.GetString();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前端实现<br>在前端，我们可以使用 vue3来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">chat</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"string\">`/v20/openai/chat`</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(&#123; <span class=\"attr\">input</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> &#125;),</span><br><span class=\"line\">      <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reader = res.<span class=\"property\">body</span>.<span class=\"title function_\">getReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(reader)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"comment\">// 流式对话</span></span><br><span class=\"line\"><span class=\"title function_\">handleReadStream</span>(<span class=\"params\">stream</span>) &#123;</span><br><span class=\"line\">  stream.<span class=\"title function_\">read</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">&#123; done, value &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">new</span> <span class=\"title class_\">TextDecoder</span>().<span class=\"title function_\">decode</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> += data.<span class=\"title function_\">replaceAll</span>(<span class=\"string\">&#x27;data: &#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 强制 Vue 渲染更新</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Stream updated&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 递归处理流</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(stream)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p>实现效果<br><img src=\"/./images/stream-output/result.gif\" alt=\"chat\"></p>\n</li>\n</ol>\n<p>需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。<br><img src=\"/./images/stream-output/gzip.png\" alt=\"gzip\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    port: 9588,</span><br><span class=\"line\">    compress: false,</span><br><span class=\"line\">    allowedHosts: &quot;all&quot;,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &#x27;v20&#x27;: &#123; target: &#x27;http://localhost:2222&#x27;, changeOrigin: true &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。</p>\n"},{"title":"WebRTC入门：让浏览器之间的实时通信变得简单","date":"2024-12-16T09:23:31.000Z","_content":"\n# 什么是WebRTC？\nWebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。\n\nWebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。\n\n# WebRTC的三大核心技术\nWebRTC的功能依赖于三个主要的API：\n\n1. getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。\n\n2. RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。\n\n3. RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。\n\n# WebRTC如何工作？\nWebRTC的工作原理可以概括为以下几个步骤：\n\n![结构](./images/webrtc/architecture.png)\n\n1. 媒体设备访问：使用getUserMedia API获取音视频流。\n\n2. 建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。\n\n3. ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。\n\n4. 数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。\n\n# SDP是什么？\nSDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。\n\n在 WebRTC 中，SDP 主要用于两个目的：\n\n+ 描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。\n+ 建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。\n\n##  WebRTC 中的 SDP 交换流程\nWebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：\n\n### 创建 Offer 和 Answer\n- Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。\n- Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。\n\n## SDP 交换过程\n1. 发起方创建 SDP offer：\n- 发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。\n- 发起方将 offer 通过信令通道发送给接收方。\n\n2. 接收方收到 offer 后创建 SDP answer：\n- 接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。\n- 接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。\n\n3. 双方交换 ICE 候选：\n- 在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。\n\n\n# 使用WebRTC实现文件传输\n下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。\n![流程](./images/webrtc/process.png)\n\n1. 连接信令服务器\nWebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。\n\n```javascript\nthis.connection = new HubConnectionBuilder()\n    .withUrl('http://localhost:5217/signalr')  // .NET SignalR 服务的 URL\n    .build();\n\n// 开始连接\ntry {\nawait this.connection.start();\nthis.isConnected = true;\nthis.connectionId = this.connection.connectionId;\nElMessage.success('SignalR 连接成功！');\n// 获取所有连接的 ID\nthis.connection.invoke('GetAllConnections');\n// 初始化 WebRTC\nthis.setupWebRTC();\n} catch (err) {\nElMessage.error('SignalR 连接失败！');\n}\n```\n这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。\n![连接](./images/webrtc/connections.png)\n\n2. 初始化 WebRTC\n创建一个RTCPeerConnection实例\n\n```javascript\nasync setupWebRTC() {\n    this.rtcPeerConnection = new RTCPeerConnection();\n\n    // 收集 ICE 候选并发送给目标连接\n    this.rtcPeerConnection.onicecandidate = event => {\n    if (event.candidate) {\n        console.log('收集到 ICE 候选:', event.candidate);\n        this.sendIceCandidate(event.candidate);\n    }\n    };\n\n    // 监听连接状态变化\n    this.rtcPeerConnection.oniceconnectionstatechange = () => {\n    console.log('ICE 连接状态:', this.rtcPeerConnection.iceConnectionState);\n    if (this.rtcPeerConnection.iceConnectionState === 'failed') {\n        console.error('ICE 连接失败！');\n    }\n    };\n\n    this.rtcPeerConnection.onconnectionstatechange = () => {\n    console.log('WebRTC 连接状态:', this.rtcPeerConnection.connectionState);\n    if (this.rtcPeerConnection.connectionState === 'failed') {\n        console.error('WebRTC 连接失败！');\n    }\n    };\n\n    this.setupDataChannel()\n}\n```\n\n3. 发送信令并建立连接\n在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。\n\n```javascript\n// 发送 Offer 给目标客户端\nasync sendOffer() {\n    if (this.targetConnectionId) {\n    const offer = await this.rtcPeerConnection.createOffer();\n    await this.rtcPeerConnection.setLocalDescription(offer);\n    try {\n        console.log('发送 Offer:', offer);\n        await this.connection.invoke('SendOffer', offer, this.targetConnectionId);\n    } catch (err) {\n        console.error('发送 Offer 失败：', err);\n    }\n    }\n},\n\n// 目标客户端接收到的 Offer，创建 Answer\nasync receiveOffer(offer) {\n    console.log('收到 Offer:', offer);\n    await this.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n    const answer = await this.rtcPeerConnection.createAnswer();\n    console.log(\"创建 Answer 成功\");\n    await this.rtcPeerConnection.setLocalDescription(answer);\n    console.log(\"Local Description 设置成功\");\n    this.connection.invoke('SendAnswer', answer, this.targetConnectionId);\n},\n```\n4. 传输文件\n在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。\n\n```javascript\n// 选择文件\nhandleFileSelection(event) {\n    const file = event.target.files[0];\n    if (file) {\n    this.file = file;\n    console.log('已选择文件:', file.name);\n    }\n},\n\n// 发送文件\nsendFile() {\n    if (this.dataChannel && this.file) {\n    const chunkSize = 16384;  // 设置块大小为 16KB\n    const fileReader = new FileReader();\n\n    let offset = 0;\n\n    // 发送文件基本信息（如文件名和文件大小）\n    const fileInfo = {\n        name: this.file.name,\n        size: this.file.size,\n    };\n\n    this.dataChannel.send(JSON.stringify(fileInfo));  // 发送文件基本信息\n\n    const sendNextChunk = () => {\n        const fileSlice = this.file.slice(offset, offset + chunkSize);\n        fileReader.onload = () => {\n        this.dataChannel.send(fileReader.result);  // 发送文件块\n        offset += chunkSize;\n        if (offset < this.file.size) {\n            sendNextChunk();  // 继续发送下一个块\n        } else {\n            console.log('文件发送完毕');\n        }\n        };\n        fileReader.readAsArrayBuffer(fileSlice);  // 读取文件块为 ArrayBuffer\n    };\n\n    sendNextChunk();  // 开始发送文件块\n    } else {\n    console.error('数据通道不可用或未选择文件');\n    }\n},\n```\n\n打完收工，最后我们来看看实现的效果：\n![效果](./images/webrtc/result.gif)\n\n# WebRTC的实际应用\nWebRTC已被广泛应用于各种实时通信场景，包括：\n\n1. 视频会议：如Zoom、Google Meet等平台都使用了WebRTC。\n2. 在线教育：利用WebRTC实现师生之间的实时互动和交流。\n3. 文件传输：通过RTCDataChannel实现浏览器间的文件传输。\n4. 在线客服：实现企业与客户之间的实时视频或语音通信。\n\n# WebRTC的优势与挑战\n## 优势\n- 无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。\n- 低延迟：WebRTC专为实时通信设计，支持高效的数据传输。\n- 跨平台：支持各种操作系统和设备，具有良好的兼容性。\n## 挑战\n- NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN/TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。\n- 信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。\n- 浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。\n\n# 小结\nWebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。\n\n----\n\n本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。\n","source":"_posts/web-rtc.md","raw":"---\ntitle: WebRTC入门：让浏览器之间的实时通信变得简单\ndate: 2024-12-16 17:23:31\ntags:\n---\n\n# 什么是WebRTC？\nWebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。\n\nWebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。\n\n# WebRTC的三大核心技术\nWebRTC的功能依赖于三个主要的API：\n\n1. getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。\n\n2. RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。\n\n3. RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。\n\n# WebRTC如何工作？\nWebRTC的工作原理可以概括为以下几个步骤：\n\n![结构](./images/webrtc/architecture.png)\n\n1. 媒体设备访问：使用getUserMedia API获取音视频流。\n\n2. 建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。\n\n3. ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。\n\n4. 数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。\n\n# SDP是什么？\nSDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。\n\n在 WebRTC 中，SDP 主要用于两个目的：\n\n+ 描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。\n+ 建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。\n\n##  WebRTC 中的 SDP 交换流程\nWebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：\n\n### 创建 Offer 和 Answer\n- Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。\n- Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。\n\n## SDP 交换过程\n1. 发起方创建 SDP offer：\n- 发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。\n- 发起方将 offer 通过信令通道发送给接收方。\n\n2. 接收方收到 offer 后创建 SDP answer：\n- 接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。\n- 接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。\n\n3. 双方交换 ICE 候选：\n- 在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。\n\n\n# 使用WebRTC实现文件传输\n下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。\n![流程](./images/webrtc/process.png)\n\n1. 连接信令服务器\nWebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。\n\n```javascript\nthis.connection = new HubConnectionBuilder()\n    .withUrl('http://localhost:5217/signalr')  // .NET SignalR 服务的 URL\n    .build();\n\n// 开始连接\ntry {\nawait this.connection.start();\nthis.isConnected = true;\nthis.connectionId = this.connection.connectionId;\nElMessage.success('SignalR 连接成功！');\n// 获取所有连接的 ID\nthis.connection.invoke('GetAllConnections');\n// 初始化 WebRTC\nthis.setupWebRTC();\n} catch (err) {\nElMessage.error('SignalR 连接失败！');\n}\n```\n这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。\n![连接](./images/webrtc/connections.png)\n\n2. 初始化 WebRTC\n创建一个RTCPeerConnection实例\n\n```javascript\nasync setupWebRTC() {\n    this.rtcPeerConnection = new RTCPeerConnection();\n\n    // 收集 ICE 候选并发送给目标连接\n    this.rtcPeerConnection.onicecandidate = event => {\n    if (event.candidate) {\n        console.log('收集到 ICE 候选:', event.candidate);\n        this.sendIceCandidate(event.candidate);\n    }\n    };\n\n    // 监听连接状态变化\n    this.rtcPeerConnection.oniceconnectionstatechange = () => {\n    console.log('ICE 连接状态:', this.rtcPeerConnection.iceConnectionState);\n    if (this.rtcPeerConnection.iceConnectionState === 'failed') {\n        console.error('ICE 连接失败！');\n    }\n    };\n\n    this.rtcPeerConnection.onconnectionstatechange = () => {\n    console.log('WebRTC 连接状态:', this.rtcPeerConnection.connectionState);\n    if (this.rtcPeerConnection.connectionState === 'failed') {\n        console.error('WebRTC 连接失败！');\n    }\n    };\n\n    this.setupDataChannel()\n}\n```\n\n3. 发送信令并建立连接\n在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。\n\n```javascript\n// 发送 Offer 给目标客户端\nasync sendOffer() {\n    if (this.targetConnectionId) {\n    const offer = await this.rtcPeerConnection.createOffer();\n    await this.rtcPeerConnection.setLocalDescription(offer);\n    try {\n        console.log('发送 Offer:', offer);\n        await this.connection.invoke('SendOffer', offer, this.targetConnectionId);\n    } catch (err) {\n        console.error('发送 Offer 失败：', err);\n    }\n    }\n},\n\n// 目标客户端接收到的 Offer，创建 Answer\nasync receiveOffer(offer) {\n    console.log('收到 Offer:', offer);\n    await this.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n    const answer = await this.rtcPeerConnection.createAnswer();\n    console.log(\"创建 Answer 成功\");\n    await this.rtcPeerConnection.setLocalDescription(answer);\n    console.log(\"Local Description 设置成功\");\n    this.connection.invoke('SendAnswer', answer, this.targetConnectionId);\n},\n```\n4. 传输文件\n在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。\n\n```javascript\n// 选择文件\nhandleFileSelection(event) {\n    const file = event.target.files[0];\n    if (file) {\n    this.file = file;\n    console.log('已选择文件:', file.name);\n    }\n},\n\n// 发送文件\nsendFile() {\n    if (this.dataChannel && this.file) {\n    const chunkSize = 16384;  // 设置块大小为 16KB\n    const fileReader = new FileReader();\n\n    let offset = 0;\n\n    // 发送文件基本信息（如文件名和文件大小）\n    const fileInfo = {\n        name: this.file.name,\n        size: this.file.size,\n    };\n\n    this.dataChannel.send(JSON.stringify(fileInfo));  // 发送文件基本信息\n\n    const sendNextChunk = () => {\n        const fileSlice = this.file.slice(offset, offset + chunkSize);\n        fileReader.onload = () => {\n        this.dataChannel.send(fileReader.result);  // 发送文件块\n        offset += chunkSize;\n        if (offset < this.file.size) {\n            sendNextChunk();  // 继续发送下一个块\n        } else {\n            console.log('文件发送完毕');\n        }\n        };\n        fileReader.readAsArrayBuffer(fileSlice);  // 读取文件块为 ArrayBuffer\n    };\n\n    sendNextChunk();  // 开始发送文件块\n    } else {\n    console.error('数据通道不可用或未选择文件');\n    }\n},\n```\n\n打完收工，最后我们来看看实现的效果：\n![效果](./images/webrtc/result.gif)\n\n# WebRTC的实际应用\nWebRTC已被广泛应用于各种实时通信场景，包括：\n\n1. 视频会议：如Zoom、Google Meet等平台都使用了WebRTC。\n2. 在线教育：利用WebRTC实现师生之间的实时互动和交流。\n3. 文件传输：通过RTCDataChannel实现浏览器间的文件传输。\n4. 在线客服：实现企业与客户之间的实时视频或语音通信。\n\n# WebRTC的优势与挑战\n## 优势\n- 无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。\n- 低延迟：WebRTC专为实时通信设计，支持高效的数据传输。\n- 跨平台：支持各种操作系统和设备，具有良好的兼容性。\n## 挑战\n- NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN/TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。\n- 信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。\n- 浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。\n\n# 小结\nWebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。\n\n----\n\n本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。\n","slug":"web-rtc","published":1,"updated":"2024-12-17T06:53:18.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm53cihmo0011m8p1amt05o7d","content":"<h1 id=\"什么是WebRTC？\"><a href=\"#什么是WebRTC？\" class=\"headerlink\" title=\"什么是WebRTC？\"></a>什么是WebRTC？</h1><p>WebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。</p>\n<p>WebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。</p>\n<h1 id=\"WebRTC的三大核心技术\"><a href=\"#WebRTC的三大核心技术\" class=\"headerlink\" title=\"WebRTC的三大核心技术\"></a>WebRTC的三大核心技术</h1><p>WebRTC的功能依赖于三个主要的API：</p>\n<ol>\n<li><p>getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。</p>\n</li>\n<li><p>RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。</p>\n</li>\n<li><p>RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。</p>\n</li>\n</ol>\n<h1 id=\"WebRTC如何工作？\"><a href=\"#WebRTC如何工作？\" class=\"headerlink\" title=\"WebRTC如何工作？\"></a>WebRTC如何工作？</h1><p>WebRTC的工作原理可以概括为以下几个步骤：</p>\n<p><img src=\"/./images/webrtc/architecture.png\" alt=\"结构\"></p>\n<ol>\n<li><p>媒体设备访问：使用getUserMedia API获取音视频流。</p>\n</li>\n<li><p>建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。</p>\n</li>\n<li><p>ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。</p>\n</li>\n<li><p>数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。</p>\n</li>\n</ol>\n<h1 id=\"SDP是什么？\"><a href=\"#SDP是什么？\" class=\"headerlink\" title=\"SDP是什么？\"></a>SDP是什么？</h1><p>SDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。</p>\n<p>在 WebRTC 中，SDP 主要用于两个目的：</p>\n<ul>\n<li>描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。</li>\n<li>建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。</li>\n</ul>\n<h2 id=\"WebRTC-中的-SDP-交换流程\"><a href=\"#WebRTC-中的-SDP-交换流程\" class=\"headerlink\" title=\"WebRTC 中的 SDP 交换流程\"></a>WebRTC 中的 SDP 交换流程</h2><p>WebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：</p>\n<h3 id=\"创建-Offer-和-Answer\"><a href=\"#创建-Offer-和-Answer\" class=\"headerlink\" title=\"创建 Offer 和 Answer\"></a>创建 Offer 和 Answer</h3><ul>\n<li>Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。</li>\n<li>Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。</li>\n</ul>\n<h2 id=\"SDP-交换过程\"><a href=\"#SDP-交换过程\" class=\"headerlink\" title=\"SDP 交换过程\"></a>SDP 交换过程</h2><ol>\n<li>发起方创建 SDP offer：</li>\n</ol>\n<ul>\n<li>发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。</li>\n<li>发起方将 offer 通过信令通道发送给接收方。</li>\n</ul>\n<ol start=\"2\">\n<li>接收方收到 offer 后创建 SDP answer：</li>\n</ol>\n<ul>\n<li>接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。</li>\n<li>接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。</li>\n</ul>\n<ol start=\"3\">\n<li>双方交换 ICE 候选：</li>\n</ol>\n<ul>\n<li>在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。</li>\n</ul>\n<h1 id=\"使用WebRTC实现文件传输\"><a href=\"#使用WebRTC实现文件传输\" class=\"headerlink\" title=\"使用WebRTC实现文件传输\"></a>使用WebRTC实现文件传输</h1><p>下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。<br><img src=\"/./images/webrtc/process.png\" alt=\"流程\"></p>\n<ol>\n<li>连接信令服务器<br>WebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">HubConnectionBuilder</span>()</span><br><span class=\"line\">    .<span class=\"title function_\">withUrl</span>(<span class=\"string\">&#x27;http://localhost:5217/signalr&#x27;</span>)  <span class=\"comment\">// .NET SignalR 服务的 URL</span></span><br><span class=\"line\">    .<span class=\"title function_\">build</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始连接</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">start</span>();</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">isConnected</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connectionId</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"property\">connectionId</span>;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;SignalR 连接成功！&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取所有连接的 ID</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;GetAllConnections&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 初始化 WebRTC</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setupWebRTC</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;SignalR 连接失败！&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。<br><img src=\"/./images/webrtc/connections.png\" alt=\"连接\"></p>\n<ol start=\"2\">\n<li>初始化 WebRTC<br>创建一个RTCPeerConnection实例</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">setupWebRTC</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">RTCPeerConnection</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 收集 ICE 候选并发送给目标连接</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onicecandidate</span> = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.<span class=\"property\">candidate</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收集到 ICE 候选:&#x27;</span>, event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">sendIceCandidate</span>(event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听连接状态变化</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">oniceconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ICE 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;ICE 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;WebRTC 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;WebRTC 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setupDataChannel</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>发送信令并建立连接<br>在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送 Offer 给目标客户端</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">sendOffer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> offer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createOffer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(offer);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;发送 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendOffer&#x27;</span>, offer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;发送 Offer 失败：&#x27;</span>, err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标客户端接收到的 Offer，创建 Answer</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">receiveOffer</span>(<span class=\"params\">offer</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收到 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setRemoteDescription</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RTCSessionDescription</span>(offer));</span><br><span class=\"line\">    <span class=\"keyword\">const</span> answer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createAnswer</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;创建 Answer 成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(answer);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Local Description 设置成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendAnswer&#x27;</span>, answer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>传输文件<br>在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择文件</span></span><br><span class=\"line\"><span class=\"title function_\">handleFileSelection</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> file = event.<span class=\"property\">target</span>.<span class=\"property\">files</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">file</span> = file;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;已选择文件:&#x27;</span>, file.<span class=\"property\">name</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送文件</span></span><br><span class=\"line\"><span class=\"title function_\">sendFile</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> chunkSize = <span class=\"number\">16384</span>;  <span class=\"comment\">// 设置块大小为 16KB</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件基本信息（如文件名和文件大小）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileInfo = &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">name</span>,</span><br><span class=\"line\">        <span class=\"attr\">size</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(fileInfo));  <span class=\"comment\">// 发送文件基本信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">sendNextChunk</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> fileSlice = <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"title function_\">slice</span>(offset, offset + chunkSize);</span><br><span class=\"line\">        fileReader.<span class=\"property\">onload</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(fileReader.<span class=\"property\">result</span>);  <span class=\"comment\">// 发送文件块</span></span><br><span class=\"line\">        offset += chunkSize;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (offset &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 继续发送下一个块</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;文件发送完毕&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        fileReader.<span class=\"title function_\">readAsArrayBuffer</span>(fileSlice);  <span class=\"comment\">// 读取文件块为 ArrayBuffer</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 开始发送文件块</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;数据通道不可用或未选择文件&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>打完收工，最后我们来看看实现的效果：<br><img src=\"/./images/webrtc/result.gif\" alt=\"效果\"></p>\n<h1 id=\"WebRTC的实际应用\"><a href=\"#WebRTC的实际应用\" class=\"headerlink\" title=\"WebRTC的实际应用\"></a>WebRTC的实际应用</h1><p>WebRTC已被广泛应用于各种实时通信场景，包括：</p>\n<ol>\n<li>视频会议：如Zoom、Google Meet等平台都使用了WebRTC。</li>\n<li>在线教育：利用WebRTC实现师生之间的实时互动和交流。</li>\n<li>文件传输：通过RTCDataChannel实现浏览器间的文件传输。</li>\n<li>在线客服：实现企业与客户之间的实时视频或语音通信。</li>\n</ol>\n<h1 id=\"WebRTC的优势与挑战\"><a href=\"#WebRTC的优势与挑战\" class=\"headerlink\" title=\"WebRTC的优势与挑战\"></a>WebRTC的优势与挑战</h1><h2 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h2><ul>\n<li>无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。</li>\n<li>低延迟：WebRTC专为实时通信设计，支持高效的数据传输。</li>\n<li>跨平台：支持各种操作系统和设备，具有良好的兼容性。</li>\n</ul>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><ul>\n<li>NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN&#x2F;TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。</li>\n<li>信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。</li>\n<li>浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>WebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。</p>\n<hr>\n<p>本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是WebRTC？\"><a href=\"#什么是WebRTC？\" class=\"headerlink\" title=\"什么是WebRTC？\"></a>什么是WebRTC？</h1><p>WebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。</p>\n<p>WebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。</p>\n<h1 id=\"WebRTC的三大核心技术\"><a href=\"#WebRTC的三大核心技术\" class=\"headerlink\" title=\"WebRTC的三大核心技术\"></a>WebRTC的三大核心技术</h1><p>WebRTC的功能依赖于三个主要的API：</p>\n<ol>\n<li><p>getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。</p>\n</li>\n<li><p>RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。</p>\n</li>\n<li><p>RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。</p>\n</li>\n</ol>\n<h1 id=\"WebRTC如何工作？\"><a href=\"#WebRTC如何工作？\" class=\"headerlink\" title=\"WebRTC如何工作？\"></a>WebRTC如何工作？</h1><p>WebRTC的工作原理可以概括为以下几个步骤：</p>\n<p><img src=\"/./images/webrtc/architecture.png\" alt=\"结构\"></p>\n<ol>\n<li><p>媒体设备访问：使用getUserMedia API获取音视频流。</p>\n</li>\n<li><p>建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。</p>\n</li>\n<li><p>ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。</p>\n</li>\n<li><p>数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。</p>\n</li>\n</ol>\n<h1 id=\"SDP是什么？\"><a href=\"#SDP是什么？\" class=\"headerlink\" title=\"SDP是什么？\"></a>SDP是什么？</h1><p>SDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。</p>\n<p>在 WebRTC 中，SDP 主要用于两个目的：</p>\n<ul>\n<li>描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。</li>\n<li>建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。</li>\n</ul>\n<h2 id=\"WebRTC-中的-SDP-交换流程\"><a href=\"#WebRTC-中的-SDP-交换流程\" class=\"headerlink\" title=\"WebRTC 中的 SDP 交换流程\"></a>WebRTC 中的 SDP 交换流程</h2><p>WebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：</p>\n<h3 id=\"创建-Offer-和-Answer\"><a href=\"#创建-Offer-和-Answer\" class=\"headerlink\" title=\"创建 Offer 和 Answer\"></a>创建 Offer 和 Answer</h3><ul>\n<li>Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。</li>\n<li>Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。</li>\n</ul>\n<h2 id=\"SDP-交换过程\"><a href=\"#SDP-交换过程\" class=\"headerlink\" title=\"SDP 交换过程\"></a>SDP 交换过程</h2><ol>\n<li>发起方创建 SDP offer：</li>\n</ol>\n<ul>\n<li>发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。</li>\n<li>发起方将 offer 通过信令通道发送给接收方。</li>\n</ul>\n<ol start=\"2\">\n<li>接收方收到 offer 后创建 SDP answer：</li>\n</ol>\n<ul>\n<li>接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。</li>\n<li>接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。</li>\n</ul>\n<ol start=\"3\">\n<li>双方交换 ICE 候选：</li>\n</ol>\n<ul>\n<li>在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。</li>\n</ul>\n<h1 id=\"使用WebRTC实现文件传输\"><a href=\"#使用WebRTC实现文件传输\" class=\"headerlink\" title=\"使用WebRTC实现文件传输\"></a>使用WebRTC实现文件传输</h1><p>下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。<br><img src=\"/./images/webrtc/process.png\" alt=\"流程\"></p>\n<ol>\n<li>连接信令服务器<br>WebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">HubConnectionBuilder</span>()</span><br><span class=\"line\">    .<span class=\"title function_\">withUrl</span>(<span class=\"string\">&#x27;http://localhost:5217/signalr&#x27;</span>)  <span class=\"comment\">// .NET SignalR 服务的 URL</span></span><br><span class=\"line\">    .<span class=\"title function_\">build</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始连接</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">start</span>();</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">isConnected</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connectionId</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"property\">connectionId</span>;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;SignalR 连接成功！&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取所有连接的 ID</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;GetAllConnections&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 初始化 WebRTC</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setupWebRTC</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;SignalR 连接失败！&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。<br><img src=\"/./images/webrtc/connections.png\" alt=\"连接\"></p>\n<ol start=\"2\">\n<li>初始化 WebRTC<br>创建一个RTCPeerConnection实例</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">setupWebRTC</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">RTCPeerConnection</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 收集 ICE 候选并发送给目标连接</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onicecandidate</span> = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.<span class=\"property\">candidate</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收集到 ICE 候选:&#x27;</span>, event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">sendIceCandidate</span>(event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听连接状态变化</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">oniceconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ICE 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;ICE 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;WebRTC 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;WebRTC 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setupDataChannel</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>发送信令并建立连接<br>在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送 Offer 给目标客户端</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">sendOffer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> offer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createOffer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(offer);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;发送 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendOffer&#x27;</span>, offer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;发送 Offer 失败：&#x27;</span>, err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标客户端接收到的 Offer，创建 Answer</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">receiveOffer</span>(<span class=\"params\">offer</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收到 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setRemoteDescription</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RTCSessionDescription</span>(offer));</span><br><span class=\"line\">    <span class=\"keyword\">const</span> answer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createAnswer</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;创建 Answer 成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(answer);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Local Description 设置成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendAnswer&#x27;</span>, answer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>传输文件<br>在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择文件</span></span><br><span class=\"line\"><span class=\"title function_\">handleFileSelection</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> file = event.<span class=\"property\">target</span>.<span class=\"property\">files</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">file</span> = file;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;已选择文件:&#x27;</span>, file.<span class=\"property\">name</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送文件</span></span><br><span class=\"line\"><span class=\"title function_\">sendFile</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> chunkSize = <span class=\"number\">16384</span>;  <span class=\"comment\">// 设置块大小为 16KB</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件基本信息（如文件名和文件大小）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileInfo = &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">name</span>,</span><br><span class=\"line\">        <span class=\"attr\">size</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(fileInfo));  <span class=\"comment\">// 发送文件基本信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">sendNextChunk</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> fileSlice = <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"title function_\">slice</span>(offset, offset + chunkSize);</span><br><span class=\"line\">        fileReader.<span class=\"property\">onload</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(fileReader.<span class=\"property\">result</span>);  <span class=\"comment\">// 发送文件块</span></span><br><span class=\"line\">        offset += chunkSize;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (offset &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 继续发送下一个块</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;文件发送完毕&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        fileReader.<span class=\"title function_\">readAsArrayBuffer</span>(fileSlice);  <span class=\"comment\">// 读取文件块为 ArrayBuffer</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 开始发送文件块</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;数据通道不可用或未选择文件&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>打完收工，最后我们来看看实现的效果：<br><img src=\"/./images/webrtc/result.gif\" alt=\"效果\"></p>\n<h1 id=\"WebRTC的实际应用\"><a href=\"#WebRTC的实际应用\" class=\"headerlink\" title=\"WebRTC的实际应用\"></a>WebRTC的实际应用</h1><p>WebRTC已被广泛应用于各种实时通信场景，包括：</p>\n<ol>\n<li>视频会议：如Zoom、Google Meet等平台都使用了WebRTC。</li>\n<li>在线教育：利用WebRTC实现师生之间的实时互动和交流。</li>\n<li>文件传输：通过RTCDataChannel实现浏览器间的文件传输。</li>\n<li>在线客服：实现企业与客户之间的实时视频或语音通信。</li>\n</ol>\n<h1 id=\"WebRTC的优势与挑战\"><a href=\"#WebRTC的优势与挑战\" class=\"headerlink\" title=\"WebRTC的优势与挑战\"></a>WebRTC的优势与挑战</h1><h2 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h2><ul>\n<li>无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。</li>\n<li>低延迟：WebRTC专为实时通信设计，支持高效的数据传输。</li>\n<li>跨平台：支持各种操作系统和设备，具有良好的兼容性。</li>\n</ul>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><ul>\n<li>NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN&#x2F;TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。</li>\n<li>信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。</li>\n<li>浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>WebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。</p>\n<hr>\n<p>本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。</p>\n"},{"title":"程序日志设计与存储：实践与注意事项(一)","date":"2024-12-18T08:34:05.000Z","_content":"# 引言\n程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。\n\n本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。\n\n----\n\n# 什么样的程序日志是优秀的？\n之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。\n\n![自信](./images/log/confident.png)\n结果我实际看到的是这样的场景是下面这样的\n\n![日志](./images/log/bad.png)\n\n怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。\n\n这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。\n\n\n在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。\n\n__不好的程序日志往往存在以下几个问题：__\n\n2.1. 缺乏结构，信息混乱\n在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：\n\n```\nError at line 34\nServer is down\nUser failed to login\n```\n这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。\n\n2.2. 信息过于简单，缺少上下文\n日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：\n\n```\nERROR: Login failed\n```\n没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。\n\n![我是谁](./images/log/whoami.jpg)\n\n2.3. 日志内容冗余，冗长无效\n有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：\n\n```\nINFO: Request started\nINFO: Request body: { \"username\": \"johndoe\", \"password\": \"123456\" }\nINFO: Headers: { \"Authorization\": \"Bearer token123\" }\nINFO: Response status: 200\nINFO: Response body: { \"message\": \"success\" }\n```\n虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。\n\n2.4. 没有日志级别，信息无法筛选\n如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：\n\n```\nA critical error occurred while processing the request.\n```\n如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。\n\n\n优秀的程序日志应该具备以下几个特征：\n\n## 1. 结构化日志\n结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。\n\n__优秀的日志示例（JSON 格式）：__\n\n```json\n复制代码\n{\n  \"timestamp\": \"2024-12-18T14:05:23.123Z\",\n  \"level\": \"INFO\",\n  \"message\": \"User login successful\",\n  \"user_id\": 12345,\n  \"ip_address\": \"192.168.1.1\",\n  \"request_id\": \"xyz123\",\n  \"duration_ms\": 150\n}\n```\n__为什么结构化日志优秀？__\n\n+ 可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。\n+ 与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。\n\n## 2. 日志级别\n日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：\n\n+ DEBUG：调试信息，帮助开发者了解程序运行的细节。\n+ INFO：常规信息，表示程序的正常运行过程。\n+ WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。\n+ ERROR：错误信息，表示程序出现了异常，需要处理。\n+ FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。\n\n__为什么使用日志级别？__\n\n+ 便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。\n+ 优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。\n\n## 3. 上下文信息\n日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。\n\n就像\n\n__优秀的日志应包含的上下文信息：__\n\n+ 请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。\n+ 用户信息：如用户 ID 或用户名，能够帮助分析用户行为。\n+ 机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。\n+ 异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。\n\n## 4. 日志可读性\n虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。\n\n# 设计日志的过程中应避免的问题\n在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：\n\n## 1. 日志信息过于冗长\n许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。\n\n__避免措施：__\n\n确保每条日志都包含足够的信息，但不要重复记录无关信息。\n对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。\n使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。\n## 2. 日志格式不统一\n日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。\n\n__避免措施：__\n\n采用统一的日志格式，尽量使用结构化日志（如 JSON）。\n定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。\n对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。\n\n## 3. 忽略日志的性能影响\n日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I/O 阻塞、磁盘空间耗尽或系统性能下降。\n\n__避免措施：__\n\n对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。\n使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。\n设定日志的生命周期，定期清理过时的日志，避免日志文件过大。\n\n## 4. 缺乏追踪和关联能力\n在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。\n\n__避免措施：__\n\n在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。\n在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。\n\n## 5. 没有有效的日志存储与管理方案\n当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。\n\n__避免措施：__\n\n使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。\n配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。\n考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。\n\n# 总结\n一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。\n\n通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。\n\n由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。","source":"_posts/log.md","raw":"---\ntitle: 程序日志设计与存储：实践与注意事项(一)\ndate: 2024-12-18 16:34:05\ntags:\n---\n# 引言\n程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。\n\n本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。\n\n----\n\n# 什么样的程序日志是优秀的？\n之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。\n\n![自信](./images/log/confident.png)\n结果我实际看到的是这样的场景是下面这样的\n\n![日志](./images/log/bad.png)\n\n怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。\n\n这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。\n\n\n在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。\n\n__不好的程序日志往往存在以下几个问题：__\n\n2.1. 缺乏结构，信息混乱\n在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：\n\n```\nError at line 34\nServer is down\nUser failed to login\n```\n这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。\n\n2.2. 信息过于简单，缺少上下文\n日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：\n\n```\nERROR: Login failed\n```\n没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。\n\n![我是谁](./images/log/whoami.jpg)\n\n2.3. 日志内容冗余，冗长无效\n有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：\n\n```\nINFO: Request started\nINFO: Request body: { \"username\": \"johndoe\", \"password\": \"123456\" }\nINFO: Headers: { \"Authorization\": \"Bearer token123\" }\nINFO: Response status: 200\nINFO: Response body: { \"message\": \"success\" }\n```\n虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。\n\n2.4. 没有日志级别，信息无法筛选\n如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：\n\n```\nA critical error occurred while processing the request.\n```\n如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。\n\n\n优秀的程序日志应该具备以下几个特征：\n\n## 1. 结构化日志\n结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。\n\n__优秀的日志示例（JSON 格式）：__\n\n```json\n复制代码\n{\n  \"timestamp\": \"2024-12-18T14:05:23.123Z\",\n  \"level\": \"INFO\",\n  \"message\": \"User login successful\",\n  \"user_id\": 12345,\n  \"ip_address\": \"192.168.1.1\",\n  \"request_id\": \"xyz123\",\n  \"duration_ms\": 150\n}\n```\n__为什么结构化日志优秀？__\n\n+ 可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。\n+ 与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。\n\n## 2. 日志级别\n日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：\n\n+ DEBUG：调试信息，帮助开发者了解程序运行的细节。\n+ INFO：常规信息，表示程序的正常运行过程。\n+ WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。\n+ ERROR：错误信息，表示程序出现了异常，需要处理。\n+ FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。\n\n__为什么使用日志级别？__\n\n+ 便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。\n+ 优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。\n\n## 3. 上下文信息\n日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。\n\n就像\n\n__优秀的日志应包含的上下文信息：__\n\n+ 请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。\n+ 用户信息：如用户 ID 或用户名，能够帮助分析用户行为。\n+ 机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。\n+ 异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。\n\n## 4. 日志可读性\n虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。\n\n# 设计日志的过程中应避免的问题\n在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：\n\n## 1. 日志信息过于冗长\n许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。\n\n__避免措施：__\n\n确保每条日志都包含足够的信息，但不要重复记录无关信息。\n对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。\n使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。\n## 2. 日志格式不统一\n日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。\n\n__避免措施：__\n\n采用统一的日志格式，尽量使用结构化日志（如 JSON）。\n定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。\n对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。\n\n## 3. 忽略日志的性能影响\n日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I/O 阻塞、磁盘空间耗尽或系统性能下降。\n\n__避免措施：__\n\n对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。\n使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。\n设定日志的生命周期，定期清理过时的日志，避免日志文件过大。\n\n## 4. 缺乏追踪和关联能力\n在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。\n\n__避免措施：__\n\n在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。\n在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。\n\n## 5. 没有有效的日志存储与管理方案\n当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。\n\n__避免措施：__\n\n使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。\n配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。\n考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。\n\n# 总结\n一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。\n\n通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。\n\n由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。","slug":"log","published":1,"updated":"2024-12-26T08:06:26.992Z","_id":"cm53cihmp0012m8p11n8q2k7w","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。</p>\n<p>本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。</p>\n<hr>\n<h1 id=\"什么样的程序日志是优秀的？\"><a href=\"#什么样的程序日志是优秀的？\" class=\"headerlink\" title=\"什么样的程序日志是优秀的？\"></a>什么样的程序日志是优秀的？</h1><p>之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。</p>\n<p><img src=\"/./images/log/confident.png\" alt=\"自信\"><br>结果我实际看到的是这样的场景是下面这样的</p>\n<p><img src=\"/./images/log/bad.png\" alt=\"日志\"></p>\n<p>怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。</p>\n<p>这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。</p>\n<p>在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。</p>\n<p><strong>不好的程序日志往往存在以下几个问题：</strong></p>\n<p>2.1. 缺乏结构，信息混乱<br>在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error at line 34</span><br><span class=\"line\">Server is down</span><br><span class=\"line\">User failed to login</span><br></pre></td></tr></table></figure>\n<p>这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。</p>\n<p>2.2. 信息过于简单，缺少上下文<br>日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: Login failed</span><br></pre></td></tr></table></figure>\n<p>没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。</p>\n<p><img src=\"/./images/log/whoami.jpg\" alt=\"我是谁\"></p>\n<p>2.3. 日志内容冗余，冗长无效<br>有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Request started</span><br><span class=\"line\">INFO: Request body: &#123; &quot;username&quot;: &quot;johndoe&quot;, &quot;password&quot;: &quot;123456&quot; &#125;</span><br><span class=\"line\">INFO: Headers: &#123; &quot;Authorization&quot;: &quot;Bearer token123&quot; &#125;</span><br><span class=\"line\">INFO: Response status: 200</span><br><span class=\"line\">INFO: Response body: &#123; &quot;message&quot;: &quot;success&quot; &#125;</span><br></pre></td></tr></table></figure>\n<p>虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。</p>\n<p>2.4. 没有日志级别，信息无法筛选<br>如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A critical error occurred while processing the request.</span><br></pre></td></tr></table></figure>\n<p>如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。</p>\n<p>优秀的程序日志应该具备以下几个特征：</p>\n<h2 id=\"1-结构化日志\"><a href=\"#1-结构化日志\" class=\"headerlink\" title=\"1. 结构化日志\"></a>1. 结构化日志</h2><p>结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。</p>\n<p><strong>优秀的日志示例（JSON 格式）：</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复制代码</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2024-12-18T14:05:23.123Z&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;INFO&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;User login successful&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;user_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">12345</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;ip_address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;192.168.1.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;request_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xyz123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;duration_ms&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">150</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>为什么结构化日志优秀？</strong></p>\n<ul>\n<li>可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。</li>\n<li>与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。</li>\n</ul>\n<h2 id=\"2-日志级别\"><a href=\"#2-日志级别\" class=\"headerlink\" title=\"2. 日志级别\"></a>2. 日志级别</h2><p>日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：</p>\n<ul>\n<li>DEBUG：调试信息，帮助开发者了解程序运行的细节。</li>\n<li>INFO：常规信息，表示程序的正常运行过程。</li>\n<li>WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。</li>\n<li>ERROR：错误信息，表示程序出现了异常，需要处理。</li>\n<li>FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。</li>\n</ul>\n<p><strong>为什么使用日志级别？</strong></p>\n<ul>\n<li>便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。</li>\n<li>优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。</li>\n</ul>\n<h2 id=\"3-上下文信息\"><a href=\"#3-上下文信息\" class=\"headerlink\" title=\"3. 上下文信息\"></a>3. 上下文信息</h2><p>日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。</p>\n<p>就像</p>\n<p><strong>优秀的日志应包含的上下文信息：</strong></p>\n<ul>\n<li>请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。</li>\n<li>用户信息：如用户 ID 或用户名，能够帮助分析用户行为。</li>\n<li>机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。</li>\n<li>异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。</li>\n</ul>\n<h2 id=\"4-日志可读性\"><a href=\"#4-日志可读性\" class=\"headerlink\" title=\"4. 日志可读性\"></a>4. 日志可读性</h2><p>虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。</p>\n<h1 id=\"设计日志的过程中应避免的问题\"><a href=\"#设计日志的过程中应避免的问题\" class=\"headerlink\" title=\"设计日志的过程中应避免的问题\"></a>设计日志的过程中应避免的问题</h1><p>在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：</p>\n<h2 id=\"1-日志信息过于冗长\"><a href=\"#1-日志信息过于冗长\" class=\"headerlink\" title=\"1. 日志信息过于冗长\"></a>1. 日志信息过于冗长</h2><p>许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。</p>\n<p><strong>避免措施：</strong></p>\n<p>确保每条日志都包含足够的信息，但不要重复记录无关信息。<br>对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。<br>使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。</p>\n<h2 id=\"2-日志格式不统一\"><a href=\"#2-日志格式不统一\" class=\"headerlink\" title=\"2. 日志格式不统一\"></a>2. 日志格式不统一</h2><p>日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。</p>\n<p><strong>避免措施：</strong></p>\n<p>采用统一的日志格式，尽量使用结构化日志（如 JSON）。<br>定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。<br>对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。</p>\n<h2 id=\"3-忽略日志的性能影响\"><a href=\"#3-忽略日志的性能影响\" class=\"headerlink\" title=\"3. 忽略日志的性能影响\"></a>3. 忽略日志的性能影响</h2><p>日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I&#x2F;O 阻塞、磁盘空间耗尽或系统性能下降。</p>\n<p><strong>避免措施：</strong></p>\n<p>对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。<br>使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。<br>设定日志的生命周期，定期清理过时的日志，避免日志文件过大。</p>\n<h2 id=\"4-缺乏追踪和关联能力\"><a href=\"#4-缺乏追踪和关联能力\" class=\"headerlink\" title=\"4. 缺乏追踪和关联能力\"></a>4. 缺乏追踪和关联能力</h2><p>在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。</p>\n<p><strong>避免措施：</strong></p>\n<p>在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。<br>在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。</p>\n<h2 id=\"5-没有有效的日志存储与管理方案\"><a href=\"#5-没有有效的日志存储与管理方案\" class=\"headerlink\" title=\"5. 没有有效的日志存储与管理方案\"></a>5. 没有有效的日志存储与管理方案</h2><p>当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。</p>\n<p><strong>避免措施：</strong></p>\n<p>使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。<br>配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。<br>考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。</p>\n<p>通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。</p>\n<p>由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。</p>\n<p>本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。</p>\n<hr>\n<h1 id=\"什么样的程序日志是优秀的？\"><a href=\"#什么样的程序日志是优秀的？\" class=\"headerlink\" title=\"什么样的程序日志是优秀的？\"></a>什么样的程序日志是优秀的？</h1><p>之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。</p>\n<p><img src=\"/./images/log/confident.png\" alt=\"自信\"><br>结果我实际看到的是这样的场景是下面这样的</p>\n<p><img src=\"/./images/log/bad.png\" alt=\"日志\"></p>\n<p>怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。</p>\n<p>这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。</p>\n<p>在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。</p>\n<p><strong>不好的程序日志往往存在以下几个问题：</strong></p>\n<p>2.1. 缺乏结构，信息混乱<br>在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error at line 34</span><br><span class=\"line\">Server is down</span><br><span class=\"line\">User failed to login</span><br></pre></td></tr></table></figure>\n<p>这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。</p>\n<p>2.2. 信息过于简单，缺少上下文<br>日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: Login failed</span><br></pre></td></tr></table></figure>\n<p>没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。</p>\n<p><img src=\"/./images/log/whoami.jpg\" alt=\"我是谁\"></p>\n<p>2.3. 日志内容冗余，冗长无效<br>有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Request started</span><br><span class=\"line\">INFO: Request body: &#123; &quot;username&quot;: &quot;johndoe&quot;, &quot;password&quot;: &quot;123456&quot; &#125;</span><br><span class=\"line\">INFO: Headers: &#123; &quot;Authorization&quot;: &quot;Bearer token123&quot; &#125;</span><br><span class=\"line\">INFO: Response status: 200</span><br><span class=\"line\">INFO: Response body: &#123; &quot;message&quot;: &quot;success&quot; &#125;</span><br></pre></td></tr></table></figure>\n<p>虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。</p>\n<p>2.4. 没有日志级别，信息无法筛选<br>如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A critical error occurred while processing the request.</span><br></pre></td></tr></table></figure>\n<p>如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。</p>\n<p>优秀的程序日志应该具备以下几个特征：</p>\n<h2 id=\"1-结构化日志\"><a href=\"#1-结构化日志\" class=\"headerlink\" title=\"1. 结构化日志\"></a>1. 结构化日志</h2><p>结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。</p>\n<p><strong>优秀的日志示例（JSON 格式）：</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复制代码</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2024-12-18T14:05:23.123Z&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;INFO&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;User login successful&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;user_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">12345</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;ip_address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;192.168.1.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;request_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xyz123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;duration_ms&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">150</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>为什么结构化日志优秀？</strong></p>\n<ul>\n<li>可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。</li>\n<li>与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。</li>\n</ul>\n<h2 id=\"2-日志级别\"><a href=\"#2-日志级别\" class=\"headerlink\" title=\"2. 日志级别\"></a>2. 日志级别</h2><p>日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：</p>\n<ul>\n<li>DEBUG：调试信息，帮助开发者了解程序运行的细节。</li>\n<li>INFO：常规信息，表示程序的正常运行过程。</li>\n<li>WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。</li>\n<li>ERROR：错误信息，表示程序出现了异常，需要处理。</li>\n<li>FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。</li>\n</ul>\n<p><strong>为什么使用日志级别？</strong></p>\n<ul>\n<li>便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。</li>\n<li>优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。</li>\n</ul>\n<h2 id=\"3-上下文信息\"><a href=\"#3-上下文信息\" class=\"headerlink\" title=\"3. 上下文信息\"></a>3. 上下文信息</h2><p>日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。</p>\n<p>就像</p>\n<p><strong>优秀的日志应包含的上下文信息：</strong></p>\n<ul>\n<li>请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。</li>\n<li>用户信息：如用户 ID 或用户名，能够帮助分析用户行为。</li>\n<li>机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。</li>\n<li>异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。</li>\n</ul>\n<h2 id=\"4-日志可读性\"><a href=\"#4-日志可读性\" class=\"headerlink\" title=\"4. 日志可读性\"></a>4. 日志可读性</h2><p>虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。</p>\n<h1 id=\"设计日志的过程中应避免的问题\"><a href=\"#设计日志的过程中应避免的问题\" class=\"headerlink\" title=\"设计日志的过程中应避免的问题\"></a>设计日志的过程中应避免的问题</h1><p>在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：</p>\n<h2 id=\"1-日志信息过于冗长\"><a href=\"#1-日志信息过于冗长\" class=\"headerlink\" title=\"1. 日志信息过于冗长\"></a>1. 日志信息过于冗长</h2><p>许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。</p>\n<p><strong>避免措施：</strong></p>\n<p>确保每条日志都包含足够的信息，但不要重复记录无关信息。<br>对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。<br>使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。</p>\n<h2 id=\"2-日志格式不统一\"><a href=\"#2-日志格式不统一\" class=\"headerlink\" title=\"2. 日志格式不统一\"></a>2. 日志格式不统一</h2><p>日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。</p>\n<p><strong>避免措施：</strong></p>\n<p>采用统一的日志格式，尽量使用结构化日志（如 JSON）。<br>定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。<br>对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。</p>\n<h2 id=\"3-忽略日志的性能影响\"><a href=\"#3-忽略日志的性能影响\" class=\"headerlink\" title=\"3. 忽略日志的性能影响\"></a>3. 忽略日志的性能影响</h2><p>日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I&#x2F;O 阻塞、磁盘空间耗尽或系统性能下降。</p>\n<p><strong>避免措施：</strong></p>\n<p>对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。<br>使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。<br>设定日志的生命周期，定期清理过时的日志，避免日志文件过大。</p>\n<h2 id=\"4-缺乏追踪和关联能力\"><a href=\"#4-缺乏追踪和关联能力\" class=\"headerlink\" title=\"4. 缺乏追踪和关联能力\"></a>4. 缺乏追踪和关联能力</h2><p>在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。</p>\n<p><strong>避免措施：</strong></p>\n<p>在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。<br>在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。</p>\n<h2 id=\"5-没有有效的日志存储与管理方案\"><a href=\"#5-没有有效的日志存储与管理方案\" class=\"headerlink\" title=\"5. 没有有效的日志存储与管理方案\"></a>5. 没有有效的日志存储与管理方案</h2><p>当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。</p>\n<p><strong>避免措施：</strong></p>\n<p>使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。<br>配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。<br>考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。</p>\n<p>通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。</p>\n<p>由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。</p>\n"},{"title":"并发不是并行！","date":"2025-01-07T08:05:45.000Z","_content":"\n\n在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。\n\n本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。\n\n# 什么是并发（Concurrency）？\n并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。\n\n## 并发的特点：\n\n- 任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。\n- 资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。\n- 通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。\n\n## 并发的例子：\n想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。\n\n```C#\nclass ConcurrencyExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并发示例：\");\n\n        // 创建两个任务，并行执行\n        var task1 = Task.Run(() => DoWork(\"任务 1\"));\n        var task2 = Task.Run(() => DoWork(\"任务 2\"));\n\n        // 等待任务完成\n        Task.WhenAll(task1, task2).Wait();\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(string taskName)\n    {\n        Console.WriteLine($\"{taskName} 开始\");\n\n        // 模拟I/O密集型操作，如网络请求或文件读写\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"{taskName} 正在处理: {i + 1}\");\n            Thread.Sleep(1000);  // 模拟I/O操作\n        }\n\n        Console.WriteLine($\"{taskName} 完成\");\n    }\n}\n```\n\n![并发示例](./images/parallelism/concurrency-result.png)\n\n# 什么是并行（Parallelism）？\n并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。\n\n## 并行的特点：\n- 任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。\n- 需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。\n- 任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。\n\n## 并行的例子：\n以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。\n\n```C#\nclass ParallelismExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并行示例：\");\n\n        // 使用 Parallel.For 并行执行多个任务\n        Parallel.For(0, 5, i => {\n            DoWork(i);\n        });\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(int taskId)\n    {\n        Console.WriteLine($\"任务 {taskId} 开始\");\n\n        // 模拟计算密集型操作\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"任务 {taskId} 正在处理: {i + 1}\");\n        }\n\n        Console.WriteLine($\"任务 {taskId} 完成\");\n    }\n}\n```\n![并发示例](./images/parallelism/parallelism-result.png)\n\n# 并发和并行的区别\n尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：\n\n__并发__\n![并发](./images/parallelism/concurrency-vs-parallelism-1.png)\n__并行__\n![并行](./images/parallelism/concurrency-vs-parallelism-2.png)\n\n\n\n|特性|\t并发（Concurrency）|\t并行（Parallelism）|\n|--|--|--|\n|定义|\t多个任务在同一时间段内交替执行，可能并不同时发生|\t多个任务在同一时刻同时执行|\n|任务执行 |\t任务交替执行，可能共享资源|\t任务同时执行，通常有多个处理单元|\n|资源需求|\t单核或多核都可以实现|\t需要多核或多个计算单元支持|\n|适用场景|\tI/O密集型任务，如文件读取、网络请求等|\t计算密集型任务，如图像处理、科学计算等|\n|实现方式|\t通过时间分片调度任务|\t通过多核或多计算节点同时执行多个任务|\n\n\n# 并发与并行的结合应用\n在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。\n\n例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。\n\n![并发与并行结合](./images/parallelism/concurrency-vs-parallelism-3.png)\n\n# 在编程中的并发与并行\n在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：\n\n## 并发编程：\n- 线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。\n- 事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。\n- 协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。\n\n## 并行编程：\n- 多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。\n- 分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。\n\n# 并发与并行的实际应用\n## 并发应用：\n- Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I/O密集型的场景下，能够有效提高吞吐量。\n- 聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。\n\n## 并行应用：\n- 科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。\n- 大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。\n\n# 总结\n- 并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I/O密集型应用。\n- 并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。\n- 在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。\n\n无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。\n\n----\n\n欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。","source":"_posts/parallelism.md","raw":"---\ntitle: 并发不是并行！\ndate: 2025-01-07 16:05:45\ntags:\n---\n\n\n在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。\n\n本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。\n\n# 什么是并发（Concurrency）？\n并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。\n\n## 并发的特点：\n\n- 任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。\n- 资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。\n- 通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。\n\n## 并发的例子：\n想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。\n\n```C#\nclass ConcurrencyExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并发示例：\");\n\n        // 创建两个任务，并行执行\n        var task1 = Task.Run(() => DoWork(\"任务 1\"));\n        var task2 = Task.Run(() => DoWork(\"任务 2\"));\n\n        // 等待任务完成\n        Task.WhenAll(task1, task2).Wait();\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(string taskName)\n    {\n        Console.WriteLine($\"{taskName} 开始\");\n\n        // 模拟I/O密集型操作，如网络请求或文件读写\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"{taskName} 正在处理: {i + 1}\");\n            Thread.Sleep(1000);  // 模拟I/O操作\n        }\n\n        Console.WriteLine($\"{taskName} 完成\");\n    }\n}\n```\n\n![并发示例](./images/parallelism/concurrency-result.png)\n\n# 什么是并行（Parallelism）？\n并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。\n\n## 并行的特点：\n- 任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。\n- 需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。\n- 任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。\n\n## 并行的例子：\n以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。\n\n```C#\nclass ParallelismExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并行示例：\");\n\n        // 使用 Parallel.For 并行执行多个任务\n        Parallel.For(0, 5, i => {\n            DoWork(i);\n        });\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(int taskId)\n    {\n        Console.WriteLine($\"任务 {taskId} 开始\");\n\n        // 模拟计算密集型操作\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"任务 {taskId} 正在处理: {i + 1}\");\n        }\n\n        Console.WriteLine($\"任务 {taskId} 完成\");\n    }\n}\n```\n![并发示例](./images/parallelism/parallelism-result.png)\n\n# 并发和并行的区别\n尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：\n\n__并发__\n![并发](./images/parallelism/concurrency-vs-parallelism-1.png)\n__并行__\n![并行](./images/parallelism/concurrency-vs-parallelism-2.png)\n\n\n\n|特性|\t并发（Concurrency）|\t并行（Parallelism）|\n|--|--|--|\n|定义|\t多个任务在同一时间段内交替执行，可能并不同时发生|\t多个任务在同一时刻同时执行|\n|任务执行 |\t任务交替执行，可能共享资源|\t任务同时执行，通常有多个处理单元|\n|资源需求|\t单核或多核都可以实现|\t需要多核或多个计算单元支持|\n|适用场景|\tI/O密集型任务，如文件读取、网络请求等|\t计算密集型任务，如图像处理、科学计算等|\n|实现方式|\t通过时间分片调度任务|\t通过多核或多计算节点同时执行多个任务|\n\n\n# 并发与并行的结合应用\n在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。\n\n例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。\n\n![并发与并行结合](./images/parallelism/concurrency-vs-parallelism-3.png)\n\n# 在编程中的并发与并行\n在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：\n\n## 并发编程：\n- 线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。\n- 事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。\n- 协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。\n\n## 并行编程：\n- 多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。\n- 分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。\n\n# 并发与并行的实际应用\n## 并发应用：\n- Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I/O密集型的场景下，能够有效提高吞吐量。\n- 聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。\n\n## 并行应用：\n- 科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。\n- 大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。\n\n# 总结\n- 并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I/O密集型应用。\n- 并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。\n- 在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。\n\n无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。\n\n----\n\n欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。","slug":"parallelism","published":1,"updated":"2025-01-08T06:21:07.620Z","_id":"cm5majdwe0000rcp1fvat20jk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。</p>\n<p>本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。</p>\n<h1 id=\"什么是并发（Concurrency）？\"><a href=\"#什么是并发（Concurrency）？\" class=\"headerlink\" title=\"什么是并发（Concurrency）？\"></a>什么是并发（Concurrency）？</h1><p>并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。</p>\n<h2 id=\"并发的特点：\"><a href=\"#并发的特点：\" class=\"headerlink\" title=\"并发的特点：\"></a>并发的特点：</h2><ul>\n<li>任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。</li>\n<li>资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。</li>\n<li>通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。</li>\n</ul>\n<h2 id=\"并发的例子：\"><a href=\"#并发的例子：\" class=\"headerlink\" title=\"并发的例子：\"></a>并发的例子：</h2><p>想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrencyExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并发示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建两个任务，并行执行</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> task1 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 1&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">var</span> task2 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待任务完成</span></span><br><span class=\"line\">        Task.WhenAll(task1, task2).Wait();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">string</span> taskName</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟I/O密集型操作，如网络请求或文件读写</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">            Thread.Sleep(<span class=\"number\">1000</span>);  <span class=\"comment\">// 模拟I/O操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./images/parallelism/concurrency-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"什么是并行（Parallelism）？\"><a href=\"#什么是并行（Parallelism）？\" class=\"headerlink\" title=\"什么是并行（Parallelism）？\"></a>什么是并行（Parallelism）？</h1><p>并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。</p>\n<h2 id=\"并行的特点：\"><a href=\"#并行的特点：\" class=\"headerlink\" title=\"并行的特点：\"></a>并行的特点：</h2><ul>\n<li>任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。</li>\n<li>需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。</li>\n<li>任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。</li>\n</ul>\n<h2 id=\"并行的例子：\"><a href=\"#并行的例子：\" class=\"headerlink\" title=\"并行的例子：\"></a>并行的例子：</h2><p>以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ParallelismExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并行示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 Parallel.For 并行执行多个任务</span></span><br><span class=\"line\">        Parallel.For(<span class=\"number\">0</span>, <span class=\"number\">5</span>, i =&gt; &#123;</span><br><span class=\"line\">            DoWork(i);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">int</span> taskId</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟计算密集型操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./images/parallelism/parallelism-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"并发和并行的区别\"><a href=\"#并发和并行的区别\" class=\"headerlink\" title=\"并发和并行的区别\"></a>并发和并行的区别</h1><p>尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：</p>\n<p><strong>并发</strong><br><img src=\"/./images/parallelism/concurrency-vs-parallelism-1.png\" alt=\"并发\"><br><strong>并行</strong><br><img src=\"/./images/parallelism/concurrency-vs-parallelism-2.png\" alt=\"并行\"></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>并发（Concurrency）</th>\n<th>并行（Parallelism）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义</td>\n<td>多个任务在同一时间段内交替执行，可能并不同时发生</td>\n<td>多个任务在同一时刻同时执行</td>\n</tr>\n<tr>\n<td>任务执行</td>\n<td>任务交替执行，可能共享资源</td>\n<td>任务同时执行，通常有多个处理单元</td>\n</tr>\n<tr>\n<td>资源需求</td>\n<td>单核或多核都可以实现</td>\n<td>需要多核或多个计算单元支持</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>I&#x2F;O密集型任务，如文件读取、网络请求等</td>\n<td>计算密集型任务，如图像处理、科学计算等</td>\n</tr>\n<tr>\n<td>实现方式</td>\n<td>通过时间分片调度任务</td>\n<td>通过多核或多计算节点同时执行多个任务</td>\n</tr>\n</tbody></table>\n<h1 id=\"并发与并行的结合应用\"><a href=\"#并发与并行的结合应用\" class=\"headerlink\" title=\"并发与并行的结合应用\"></a>并发与并行的结合应用</h1><p>在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。</p>\n<p>例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。</p>\n<p><img src=\"/./images/parallelism/concurrency-vs-parallelism-3.png\" alt=\"并发与并行结合\"></p>\n<h1 id=\"在编程中的并发与并行\"><a href=\"#在编程中的并发与并行\" class=\"headerlink\" title=\"在编程中的并发与并行\"></a>在编程中的并发与并行</h1><p>在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：</p>\n<h2 id=\"并发编程：\"><a href=\"#并发编程：\" class=\"headerlink\" title=\"并发编程：\"></a>并发编程：</h2><ul>\n<li>线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。</li>\n<li>事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。</li>\n<li>协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。</li>\n</ul>\n<h2 id=\"并行编程：\"><a href=\"#并行编程：\" class=\"headerlink\" title=\"并行编程：\"></a>并行编程：</h2><ul>\n<li>多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。</li>\n<li>分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。</li>\n</ul>\n<h1 id=\"并发与并行的实际应用\"><a href=\"#并发与并行的实际应用\" class=\"headerlink\" title=\"并发与并行的实际应用\"></a>并发与并行的实际应用</h1><h2 id=\"并发应用：\"><a href=\"#并发应用：\" class=\"headerlink\" title=\"并发应用：\"></a>并发应用：</h2><ul>\n<li>Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I&#x2F;O密集型的场景下，能够有效提高吞吐量。</li>\n<li>聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。</li>\n</ul>\n<h2 id=\"并行应用：\"><a href=\"#并行应用：\" class=\"headerlink\" title=\"并行应用：\"></a>并行应用：</h2><ul>\n<li>科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。</li>\n<li>大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I&#x2F;O密集型应用。</li>\n<li>并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。</li>\n<li>在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。</li>\n</ul>\n<p>无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。</p>\n<hr>\n<p>欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。</p>\n<p>本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。</p>\n<h1 id=\"什么是并发（Concurrency）？\"><a href=\"#什么是并发（Concurrency）？\" class=\"headerlink\" title=\"什么是并发（Concurrency）？\"></a>什么是并发（Concurrency）？</h1><p>并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。</p>\n<h2 id=\"并发的特点：\"><a href=\"#并发的特点：\" class=\"headerlink\" title=\"并发的特点：\"></a>并发的特点：</h2><ul>\n<li>任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。</li>\n<li>资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。</li>\n<li>通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。</li>\n</ul>\n<h2 id=\"并发的例子：\"><a href=\"#并发的例子：\" class=\"headerlink\" title=\"并发的例子：\"></a>并发的例子：</h2><p>想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrencyExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并发示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建两个任务，并行执行</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> task1 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 1&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">var</span> task2 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待任务完成</span></span><br><span class=\"line\">        Task.WhenAll(task1, task2).Wait();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">string</span> taskName</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟I/O密集型操作，如网络请求或文件读写</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">            Thread.Sleep(<span class=\"number\">1000</span>);  <span class=\"comment\">// 模拟I/O操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./images/parallelism/concurrency-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"什么是并行（Parallelism）？\"><a href=\"#什么是并行（Parallelism）？\" class=\"headerlink\" title=\"什么是并行（Parallelism）？\"></a>什么是并行（Parallelism）？</h1><p>并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。</p>\n<h2 id=\"并行的特点：\"><a href=\"#并行的特点：\" class=\"headerlink\" title=\"并行的特点：\"></a>并行的特点：</h2><ul>\n<li>任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。</li>\n<li>需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。</li>\n<li>任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。</li>\n</ul>\n<h2 id=\"并行的例子：\"><a href=\"#并行的例子：\" class=\"headerlink\" title=\"并行的例子：\"></a>并行的例子：</h2><p>以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ParallelismExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并行示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 Parallel.For 并行执行多个任务</span></span><br><span class=\"line\">        Parallel.For(<span class=\"number\">0</span>, <span class=\"number\">5</span>, i =&gt; &#123;</span><br><span class=\"line\">            DoWork(i);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">int</span> taskId</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟计算密集型操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./images/parallelism/parallelism-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"并发和并行的区别\"><a href=\"#并发和并行的区别\" class=\"headerlink\" title=\"并发和并行的区别\"></a>并发和并行的区别</h1><p>尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：</p>\n<p><strong>并发</strong><br><img src=\"/./images/parallelism/concurrency-vs-parallelism-1.png\" alt=\"并发\"><br><strong>并行</strong><br><img src=\"/./images/parallelism/concurrency-vs-parallelism-2.png\" alt=\"并行\"></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>并发（Concurrency）</th>\n<th>并行（Parallelism）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义</td>\n<td>多个任务在同一时间段内交替执行，可能并不同时发生</td>\n<td>多个任务在同一时刻同时执行</td>\n</tr>\n<tr>\n<td>任务执行</td>\n<td>任务交替执行，可能共享资源</td>\n<td>任务同时执行，通常有多个处理单元</td>\n</tr>\n<tr>\n<td>资源需求</td>\n<td>单核或多核都可以实现</td>\n<td>需要多核或多个计算单元支持</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>I&#x2F;O密集型任务，如文件读取、网络请求等</td>\n<td>计算密集型任务，如图像处理、科学计算等</td>\n</tr>\n<tr>\n<td>实现方式</td>\n<td>通过时间分片调度任务</td>\n<td>通过多核或多计算节点同时执行多个任务</td>\n</tr>\n</tbody></table>\n<h1 id=\"并发与并行的结合应用\"><a href=\"#并发与并行的结合应用\" class=\"headerlink\" title=\"并发与并行的结合应用\"></a>并发与并行的结合应用</h1><p>在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。</p>\n<p>例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。</p>\n<p><img src=\"/./images/parallelism/concurrency-vs-parallelism-3.png\" alt=\"并发与并行结合\"></p>\n<h1 id=\"在编程中的并发与并行\"><a href=\"#在编程中的并发与并行\" class=\"headerlink\" title=\"在编程中的并发与并行\"></a>在编程中的并发与并行</h1><p>在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：</p>\n<h2 id=\"并发编程：\"><a href=\"#并发编程：\" class=\"headerlink\" title=\"并发编程：\"></a>并发编程：</h2><ul>\n<li>线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。</li>\n<li>事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。</li>\n<li>协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。</li>\n</ul>\n<h2 id=\"并行编程：\"><a href=\"#并行编程：\" class=\"headerlink\" title=\"并行编程：\"></a>并行编程：</h2><ul>\n<li>多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。</li>\n<li>分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。</li>\n</ul>\n<h1 id=\"并发与并行的实际应用\"><a href=\"#并发与并行的实际应用\" class=\"headerlink\" title=\"并发与并行的实际应用\"></a>并发与并行的实际应用</h1><h2 id=\"并发应用：\"><a href=\"#并发应用：\" class=\"headerlink\" title=\"并发应用：\"></a>并发应用：</h2><ul>\n<li>Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I&#x2F;O密集型的场景下，能够有效提高吞吐量。</li>\n<li>聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。</li>\n</ul>\n<h2 id=\"并行应用：\"><a href=\"#并行应用：\" class=\"headerlink\" title=\"并行应用：\"></a>并行应用：</h2><ul>\n<li>科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。</li>\n<li>大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I&#x2F;O密集型应用。</li>\n<li>并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。</li>\n<li>在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。</li>\n</ul>\n<p>无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。</p>\n<hr>\n<p>欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。</p>\n"},{"title":"减少 Docker 日志大小：实用的日志管理指南","date":"2025-02-05T07:40:48.000Z","_content":"之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。\n\n在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。\n\n# Docker 日志机制概述\nDocker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 /var/lib/docker/containers/[container-id]/ 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。\n\nDocker 提供了多种日志驱动方式，例如：\n\n- json-file（默认）\n- syslog\n- journald\n- fluentd\n- gelf\n- awslogs\n- none（不记录日志）\n\n通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。\n\n# 为什么 Docker 日志会膨胀？\n让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。\n\n发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。\n\n同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。\n\n\n# 减少 Docker 日志大小的有效策略\n## 使用合适的日志驱动\n选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。\n\n示例：将 Docker 容器日志发送到 syslog\n```bash\ndocker run --log-driver=syslog --name my-container my-image\n```\n## 限制日志文件大小和日志文件数量\nDocker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。\n\n使用 --log-opt 参数可以设置以下选项：\n\n- max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。\n- max-file：设置最多保存多少个轮换的日志文件。\n\n示例：限制日志文件大小和数量\n```bash\ndocker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image\n```\n在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。\n\n也可以通过配置文件（如 /etc/docker/daemon.json）来全局设置日志驱动和日志选项。\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n要应用更改，还需重启 Docker 服务：\n```bash\nsudo systemctl restart docker\n```\n<font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font>\n\n要将更改应用于现有容器，必须先删除它们，然后重新创建它们\n```bash\ndocker rm -f <container_id_or_name>\n```\n\n再次查看容器详情，你会看到日志选项已经被设置。\n![日志文件](./images/docker-log/log5.png)\n\n## 禁用日志\n如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。\n\n示例：禁用日志记录\n```bash\ndocker run --log-driver=none --name my-container my-image\n```\n\n## 定期清理旧日志文件\n虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。\n\n\n### 检查容器日志大小\n\nDocker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：\n\n```bash\n/var/lib/docker/containers/<container-id>/<container-id>-json.log\n```\n每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。\n\n要快速检查所有 Docker 容器日志的大小，可以使用以下命令：\n\n```bash\nfind /var/lib/docker/containers/ -name \"*json.log\" | xargs du -h | sort -rh\n```\n这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。\n\n![日志文件](./images/docker-log/log1.png)\n\n### 根据日志文件 ID 查找容器名称\n现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。\n\n要查找该容器的名称，可以运行以下命令：\n\n```bash\ndocker inspect --format='{{.Name}}' <container_id>\n```\n对于我们的例子：\n\n```bash\ndocker inspect --format='{{.Name}}' 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4\n```\n这将返回容器的名称，如下图。\n![日志文件](./images/docker-log/log2.png)\n\n要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。\n```bash\ndocker inspect registry_registry_1\n```\n\n![日志文件](./images/docker-log/log3.png)\n\n或者直接使用如下命令查看容器日志路径信息\n```bash\ndocker inspect --format='{{.LogPath}}' registry_registry_1\n```\n![日志文件](./images/docker-log/log4.png)\n\n### 清理 Docker 容器日志\n一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。\n\n要清理特定容器的日志文件，可以使用 truncate 命令。例如：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log\n```\n如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/*/*-json.log\n```\n这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。\n\n## 配置容器的标准输出和标准错误输出\nDocker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。\n\n## 使用日志聚合和集中化\n使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：\n\n- Elasticsearch + Logstash + Kibana（ELK）\n- Fluentd\n- Graylog\n- Splunk\n\n这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。\n\n## 使用外部日志存储\n将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：\n\n```bash\ndocker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image\n```\n\n# 监控 Docker 日志大小\n为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。\n\n# 小结\n\nDocker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。\n\n----\n\n这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。","source":"_posts/docker-log.md","raw":"---\ntitle: 减少 Docker 日志大小：实用的日志管理指南\ndate: 2025-02-05 15:40:48\ntags:\n---\n之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。\n\n在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。\n\n# Docker 日志机制概述\nDocker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 /var/lib/docker/containers/[container-id]/ 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。\n\nDocker 提供了多种日志驱动方式，例如：\n\n- json-file（默认）\n- syslog\n- journald\n- fluentd\n- gelf\n- awslogs\n- none（不记录日志）\n\n通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。\n\n# 为什么 Docker 日志会膨胀？\n让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。\n\n发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。\n\n同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。\n\n\n# 减少 Docker 日志大小的有效策略\n## 使用合适的日志驱动\n选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。\n\n示例：将 Docker 容器日志发送到 syslog\n```bash\ndocker run --log-driver=syslog --name my-container my-image\n```\n## 限制日志文件大小和日志文件数量\nDocker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。\n\n使用 --log-opt 参数可以设置以下选项：\n\n- max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。\n- max-file：设置最多保存多少个轮换的日志文件。\n\n示例：限制日志文件大小和数量\n```bash\ndocker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image\n```\n在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。\n\n也可以通过配置文件（如 /etc/docker/daemon.json）来全局设置日志驱动和日志选项。\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n要应用更改，还需重启 Docker 服务：\n```bash\nsudo systemctl restart docker\n```\n<font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font>\n\n要将更改应用于现有容器，必须先删除它们，然后重新创建它们\n```bash\ndocker rm -f <container_id_or_name>\n```\n\n再次查看容器详情，你会看到日志选项已经被设置。\n![日志文件](./images/docker-log/log5.png)\n\n## 禁用日志\n如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。\n\n示例：禁用日志记录\n```bash\ndocker run --log-driver=none --name my-container my-image\n```\n\n## 定期清理旧日志文件\n虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。\n\n\n### 检查容器日志大小\n\nDocker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：\n\n```bash\n/var/lib/docker/containers/<container-id>/<container-id>-json.log\n```\n每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。\n\n要快速检查所有 Docker 容器日志的大小，可以使用以下命令：\n\n```bash\nfind /var/lib/docker/containers/ -name \"*json.log\" | xargs du -h | sort -rh\n```\n这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。\n\n![日志文件](./images/docker-log/log1.png)\n\n### 根据日志文件 ID 查找容器名称\n现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。\n\n要查找该容器的名称，可以运行以下命令：\n\n```bash\ndocker inspect --format='{{.Name}}' <container_id>\n```\n对于我们的例子：\n\n```bash\ndocker inspect --format='{{.Name}}' 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4\n```\n这将返回容器的名称，如下图。\n![日志文件](./images/docker-log/log2.png)\n\n要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。\n```bash\ndocker inspect registry_registry_1\n```\n\n![日志文件](./images/docker-log/log3.png)\n\n或者直接使用如下命令查看容器日志路径信息\n```bash\ndocker inspect --format='{{.LogPath}}' registry_registry_1\n```\n![日志文件](./images/docker-log/log4.png)\n\n### 清理 Docker 容器日志\n一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。\n\n要清理特定容器的日志文件，可以使用 truncate 命令。例如：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log\n```\n如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/*/*-json.log\n```\n这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。\n\n## 配置容器的标准输出和标准错误输出\nDocker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。\n\n## 使用日志聚合和集中化\n使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：\n\n- Elasticsearch + Logstash + Kibana（ELK）\n- Fluentd\n- Graylog\n- Splunk\n\n这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。\n\n## 使用外部日志存储\n将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：\n\n```bash\ndocker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image\n```\n\n# 监控 Docker 日志大小\n为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。\n\n# 小结\n\nDocker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。\n\n----\n\n这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。","slug":"docker-log","published":1,"updated":"2025-02-06T08:52:43.934Z","_id":"cm6sxvwfi00005cp143mubc8r","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。</p>\n<p>在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。</p>\n<h1 id=\"Docker-日志机制概述\"><a href=\"#Docker-日志机制概述\" class=\"headerlink\" title=\"Docker 日志机制概述\"></a>Docker 日志机制概述</h1><p>Docker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;[container-id]&#x2F; 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。</p>\n<p>Docker 提供了多种日志驱动方式，例如：</p>\n<ul>\n<li>json-file（默认）</li>\n<li>syslog</li>\n<li>journald</li>\n<li>fluentd</li>\n<li>gelf</li>\n<li>awslogs</li>\n<li>none（不记录日志）</li>\n</ul>\n<p>通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。</p>\n<h1 id=\"为什么-Docker-日志会膨胀？\"><a href=\"#为什么-Docker-日志会膨胀？\" class=\"headerlink\" title=\"为什么 Docker 日志会膨胀？\"></a>为什么 Docker 日志会膨胀？</h1><p>让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。</p>\n<p>发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。</p>\n<p>同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。</p>\n<h1 id=\"减少-Docker-日志大小的有效策略\"><a href=\"#减少-Docker-日志大小的有效策略\" class=\"headerlink\" title=\"减少 Docker 日志大小的有效策略\"></a>减少 Docker 日志大小的有效策略</h1><h2 id=\"使用合适的日志驱动\"><a href=\"#使用合适的日志驱动\" class=\"headerlink\" title=\"使用合适的日志驱动\"></a>使用合适的日志驱动</h2><p>选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。</p>\n<p>示例：将 Docker 容器日志发送到 syslog</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=syslog --name my-container my-image</span><br></pre></td></tr></table></figure>\n<h2 id=\"限制日志文件大小和日志文件数量\"><a href=\"#限制日志文件大小和日志文件数量\" class=\"headerlink\" title=\"限制日志文件大小和日志文件数量\"></a>限制日志文件大小和日志文件数量</h2><p>Docker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。</p>\n<p>使用 –log-opt 参数可以设置以下选项：</p>\n<ul>\n<li>max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。</li>\n<li>max-file：设置最多保存多少个轮换的日志文件。</li>\n</ul>\n<p>示例：限制日志文件大小和数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。</p>\n<p>也可以通过配置文件（如 &#x2F;etc&#x2F;docker&#x2F;daemon.json）来全局设置日志驱动和日志选项。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>要应用更改，还需重启 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font></p>\n<p>要将更改应用于现有容器，必须先删除它们，然后重新创建它们</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> -f &lt;container_id_or_name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>再次查看容器详情，你会看到日志选项已经被设置。<br><img src=\"/./images/docker-log/log5.png\" alt=\"日志文件\"></p>\n<h2 id=\"禁用日志\"><a href=\"#禁用日志\" class=\"headerlink\" title=\"禁用日志\"></a>禁用日志</h2><p>如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。</p>\n<p>示例：禁用日志记录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=none --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定期清理旧日志文件\"><a href=\"#定期清理旧日志文件\" class=\"headerlink\" title=\"定期清理旧日志文件\"></a>定期清理旧日志文件</h2><p>虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。</p>\n<h3 id=\"检查容器日志大小\"><a href=\"#检查容器日志大小\" class=\"headerlink\" title=\"检查容器日志大小\"></a>检查容器日志大小</h3><p>Docker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</span><br></pre></td></tr></table></figure>\n<p>每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。</p>\n<p>要快速检查所有 Docker 容器日志的大小，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /var/lib/docker/containers/ -name <span class=\"string\">&quot;*json.log&quot;</span> | xargs <span class=\"built_in\">du</span> -h | <span class=\"built_in\">sort</span> -rh</span><br></pre></td></tr></table></figure>\n<p>这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。</p>\n<p><img src=\"/./images/docker-log/log1.png\" alt=\"日志文件\"></p>\n<h3 id=\"根据日志文件-ID-查找容器名称\"><a href=\"#根据日志文件-ID-查找容器名称\" class=\"headerlink\" title=\"根据日志文件 ID 查找容器名称\"></a>根据日志文件 ID 查找容器名称</h3><p>现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。</p>\n<p>要查找该容器的名称，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br></pre></td></tr></table></figure>\n<p>对于我们的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4</span><br></pre></td></tr></table></figure>\n<p>这将返回容器的名称，如下图。<br><img src=\"/./images/docker-log/log2.png\" alt=\"日志文件\"></p>\n<p>要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect registry_registry_1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./images/docker-log/log3.png\" alt=\"日志文件\"></p>\n<p>或者直接使用如下命令查看容器日志路径信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> registry_registry_1</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./images/docker-log/log4.png\" alt=\"日志文件\"></p>\n<h3 id=\"清理-Docker-容器日志\"><a href=\"#清理-Docker-容器日志\" class=\"headerlink\" title=\"清理 Docker 容器日志\"></a>清理 Docker 容器日志</h3><p>一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。</p>\n<p>要清理特定容器的日志文件，可以使用 truncate 命令。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log</span><br></pre></td></tr></table></figure>\n<p>如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/*/*-json.log</span><br></pre></td></tr></table></figure>\n<p>这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。</p>\n<h2 id=\"配置容器的标准输出和标准错误输出\"><a href=\"#配置容器的标准输出和标准错误输出\" class=\"headerlink\" title=\"配置容器的标准输出和标准错误输出\"></a>配置容器的标准输出和标准错误输出</h2><p>Docker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。</p>\n<h2 id=\"使用日志聚合和集中化\"><a href=\"#使用日志聚合和集中化\" class=\"headerlink\" title=\"使用日志聚合和集中化\"></a>使用日志聚合和集中化</h2><p>使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：</p>\n<ul>\n<li>Elasticsearch + Logstash + Kibana（ELK）</li>\n<li>Fluentd</li>\n<li>Graylog</li>\n<li>Splunk</li>\n</ul>\n<p>这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。</p>\n<h2 id=\"使用外部日志存储\"><a href=\"#使用外部日志存储\" class=\"headerlink\" title=\"使用外部日志存储\"></a>使用外部日志存储</h2><p>将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"监控-Docker-日志大小\"><a href=\"#监控-Docker-日志大小\" class=\"headerlink\" title=\"监控 Docker 日志大小\"></a>监控 Docker 日志大小</h1><p>为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>Docker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。</p>\n<hr>\n<p>这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。</p>\n<p>在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。</p>\n<h1 id=\"Docker-日志机制概述\"><a href=\"#Docker-日志机制概述\" class=\"headerlink\" title=\"Docker 日志机制概述\"></a>Docker 日志机制概述</h1><p>Docker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;[container-id]&#x2F; 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。</p>\n<p>Docker 提供了多种日志驱动方式，例如：</p>\n<ul>\n<li>json-file（默认）</li>\n<li>syslog</li>\n<li>journald</li>\n<li>fluentd</li>\n<li>gelf</li>\n<li>awslogs</li>\n<li>none（不记录日志）</li>\n</ul>\n<p>通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。</p>\n<h1 id=\"为什么-Docker-日志会膨胀？\"><a href=\"#为什么-Docker-日志会膨胀？\" class=\"headerlink\" title=\"为什么 Docker 日志会膨胀？\"></a>为什么 Docker 日志会膨胀？</h1><p>让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。</p>\n<p>发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。</p>\n<p>同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。</p>\n<h1 id=\"减少-Docker-日志大小的有效策略\"><a href=\"#减少-Docker-日志大小的有效策略\" class=\"headerlink\" title=\"减少 Docker 日志大小的有效策略\"></a>减少 Docker 日志大小的有效策略</h1><h2 id=\"使用合适的日志驱动\"><a href=\"#使用合适的日志驱动\" class=\"headerlink\" title=\"使用合适的日志驱动\"></a>使用合适的日志驱动</h2><p>选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。</p>\n<p>示例：将 Docker 容器日志发送到 syslog</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=syslog --name my-container my-image</span><br></pre></td></tr></table></figure>\n<h2 id=\"限制日志文件大小和日志文件数量\"><a href=\"#限制日志文件大小和日志文件数量\" class=\"headerlink\" title=\"限制日志文件大小和日志文件数量\"></a>限制日志文件大小和日志文件数量</h2><p>Docker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。</p>\n<p>使用 –log-opt 参数可以设置以下选项：</p>\n<ul>\n<li>max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。</li>\n<li>max-file：设置最多保存多少个轮换的日志文件。</li>\n</ul>\n<p>示例：限制日志文件大小和数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。</p>\n<p>也可以通过配置文件（如 &#x2F;etc&#x2F;docker&#x2F;daemon.json）来全局设置日志驱动和日志选项。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>要应用更改，还需重启 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font></p>\n<p>要将更改应用于现有容器，必须先删除它们，然后重新创建它们</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> -f &lt;container_id_or_name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>再次查看容器详情，你会看到日志选项已经被设置。<br><img src=\"/./images/docker-log/log5.png\" alt=\"日志文件\"></p>\n<h2 id=\"禁用日志\"><a href=\"#禁用日志\" class=\"headerlink\" title=\"禁用日志\"></a>禁用日志</h2><p>如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。</p>\n<p>示例：禁用日志记录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=none --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定期清理旧日志文件\"><a href=\"#定期清理旧日志文件\" class=\"headerlink\" title=\"定期清理旧日志文件\"></a>定期清理旧日志文件</h2><p>虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。</p>\n<h3 id=\"检查容器日志大小\"><a href=\"#检查容器日志大小\" class=\"headerlink\" title=\"检查容器日志大小\"></a>检查容器日志大小</h3><p>Docker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</span><br></pre></td></tr></table></figure>\n<p>每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。</p>\n<p>要快速检查所有 Docker 容器日志的大小，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /var/lib/docker/containers/ -name <span class=\"string\">&quot;*json.log&quot;</span> | xargs <span class=\"built_in\">du</span> -h | <span class=\"built_in\">sort</span> -rh</span><br></pre></td></tr></table></figure>\n<p>这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。</p>\n<p><img src=\"/./images/docker-log/log1.png\" alt=\"日志文件\"></p>\n<h3 id=\"根据日志文件-ID-查找容器名称\"><a href=\"#根据日志文件-ID-查找容器名称\" class=\"headerlink\" title=\"根据日志文件 ID 查找容器名称\"></a>根据日志文件 ID 查找容器名称</h3><p>现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。</p>\n<p>要查找该容器的名称，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br></pre></td></tr></table></figure>\n<p>对于我们的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4</span><br></pre></td></tr></table></figure>\n<p>这将返回容器的名称，如下图。<br><img src=\"/./images/docker-log/log2.png\" alt=\"日志文件\"></p>\n<p>要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect registry_registry_1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/./images/docker-log/log3.png\" alt=\"日志文件\"></p>\n<p>或者直接使用如下命令查看容器日志路径信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> registry_registry_1</span><br></pre></td></tr></table></figure>\n<p><img src=\"/./images/docker-log/log4.png\" alt=\"日志文件\"></p>\n<h3 id=\"清理-Docker-容器日志\"><a href=\"#清理-Docker-容器日志\" class=\"headerlink\" title=\"清理 Docker 容器日志\"></a>清理 Docker 容器日志</h3><p>一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。</p>\n<p>要清理特定容器的日志文件，可以使用 truncate 命令。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log</span><br></pre></td></tr></table></figure>\n<p>如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/*/*-json.log</span><br></pre></td></tr></table></figure>\n<p>这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。</p>\n<h2 id=\"配置容器的标准输出和标准错误输出\"><a href=\"#配置容器的标准输出和标准错误输出\" class=\"headerlink\" title=\"配置容器的标准输出和标准错误输出\"></a>配置容器的标准输出和标准错误输出</h2><p>Docker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。</p>\n<h2 id=\"使用日志聚合和集中化\"><a href=\"#使用日志聚合和集中化\" class=\"headerlink\" title=\"使用日志聚合和集中化\"></a>使用日志聚合和集中化</h2><p>使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：</p>\n<ul>\n<li>Elasticsearch + Logstash + Kibana（ELK）</li>\n<li>Fluentd</li>\n<li>Graylog</li>\n<li>Splunk</li>\n</ul>\n<p>这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。</p>\n<h2 id=\"使用外部日志存储\"><a href=\"#使用外部日志存储\" class=\"headerlink\" title=\"使用外部日志存储\"></a>使用外部日志存储</h2><p>将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"监控-Docker-日志大小\"><a href=\"#监控-Docker-日志大小\" class=\"headerlink\" title=\"监控 Docker 日志大小\"></a>监控 Docker 日志大小</h1><p>为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>Docker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。</p>\n<hr>\n<p>这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。</p>\n"},{"title":"DeepSeek 本地部署指南","date":"2025-02-07T01:33:25.000Z","_content":"去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。\n\n这不，老夫也算是起了个大早，赶了个晚集。\n这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。\n![迟到](./images/deepseek-1/late.jpg)\n\n在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。\n\n# 本地部署DeepSeek\n## 下载并安装Ollama\n首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。\n\nWindows/macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。\n\n![下载](./images/deepseek-1/download.png)\n\nLinux用户：需要通过命令行执行以下命令来安装：\n```bash\ncurl -fsSL https://ollama.com/install.sh | sh\n```\n## 选择DeepSeek模型\n安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。\n\n![模型](./images/deepseek-1/models.png)\n\n7B版本：命令为 ollama run deepseek-r1:7b\n1.5B版本：命令为 ollama run deepseek-r1:1.5b\n\n![deepseek模型](./images/deepseek-1/deepseek-models.png)\n\n这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。\n\n## 运行命令\n选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。\n\n## 效果测试\n一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。\n\n# 使用Chatbox进行网页端访问\n命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。\n\n## 环境变量配置\n默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：\n\n- OLLAMA_HOST：设置为 0.0.0.0\n- OLLAMA_ORIGINS：设置为 *\n\n在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。\n\n![deepseek模型](./images/deepseek-1/env-var.png)\n\n保存设置后，从Windows开始菜单启动Ollama。\n\n## 配置Chatbox\n完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。\n\n打开[Chatbox](https://web.chatboxai.app/)官网，并选择启动网页版。\n![ChatBox](./images/deepseek-1/chatboxai.png)\n选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。\n在设置中选择Ollama API。\n\n选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。\n点击“DISPLAY”选项，选择简体中文，并点击保存按钮。\n\n![deepseek模型](./images/deepseek-1/chatbox-setting4.png)\n\n完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。\n\n这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。\n![deepseek模型](./images/deepseek-1/chatbox-answer.png)\n\n# 总结\n通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。\n\n希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！","source":"_posts/deepseek-1.md","raw":"---\ntitle: DeepSeek 本地部署指南\ndate: 2025-02-07 09:33:25\ntags:\n---\n去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。\n\n这不，老夫也算是起了个大早，赶了个晚集。\n这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。\n![迟到](./images/deepseek-1/late.jpg)\n\n在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。\n\n# 本地部署DeepSeek\n## 下载并安装Ollama\n首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。\n\nWindows/macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。\n\n![下载](./images/deepseek-1/download.png)\n\nLinux用户：需要通过命令行执行以下命令来安装：\n```bash\ncurl -fsSL https://ollama.com/install.sh | sh\n```\n## 选择DeepSeek模型\n安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。\n\n![模型](./images/deepseek-1/models.png)\n\n7B版本：命令为 ollama run deepseek-r1:7b\n1.5B版本：命令为 ollama run deepseek-r1:1.5b\n\n![deepseek模型](./images/deepseek-1/deepseek-models.png)\n\n这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。\n\n## 运行命令\n选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。\n\n## 效果测试\n一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。\n\n# 使用Chatbox进行网页端访问\n命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。\n\n## 环境变量配置\n默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：\n\n- OLLAMA_HOST：设置为 0.0.0.0\n- OLLAMA_ORIGINS：设置为 *\n\n在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。\n\n![deepseek模型](./images/deepseek-1/env-var.png)\n\n保存设置后，从Windows开始菜单启动Ollama。\n\n## 配置Chatbox\n完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。\n\n打开[Chatbox](https://web.chatboxai.app/)官网，并选择启动网页版。\n![ChatBox](./images/deepseek-1/chatboxai.png)\n选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。\n在设置中选择Ollama API。\n\n选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。\n点击“DISPLAY”选项，选择简体中文，并点击保存按钮。\n\n![deepseek模型](./images/deepseek-1/chatbox-setting4.png)\n\n完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。\n\n这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。\n![deepseek模型](./images/deepseek-1/chatbox-answer.png)\n\n# 总结\n通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。\n\n希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！","slug":"deepseek-1","published":1,"updated":"2025-02-07T08:00:29.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm6ydwnlw00009sp15n3tgkw5","content":"<p>去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。</p>\n<p>这不，老夫也算是起了个大早，赶了个晚集。<br>这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。<br><img src=\"/./images/deepseek-1/late.jpg\" alt=\"迟到\"></p>\n<p>在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。</p>\n<h1 id=\"本地部署DeepSeek\"><a href=\"#本地部署DeepSeek\" class=\"headerlink\" title=\"本地部署DeepSeek\"></a>本地部署DeepSeek</h1><h2 id=\"下载并安装Ollama\"><a href=\"#下载并安装Ollama\" class=\"headerlink\" title=\"下载并安装Ollama\"></a>下载并安装Ollama</h2><p>首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。</p>\n<p>Windows&#x2F;macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。</p>\n<p><img src=\"/./images/deepseek-1/download.png\" alt=\"下载\"></p>\n<p>Linux用户：需要通过命令行执行以下命令来安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择DeepSeek模型\"><a href=\"#选择DeepSeek模型\" class=\"headerlink\" title=\"选择DeepSeek模型\"></a>选择DeepSeek模型</h2><p>安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。</p>\n<p><img src=\"/./images/deepseek-1/models.png\" alt=\"模型\"></p>\n<p>7B版本：命令为 ollama run deepseek-r1:7b<br>1.5B版本：命令为 ollama run deepseek-r1:1.5b</p>\n<p><img src=\"/./images/deepseek-1/deepseek-models.png\" alt=\"deepseek模型\"></p>\n<p>这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。</p>\n<h2 id=\"运行命令\"><a href=\"#运行命令\" class=\"headerlink\" title=\"运行命令\"></a>运行命令</h2><p>选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。</p>\n<h2 id=\"效果测试\"><a href=\"#效果测试\" class=\"headerlink\" title=\"效果测试\"></a>效果测试</h2><p>一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。</p>\n<h1 id=\"使用Chatbox进行网页端访问\"><a href=\"#使用Chatbox进行网页端访问\" class=\"headerlink\" title=\"使用Chatbox进行网页端访问\"></a>使用Chatbox进行网页端访问</h1><p>命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。</p>\n<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：</p>\n<ul>\n<li>OLLAMA_HOST：设置为 0.0.0.0</li>\n<li>OLLAMA_ORIGINS：设置为 *</li>\n</ul>\n<p>在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。</p>\n<p><img src=\"/./images/deepseek-1/env-var.png\" alt=\"deepseek模型\"></p>\n<p>保存设置后，从Windows开始菜单启动Ollama。</p>\n<h2 id=\"配置Chatbox\"><a href=\"#配置Chatbox\" class=\"headerlink\" title=\"配置Chatbox\"></a>配置Chatbox</h2><p>完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。</p>\n<p>打开<a href=\"https://web.chatboxai.app/\">Chatbox</a>官网，并选择启动网页版。<br><img src=\"/./images/deepseek-1/chatboxai.png\" alt=\"ChatBox\"><br>选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。<br>在设置中选择Ollama API。</p>\n<p>选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。<br>点击“DISPLAY”选项，选择简体中文，并点击保存按钮。</p>\n<p><img src=\"/./images/deepseek-1/chatbox-setting4.png\" alt=\"deepseek模型\"></p>\n<p>完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。</p>\n<p>这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。<br><img src=\"/./images/deepseek-1/chatbox-answer.png\" alt=\"deepseek模型\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。</p>\n<p>希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。</p>\n<p>这不，老夫也算是起了个大早，赶了个晚集。<br>这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。<br><img src=\"/./images/deepseek-1/late.jpg\" alt=\"迟到\"></p>\n<p>在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。</p>\n<h1 id=\"本地部署DeepSeek\"><a href=\"#本地部署DeepSeek\" class=\"headerlink\" title=\"本地部署DeepSeek\"></a>本地部署DeepSeek</h1><h2 id=\"下载并安装Ollama\"><a href=\"#下载并安装Ollama\" class=\"headerlink\" title=\"下载并安装Ollama\"></a>下载并安装Ollama</h2><p>首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。</p>\n<p>Windows&#x2F;macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。</p>\n<p><img src=\"/./images/deepseek-1/download.png\" alt=\"下载\"></p>\n<p>Linux用户：需要通过命令行执行以下命令来安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择DeepSeek模型\"><a href=\"#选择DeepSeek模型\" class=\"headerlink\" title=\"选择DeepSeek模型\"></a>选择DeepSeek模型</h2><p>安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。</p>\n<p><img src=\"/./images/deepseek-1/models.png\" alt=\"模型\"></p>\n<p>7B版本：命令为 ollama run deepseek-r1:7b<br>1.5B版本：命令为 ollama run deepseek-r1:1.5b</p>\n<p><img src=\"/./images/deepseek-1/deepseek-models.png\" alt=\"deepseek模型\"></p>\n<p>这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。</p>\n<h2 id=\"运行命令\"><a href=\"#运行命令\" class=\"headerlink\" title=\"运行命令\"></a>运行命令</h2><p>选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。</p>\n<h2 id=\"效果测试\"><a href=\"#效果测试\" class=\"headerlink\" title=\"效果测试\"></a>效果测试</h2><p>一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。</p>\n<h1 id=\"使用Chatbox进行网页端访问\"><a href=\"#使用Chatbox进行网页端访问\" class=\"headerlink\" title=\"使用Chatbox进行网页端访问\"></a>使用Chatbox进行网页端访问</h1><p>命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。</p>\n<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：</p>\n<ul>\n<li>OLLAMA_HOST：设置为 0.0.0.0</li>\n<li>OLLAMA_ORIGINS：设置为 *</li>\n</ul>\n<p>在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。</p>\n<p><img src=\"/./images/deepseek-1/env-var.png\" alt=\"deepseek模型\"></p>\n<p>保存设置后，从Windows开始菜单启动Ollama。</p>\n<h2 id=\"配置Chatbox\"><a href=\"#配置Chatbox\" class=\"headerlink\" title=\"配置Chatbox\"></a>配置Chatbox</h2><p>完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。</p>\n<p>打开<a href=\"https://web.chatboxai.app/\">Chatbox</a>官网，并选择启动网页版。<br><img src=\"/./images/deepseek-1/chatboxai.png\" alt=\"ChatBox\"><br>选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。<br>在设置中选择Ollama API。</p>\n<p>选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。<br>点击“DISPLAY”选项，选择简体中文，并点击保存按钮。</p>\n<p><img src=\"/./images/deepseek-1/chatbox-setting4.png\" alt=\"deepseek模型\"></p>\n<p>完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。</p>\n<p>这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。<br><img src=\"/./images/deepseek-1/chatbox-answer.png\" alt=\"deepseek模型\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。</p>\n<p>希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cm53cihmf0003m8p1gu8u9eal","tag_id":"cm53cihmg0005m8p1fd6md0y7","_id":"cm53cihmi0009m8p10dc8ars4"},{"post_id":"cm53cihmi000am8p139hzcz0o","tag_id":"cm53cihmj000cm8p1cmymf3ee","_id":"cm53cihmk000hm8p1dxy1df0b"},{"post_id":"cm53cihmk000em8p18grse4qr","tag_id":"cm53cihmk000gm8p19nwog3jl","_id":"cm53cihmm000mm8p14l7ug71o"},{"post_id":"cm53cihmk000fm8p190owcnim","tag_id":"cm53cihml000lm8p1aqvc1nj4","_id":"cm53cihmm000rm8p1g1a5hwmv"},{"post_id":"cm53cihml000km8p1eq3bex5s","tag_id":"cm53cihmm000pm8p10i3e00j4","_id":"cm53cihmn000um8p1gn9ag5vt"},{"post_id":"cm53cihmn000vm8p15a6th0co","tag_id":"cm53cihmn000xm8p19483anb9","_id":"cm53cihmo000zm8p16tdwhgi1"}],"Tag":[{"name":"dump 性能 异常","_id":"cm53cihmg0005m8p1fd6md0y7"},{"name":"http http协议 Connection","_id":"cm53cihmj000cm8p1cmymf3ee"},{"name":"https http ssl tls","_id":"cm53cihmk000gm8p19nwog3jl"},{"name":"Garnet 缓存 微软","_id":"cm53cihml000lm8p1aqvc1nj4"},{"name":"组织 内耗","_id":"cm53cihmm000pm8p10i3e00j4"},{"name":"redis 面试 求职","_id":"cm53cihmn000xm8p19483anb9"}]}}