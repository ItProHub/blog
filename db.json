{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon_bak.ico","path":"assets/favicon_bak.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/wechat_qr.jpg","path":"assets/wechat_qr.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Jason.jpg","path":"avatar/Jason.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"source/images/hello-bg.png","path":"images/hello-bg.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/DaemonSets.png","path":"images/daemonset/DaemonSets.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/bg.png","path":"images/daemonset/bg.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/daemonset-1.png","path":"images/daemonset/daemonset-1.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/daemonset-pods.png","path":"images/daemonset/daemonset-pods.png","modified":0,"renderable":0},{"_id":"source/images/daemonset/nodes.png","path":"images/daemonset/nodes.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-3.png","path":"images/dead-message/dead-letter-3.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","path":"images/dead-message/dead-letter-exchange-1.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/bg.jpg","path":"images/dead-message/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_1.png","path":"images/dead-message/delay_comsuption_1.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_2.png","path":"images/dead-message/delay_comsuption_2.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-2.jpg","path":"images/dead-message/dead-letter-2.jpg","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/error.png","path":"images/deepseek-2/error.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/apikeys.png","path":"images/deepseek-2/apikeys.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/feedback.png","path":"images/deepseek-2/feedback.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/game1.png","path":"images/deepseek-2/game1.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/generating.gif","path":"images/deepseek-2/generating.gif","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/hot.png","path":"images/deepseek-2/hot.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/installed.png","path":"images/deepseek-2/installed.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/price.png","path":"images/deepseek-2/price.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/running.gif","path":"images/deepseek-2/running.gif","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/search.png","path":"images/deepseek-2/search.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-2/settings.png","path":"images/deepseek-2/settings.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/PageAssist.png","path":"images/deepseek-1/PageAssist.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/bg.png","path":"images/deepseek-1/bg.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/bg.webp","path":"images/deepseek-1/bg.webp","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-answer.png","path":"images/deepseek-1/chatbox-answer.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-setting.png","path":"images/deepseek-1/chatbox-setting.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-setting2.png","path":"images/deepseek-1/chatbox-setting2.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-setting3.png","path":"images/deepseek-1/chatbox-setting3.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/chatboxai.png","path":"images/deepseek-1/chatboxai.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/cmd-effect.png","path":"images/deepseek-1/cmd-effect.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/deepseek-models.png","path":"images/deepseek-1/deepseek-models.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/download.png","path":"images/deepseek-1/download.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/env_var.png","path":"images/deepseek-1/env_var.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/chatbox-setting4.png","path":"images/deepseek-1/chatbox-setting4.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/environment.png","path":"images/deepseek-1/environment.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/late.jpg","path":"images/deepseek-1/late.jpg","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/models.png","path":"images/deepseek-1/models.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/pull.png","path":"images/deepseek-1/pull.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/pulling.png","path":"images/deepseek-1/pulling.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/qiruu-dhecb.gif","path":"images/deepseek-1/qiruu-dhecb.gif","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/resource.png","path":"images/deepseek-1/resource.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/speed.gif","path":"images/deepseek-1/speed.gif","modified":0,"renderable":0},{"_id":"source/images/deepseek-1/success.png","path":"images/deepseek-1/success.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-hackernews/企业微信截图_20250220100545.png","path":"images/deepseek-hackernews/企业微信截图_20250220100545.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/RAG-system-architecture.png","path":"images/deepseek-rag/RAG-system-architecture.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/RAG-system-architecture.ppm","path":"images/deepseek-rag/RAG-system-architecture.ppm","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/baipiao.jpg","path":"images/deepseek-rag/baipiao.jpg","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/bg.png","path":"images/deepseek-rag/bg.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/hallucination.png","path":"images/deepseek-rag/hallucination.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/hallucination.webp","path":"images/deepseek-rag/hallucination.webp","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/imglarger.zip","path":"images/deepseek-rag/imglarger.zip","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/rag-result.png","path":"images/deepseek-rag/rag-result.png","modified":0,"renderable":0},{"_id":"source/images/deepseek-rag/raw-result.png","path":"images/deepseek-rag/raw-result.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/bg.png","path":"images/docker-1/bg.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/configurations.png","path":"images/docker-1/configurations.png","modified":0,"renderable":0},{"_id":"source/images/docker-1/multi-env.png","path":"images/docker-1/multi-env.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/after.png","path":"images/docker-2/after.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/before.png","path":"images/docker-2/before.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect1.png","path":"images/docker-2/inspect1.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect2.png","path":"images/docker-2/inspect2.png","modified":0,"renderable":0},{"_id":"source/images/docker-2/inspect3.png","path":"images/docker-2/inspect3.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/bg.png","path":"images/docker-log/bg.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/courgette.log","path":"images/docker-log/courgette.log","modified":0,"renderable":0},{"_id":"source/images/docker-log/log1.png","path":"images/docker-log/log1.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/log2.png","path":"images/docker-log/log2.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/log3.png","path":"images/docker-log/log3.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/log4.png","path":"images/docker-log/log4.png","modified":0,"renderable":0},{"_id":"source/images/docker-log/log5.png","path":"images/docker-log/log5.png","modified":0,"renderable":0},{"_id":"source/images/dump/bg.png","path":"images/dump/bg.png","modified":0,"renderable":0},{"_id":"source/images/dump/crash.jpeg","path":"images/dump/crash.jpeg","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_1.png","path":"images/dump/windbg_1.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_2.png","path":"images/dump/windbg_2.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_3.png","path":"images/dump/windbg_3.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_4.png","path":"images/dump/windbg_4.png","modified":0,"renderable":0},{"_id":"source/images/function-calling/bg.jpeg","path":"images/function-calling/bg.jpeg","modified":0,"renderable":0},{"_id":"source/images/function-calling/completion.png","path":"images/function-calling/completion.png","modified":0,"renderable":0},{"_id":"source/images/function-calling/labour.jpg","path":"images/function-calling/labour.jpg","modified":0,"renderable":0},{"_id":"source/images/function-calling/out.jpg","path":"images/function-calling/out.jpg","modified":0,"renderable":0},{"_id":"source/images/function-calling/process.png","path":"images/function-calling/process.png","modified":0,"renderable":0},{"_id":"source/images/function-calling/result-mini.gif","path":"images/function-calling/result-mini.gif","modified":0,"renderable":0},{"_id":"source/images/function-calling/result.gif","path":"images/function-calling/result.gif","modified":0,"renderable":0},{"_id":"source/images/function-calling/result.png","path":"images/function-calling/result.png","modified":0,"renderable":0},{"_id":"source/images/function-calling/search.png","path":"images/function-calling/search.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/filesystem.png","path":"images/docker-layer/filesystem.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/layers.png","path":"images/docker-layer/layers.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/ls_upper.png","path":"images/docker-layer/ls_upper.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/tree.png","path":"images/docker-layer/tree.png","modified":0,"renderable":0},{"_id":"source/images/docker-layer/merged.png","path":"images/docker-layer/merged.png","modified":0,"renderable":0},{"_id":"source/images/garnet/1.png","path":"images/garnet/1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/client.png","path":"images/garnet/client.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compare1.png","path":"images/garnet/compare1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compatible.png","path":"images/garnet/compatible.png","modified":0,"renderable":0},{"_id":"source/images/garnet/connect.png","path":"images/garnet/connect.png","modified":0,"renderable":0},{"_id":"source/images/garnet/custom-command.png","path":"images/garnet/custom-command.png","modified":0,"renderable":0},{"_id":"source/images/garnet/log.png","path":"images/garnet/log.png","modified":0,"renderable":0},{"_id":"source/images/garnet/running.png","path":"images/garnet/running.png","modified":0,"renderable":0},{"_id":"source/images/helm/Helmcharts.png","path":"images/helm/Helmcharts.png","modified":0,"renderable":0},{"_id":"source/images/helm/helm3-arch.png","path":"images/helm/helm3-arch.png","modified":0,"renderable":0},{"_id":"source/images/helm/lens-helm.png","path":"images/helm/lens-helm.png","modified":0,"renderable":0},{"_id":"source/images/helm/lens-pod.png","path":"images/helm/lens-pod.png","modified":0,"renderable":0},{"_id":"source/images/helm/new-helm.png","path":"images/helm/new-helm.png","modified":0,"renderable":0},{"_id":"source/images/encrypt-hash-signature/md5.png","path":"images/encrypt-hash-signature/md5.png","modified":0,"renderable":0},{"_id":"source/images/encrypt-hash-signature/rsa.png","path":"images/encrypt-hash-signature/rsa.png","modified":0,"renderable":0},{"_id":"source/images/encrypt-hash-signature/certificate.png","path":"images/encrypt-hash-signature/certificate.png","modified":0,"renderable":0},{"_id":"source/images/image-search/bg.jpg","path":"images/image-search/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/image-search/images.png","path":"images/image-search/images.png","modified":0,"renderable":0},{"_id":"source/images/image-search/process.png","path":"images/image-search/process.png","modified":0,"renderable":0},{"_id":"source/images/image-search/qdrant.png","path":"images/image-search/qdrant.png","modified":0,"renderable":0},{"_id":"source/images/image-search/search.gif","path":"images/image-search/search.gif","modified":0,"renderable":0},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","path":"images/internal-loss/20231109_sy_01.jpg","modified":0,"renderable":0},{"_id":"source/images/internal-loss/996.jpg","path":"images/internal-loss/996.jpg","modified":0,"renderable":0},{"_id":"source/images/internal-loss/depressed.jpg","path":"images/internal-loss/depressed.jpg","modified":0,"renderable":0},{"_id":"source/images/java-init/java.webp","path":"images/java-init/java.webp","modified":0,"renderable":0},{"_id":"source/images/java-init/me.png","path":"images/java-init/me.png","modified":0,"renderable":0},{"_id":"source/images/java-init/mid-life-cris.jpg","path":"images/java-init/mid-life-cris.jpg","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/bg.png","path":"images/js-monitoring/bg.png","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/click.png","path":"images/js-monitoring/click.png","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/courgette.log","path":"images/js-monitoring/courgette.log","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/error.png","path":"images/js-monitoring/error.png","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/fetch.png","path":"images/js-monitoring/fetch.png","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/flow_diagram.png","path":"images/js-monitoring/flow_diagram.png","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/fmp.png","path":"images/js-monitoring/fmp.png","modified":0,"renderable":0},{"_id":"source/images/js-monitoring/promise.png","path":"images/js-monitoring/promise.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/EventTarget.png","path":"images/js-signal/EventTarget.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/EventTarget2.png","path":"images/js-signal/EventTarget2.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/EventTarget3.png","path":"images/js-signal/EventTarget3.png","modified":0,"renderable":0},{"_id":"source/images/js-signal/responsive.gif","path":"images/js-signal/responsive.gif","modified":0,"renderable":0},{"_id":"source/images/js-signal/switch-theme.gif","path":"images/js-signal/switch-theme.gif","modified":0,"renderable":0},{"_id":"source/images/https/bg.jpg","path":"images/https/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/https/ca.png","path":"images/https/ca.png","modified":0,"renderable":0},{"_id":"source/images/https/ca2.png","path":"images/https/ca2.png","modified":0,"renderable":0},{"_id":"source/images/https/cipher-suites.png","path":"images/https/cipher-suites.png","modified":0,"renderable":0},{"_id":"source/images/https/client-hello.png","path":"images/https/client-hello.png","modified":0,"renderable":0},{"_id":"source/images/https/encrypted.png","path":"images/https/encrypted.png","modified":0,"renderable":0},{"_id":"source/images/https/handshake.png","path":"images/https/handshake.png","modified":0,"renderable":0},{"_id":"source/images/https/negotiated-cipher-suite.png","path":"images/https/negotiated-cipher-suite.png","modified":0,"renderable":0},{"_id":"source/images/https/security.png","path":"images/https/security.png","modified":0,"renderable":0},{"_id":"source/images/https/expire.png","path":"images/https/expire.png","modified":0,"renderable":0},{"_id":"source/images/log/bad.png","path":"images/log/bad.png","modified":0,"renderable":0},{"_id":"source/images/log/bg.png","path":"images/log/bg.png","modified":0,"renderable":0},{"_id":"source/images/log/confident.png","path":"images/log/confident.png","modified":0,"renderable":0},{"_id":"source/images/log/courgette.log","path":"images/log/courgette.log","modified":0,"renderable":0},{"_id":"source/images/log/long.png","path":"images/log/long.png","modified":0,"renderable":0},{"_id":"source/images/log/whoami.jpg","path":"images/log/whoami.jpg","modified":0,"renderable":0},{"_id":"source/images/mcp/3aabd8804251c0364cbde9d2e4be6dc8e8c2faec-2880x1620.webp","path":"images/mcp/3aabd8804251c0364cbde9d2e4be6dc8e8c2faec-2880x1620.webp","modified":0,"renderable":0},{"_id":"source/images/mcp/architecture.png","path":"images/mcp/architecture.png","modified":0,"renderable":0},{"_id":"source/images/mcp/bg.png","path":"images/mcp/bg.png","modified":0,"renderable":0},{"_id":"source/images/mcp/inspector.png","path":"images/mcp/inspector.png","modified":0,"renderable":0},{"_id":"source/images/mcp/result2.png","path":"images/mcp/result2.png","modified":0,"renderable":0},{"_id":"source/images/mcp/architecture2.png","path":"images/mcp/architecture2.png","modified":0,"renderable":0},{"_id":"source/images/mcp/result3.png","path":"images/mcp/result3.png","modified":0,"renderable":0},{"_id":"source/images/mcp/result1.png","path":"images/mcp/result1.png","modified":0,"renderable":0},{"_id":"source/images/mcp/running.png","path":"images/mcp/running.png","modified":0,"renderable":0},{"_id":"source/images/mcp/with-mcp.png","path":"images/mcp/with-mcp.png","modified":0,"renderable":0},{"_id":"source/images/mcp/without-mcp.png","path":"images/mcp/without-mcp.png","modified":0,"renderable":0},{"_id":"source/images/openai-operator/bg.png","path":"images/openai-operator/bg.png","modified":0,"renderable":0},{"_id":"source/images/openai-operator/decline.jpg","path":"images/openai-operator/decline.jpg","modified":0,"renderable":0},{"_id":"source/images/openai-operator/future.jpg","path":"images/openai-operator/future.jpg","modified":0,"renderable":0},{"_id":"source/images/openai-operator/operator-demo.gif","path":"images/openai-operator/operator-demo.gif","modified":0,"renderable":0},{"_id":"source/images/openai-operator/operator.jpg","path":"images/openai-operator/operator.jpg","modified":0,"renderable":0},{"_id":"source/images/openai-operator/price.png","path":"images/openai-operator/price.png","modified":0,"renderable":0},{"_id":"source/images/openai-operator/principle.png","path":"images/openai-operator/principle.png","modified":0,"renderable":0},{"_id":"source/images/openai-operator/principle.webp","path":"images/openai-operator/principle.webp","modified":0,"renderable":0},{"_id":"source/images/http/TCP-connection-1.png","path":"images/http/TCP-connection-1.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect.png","path":"images/http/auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect2.png","path":"images/http/auto-disconnect2.png","modified":0,"renderable":0},{"_id":"source/images/http/curl-header.png","path":"images/http/curl-header.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-1.png","path":"images/http/handshake-1.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-2.png","path":"images/http/handshake-2.png","modified":0,"renderable":0},{"_id":"source/images/http/http-keep-alive-header.png","path":"images/http/http-keep-alive-header.png","modified":0,"renderable":0},{"_id":"source/images/http/http-request.png","path":"images/http/http-request.png","modified":0,"renderable":0},{"_id":"source/images/http/perisitent-connection.png","path":"images/http/perisitent-connection.png","modified":0,"renderable":0},{"_id":"source/images/http/request-methods.png","path":"images/http/request-methods.png","modified":0,"renderable":0},{"_id":"source/images/http/timeout-auto-disconnect.png","path":"images/http/timeout-auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/mfa/bg.png","path":"images/mfa/bg.png","modified":0,"renderable":0},{"_id":"source/images/mfa/github.png","path":"images/mfa/github.png","modified":0,"renderable":0},{"_id":"source/images/mfa/run.png","path":"images/mfa/run.png","modified":0,"renderable":0},{"_id":"source/images/mfa/web.png","path":"images/mfa/web.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/bg.png","path":"images/midscenejs/bg.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/fail.png","path":"images/midscenejs/fail.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/login-report.png","path":"images/midscenejs/login-report.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/login-result.png","path":"images/midscenejs/login-result.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/login.png","path":"images/midscenejs/login.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/midscene-locate.png","path":"images/midscenejs/midscene-locate.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/playwright-report.png","path":"images/midscenejs/playwright-report.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/midscene-login.gif","path":"images/midscenejs/midscene-login.gif","modified":0,"renderable":0},{"_id":"source/images/midscenejs/principle.png","path":"images/midscenejs/principle.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/yaml.png","path":"images/midscenejs/yaml.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/企业微信截图_20250228180601.png","path":"images/midscenejs/企业微信截图_20250228180601.png","modified":0,"renderable":0},{"_id":"source/images/midscenejs/企业微信截图_20250303204121.png","path":"images/midscenejs/企业微信截图_20250303204121.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/bg.jpg","path":"images/parallelism/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-result.png","path":"images/parallelism/concurrency-result.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-vs-parallelism-1.png","path":"images/parallelism/concurrency-vs-parallelism-1.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-vs-parallelism-2.png","path":"images/parallelism/concurrency-vs-parallelism-2.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/concurrency-vs-parallelism-3.png","path":"images/parallelism/concurrency-vs-parallelism-3.png","modified":0,"renderable":0},{"_id":"source/images/parallelism/courgette.log","path":"images/parallelism/courgette.log","modified":0,"renderable":0},{"_id":"source/images/parallelism/parallelism-result.png","path":"images/parallelism/parallelism-result.png","modified":0,"renderable":0},{"_id":"source/images/proxy/forward-proxy.png","path":"images/proxy/forward-proxy.png","modified":0,"renderable":0},{"_id":"source/images/proxy/reverse-proxy.png","path":"images/proxy/reverse-proxy.png","modified":0,"renderable":0},{"_id":"source/images/proxy/transparent-proxy.png","path":"images/proxy/transparent-proxy.png","modified":0,"renderable":0},{"_id":"source/images/proxy/bg.jpg","path":"images/proxy/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/quic/handshake.png","path":"images/quic/handshake.png","modified":0,"renderable":0},{"_id":"source/images/quic/head_of_line_blocking.png","path":"images/quic/head_of_line_blocking.png","modified":0,"renderable":0},{"_id":"source/images/quic/quic-logo.png","path":"images/quic/quic-logo.png","modified":0,"renderable":0},{"_id":"source/images/quic/quic.png","path":"images/quic/quic.png","modified":0,"renderable":0},{"_id":"source/images/quic/tcp.png","path":"images/quic/tcp.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/16elk-ujaxc.gif","path":"images/rabbitmq-basic/16elk-ujaxc.gif","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/channel1.png","path":"images/rabbitmq-basic/channel1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/channel2.png","path":"images/rabbitmq-basic/channel2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/default-exchange.png","path":"images/rabbitmq-basic/default-exchange.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/direct-exchange.svg","path":"images/rabbitmq-basic/direct-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","path":"images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout-exchange.svg","path":"images/rabbitmq-basic/fanout-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout.mp4","path":"images/rabbitmq-basic/fanout.mp4","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/fanout.png","path":"images/rabbitmq-basic/fanout.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/main.png","path":"images/rabbitmq-basic/main.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/rabbitmq-headers-exchange.svg","path":"images/rabbitmq-basic/rabbitmq-headers-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/topic-exchange.svg","path":"images/rabbitmq-basic/topic-exchange.svg","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-basic/vro2s-b2mub.gif","path":"images/rabbitmq-basic/vro2s-b2mub.gif","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/courgette.log","path":"images/rabbitmq-quarum/courgette.log","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/normal.png","path":"images/rabbitmq-quarum/normal.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/quarum1.png","path":"images/rabbitmq-quarum/quarum1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/quarum2.png","path":"images/rabbitmq-quarum/quarum2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_error1.png","path":"images/rabbitmq-quarum/stream_error1.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_error2.png","path":"images/rabbitmq-quarum/stream_error2.png","modified":0,"renderable":0},{"_id":"source/images/rabbitmq-quarum/stream_offset.png","path":"images/rabbitmq-quarum/stream_offset.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/bg.jpg","path":"images/sticky-packet/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/sender-sticky.png","path":"images/sticky-packet/sender-sticky.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/server-sticky.png","path":"images/sticky-packet/server-sticky.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/solve-sender-sticky.png","path":"images/sticky-packet/solve-sender-sticky.png","modified":0,"renderable":0},{"_id":"source/images/sticky-packet/solve-server-sticky.png","path":"images/sticky-packet/solve-server-sticky.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/bg.png","path":"images/redis-interview/bg.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-avalanche.png","path":"images/redis-interview/cache-avalanche.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-breakdown.png","path":"images/redis-interview/cache-breakdown.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-penetration.png","path":"images/redis-interview/cache-penetration.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/memory.png","path":"images/redis-interview/memory.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/recruitment.png","path":"images/redis-interview/recruitment.png","modified":0,"renderable":0},{"_id":"source/images/stream-output/4a7aa-203zt.gif","path":"images/stream-output/4a7aa-203zt.gif","modified":0,"renderable":0},{"_id":"source/images/stream-output/courgette.log","path":"images/stream-output/courgette.log","modified":0,"renderable":0},{"_id":"source/images/stream-output/gpt-1.gif","path":"images/stream-output/gpt-1.gif","modified":0,"renderable":0},{"_id":"source/images/stream-output/gzip.png","path":"images/stream-output/gzip.png","modified":0,"renderable":0},{"_id":"source/images/stream-output/regular-http-communication.png","path":"images/stream-output/regular-http-communication.png","modified":0,"renderable":0},{"_id":"source/images/stream-output/result.gif","path":"images/stream-output/result.gif","modified":0,"renderable":0},{"_id":"source/images/stream-output/sse-communication.png","path":"images/stream-output/sse-communication.png","modified":0,"renderable":0},{"_id":"source/images/stream-output/sse.gif","path":"images/stream-output/sse.gif","modified":0,"renderable":0},{"_id":"source/images/webrtc/1_kDeCUgDd-T-KLvSH4sTiLw.png","path":"images/webrtc/1_kDeCUgDd-T-KLvSH4sTiLw.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/bg.png","path":"images/webrtc/bg.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/connections.png","path":"images/webrtc/connections.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/result.gif","path":"images/webrtc/result.gif","modified":0,"renderable":0},{"_id":"source/images/webrtc/server.png","path":"images/webrtc/server.png","modified":0,"renderable":0},{"_id":"source/images/webrtc/webrtc-overview.svg","path":"images/webrtc/webrtc-overview.svg","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/bg.jpg","path":"images/task-completion-source/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/pause-1.png","path":"images/task-completion-source/pause-1.png","modified":0,"renderable":0},{"_id":"source/images/task-completion-source/pause-2.png","path":"images/task-completion-source/pause-2.png","modified":0,"renderable":0},{"_id":"source/images/rspack/bg.png","path":"images/rspack/bg.png","modified":0,"renderable":0},{"_id":"source/images/rspack/result1.png","path":"images/rspack/result1.png","modified":0,"renderable":0},{"_id":"source/images/rspack/tools.png","path":"images/rspack/tools.png","modified":0,"renderable":0},{"_id":"source/images/java-init/bg-1.webp","path":"images/java-init/bg-1.webp","modified":0,"renderable":0},{"_id":"source/images/java-init/bg-2.webp","path":"images/java-init/bg-2.webp","modified":0,"renderable":0},{"_id":"source/images/java-init/DALL·E 2025-04-07 14.02.49 - An inspiring illustration of a person seen from behind, facing a sunrise on the horizon. The person is walking forward with confidence, wearing a shor.webp","path":"images/java-init/DALL·E 2025-04-07 14.02.49 - An inspiring illustration of a person seen from behind, facing a sunrise on the horizon. The person is walking forward with confidence, wearing a shor.webp","modified":0,"renderable":0},{"_id":"source/images/java-init/future.png","path":"images/java-init/future.png","modified":0,"renderable":0},{"_id":"source/images/java-init/java.png","path":"images/java-init/java.png","modified":0,"renderable":0},{"_id":"source/images/java-init/DALL·E 2025-04-07 11.14.35 - An artistic illustration of a person seen from behind, walking toward a beautiful sunrise on the horizon. The figure is wearing casual clothes_ a shor.webp","path":"images/java-init/DALL·E 2025-04-07 11.14.35 - An artistic illustration of a person seen from behind, walking toward a beautiful sunrise on the horizon. The figure is wearing casual clothes_ a shor.webp","modified":0,"renderable":0},{"_id":"source/images/spring-1/fail.png","path":"images/spring-1/fail.png","modified":0,"renderable":0},{"_id":"source/images/spring-1/architecture.png","path":"images/spring-1/architecture.png","modified":0,"renderable":0},{"_id":"source/images/spring-1/bg.png","path":"images/spring-1/bg.png","modified":0,"renderable":0},{"_id":"source/images/spring-1/result.png","path":"images/spring-1/result.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/AllowAnonymous.png","path":"images/javelin-2/AllowAnonymous.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/json.png","path":"images/javelin-2/json.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/post-params.png","path":"images/javelin-2/post-params.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/query-params.png","path":"images/javelin-2/query-params.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/route-params.png","path":"images/javelin-2/route-params.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/unauthorized.png","path":"images/javelin-2/unauthorized.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/authorize.png","path":"images/javelin-2/authorize.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/life-cycle.png","path":"images/javelin-2/life-cycle.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/log.png","path":"images/javelin-2/log.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/error.png","path":"images/javelin-2/error.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/pipeline.png","path":"images/javelin-2/pipeline.png","modified":0,"renderable":0},{"_id":"source/images/javelin-2/request-delegate-pipeline.png","path":"images/javelin-2/request-delegate-pipeline.png","modified":0,"renderable":0},{"_id":"source/images/javelin-3/uml.png","path":"images/javelin-3/uml.png","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/ChatGPT Image 2025年5月6日 16_05_18.png","path":"images/javelin-servlet/ChatGPT Image 2025年5月6日 16_05_18.png","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/State-of-sevlet-life-cycle.webp","path":"images/javelin-servlet/State-of-sevlet-life-cycle.webp","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/architecture.png","path":"images/javelin-servlet/architecture.png","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/result.png","path":"images/javelin-servlet/result.png","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/servlet-container.png","path":"images/javelin-servlet/servlet-container.png","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/servlet-lifecycle.png","path":"images/javelin-servlet/servlet-lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/servlet.webp","path":"images/javelin-servlet/servlet.webp","modified":0,"renderable":0},{"_id":"source/images/javelin-servlet/servlet.png","path":"images/javelin-servlet/servlet.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/entity-delete-2.png","path":"images/javelin-dal/entity-delete-2.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/architecture.png","path":"images/javelin-dal/architecture.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/entity-delete-1.png","path":"images/javelin-dal/entity-delete-1.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/entity-insert-1.png","path":"images/javelin-dal/entity-insert-1.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/entity-insert-2.png","path":"images/javelin-dal/entity-insert-2.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/entity-read-1.png","path":"images/javelin-dal/entity-read-1.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/entity-update-1.png","path":"images/javelin-dal/entity-update-1.png","modified":0,"renderable":0},{"_id":"source/images/javelin-dal/entity-update-2.png","path":"images/javelin-dal/entity-update-2.png","modified":0,"renderable":0},{"_id":"source/images/javelin-unit-testing/zhaolei.png","path":"images/javelin-unit-testing/zhaolei.png","modified":0,"renderable":0},{"_id":"source/images/javelin-unit-testing/jacoco.png","path":"images/javelin-unit-testing/jacoco.png","modified":0,"renderable":0},{"_id":"source/images/javelin-unit-testing/tdd.jpg","path":"images/javelin-unit-testing/tdd.jpg","modified":0,"renderable":0},{"_id":"source/images/codex/environment.png","path":"images/codex/environment.png","modified":0,"renderable":0},{"_id":"source/images/codex/internet.png","path":"images/codex/internet.png","modified":0,"renderable":0},{"_id":"source/images/codex/project-1.png","path":"images/codex/project-1.png","modified":0,"renderable":0},{"_id":"source/images/codex/project-init.png","path":"images/codex/project-init.png","modified":0,"renderable":0},{"_id":"source/images/css-scope/bg.png","path":"images/css-scope/bg.png","modified":0,"renderable":0},{"_id":"source/images/css-scope/dynamic.png","path":"images/css-scope/dynamic.png","modified":0,"renderable":0},{"_id":"source/images/css-scope/inline.png","path":"images/css-scope/inline.png","modified":0,"renderable":0},{"_id":"source/images/css-scope/result.png","path":"images/css-scope/result.png","modified":0,"renderable":0},{"_id":"source/images/css-scope/test1.png","path":"images/css-scope/test1.png","modified":0,"renderable":0},{"_id":"source/images/css-scope/vue-scoped-style.png","path":"images/css-scope/vue-scoped-style.png","modified":0,"renderable":0},{"_id":"source/images/codex/bg.jpg","path":"images/codex/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/codex/npe.png","path":"images/codex/npe.png","modified":0,"renderable":0},{"_id":"source/images/codex/project-init-pr.png","path":"images/codex/project-init-pr.png","modified":0,"renderable":0},{"_id":"source/images/codex/unit-test.png","path":"images/codex/unit-test.png","modified":0,"renderable":0},{"_id":"source/images/promise/process.png","path":"images/promise/process.png","modified":0,"renderable":0},{"_id":"source/images/promise/event_loop.gif","path":"images/promise/event_loop.gif","modified":0,"renderable":0},{"_id":"source/images/promise/multi-queue.png","path":"images/promise/multi-queue.png","modified":0,"renderable":0},{"_id":"source/images/promise/fight.png","path":"images/promise/fight.png","modified":0,"renderable":0},{"_id":"source/images/promise/bg.png","path":"images/promise/bg.png","modified":0,"renderable":0},{"_id":"source/images/send-off-1/drink.png","path":"images/send-off-1/drink.png","modified":0,"renderable":0},{"_id":"source/images/send-off-1/goodbye.png","path":"images/send-off-1/goodbye.png","modified":0,"renderable":0},{"_id":"source/images/send-off-1/work-overtime.png","path":"images/send-off-1/work-overtime.png","modified":0,"renderable":0},{"_id":"source/images/js-arrow-function/stack.png","path":"images/js-arrow-function/stack.png","modified":0,"renderable":0},{"_id":"source/images/js-arrow-function/choose.png","path":"images/js-arrow-function/choose.png","modified":0,"renderable":0},{"_id":"source/images/js-arrow-function/bg.png","path":"images/js-arrow-function/bg.png","modified":0,"renderable":0},{"_id":"source/images/oauth/door.png","path":"images/oauth/door.png","modified":0,"renderable":0},{"_id":"source/images/oauth/ChatGPT Image 2025年9月4日 15_30_38.png","path":"images/oauth/ChatGPT Image 2025年9月4日 15_30_38.png","modified":0,"renderable":0},{"_id":"source/images/oauth/oauth.png","path":"images/oauth/oauth.png","modified":0,"renderable":0},{"_id":"source/images/geo/SEO-GEO.png","path":"images/geo/SEO-GEO.png","modified":0,"renderable":0},{"_id":"source/images/geo/bg.png","path":"images/geo/bg.png","modified":1,"renderable":0},{"_id":"source/images/geo/bg.webp","path":"images/geo/bg.webp","modified":1,"renderable":0}],"Cache":[{"_id":"source/images/docker-log/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1738853895906},{"_id":"source/images/js-monitoring/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1743633587628},{"_id":"source/images/log/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1734591686566},{"_id":"source/images/parallelism/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1736269704686},{"_id":"source/images/rabbitmq-quarum/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1720774060906},{"_id":"source/images/stream-output/courgette.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1731620201071},{"_id":"source/_posts/TaskCompletionSource.md","hash":"a2bcfbda71ac8d8406e1bd14fa333169457384e5","modified":1717658556858},{"_id":"source/_posts/daemonset.md","hash":"bb165cf091f0a25e1fab93fc06dcc7bd2ec4e71f","modified":1722592868923},{"_id":"source/_posts/MCP.md","hash":"b50b9565608bf44d9e468fe63c80e2454c8ec2ca","modified":1742991453342},{"_id":"source/_posts/deepseek-vscode.md","hash":"2a823e638131c89048f88ec70f55bbf06332d10a","modified":1739346151858},{"_id":"source/_posts/deepseek-rag.md","hash":"84c3ea11b020065fc7f19b6dfcc23d2c61e73e0e","modified":1742267422717},{"_id":"source/_posts/dead-message.md","hash":"e0a8e83a589cd97cb599fd243d348f4b1896eb71","modified":1716628987803},{"_id":"source/_posts/docker-1.md","hash":"3f9d81f24d238d3b9a48b5ec67c5a65fb52388f8","modified":1720255588285},{"_id":"source/_posts/deepseek-1.md","hash":"20ef8e02532900e2b9fb8ca4580f0671f2ce4b65","modified":1739172880617},{"_id":"source/_posts/docker-layer.md","hash":"f608b1c31fe24320a204f1473a25524dc90110b9","modified":1723448461339},{"_id":"source/_posts/docker-log.md","hash":"6277ec78715ac2c07b778aba5c34eed1abc451d1","modified":1738831963934},{"_id":"source/_posts/docker-2.md","hash":"a75951a67f13186efc0b09411b6255a83af11df5","modified":1720444768360},{"_id":"source/_posts/function-calling.md","hash":"f3e8da4827b4d8fbc0619801a488add8f6dcbdd6","modified":1740469827478},{"_id":"source/_posts/encrypt-hash-signature.md","hash":"608837ab32dd4166ef5ea0339425281ffc9c5667","modified":1730878713008},{"_id":"source/_posts/dump.md","hash":"fc0d11e98d4a2c35e8f590fc901c33ec87cf1654","modified":1715157478693},{"_id":"source/_posts/garnet.md","hash":"9fa10e3a47f78d4b6f8465f3e49e33da56758f21","modified":1714100842478},{"_id":"source/_posts/hello-world-bak.md1","hash":"1e16dbc0dbf8b18e83f47dbbdffd0d1f27cfe955","modified":1710398484836},{"_id":"source/_posts/java-init.md","hash":"98a373d2b521b6c5f45f4dca8a312472239416b3","modified":1743995732610},{"_id":"source/_posts/hello-world.md","hash":"3c422ea24b75465e6ea2a80c268251ca0a03e042","modified":1714100836002},{"_id":"source/_posts/https.md","hash":"00df307cec478b57c6b9ab848f2b3d2ef578098a","modified":1714100800272},{"_id":"source/_posts/js-monitoring.md","hash":"c54cfc42109f9ea960fa029228826d8f861cb8d2","modified":1743564015169},{"_id":"source/_posts/js-signal.md","hash":"99254f370782596935a99c866ff0dffef867da63","modified":1730790518259},{"_id":"source/_posts/mfa.md","hash":"13306922ee3043abf2dc43733c1d3b71d6e44b70","modified":1732170191011},{"_id":"source/_posts/http.md","hash":"e538858062edce06c26c8060d05f61b3e6fe772b","modified":1714100804259},{"_id":"source/_posts/k8s-helm.md","hash":"7d95c728a51be2354d84d3707104ab0267715ffc","modified":1733985051694},{"_id":"source/_posts/log.md","hash":"8f96cc04dba4260efe314cbb2def15234798a71a","modified":1735200386992},{"_id":"source/_posts/openai-operator.md","hash":"6cf99706fd17a628f156a818dfc04c4074ac504a","modified":1739516127827},{"_id":"source/_posts/organization-internal-loss.md","hash":"b157730ebdda6cfd58233ff8ec9d9bfed27d37b1","modified":1714100795957},{"_id":"source/_posts/parallelism.md","hash":"86a4d802b4eb8a1ce9e35778c85e6ebc9c42103f","modified":1736317267620},{"_id":"source/_posts/proxy.md","hash":"fbe68bb5c014a73c809edf55bd34ac75f88dc814","modified":1718931872131},{"_id":"source/_posts/midscenejs.md","hash":"52c11e2a94969b68092eb1039e86d02428223297","modified":1741050655104},{"_id":"source/_posts/rabbitmq-basic.md","hash":"9d43ee83b6448cbc3cfd9e77099ab1ee31027684","modified":1720615377682},{"_id":"source/_posts/redis-interview-1.md","hash":"951b57d41f67b3f9287684d1808c63e0ab08023d","modified":1714102286087},{"_id":"source/_posts/rspack.md","hash":"4b4159395b0e9406b8725c33f7bacf93669f95ec","modified":1732869205589},{"_id":"source/_posts/rabbitmq-quorum.md","hash":"01529732ac69c5892cb1c977a36b8093fed2fe84","modified":1720857305748},{"_id":"source/_posts/quic.md","hash":"f69a826a8a6c38e5269bff4127f55bb5dce9f6df","modified":1724379707402},{"_id":"source/_posts/sticky-packet.md","hash":"e71dbd0f9ac05830a8921dda3ec1ea5e8723069c","modified":1724999441472},{"_id":"source/_posts/web-rtc.md","hash":"750a7ee5daf2b557581431e8f07a6d75cec4cc4f","modified":1734418398657},{"_id":"source/_posts/stream-output.md","hash":"77b7564dd2485195558714d2f3e694ab455b7fd5","modified":1731490817137},{"_id":"source/_posts/similar-image-search.md","hash":"80b6ecb4440b108c26f92fd41d4f1d326f88eba5","modified":1717774298746},{"_id":"source/images/daemonset/DaemonSets.png","hash":"b2d8cb6e9f9a3246d70a6c4f1fa6656c6128eb67","modified":1722580496257},{"_id":"source/images/daemonset/daemonset-1.png","hash":"30bd683b3eba29092f63bb3c3d1b3742a94706e4","modified":1722562440090},{"_id":"source/images/daemonset/nodes.png","hash":"9ddeb9b6441cfee33edce7aa99af8058c7a291b1","modified":1722586074002},{"_id":"source/images/dead-message/dead-letter-3.png","hash":"d8017b10c2efd5448993b92f0a35783e4d0b71f7","modified":1716626485267},{"_id":"source/images/dead-message/bg.jpg","hash":"e0de32bdd097eeb58f534882e876a282606db679","modified":1716366165441},{"_id":"source/images/dead-message/delay_comsuption_2.png","hash":"f9b57ebe4ba7cefabad08a139f92e619fd1aae8f","modified":1716627676317},{"_id":"source/images/deepseek-2/error.png","hash":"43b9b8db9d3a4155becc2bdcdee54441a9a022d5","modified":1739343779829},{"_id":"source/images/dead-message/delay_comsuption_1.png","hash":"c093bbb3f975f40087d037aa56b8fd32ed866332","modified":1716627815685},{"_id":"source/images/daemonset/daemonset-pods.png","hash":"ffc713e43daebc3db7fbcde65c154bfc0c4e5148","modified":1722586245355},{"_id":"source/images/deepseek-2/feedback.png","hash":"fa95b25493a766d74db687d915083eba442fd3a2","modified":1739343897812},{"_id":"source/images/deepseek-2/search.png","hash":"e1d6a5d579f466543796eccb5328a15ed978a407","modified":1739177923324},{"_id":"source/images/deepseek-2/settings.png","hash":"956b2095c228ae679457e2d5402bf8b349d258f3","modified":1739178927123},{"_id":"source/images/deepseek-1/chatbox-answer.png","hash":"d2a9765ca4d3eb08839c8a7a6cb4714fe04dedb8","modified":1739157987522},{"_id":"source/images/deepseek-1/bg.webp","hash":"bbf5ee687ba71eccce5b7ffcecac84e1c587300a","modified":1739160177851},{"_id":"source/images/deepseek-1/deepseek-models.png","hash":"d668dcfc63c26f25272b0fc517eddd359a1f5ba7","modified":1738899736949},{"_id":"source/images/deepseek-1/download.png","hash":"0a6d5cbaa8b0b86e005028706f149c8106a53699","modified":1738911122666},{"_id":"source/images/deepseek-1/environment.png","hash":"b273ee73bb6d996c2c6d5d6730864f850b93d60a","modified":1739155321625},{"_id":"source/images/deepseek-1/chatbox-setting4.png","hash":"1cd83b0e6b7b8102e85b9d35ce069b7228b2ab09","modified":1739156792735},{"_id":"source/images/deepseek-1/late.jpg","hash":"d48b1789f7cd24eac8a3618b0154f76d26fb255a","modified":1738897669658},{"_id":"source/images/deepseek-1/resource.png","hash":"145758ebe9b03dcf295e23e838a94ec98fa0d6df","modified":1739159046167},{"_id":"source/images/deepseek-rag/baipiao.jpg","hash":"c1ca075698470d72da81743f93a5c5f5c8293b44","modified":1742260763665},{"_id":"source/images/deepseek-rag/RAG-system-architecture.png","hash":"e10600ea515ec2bb5fdb94ca38e740441121aa38","modified":1742185218000},{"_id":"source/images/deepseek-hackernews/企业微信截图_20250220100545.png","hash":"2e04c42d2823e7a898dfa36311f9eaa9ef42eb24","modified":1740017177052},{"_id":"source/images/deepseek-rag/RAG-system-architecture.ppm","hash":"c0661f3443815ea161b0a2c1a3ae2a1b153c8fb3","modified":1742213855172},{"_id":"source/images/deepseek-rag/imglarger.zip","hash":"949daa2be04f5702c9c67b023e998bf866b888ce","modified":1742214018037},{"_id":"source/images/docker-1/bg.png","hash":"e3b82c04b261788b6c333288578220dad894e135","modified":1720252982915},{"_id":"source/images/docker-log/log2.png","hash":"16057d65bce504bc50c9df4e556234a035f0d3a3","modified":1738807895677},{"_id":"source/images/docker-log/log3.png","hash":"6b51a12688a7acf913c6883b6a7526bf6d1b90d9","modified":1738827287697},{"_id":"source/images/docker-log/log4.png","hash":"e014e11d1fada994b4cc720ff713f971a2a0283e","modified":1738827357024},{"_id":"source/images/dump/crash.jpeg","hash":"e25f4327f9073e01e8b1a3e13c209ca732880e15","modified":1714290837084},{"_id":"source/images/dump/windbg_3.png","hash":"47fa0c7ac253a9a44eef9bc6d5dce90d96445ba2","modified":1715068901454},{"_id":"source/images/function-calling/out.jpg","hash":"3a8d0dd3c5e60c88d13962d3b46c7d43754b7a5f","modified":1740383583659},{"_id":"source/images/function-calling/labour.jpg","hash":"1a2d86dd99e15bbe2bff8e1250c52e29234a1f8f","modified":1740377700358},{"_id":"source/images/function-calling/completion.png","hash":"5d13b91a406de27dee205d79edec2d8cb174020b","modified":1740366409996},{"_id":"source/images/function-calling/search.png","hash":"65f69f58917946e8e72ae0c606bc8af614275040","modified":1740454948097},{"_id":"source/images/docker-layer/filesystem.png","hash":"969d25d9599c4bcc72ee3403e1805d7ad7a874e6","modified":1723428032741},{"_id":"source/images/docker-layer/layers.png","hash":"cf95861f382cab38dfcb0864099633592e85fc50","modified":1723432713503},{"_id":"source/images/docker-layer/ls_upper.png","hash":"aa190ff2fa11cfcf0c125e79b71e9b5d161358a5","modified":1723443838820},{"_id":"source/images/docker-layer/merged.png","hash":"a35d1d9111feb7ed81e3279ef2f1f5c9bb8951d6","modified":1723443249117},{"_id":"source/images/docker-layer/tree.png","hash":"8650756f7321bd4e7a53e0525f3e42411b7d51b7","modified":1723443628297},{"_id":"source/images/garnet/compare1.png","hash":"ed8a21697688433ffe376d2a4ccaa7ec53c667ff","modified":1712648062046},{"_id":"source/images/garnet/compatible.png","hash":"1714c1d5f1c6fd0421b4594015595976b5fd4ee4","modified":1712567994543},{"_id":"source/images/garnet/connect.png","hash":"82d4fc4511b032c7c797018845ca40d83ac7aa9d","modified":1712650225409},{"_id":"source/images/garnet/client.png","hash":"4889111b6b22a0f07ed3e80b70ee4e1e99c8045e","modified":1712652420303},{"_id":"source/images/garnet/running.png","hash":"3253e7a14adf9509baead2613151f614a0012ab5","modified":1712567881514},{"_id":"source/images/garnet/custom-command.png","hash":"bea263307a51c77205885ace2c3060272e444339","modified":1712736760989},{"_id":"source/images/helm/helm3-arch.png","hash":"a7b8a99dc3aad21a3d999cf55649b83ece440b2e","modified":1733902937390},{"_id":"source/images/helm/Helmcharts.png","hash":"8f3934f4b82bb99d9889f3c147a6f5e328aa94ee","modified":1733986204951},{"_id":"source/images/encrypt-hash-signature/md5.png","hash":"fad0964bd0a818545e9ba11fea2835793a6e8625","modified":1730878089744},{"_id":"source/images/encrypt-hash-signature/rsa.png","hash":"d3754f8c7d483647dd81f6faae4f4b185aabef55","modified":1730878691786},{"_id":"source/images/helm/new-helm.png","hash":"0e80788d40b1e71fda030c40b348d3eec4cb1971","modified":1733899062841},{"_id":"source/images/image-search/process.png","hash":"c1f5c3452b606dc8a510d9b3a5a24b330eff06eb","modified":1717772066200},{"_id":"source/images/image-search/qdrant.png","hash":"0c42f079a8b35f9fe8da6c3b3cf3180e9d603c62","modified":1717773798375},{"_id":"source/images/image-search/bg.jpg","hash":"a02f0b66241373b0fb83610977010c41297c6985","modified":1718069912767},{"_id":"source/images/java-init/mid-life-cris.jpg","hash":"5a69d555bf1fdf42cccb72535766582c6b42e00e","modified":1743674017971},{"_id":"source/images/internal-loss/depressed.jpg","hash":"8ff19e979ef211030d79fc29eca3bef0ed42f9e9","modified":1711678444570},{"_id":"source/images/js-monitoring/error.png","hash":"c80f5df478af0e91db7073cd2ea4d8fe4596f5a7","modified":1743498701913},{"_id":"source/images/js-monitoring/click.png","hash":"b91cbff1cdefb5d45aac00a850c1f4c3e637a009","modified":1743501191619},{"_id":"source/images/js-monitoring/fetch.png","hash":"9429e73369f18d751e51425e4bb5966ba55ac0e5","modified":1743500791101},{"_id":"source/images/js-monitoring/fmp.png","hash":"33cdab5196d7de6cbe0f07c16a1b62f8dc21a77c","modified":1743498731707},{"_id":"source/images/js-monitoring/promise.png","hash":"89e19d67a83356be787cfbbd3191d7a05e76cf5c","modified":1743500801925},{"_id":"source/images/js-signal/EventTarget3.png","hash":"e5f9ea6836e53d2a388a09cf54190253f5d4a467","modified":1730788409397},{"_id":"source/images/js-signal/EventTarget.png","hash":"818561377792246188fd5e247e0de485c99b889e","modified":1730776254380},{"_id":"source/images/js-signal/EventTarget2.png","hash":"58db529e086abb315e24f6738d871e776e72f9c6","modified":1730777763048},{"_id":"source/images/https/ca.png","hash":"a3f65f3b7f108a2e18c61d13c3024d761586a9ca","modified":1712826407187},{"_id":"source/images/https/handshake.png","hash":"9d2b92013eb6b78a0f3b84855a383b29962da2ba","modified":1713152131440},{"_id":"source/images/https/bg.jpg","hash":"9424b491fdae5f8c91344596469c3980217e2206","modified":1712821936174},{"_id":"source/images/https/security.png","hash":"e040846f476100e1ac38f67dec1fc9735978fc9f","modified":1713148972216},{"_id":"source/images/https/expire.png","hash":"801009fef98fa9d46a677f153f097e6476c139e2","modified":1712824416637},{"_id":"source/images/log/bad.png","hash":"8096161c7245cf56a0becfacf784179d9251ddc6","modified":1734570885990},{"_id":"source/images/log/confident.png","hash":"59601ad4b3d8c43998ca4d4c0384e1072c8bd3c9","modified":1734576785302},{"_id":"source/images/log/whoami.jpg","hash":"c2770cfe797d0874caa175eb1f1a0ec681fd6735","modified":1735199209307},{"_id":"source/images/mcp/architecture.png","hash":"132d6800e34d8c0eeecff3e32ad97afdcb43821c","modified":1742299323319},{"_id":"source/images/mcp/result2.png","hash":"dd5722090efd71b99dfb5a1429dea46cae15d26f","modified":1742903995166},{"_id":"source/images/mcp/result3.png","hash":"5758767c91400ff6860ed66dca538b301653959c","modified":1742904967445},{"_id":"source/images/mcp/architecture2.png","hash":"b16bc965b4f5e5c6cac9a97a8e522d6831199eaf","modified":1742895340285},{"_id":"source/images/mcp/result1.png","hash":"03c06471b6b1ee116b26eb16db81bfcc79816e52","modified":1742903905796},{"_id":"source/images/mcp/running.png","hash":"da696eca2891a582e80dffe4dc06dfa549763163","modified":1742896473678},{"_id":"source/images/mcp/without-mcp.png","hash":"87ec82a5c0572022d69d60d7020c29a46918a934","modified":1742950376898},{"_id":"source/images/mcp/with-mcp.png","hash":"916752d741a8f1356dbe5f0b05de4134eba10572","modified":1742950388554},{"_id":"source/images/openai-operator/price.png","hash":"04df7ca81eaa73268f100fb60ef1dd80aa353baf","modified":1739500632815},{"_id":"source/images/openai-operator/principle.webp","hash":"212e434bf36506abf3bca5f8e6a0614d21e5e4fa","modified":1739436664896},{"_id":"source/images/openai-operator/operator.jpg","hash":"69cb1ec3c10ad73bd4dd9c020c57a4c23e3fbcc7","modified":1739354135295},{"_id":"source/images/http/TCP-connection-1.png","hash":"588cade2c5e791bee0f282a6290889ba15c3a039","modified":1711091658444},{"_id":"source/images/http/handshake-1.png","hash":"698f25b0696249dbbadbf1b71ea5e3e48b57348e","modified":1711100170452},{"_id":"source/images/http/http-keep-alive-header.png","hash":"d2b1f6ccc2903ffbd4308627c2562b42c80a2cb7","modified":1711435826469},{"_id":"source/images/http/http-request.png","hash":"4d29675c37a4cc0df885db03cff820aa3f98080c","modified":1710926387387},{"_id":"source/images/http/perisitent-connection.png","hash":"0e16961aaa4851908823dccfa904d3f4f6989c08","modified":1711092222874},{"_id":"source/images/http/curl-header.png","hash":"e5c4a20f54045759a1a29f7f35a344d45ee51ecb","modified":1711013282028},{"_id":"source/images/mfa/bg.png","hash":"cbedc017c425e8db16698c5e162a5171e6a6f27f","modified":1732170553537},{"_id":"source/images/mfa/github.png","hash":"a19a0b7ebdcb4c8e17a7e3fa11f87a2d0540c99f","modified":1732157808898},{"_id":"source/images/mfa/run.png","hash":"a7e3121b6cd448b1d6d6955e0ccbbd43c5af8cb8","modified":1732157597417},{"_id":"source/images/midscenejs/login-result.png","hash":"8ae69bce8f2908ec12532d7be472b7c6a39cfc22","modified":1740986626674},{"_id":"source/images/midscenejs/fail.png","hash":"1e5294803b10fda155d1ec7f4314def342b281c9","modified":1741049372428},{"_id":"source/images/mfa/web.png","hash":"951c2f74e5cecb877194458272a6c2220f8423f1","modified":1732157561158},{"_id":"source/images/midscenejs/login.png","hash":"7bf8ff9c3c2e325032cf1a582c5b9f75fa258a4b","modified":1740983778650},{"_id":"source/images/midscenejs/midscene-locate.png","hash":"a26486d377f935b2fc45625ef987419e7f9feb26","modified":1741004627957},{"_id":"source/images/midscenejs/principle.png","hash":"e9195223bee5f32e4f15c6f6b872db8a11bd712e","modified":1740645448751},{"_id":"source/images/parallelism/concurrency-result.png","hash":"3db8a207e5188e010d44c58ddea64fd71311ed2f","modified":1736240554152},{"_id":"source/images/midscenejs/yaml.png","hash":"9da83474dd112d425aa4085fa23799cda48baedd","modified":1740733409134},{"_id":"source/images/parallelism/bg.jpg","hash":"4f40fcea3cee377e56d906645ff5fb2ed9aabc4e","modified":1736324992675},{"_id":"source/images/parallelism/concurrency-vs-parallelism-2.png","hash":"4fd6173862df3c1b067d5bf7d819a6d2ca75dc40","modified":1736240672832},{"_id":"source/images/parallelism/concurrency-vs-parallelism-1.png","hash":"8f4fb3314f80e0c6a82f33064db84c05c7ffa478","modified":1736240660873},{"_id":"source/images/parallelism/concurrency-vs-parallelism-3.png","hash":"eda6c6fe8b20152b8d712f46a76baa5d27ec46ed","modified":1736240684542},{"_id":"source/images/proxy/forward-proxy.png","hash":"49892dfa05b23599732f106b70b44fa95bc2eaa5","modified":1718888217801},{"_id":"source/images/proxy/reverse-proxy.png","hash":"57444303e4d4327cd1ebaedd3d954dfcf2486b69","modified":1718888319294},{"_id":"source/images/parallelism/parallelism-result.png","hash":"a5aa85c57c2f095da285c016b954b31b61f873f2","modified":1736240471813},{"_id":"source/images/proxy/bg.jpg","hash":"c884b6efad5351ee2996fe0d18715fb27f7b3749","modified":1718931303461},{"_id":"source/images/proxy/transparent-proxy.png","hash":"e2bc2ee06dbfa33170ec3120277f21f4e3e503f9","modified":1718890992387},{"_id":"source/images/quic/head_of_line_blocking.png","hash":"2203cca89e72b24f13cc9774fb78ee64927f32ea","modified":1723801376313},{"_id":"source/images/quic/quic-logo.png","hash":"f2cf0868ef61bfe597981193c314327741c5a48e","modified":1724382247911},{"_id":"source/images/rabbitmq-basic/channel1.png","hash":"fcde762d9619fe15b3fbdbe32455dfee9214dee0","modified":1720580078238},{"_id":"source/images/rabbitmq-basic/channel2.png","hash":"f09e7365fd1026393f0b89777406570fbb1be70b","modified":1720580479287},{"_id":"source/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg","hash":"ec548510fb86ab373be5decbb3f65896813d048b","modified":1720517279179},{"_id":"source/images/rabbitmq-basic/fanout-exchange.svg","hash":"5e14973b4eba3986a1805c585260d34e781c512a","modified":1720612870539},{"_id":"source/images/rabbitmq-basic/direct-exchange.svg","hash":"e1e7e8648d3c479c2b4223af6be07e434ea62730","modified":1720612845887},{"_id":"source/images/rabbitmq-basic/main.png","hash":"e45cabff6e1cc9ea8477412977a49277b9656faa","modified":1720530900322},{"_id":"source/images/rabbitmq-basic/fanout.png","hash":"6458eb591f42ff61e67364d480c4b2c0dc1ff3bf","modified":1720524567852},{"_id":"source/images/rabbitmq-quarum/quarum1.png","hash":"e24787c731793ab83bc335c08dcf21060babd92d","modified":1720704401188},{"_id":"source/images/rabbitmq-quarum/normal.png","hash":"7a81405dc9d73b0a7cdff3b685c35853bad1cb1a","modified":1720679165151},{"_id":"source/images/rabbitmq-quarum/quarum2.png","hash":"7c88c03d166aee001257f3fe29918c29ff0df8bb","modified":1720680123566},{"_id":"source/images/rabbitmq-quarum/stream_error1.png","hash":"ce4c9e1a9a9da1cb4278e2e74be852611c8c265d","modified":1720855445532},{"_id":"source/images/rabbitmq-quarum/stream_error2.png","hash":"0d84d8d3ae357383925c86c728d865ce461bce8b","modified":1720855694734},{"_id":"source/images/sticky-packet/sender-sticky.png","hash":"199862fcf0175fe9b9acca3c698c58482dd123c5","modified":1724987423202},{"_id":"source/images/sticky-packet/bg.jpg","hash":"9a73ba1e1dfa83d5e79399fe25745e9c90915762","modified":1724999655551},{"_id":"source/images/sticky-packet/solve-server-sticky.png","hash":"0833d4fd870412068dc5b3515a60e9f078bd0ae9","modified":1724990256799},{"_id":"source/images/sticky-packet/server-sticky.png","hash":"8a7a47f695c9d74f4bebb7cf444d221e59bc8923","modified":1724988818136},{"_id":"source/images/sticky-packet/solve-sender-sticky.png","hash":"9060a5391d9fe9f8a5b49dbda8ef182d7690e0c5","modified":1724998588917},{"_id":"source/images/redis-interview/cache-penetration.png","hash":"17f21e18052f40f20189a31c4bfbf749a1dedcbc","modified":1714100540904},{"_id":"source/images/redis-interview/memory.png","hash":"37fadd91ec8573c6c30ec5fd32562f2c3d22d5a9","modified":1714031983730},{"_id":"source/images/stream-output/gzip.png","hash":"bebbc7498d81a46696636a49aa736063466f090a","modified":1731488916979},{"_id":"source/images/redis-interview/recruitment.png","hash":"9da7eff910bfb50b7f11618614003b6153e71d98","modified":1713425715760},{"_id":"source/images/webrtc/connections.png","hash":"3f79caaf253bb208eb221aba617064d3985f2314","modified":1734403965091},{"_id":"source/images/webrtc/server.png","hash":"71034110834293ac533faba16cb15b2d62f7c6ec","modified":1734400685422},{"_id":"source/images/webrtc/bg.png","hash":"9ba29395c41cce47b769f3623ae2fac7390ca226","modified":1734489675642},{"_id":"source/images/task-completion-source/bg.jpg","hash":"762d9571bdc71e36879c00907cb524e825980694","modified":1718067987009},{"_id":"source/images/webrtc/webrtc-overview.svg","hash":"46b2ff10a8f0316759ab8cf1b8e6e2e64380da23","modified":1734405333222},{"_id":"source/images/task-completion-source/pause-1.png","hash":"14d301e1283ad280dd8ea0525be0e5c38531ef74","modified":1717658041988},{"_id":"source/images/task-completion-source/pause-2.png","hash":"f681d83790b004e1703e18560c2f7d2db0cd6d01","modified":1717658059375},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","hash":"7b141675f4bd37c8d65a63b5d22612430b945720","modified":1716621402662},{"_id":"source/images/deepseek-2/apikeys.png","hash":"3df1d5e9406d626bdc1e7cd56bee9698721a362a","modified":1739343120762},{"_id":"source/images/dead-message/dead-letter-2.jpg","hash":"424a4237b4485e845ed3e9e6e74ee1f34485d196","modified":1716542966790},{"_id":"source/images/deepseek-2/game1.png","hash":"efc973eaf23e7287254240f673dd89a93669605c","modified":1739343580986},{"_id":"source/images/deepseek-2/installed.png","hash":"0be61ea87cd174858d59ca2d2b55106daaa43e64","modified":1739178610459},{"_id":"source/images/deepseek-1/chatbox-setting2.png","hash":"084982a7f7ba9b139e24f32fb9c3aa9af8a35ef5","modified":1738914777220},{"_id":"source/images/deepseek-1/chatbox-setting.png","hash":"85d3323cf19f5532bbdbd77c11038c630ff04e01","modified":1738914750350},{"_id":"source/images/deepseek-1/env_var.png","hash":"eb7e7f64e4b36d2a26042653fbc7dd51f6a89840","modified":1738913934713},{"_id":"source/images/deepseek-1/models.png","hash":"13d4b90b4fe8b5ddf880ecc8a552a8cc7270f64e","modified":1738899518057},{"_id":"source/images/docker-1/configurations.png","hash":"c6f58a834400b5d6fff7c76249562888a908304c","modified":1720252449460},{"_id":"source/images/docker-2/inspect3.png","hash":"e8523ef78b9823458520eb25300303381b046a8e","modified":1720441204166},{"_id":"source/images/docker-1/multi-env.png","hash":"a8aa3cdee473ee5987c28a30c4def6b06b1c4708","modified":1720253343754},{"_id":"source/images/rspack/result1.png","hash":"a9520839c7ee5c932364c29354b20e80001b531c","modified":1732866474263},{"_id":"source/images/docker-log/log1.png","hash":"79ec752acb8d7a533e6e5747096b6bd54bcc17fe","modified":1738807140322},{"_id":"source/images/dump/bg.png","hash":"32c7ad31ef1117233e7691e74198041f62870e63","modified":1714290251488},{"_id":"source/images/dump/windbg_4.png","hash":"5618b95c756aab451803e23e9c0f77b5fa94e6b4","modified":1715069009388},{"_id":"source/images/function-calling/process.png","hash":"cdb1e4c5cc84d2f1d3c77faa72fb0bd2106b6cb6","modified":1740365101656},{"_id":"source/images/garnet/1.png","hash":"0d8a64004413ec34a334cce4925372781b3c88b0","modified":1712566365601},{"_id":"source/images/garnet/log.png","hash":"0c32a044823dd2b85353c2816c9109c9df0626b4","modified":1712721260633},{"_id":"source/images/helm/lens-helm.png","hash":"fda441250c1bc5e52beed094d8b976c0d877bd37","modified":1733905363051},{"_id":"source/images/encrypt-hash-signature/certificate.png","hash":"107871901480c47bdf9fbc41a0d51511c78498e5","modified":1730875039053},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","hash":"f637ac12cf901b7e557077687482f7232bbc2a72","modified":1711685199687},{"_id":"source/images/java-init/java.webp","hash":"902e13eac443b3951e7e0c79cb24708ffc5ee4ac","modified":1743994550890},{"_id":"source/images/java-init/me.png","hash":"79a3abc8835af271f982f994ce6e2116a682b5de","modified":1743661475565},{"_id":"source/images/internal-loss/996.jpg","hash":"d712414d1167ea1a5790683d549a3dbf56cc3c8c","modified":1711684344049},{"_id":"source/images/https/client-hello.png","hash":"65039f3b5656ce343d9c36842642aedef464f9d1","modified":1712827328350},{"_id":"source/images/log/long.png","hash":"08675894c527af3804511fedea61148084e98500","modified":1734579843735},{"_id":"source/images/mcp/3aabd8804251c0364cbde9d2e4be6dc8e8c2faec-2880x1620.webp","hash":"ca7e91ae472163b5c4dfd9062a79b4e7b6c1e9e3","modified":1742895733950},{"_id":"source/images/mcp/inspector.png","hash":"05e77d707922a69593426f493e373cbd6b491724","modified":1742891518908},{"_id":"source/images/openai-operator/bg.png","hash":"3b35c8cde27f1ee84dd956cff4d67cd8336dc198","modified":1739354109710},{"_id":"source/images/openai-operator/principle.png","hash":"0d0bd55852d20df00fef42ee68d9fa2f43f84e3e","modified":1739514011760},{"_id":"source/images/http/auto-disconnect.png","hash":"6eb07b19f5350b86e32c41503abdef786d1cc8a3","modified":1711368567428},{"_id":"source/images/http/handshake-2.png","hash":"f50dd3fab7ff21a20cd91622aefb077b7ec74b89","modified":1711353457535},{"_id":"source/images/http/timeout-auto-disconnect.png","hash":"87f74686dc596abb5be91260a40dcf38ed3d0d17","modified":1711433208748},{"_id":"source/images/midscenejs/playwright-report.png","hash":"609aeff6e0bffc56108660015f5f314990cff7fa","modified":1740993686058},{"_id":"source/images/midscenejs/企业微信截图_20250303204121.png","hash":"0bdbc5673059c9c0992a876bef00d34da7b0c0c8","modified":1741005683120},{"_id":"source/images/quic/handshake.png","hash":"38daab0f33947a35e7caacf41e3e2979cc854b89","modified":1723797528048},{"_id":"source/images/quic/tcp.png","hash":"1fba23e6486468abf1e4baa60d8a2cf85c5685cf","modified":1724377517189},{"_id":"source/images/quic/quic.png","hash":"5a459deaef952ec228d3515dfdbf47048fc05c5c","modified":1724379367865},{"_id":"source/images/midscenejs/企业微信截图_20250228180601.png","hash":"66dd29339988ee8b8546b69d14726f446e912cae","modified":1740737164058},{"_id":"source/images/rabbitmq-basic/rabbitmq-headers-exchange.svg","hash":"b9983fdc354c45500fcfe57e9f78ab4cb88a2c4d","modified":1720612881431},{"_id":"source/images/http/request-methods.png","hash":"5914a2642fc3c771aaddbb5a4db79d020c75ba27","modified":1710917201189},{"_id":"source/images/rabbitmq-basic/topic-exchange.svg","hash":"ed3868a0efc180866dca5c7ba33cb6797ad96bc5","modified":1720612864235},{"_id":"source/images/rabbitmq-quarum/stream_offset.png","hash":"156f277e1c766644c8704892454397fc113f153d","modified":1720856674850},{"_id":"source/images/midscenejs/bg.png","hash":"6885406cca088c8387347c17c1d75fa84dbda65a","modified":1740649014498},{"_id":"source/images/redis-interview/cache-avalanche.png","hash":"8bcdb1787aa12c08febeb8c2324cf7fa9c6d3c02","modified":1714100497420},{"_id":"source/images/redis-interview/cache-breakdown.png","hash":"de31f8ba0958f9428c1148746206f8351fa1bf18","modified":1714100525728},{"_id":"source/images/deepseek-1/chatbox-setting3.png","hash":"c030f827c2a5638444cdb43d1a328ad31f0decbd","modified":1739157619070},{"_id":"source/images/docker-log/bg.png","hash":"f2af0b61e769c240a2d901b15f092fece99082b2","modified":1738834078837},{"_id":"source/images/dump/windbg_2.png","hash":"e55722d89679167f37e0b851a53e27ae989663f8","modified":1714439116512},{"_id":"source/images/helm/lens-pod.png","hash":"770434a233f77381b1c4a98cf49ad068a325ce69","modified":1733905400785},{"_id":"source/images/function-calling/bg.jpeg","hash":"660035026ac5f41b256a72c6ea1cb59a36919baf","modified":1740476145274},{"_id":"source/images/log/bg.png","hash":"1d1fd20fa466aeec5cfb6f9e71322c1132fbf2fe","modified":1735201402107},{"_id":"source/images/http/auto-disconnect2.png","hash":"d96b55fe2a3d138263e29ec9ba3a171b78eaf003","modified":1711356920847},{"_id":"source/images/openai-operator/future.jpg","hash":"e1dd50203c33e79f34a74fefd6e49591eed0aa4e","modified":1739502523406},{"_id":"source/images/rabbitmq-basic/default-exchange.png","hash":"da48c3eae865c3758c2998b9234193ef1c52e26c","modified":1720515775722},{"_id":"source/images/stream-output/sse-communication.png","hash":"274d518fb1af551094f0493daa37e69e6579c458","modified":1731490255089},{"_id":"source/images/deepseek-2/price.png","hash":"5fe9e7ee3438ebdfe97a49d96d2c3c354b4e1c64","modified":1739326447502},{"_id":"source/images/rspack/tools.png","hash":"8074e78f7fd5fa877f317422f5dd1ac5b947823c","modified":1732869166096},{"_id":"source/images/deepseek-1/cmd-effect.png","hash":"fdca817bc517088459313c9a7b22d27321a78f2b","modified":1739156200365},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688482306000},{"_id":"source/images/docker-2/before.png","hash":"4d6df539061278c5a371d63bbf494a54ac390588","modified":1720419780264},{"_id":"source/images/rspack/bg.png","hash":"2b32b38f48f915b04be88f6cbf31bae0cbcc7fb2","modified":1732868708252},{"_id":"source/images/https/encrypted.png","hash":"51f01f7c79cbb8e5ace366b423a46c677483d4f3","modified":1712827358003},{"_id":"source/images/midscenejs/login-report.png","hash":"239853028ebb49f94ecfcbe46bfe9b4ae298083d","modified":1740986669936},{"_id":"source/images/stream-output/regular-http-communication.png","hash":"ace2e8bcb78fbd9f288105ea5c821a45625bde95","modified":1731490232699},{"_id":"source/images/webrtc/1_kDeCUgDd-T-KLvSH4sTiLw.png","hash":"774ac8a3865a67d0ef56cc6104d6fb86a908d9a6","modified":1734074915610},{"_id":"source/images/deepseek-1/PageAssist.png","hash":"e6c457aed24d226c1e14cc3713d01aa2aa0bf2c9","modified":1738919852130},{"_id":"source/images/dump/windbg_1.png","hash":"fec01b96435a46269b0a241c8feb13764458b0e9","modified":1714438955774},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1688482306000},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1688482306000},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1688482306000},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1688482306000},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1688482306000},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1688482306000},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1688482306000},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1688482306000},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1688482306000},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1688482306000},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1688482306000},{"_id":"themes/archer/_config.yml","hash":"bf3d3444da07f4901d77f3455af63aeea406d8f8","modified":1723520595061},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1688482306000},{"_id":"themes/archer/package.json","hash":"1177cb27ab8e279681f1e53c8f0f8735238fde8d","modified":1730794844406},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1688482306000},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1688482306000},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1688482306000},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1688482306000},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1688482306000},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1688482306000},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1688482306000},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1711010720209},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1688482306000},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1688482306000},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1688482306000},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1688482306000},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1688482306000},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1688482306000},{"_id":"themes/archer/layout/layout.ejs","hash":"23235793df01cf129ae747293172dab307e2b9ac","modified":1725011322544},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"2afd877a9ae9509622a6163094ae27df17e36184","modified":1723102105116},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1688482306000},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"f4b8e36a8ae882f3b1e194811b0c5a370913270f","modified":1725011450243},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1688482306000},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1688482306000},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1688482306000},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1688482306000},{"_id":"themes/archer/source/assets/wechat_qr.jpg","hash":"20763d666624facc585e34645018deadb343b4b5","modified":1705482083315},{"_id":"themes/archer/source/assets/favicon_bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1688482306000},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1688482306000},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1688482306000},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1688482306000},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1688482306000},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1688482306000},{"_id":"themes/archer/source/avatar/Jason.jpg","hash":"0eae332ea91f9e04b54f35d2ed1b17b5b37aee64","modified":1710397722571},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1688482306000},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1688482306000},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1688482306000},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1688482306000},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1688482306000},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1688482306000},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1688482306000},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1688482306000},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1688482306000},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1688482306000},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1688482306000},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1688482306000},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1688482306000},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1688482306000},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1688482306000},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1688482306000},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1688482306000},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1688482306000},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1688482306000},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1688482306000},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1688482306000},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1688482306000},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1688482306000},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1688482306000},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1688482306000},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1688482306000},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1688482306000},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1688482306000},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1688482306000},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1688482306000},{"_id":"source/images/docker-2/after.png","hash":"2aa4ca9b53dc8a4270e3174115fcf96887185f64","modified":1720439019007},{"_id":"source/images/docker-log/log5.png","hash":"b63fe108723f011bcd4cfbb5f0342e053ad04e61","modified":1738831913419},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1688482306000},{"_id":"source/images/daemonset/bg.png","hash":"b1603478da28b1f0e9b0f1e54d6eca8e30537b4b","modified":1722579353097},{"_id":"source/images/https/negotiated-cipher-suite.png","hash":"32d7a6f6ad24e6c5755d2ba2626e0ba71520fd50","modified":1713149675775},{"_id":"source/images/openai-operator/decline.jpg","hash":"4127c32c5be728bf3fb98d093dc5fa539f123684","modified":1739502723680},{"_id":"source/images/https/cipher-suites.png","hash":"e9faeff8e36d3efd82a5a0800c85a8e23d6ebf56","modified":1713149632927},{"_id":"source/images/deepseek-2/running.gif","hash":"e755735eb76c58c401d1215810fc36c0c422a2ee","modified":1739344952051},{"_id":"themes/archer/source/assets/favicon.ico","hash":"c136618e070daf370da961ac730973293a088b9e","modified":1710382119333},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1688482306000},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1688482306000},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1688482306000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1688482306000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1688482306000},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1688482306000},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1688482306000},{"_id":"source/images/deepseek-1/chatboxai.png","hash":"4c1480c05a3f8278167c75283c6fdc6a20823033","modified":1738914427827},{"_id":"source/images/js-monitoring/flow_diagram.png","hash":"31ca56b7e1fed84b8d7ff5172729a9663954adff","modified":1743409954781},{"_id":"source/images/redis-interview/bg.png","hash":"e5be0650aa2343b4a62218b58ebae10c4f4b9ba6","modified":1714101428369},{"_id":"source/images/js-signal/switch-theme.gif","hash":"8e8f0c1a5add7925ac6f7f5931d43a6f829373b7","modified":1730790295869},{"_id":"source/images/hello-bg.png","hash":"f70f2a6805ceb4ab1175e391c03923b7264bc431","modified":1705386424945},{"_id":"source/images/deepseek-rag/hallucination.webp","hash":"05d4d772416425471100fc7386c0429051136d1b","modified":1742181626748},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1688482306000},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1688482306000},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1688482306000},{"_id":"source/images/image-search/images.png","hash":"b2a77e00a2290543613f0df77f8c30337c91f441","modified":1717681798910},{"_id":"source/images/deepseek-rag/bg.png","hash":"0f630681148f3d9419bced0140d860bff9d1aeab","modified":1742266636687},{"_id":"source/images/deepseek-1/bg.png","hash":"a66fa9e653f12d5806b99d3163110dfab8e07b35","modified":1739160199061},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1688482306000},{"_id":"themes/archer/package-lock.json","hash":"381413c920d827f250508a4ed59f934420757913","modified":1747638607437},{"_id":"source/images/deepseek-1/pull.png","hash":"3366a7b8808b638d21ec89e0428f34dc3dcc39fb","modified":1738899057503},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1688482306000},{"_id":"source/images/deepseek-1/pulling.png","hash":"fe9c99ee0055aec3042453f712d2922d8d4588c0","modified":1738899189346},{"_id":"source/images/js-signal/responsive.gif","hash":"32b125a785deeae5ffac981705d6f896369e0f1b","modified":1730450652968},{"_id":"source/images/docker-2/inspect1.png","hash":"e818b04708ae3c4ffa2ca0e3e890c5d2d4c0bb05","modified":1720441093812},{"_id":"source/images/docker-2/inspect2.png","hash":"30515858e2dddad39c76f016c55a02af8f639856","modified":1720441069919},{"_id":"source/images/https/ca2.png","hash":"e71ae267fc6a9eda8943e4881e2f408b0a84055f","modified":1712827074795},{"_id":"source/images/stream-output/gpt-1.gif","hash":"764ea283c2613f6d12d84b4d1b38499b5ca565c5","modified":1731402848535},{"_id":"source/images/stream-output/result.gif","hash":"e6611131cf12bea45d6d4a548ac9142efc2dfe86","modified":1731404086880},{"_id":"source/images/deepseek-2/hot.png","hash":"7de1a9821a5ea6d5c0410dd376296b40d71eb12c","modified":1739342861717},{"_id":"source/images/image-search/search.gif","hash":"eb44e6dcab6b4292eb95ef63cbf64035ed01c878","modified":1717770772367},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1688482306000},{"_id":"source/images/deepseek-1/success.png","hash":"b333b1cd1c7f4caf5cc2f667692b258a6be21631","modified":1739148944344},{"_id":"source/images/deepseek-rag/rag-result.png","hash":"3eebb47de722ac032138ddf639e97edd19dfb811","modified":1742216019012},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1688482306000},{"_id":"source/images/function-calling/result.png","hash":"7e717fa7357215daed63efcceafb363ac8ea65d4","modified":1740363991126},{"_id":"source/images/js-monitoring/bg.png","hash":"80f5f748716802e98a1ec258f800e56178a81b3b","modified":1743565558939},{"_id":"source/images/deepseek-rag/raw-result.png","hash":"c44afeaefe13426c5cccb51e810247d258f3e1a3","modified":1742216259349},{"_id":"source/images/deepseek-rag/hallucination.png","hash":"c18dacd532df26b06f9a904c4d4e7644958a2275","modified":1742182805501},{"_id":"source/images/deepseek-1/qiruu-dhecb.gif","hash":"59b9836485b162cf5ea27963ae61bf79d7591873","modified":1739168410107},{"_id":"source/images/rabbitmq-basic/fanout.mp4","hash":"132a8c24996e91d19467bff53d9fb453c609cb79","modified":1720611325113},{"_id":"source/images/webrtc/result.gif","hash":"cebdafb38d4fbbe7ad0508ccad6814e5daa0dff6","modified":1743664639533},{"_id":"source/images/stream-output/4a7aa-203zt.gif","hash":"67c0872a27bfb8d50f5f85e7a3f6f44fffec18bd","modified":1731034592330},{"_id":"source/images/deepseek-2/generating.gif","hash":"46b8ebd38077fbfeee8f15c49f22985680f42a79","modified":1739345030908},{"_id":"source/images/mcp/bg.png","hash":"789b3e4b4e793cd5741dd9fc8413c9c0da23a7ad","modified":1742905673919},{"_id":"source/images/stream-output/sse.gif","hash":"5471fd5fefe89682d0187a3ccb7fd33044ce3359","modified":1731034795193},{"_id":"source/images/midscenejs/midscene-login.gif","hash":"3089699a99f93c15eb574ca0c4d43141efbc8b41","modified":1741003671234},{"_id":"source/images/rabbitmq-basic/16elk-ujaxc.gif","hash":"0b01075739b5d1b96d35a878bf55ff2575b50d41","modified":1720527427526},{"_id":"source/images/rabbitmq-basic/vro2s-b2mub.gif","hash":"70b8ce43edd1599dd11a8c8dd529c26405323082","modified":1720612469268},{"_id":"source/images/function-calling/result.gif","hash":"661b3cb1690dc6936d44b826770628078bc092de","modified":1740473087633},{"_id":"source/images/function-calling/result-mini.gif","hash":"eaf5a15b124c9cd4f8a89c7bb8f232cd5d06a54f","modified":1740474984059},{"_id":"source/images/openai-operator/operator-demo.gif","hash":"d4abd595681a7665e903c65b2a17327aa8903f0d","modified":1739438845424},{"_id":"source/images/deepseek-1/speed.gif","hash":"4d4e9f19761fa67524e7dbe6fb59f745db203401","modified":1739159397540},{"_id":"source/_posts/spring-1.md","hash":"f67d82efcf0234b3ac8da338a3ba6c82b5b4307b","modified":1744688273480},{"_id":"source/images/java-init/future.png","hash":"c2d07939348540bf3dbd07e476dedf0a4ef72862","modified":1744005797211},{"_id":"source/images/java-init/bg-1.webp","hash":"4c8158addc1d2e3e18fe3dcbd99346dd5b4ccd58","modified":1744008021137},{"_id":"source/images/java-init/DALL·E 2025-04-07 14.02.49 - An inspiring illustration of a person seen from behind, facing a sunrise on the horizon. The person is walking forward with confidence, wearing a shor.webp","hash":"9e90e50fd95fb6a84e0fb0a07f55f90e478032e2","modified":1744005769162},{"_id":"source/images/java-init/java.png","hash":"045f7007770c993576be633a67fa205a4a07f932","modified":1743994803109},{"_id":"source/images/java-init/bg-2.webp","hash":"1dc5d1f31829eca58ca6a7f62df6d2340461583d","modified":1744008292118},{"_id":"source/images/java-init/DALL·E 2025-04-07 11.14.35 - An artistic illustration of a person seen from behind, walking toward a beautiful sunrise on the horizon. The figure is wearing casual clothes_ a shor.webp","hash":"1a66654c31639a866a77fda46c85f441993e40aa","modified":1743995675266},{"_id":"source/images/spring-1/fail.png","hash":"5e8f4c1e13af5519c5c9ef618a1a195cc25ae7a1","modified":1744688207681},{"_id":"source/images/spring-1/result.png","hash":"eaca97366f1e218c54443385f14d96b96b23035d","modified":1744619322114},{"_id":"source/images/spring-1/architecture.png","hash":"1d6876d8687ae20cd2ec12170258c1d3413076a7","modified":1744620463975},{"_id":"source/images/spring-1/bg.png","hash":"5e7738d363e57844ea14def3e3a6ca5721d9e2c2","modified":1744624378790},{"_id":"source/_posts/javelin-1.md","hash":"f67d82efcf0234b3ac8da338a3ba6c82b5b4307b","modified":1744688273480},{"_id":"source/_posts/javelin-2.md","hash":"66c093fe1d2446496a394385402c5f4ce2f34079","modified":1745919236621},{"_id":"source/images/javelin-2/AllowAnonymous.png","hash":"ada5f7ba389901e080061d8ef974a5c8ed85413a","modified":1745399206736},{"_id":"source/images/javelin-2/route-params.png","hash":"ea97e04bd2314e2a3253f8567934c23f7a1315ed","modified":1744774074932},{"_id":"source/images/javelin-2/query-params.png","hash":"5ec49a0d00ec5f1739a3b48d4005001119bb295e","modified":1744774049593},{"_id":"source/images/javelin-2/post-params.png","hash":"d7fb0109a7e42ed06115405c8820d66e38a2c82e","modified":1744774164995},{"_id":"source/images/javelin-2/unauthorized.png","hash":"cb8ec479b94ae6ae236740cfb861be24e7a92db4","modified":1745399138909},{"_id":"source/images/javelin-2/json.png","hash":"d31478ce96e30791f6368255406b73e15b620f2d","modified":1745313703711},{"_id":"source/_posts/javelin-nhttpcontext.md","hash":"126fa7b11549801c595ec539946d4d23e81740c2","modified":1746003241956},{"_id":"source/images/javelin-2/life-cycle.png","hash":"c52dd1aaf6bf1a4980961b7676615fcdd6073f63","modified":1745918429978},{"_id":"source/images/javelin-2/authorize.png","hash":"f4def0815bdf54da8f2ed4a990f55131045a547a","modified":1745803449918},{"_id":"source/images/javelin-2/log.png","hash":"0db6ce904774593bcd45529258eaa8dbdf74674e","modified":1745808963937},{"_id":"source/images/javelin-2/pipeline.png","hash":"ee930803996956a01c017708c6b73c48d491dc71","modified":1745888669331},{"_id":"source/images/javelin-2/error.png","hash":"2c630e0ee2ee440d9bf9253eb10004ec9036599a","modified":1745808577162},{"_id":"source/images/javelin-2/request-delegate-pipeline.png","hash":"3ca6bea1b125276cdc2cb2c548f93a846d25371f","modified":1745811518693},{"_id":"source/_posts/javelin-servlet.md","hash":"3c8277c955489a3bfd658772b5ace8d034e96833","modified":1746604200379},{"_id":"source/images/javelin-3/uml.png","hash":"a9d07bd856fd2dce82f95b074d3d7953936be5e5","modified":1746003167196},{"_id":"source/_posts/javelin-dal.md","hash":"c8e9752bb7cff6614699837e482c3ac3b0bb678b","modified":1747812659733},{"_id":"source/images/javelin-servlet/State-of-sevlet-life-cycle.webp","hash":"826fd130d66faf27749c6b3b8355c30050ef6ef5","modified":1746588674484},{"_id":"source/images/javelin-servlet/result.png","hash":"dbc762ae4afa5155cd3bc9fd8c08c46b9f45fe5b","modified":1746585958790},{"_id":"source/images/javelin-servlet/servlet.webp","hash":"d9efa91b133c1b0c645fe4c24eb19ef61bee9727","modified":1746519877056},{"_id":"source/images/javelin-dal/entity-delete-2.png","hash":"d221cc8ffd46d6b1365dab5260c34db32ea19b34","modified":1746784437548},{"_id":"source/images/javelin-dal/entity-delete-1.png","hash":"089bd80a0d8ce80ca1ddea3a285b1e275ec3ea2f","modified":1746784427338},{"_id":"source/images/javelin-dal/entity-insert-1.png","hash":"e7474a89351494f6a161252c184671b61a58cee9","modified":1746783935460},{"_id":"source/images/javelin-dal/entity-read-1.png","hash":"1cf30ea8498d9123f54f1f3526d5ce8149770288","modified":1746784322986},{"_id":"source/images/javelin-dal/entity-update-1.png","hash":"c9f0a13b57a4383287e655bac896926a6b759411","modified":1746784215124},{"_id":"source/images/javelin-servlet/architecture.png","hash":"332bbe5330b74f82fbca1eb406ceff0e64bdcb24","modified":1746517018487},{"_id":"source/images/javelin-dal/entity-insert-2.png","hash":"a7209466d9ffcc8b524b961fd73f7d0c9dd889fb","modified":1746783959631},{"_id":"source/images/javelin-servlet/servlet-lifecycle.png","hash":"0aca4a3ab019fa1e7ba372107826533ffa01bd65","modified":1746588930447},{"_id":"source/images/javelin-dal/entity-update-2.png","hash":"3a48f9f5b4354264fd69f043bd2e6cf9a1dd313b","modified":1746784229606},{"_id":"source/images/javelin-servlet/servlet-container.png","hash":"48a7da88d215d7b96224ffed9e60ab70ff2201bd","modified":1746521388154},{"_id":"source/images/javelin-servlet/servlet.png","hash":"a62273d782c89ade13f7a210fcc13ccb77167f64","modified":1746520017690},{"_id":"source/images/javelin-dal/architecture.png","hash":"40fc82abd573d3abe9b6f6b9047ba14157cd823a","modified":1747031729806},{"_id":"source/images/javelin-servlet/ChatGPT Image 2025年5月6日 16_05_18.png","hash":"8e6aaf58fedd22148fc04793986dc059f88c1a5c","modified":1746518719019},{"_id":"source/_posts/javelin-unit-testing.md","hash":"fbe2fbcde180020741a1690d8918a36ea4fc95ca","modified":1748397959021},{"_id":"source/images/javelin-unit-testing/zhaolei.png","hash":"ecfe8753429ba5ec6c3e117bd8cefc26e428c8dc","modified":1747993446310},{"_id":"source/_posts/css-scope.md","hash":"b3a8b156854971022afee5d1817be4d47cfb3b99","modified":1748938963106},{"_id":"source/images/javelin-unit-testing/tdd.jpg","hash":"0767abd6efdaee0a955366875c309f2e7f63c4d8","modified":1748336754117},{"_id":"source/images/javelin-unit-testing/jacoco.png","hash":"88b5faf2de9e6221af71811d96421cdc5b787caf","modified":1748336899017},{"_id":"source/_posts/codex.md","hash":"67e95b904e1ceeccab4e0dcc178e945f47dae441","modified":1749104342521},{"_id":"source/images/codex/environment.png","hash":"92ea9dc7cff66772321c11ce55e01f0ae7a64bb3","modified":1749029052373},{"_id":"source/images/codex/internet.png","hash":"acbb06e1d9c8c3c7a38d17425a89f61bb0272ea2","modified":1749029088426},{"_id":"source/images/codex/project-1.png","hash":"dc335c3daf0f7ffee82b56d2c5ee740e84635b53","modified":1749029424370},{"_id":"source/images/css-scope/dynamic.png","hash":"67adf714f56c7671780d26d914b4065656beb1d8","modified":1748938861353},{"_id":"source/images/css-scope/result.png","hash":"52a7665e38ae5d700f1abb2162aafddbac0e05c9","modified":1748938650712},{"_id":"source/images/css-scope/test1.png","hash":"dca84b83bdf1212c24df4e9253f9cc9b8de7f8dc","modified":1748938330282},{"_id":"source/images/css-scope/inline.png","hash":"d364fa39440eb38b3cbe0cca178b26d2ff2e18b0","modified":1748936560971},{"_id":"source/images/css-scope/vue-scoped-style.png","hash":"dd5fa900dce2f53a1b09eff2f1b4cacba0e24bc9","modified":1748935967998},{"_id":"source/images/codex/project-init.png","hash":"c840a29da83012632b8852b8b1390e6b3abda851","modified":1749030259264},{"_id":"source/images/css-scope/bg.png","hash":"66e9ae08ed1e0504bdce6078f28c474710e8ef57","modified":1748943246289},{"_id":"source/_posts/promise.md","hash":"67901d97b3df4467e79212715c7a13917117b77a","modified":1750659078197},{"_id":"source/images/codex/unit-test.png","hash":"53208d20a5e73a5b13a8d65fa803e04ce553bea8","modified":1749104313536},{"_id":"source/images/codex/npe.png","hash":"cbf07bd57241ed6a2d041607f78a1327003ff9ce","modified":1749088126933},{"_id":"source/images/codex/project-init-pr.png","hash":"1933c60e00d6e33c1031f4da5881f220e9735857","modified":1749030518761},{"_id":"source/images/codex/bg.jpg","hash":"051f8c9457d76f177dc18e4b83cb2e0c92247ce2","modified":1749105049988},{"_id":"source/images/promise/fight.png","hash":"858ca365b75596852b4b8eb167afffa1d9ac6fc2","modified":1750659810434},{"_id":"source/images/promise/multi-queue.png","hash":"92f9f8373d633ec9d117d82cdd8544c5740cf8c5","modified":1750411617408},{"_id":"source/images/promise/event_loop.gif","hash":"ae24893451ef2ba8dd505635ec98a8c308e58f72","modified":1750646259042},{"_id":"source/images/promise/process.png","hash":"1d56f3c451f4f7fbf8c3e1d0a42fa2fd640020ca","modified":1750408163682},{"_id":"source/_posts/send-off-1.md","hash":"987b9e763f7d357ead550f2a7608cd3869223720","modified":1754018249858},{"_id":"source/images/promise/bg.png","hash":"e1470f661cf9f51f587b256d62469fcf61dd103c","modified":1750660735304},{"_id":"source/images/send-off-1/goodbye.png","hash":"ce23cc28d7d7dbb4d96f0c612c8b5f1121b2eeb3","modified":1754017703670},{"_id":"source/images/send-off-1/drink.png","hash":"9d7139655e33213e79116b7cbf7773d4c7e25ac3","modified":1754015945878},{"_id":"source/images/send-off-1/work-overtime.png","hash":"de6666e5cf6b80d8d159feea7a6b5a808eddbd8b","modified":1754016156096},{"_id":"source/_posts/js-arrow-function.md","hash":"64b912483cf7722e88392d1a2e4fe1461b0f8bb5","modified":1754637756728},{"_id":"source/images/js-arror-function/choose.png","hash":"fbe4bd3f2e1d726799657ccb8893337a11b22b53","modified":1754468542429},{"_id":"source/images/js-arrow-function/stack.png","hash":"c3f0cc7427f4ff662879452483474c99b057073e","modified":1754559375019},{"_id":"source/images/js-arrow-function/choose.png","hash":"fbe4bd3f2e1d726799657ccb8893337a11b22b53","modified":1754468542429},{"_id":"source/_posts/oauth.md","hash":"93e37f64a9018425f1e22047d705f5fba54c44ad","modified":1757553159750},{"_id":"source/images/js-arrow-function/bg.png","hash":"55e75ef86de9c4cee38c167b439b27199009eb82","modified":1754616996046},{"_id":"source/images/oauth/ChatGPT Image 2025年9月4日 15_30_38.png","hash":"ae9e58abc785bfd92c3181de0e13150ac16f4197","modified":1756971039390},{"_id":"source/images/oauth/oauth.png","hash":"76435a9dc45a09dca913ad50eaf47b61d025ef09","modified":1756957912712},{"_id":"source/images/oauth/door.png","hash":"1b3d1d92a03e67af0c852f59a1567a842df2ed3a","modified":1756977950949},{"_id":"source/_posts/GEO.md","hash":"229caeab34ee1dbe756191fc530bb6f5fa3419fd","modified":1757661811300},{"_id":"source/images/geo/SEO-GEO.png","hash":"e75d6d130200943ea55333d69be76cd8f483c0d8","modified":1757646680997},{"_id":"source/_posts/http-option.md","hash":"d32f9334d2254e396b8d3fe7e916a9bc5f51e89f","modified":1758764667037},{"_id":"source/images/geo/bg.png","hash":"23a76df1d7e54e3f862e7c8672afc2b0d36e24f6","modified":1757649654752},{"_id":"source/images/geo/bg.webp","hash":"b8fec251a33357a9a25691aed47b9017427eed18","modified":1757649621604}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"C# 学习笔记： TaskCompletionSource","date":"2024-05-30T00:52:16.000Z","published":1,"_content":"\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/TaskCompletionSource.md","raw":"---\ntitle: C# 学习笔记： TaskCompletionSource\ndate: 2024-05-30 08:52:16\npublished: true\ntags:\n---\n\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"TaskCompletionSource","updated":"2024-06-06T07:22:36.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfaw40000rkp16zw0allj","content":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/blog/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/blog/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/blog/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/blog/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"MCP：AI 时代的“USB-C”，解锁模型上下文新范式","date":"2025-03-18T09:03:04.000Z","_content":"\n## MCP 出现的背景\n\nMCP（Model Context Protocol，模型上下文协议）是一个开放协议，它标准化了应用程序向大语言模型（LLM）提供上下文的方式。可以将 MCP 类比为 AI 应用的 USB-C 端口。就像 USB-C 提供了一种标准化的方式来连接不同设备和配件一样，MCP 也为 AI 模型提供了一种标准化的方式，使其能够与不同的数据源和工具进行交互。这样，开发者可以更轻松地将 MCP 集成到各类 AI 解决方案中，提高模型的上下文获取能力，并增强其对外部数据的适配性。\n\n本文将深入探讨 MCP 的核心概念、适用场景、架构设计以及如何在实际应用中使用 MCP，并提供具体的代码示例，帮助开发者更好地理解和应用 MCP。\n\n\n\n## 什么是 MCP？\n\nMCP（Model Context Protocol，模型上下文协议）是一种协议，旨在促进分布式或模块化系统中模型之间的高效和结构化交互。它定义了一种标准化的方式来交换模型上下文信息，确保一致的数据流和跨不同模型组件的互操作性。\n\nMCP 在人工智能、微服务和去中心化计算环境中特别有用，这些环境中需要多个模型进行通信并保持上下文一致性。\n\n---\n\n## 为什么选择 MCP？\n\nMCP 的出现是 Prompt Engineering 发展的产物。更结构化的上下文信息能够显著提升模型的性能。在构造 Prompt 时，我们希望提供更具体的信息（如本地文件、数据库、实时网络数据等）给模型，以便它能够更准确地理解真实场景中的问题。\n\n### 传统方法的局限性\n\n在 MCP 之前，我们通常会手动从数据库中筛选或使用工具检索相关信息，并将其粘贴到 Prompt 中。然而，随着问题的复杂性增加，手动管理这些信息变得越来越困难。\n\n为了解决这一问题，许多 LLM 平台（如 OpenAI、Google）引入了 **Function Call** 机制，使得模型可以在需要时调用预定义的函数来获取数据或执行操作，从而提升自动化水平。\n\n### Function Call 的局限性\n\n尽管 Function Call 机制带来了便利，但它存在一些关键问题：\n\n- **平台依赖性**：不同 LLM 平台的 Function Call API 实现方式各不相同，例如 OpenAI 和 Google 的调用方式不兼容，开发者在切换模型时需要重写代码，增加了适配成本。\n- **安全性**：Function Call 需要开放额外的接口，可能带来安全隐患。\n- **交互性**：在部分场景下，Function Call 的交互流程可能较为复杂，影响整体使用体验。\n![没有MCP](./images/mcp/without-mcp.png)\n\n#### MCP 如何改进？\n\n- **标准化上下文管理**：MCP 通过提供统一的协议，使应用能够高效地存取和管理上下文，而无需手动管理 Prompt 结构。\n- **跨平台兼容性**：MCP 作为开放协议，减少了不同 LLM 平台之间的适配成本，开发者可以更轻松地切换底层模型。\n- **提升自动化水平**：MCP 允许应用程序自动从不同数据源（数据库、API、文件等）动态填充上下文，提高模型的理解能力。\n\n![有MCP](./images/mcp/with-mcp.png)\n因此，MCP 的引入为 AI 应用带来了更高效、灵活的上下文管理方式，突破了 Function Call 的局限，使得开发者能够更专注于模型能力的发挥，而非手动适配数据。\n\n---\n\n## MCP 架构解析\n\n这里我就直接引入官方给出的架构图吧\n\n![架构图](./images/mcp/architecture.png)\n\nMCP 的架构设计清晰地划分为几个核心组件，每个组件都有明确的职责，共同实现上下文信息的标准化交互：\n\n- MCP Hosts（宿主程序）：\n如 Claude Desktop、各类 IDE 或 AI 工具，这些应用程序希望通过 MCP 获取上下文信息或数据，以增强模型的能力。\n\n- MCP Clients（客户端）：\n协议中的客户端，负责与 MCP Servers 建立并维护一对一的连接，实现标准化的数据请求与交互。\n\n- MCP Servers（服务端）：\n轻量级的服务程序，每个服务端都通过 MCP 协议暴露出特定的能力或数据访问接口，从而满足客户端的不同需求。\n\n- Local Data Sources（本地数据源）：\n包括用户计算机上的本地文件、数据库、服务等。这些数据源可通过 MCP Servers 被安全地访问，以提供丰富的上下文信息。\n\n- Remote Services（远程服务）：\n指可通过网络访问的外部系统或第三方服务（如 API），MCP Servers 可安全连接到这些服务，以进一步扩展模型所能获取的上下文范围。\n\n通过以上的分层结构，MCP 架构确保了数据访问的安全性、扩展性与灵活性，使得应用程序能轻松、安全地利用多种数据来源提升模型表现。\n\n---\n\n## 4. 如何使用 MCP（结合代码示例）\n\n### 示例：在 Python 中使用 MCP 进行 AI 模型交互\n\n![架构图](./images/mcp/architecture2.png)\n\n#### 前置工作\n1. ollama\n2. 环境配置[（参考官网的推荐配置）](https://modelcontextprotocol.io/quickstart/server)\n3. 安装 MCP SDK\n\n\n#### ** 实现MCP Server **\n这里我只实现了两个简单的工具\n\n```python\n# 创建 MCP 服务器实例\nmcp = FastMCP(\"DataService\")\n\n# 定义工具：从本地 MySQL 数据库获取数据\n@mcp.tool()\ndef get_local_data(name: str) -> str:\n    \"\"\"执行查询并返回本地 MySQL 数据库中的数据\"\"\"\n    load_dotenv()\n    # 连接到本地数据库\n    connection = mysql.connector.connect(\n        host=os.getenv('db_host'),\n        user=os.getenv('db_user'),\n        password=os.getenv('db_password'),\n        database=os.getenv('db_name')\n    )\n    try:\n        with connection.cursor() as cursor:\n            cursor.execute(\"select salary from employees where name like %s limit 1\", (f\"%{name}%\",))\n            row = cursor.fetchone()\n            while row is not None:\n                return row[0]\n        return ''\n    finally:\n        connection.close()\n\n# 定义工具：从网络上搜索数据\n@mcp.tool()\ndef get_web_data(query: str) -> str:\n    \"\"\"Search the web for current information on a topic\"\"\"\n    \n    # 使用 Google 搜索 API\n\n# 运行 MCP 服务器\nif __name__ == \"__main__\":\n    mcp.run()\n\n```\n定义完工具之后，我们可以运行 MCP 服务器，让它监听来自客户端的请求。\n\n#### ** 测试MCP Server **\n使用 MCP Inspector 我们可以查看服务器的状态和工具列表，同时对工具进行调试。\n```bash\nmcp dev server.py\n```\n看到如下输出，说明服务器已经启动成功\n![运行中](./images/mcp/running.png)\n然后我们就可以通过访问Inspector的地址来查看服务器的状态和工具列表。\n![Inspector](./images/mcp/inspector.png)\n\n\n#### **实现客户端**\n\n```python\nclass MCPClient:\n    def __init__(self):\n        self.servers = []\n        self.tools = []\n        self.exit_stack = AsyncExitStack()\n        self.ollama = AsyncClient('127.0.0.1')\n\n    async def initialize(self):\n        server_config = None\n        with open(\"servers_config.json\", \"r\") as f:\n            server_config = json.load(f)\n        # 列出服务器提供的工具\n        print(\"可用的工具:\", self.tools)\n\n    async def chat_loop(self):\n        \"\"\"Run an interactive chat loop\"\"\"\n        print(\"\\nMCP Client Started!\")\n        print(\"Type your queries or 'quit' to exit.\")\n        \n        while True:\n            try:\n                response = await self.process_query(query)\n                print(\"\\n\" + response)\n                    \n            except Exception as e:\n                print(f\"\\nError: {str(e)}\")\n\n\n    async def process_query(self, query: str) -> str:\n        \"\"\"Process a query using Claude and available tools\"\"\"\n\n        tools_description = \"\\n\".join([tool.format_for_llm() for tool in self.tools])\n\n        system_message = (\n                \"You are a helpful assistant with access to these tools:\\n\\n\"\n                f\"{tools_description}\\n\"\n                ...\n            )\n\n        messages = [{\"role\": \"system\", \"content\": system_message}]\n        messages.append({\"role\": \"user\", \"content\": query})\n\n        llm_response = await self.ollama.chat(\n            'qwen2.5:0.5b',        \n            messages=messages\n        )\n        \n        result = await self.process_llm_response(llm_response)\n\n        if result != llm_response:\n            messages.append({\"role\": \"assistant\", \"content\": llm_response})\n            messages.append({\"role\": \"system\", \"content\": result})\n\n            final_response = await self.ollama.chat(\n                'qwen2.5:0.5b',        \n                messages=messages\n            )\n            final_response = final_response.message['content']\n            logging.info(\"\\nFinal response: %s\", final_response)\n            messages.append(\n                {\"role\": \"assistant\", \"content\": final_response}\n            )\n        else:\n            messages.append({\"role\": \"assistant\", \"content\": llm_response})\n\n\n        return final_response\n\n\nasync def main():\n    client = MCPClient()\n    try:\n        await client.initialize()\n        await client.chat_loop()\n    finally:\n        await client.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n```\n\n#### **运行效果**\n通过上述代码，我们可以实现一个简单的 AI 对话系统，它可以使用 MCP 服务器提供的工具来获取上下文信息，并与用户进行交互。\n![运行效果](./images/mcp/result1.png)\n\n![运行效果](./images/mcp/result3.png)\n\n---\n\n##  关于 MCP 与 Function Call 机制的关系（补充说明）\n### MCP Client 如何决定调用哪个工具？\n在实际应用中，MCP 客户端判断调用哪个工具主要有两种实现方式：\n\n1. 利用 LLM 平台原生的 Function Call 功能\n\n这种方式依赖 LLM 平台自带的函数调用能力，例如 OpenAI 的 Function Call API。具体流程为：\n\n- 模型识别用户意图，返回指定的函数调用请求。\n\n- 客户端接收到函数调用指令后，通过 MCP 协议访问具体数据或服务。\n\n优点是模型能够直接识别调用意图，调用精准度较高。\n缺点是不同模型平台之间存在 API 差异，切换模型可能需要额外适配。\n\n2. 通过特定的 Prompt 结构（Prompt Engineering）来实现调用判断\n\n通过向模型提供明确、结构化的 system prompt（如下面示例），指导模型在需要调用外部工具时输出指定格式的 JSON 指令：\n\n```\n\"You are a helpful assistant with access to these tools:\\n\\n\"\nf\"{tools_description}\\n\"\n\"Choose the appropriate tool based on the user's question. \"\n\"If no tool is needed, reply directly.\\n\\n\"\n\"IMPORTANT: When you need to use a tool, you must ONLY respond with \"\n\"the exact JSON object format below, nothing else:\\n\"\n\"{\\n\"\n'    \"tool\": \"tool-name\",\\n'\n'    \"arguments\": {\\n'\n'        \"argument-name\": \"value\"\\n'\n\"    }\\n\"\n\"}\\n\\n\"\n\"After receiving a tool's response:\\n\"\n\"1. Transform the raw data into a natural, conversational response\\n\"\n\"2. Keep responses concise but informative\\n\"\n\"3. Focus on the most relevant information\\n\"\n\"4. Use appropriate context from the user's question\\n\"\n\"5. Avoid simply repeating the raw data\\n\\n\"\n\"Please use only the tools that are explicitly defined above.\"\n```\n在这种方法中：\n\n- 模型无需特定的函数调用能力，而是通过 prompt engineering 来判断何时调用工具。\n\n- 客户端解析 JSON 格式指令后调用 MCP 接口访问工具。\n\n优点是对模型平台的 function call API 无依赖，适配性强。\n缺点是依赖 Prompt 结构，模型输出的稳定性可能较差，偶尔需要额外的校验和容错处理。\n\n\n## 总结\n\nMCP（模型上下文协议）提供了一种结构化、高效的方式，使得模型在分布式环境中能够交换上下文信息。它的主要优势包括：\n\n- **标准化的上下文共享**，确保多模型系统的稳定性。\n- **高效可扩展**，适用于不同规模的模型交互需求。\n- **无缝集成**，可通过简单的 API 调用轻松适配现有框架。\n\n通过实现 MCP，开发者可以增强模型之间的协作，减少冗余，并确保模型驱动应用程序中的一致性。如果你正在从事 AI、微服务或分布式计算，MCP 是一个值得考虑的协议！\n\n","source":"_posts/MCP.md","raw":"---\ntitle: MCP：AI 时代的“USB-C”，解锁模型上下文新范式\ndate: 2025-03-18 17:03:04\ntags:\n---\n\n## MCP 出现的背景\n\nMCP（Model Context Protocol，模型上下文协议）是一个开放协议，它标准化了应用程序向大语言模型（LLM）提供上下文的方式。可以将 MCP 类比为 AI 应用的 USB-C 端口。就像 USB-C 提供了一种标准化的方式来连接不同设备和配件一样，MCP 也为 AI 模型提供了一种标准化的方式，使其能够与不同的数据源和工具进行交互。这样，开发者可以更轻松地将 MCP 集成到各类 AI 解决方案中，提高模型的上下文获取能力，并增强其对外部数据的适配性。\n\n本文将深入探讨 MCP 的核心概念、适用场景、架构设计以及如何在实际应用中使用 MCP，并提供具体的代码示例，帮助开发者更好地理解和应用 MCP。\n\n\n\n## 什么是 MCP？\n\nMCP（Model Context Protocol，模型上下文协议）是一种协议，旨在促进分布式或模块化系统中模型之间的高效和结构化交互。它定义了一种标准化的方式来交换模型上下文信息，确保一致的数据流和跨不同模型组件的互操作性。\n\nMCP 在人工智能、微服务和去中心化计算环境中特别有用，这些环境中需要多个模型进行通信并保持上下文一致性。\n\n---\n\n## 为什么选择 MCP？\n\nMCP 的出现是 Prompt Engineering 发展的产物。更结构化的上下文信息能够显著提升模型的性能。在构造 Prompt 时，我们希望提供更具体的信息（如本地文件、数据库、实时网络数据等）给模型，以便它能够更准确地理解真实场景中的问题。\n\n### 传统方法的局限性\n\n在 MCP 之前，我们通常会手动从数据库中筛选或使用工具检索相关信息，并将其粘贴到 Prompt 中。然而，随着问题的复杂性增加，手动管理这些信息变得越来越困难。\n\n为了解决这一问题，许多 LLM 平台（如 OpenAI、Google）引入了 **Function Call** 机制，使得模型可以在需要时调用预定义的函数来获取数据或执行操作，从而提升自动化水平。\n\n### Function Call 的局限性\n\n尽管 Function Call 机制带来了便利，但它存在一些关键问题：\n\n- **平台依赖性**：不同 LLM 平台的 Function Call API 实现方式各不相同，例如 OpenAI 和 Google 的调用方式不兼容，开发者在切换模型时需要重写代码，增加了适配成本。\n- **安全性**：Function Call 需要开放额外的接口，可能带来安全隐患。\n- **交互性**：在部分场景下，Function Call 的交互流程可能较为复杂，影响整体使用体验。\n![没有MCP](./images/mcp/without-mcp.png)\n\n#### MCP 如何改进？\n\n- **标准化上下文管理**：MCP 通过提供统一的协议，使应用能够高效地存取和管理上下文，而无需手动管理 Prompt 结构。\n- **跨平台兼容性**：MCP 作为开放协议，减少了不同 LLM 平台之间的适配成本，开发者可以更轻松地切换底层模型。\n- **提升自动化水平**：MCP 允许应用程序自动从不同数据源（数据库、API、文件等）动态填充上下文，提高模型的理解能力。\n\n![有MCP](./images/mcp/with-mcp.png)\n因此，MCP 的引入为 AI 应用带来了更高效、灵活的上下文管理方式，突破了 Function Call 的局限，使得开发者能够更专注于模型能力的发挥，而非手动适配数据。\n\n---\n\n## MCP 架构解析\n\n这里我就直接引入官方给出的架构图吧\n\n![架构图](./images/mcp/architecture.png)\n\nMCP 的架构设计清晰地划分为几个核心组件，每个组件都有明确的职责，共同实现上下文信息的标准化交互：\n\n- MCP Hosts（宿主程序）：\n如 Claude Desktop、各类 IDE 或 AI 工具，这些应用程序希望通过 MCP 获取上下文信息或数据，以增强模型的能力。\n\n- MCP Clients（客户端）：\n协议中的客户端，负责与 MCP Servers 建立并维护一对一的连接，实现标准化的数据请求与交互。\n\n- MCP Servers（服务端）：\n轻量级的服务程序，每个服务端都通过 MCP 协议暴露出特定的能力或数据访问接口，从而满足客户端的不同需求。\n\n- Local Data Sources（本地数据源）：\n包括用户计算机上的本地文件、数据库、服务等。这些数据源可通过 MCP Servers 被安全地访问，以提供丰富的上下文信息。\n\n- Remote Services（远程服务）：\n指可通过网络访问的外部系统或第三方服务（如 API），MCP Servers 可安全连接到这些服务，以进一步扩展模型所能获取的上下文范围。\n\n通过以上的分层结构，MCP 架构确保了数据访问的安全性、扩展性与灵活性，使得应用程序能轻松、安全地利用多种数据来源提升模型表现。\n\n---\n\n## 4. 如何使用 MCP（结合代码示例）\n\n### 示例：在 Python 中使用 MCP 进行 AI 模型交互\n\n![架构图](./images/mcp/architecture2.png)\n\n#### 前置工作\n1. ollama\n2. 环境配置[（参考官网的推荐配置）](https://modelcontextprotocol.io/quickstart/server)\n3. 安装 MCP SDK\n\n\n#### ** 实现MCP Server **\n这里我只实现了两个简单的工具\n\n```python\n# 创建 MCP 服务器实例\nmcp = FastMCP(\"DataService\")\n\n# 定义工具：从本地 MySQL 数据库获取数据\n@mcp.tool()\ndef get_local_data(name: str) -> str:\n    \"\"\"执行查询并返回本地 MySQL 数据库中的数据\"\"\"\n    load_dotenv()\n    # 连接到本地数据库\n    connection = mysql.connector.connect(\n        host=os.getenv('db_host'),\n        user=os.getenv('db_user'),\n        password=os.getenv('db_password'),\n        database=os.getenv('db_name')\n    )\n    try:\n        with connection.cursor() as cursor:\n            cursor.execute(\"select salary from employees where name like %s limit 1\", (f\"%{name}%\",))\n            row = cursor.fetchone()\n            while row is not None:\n                return row[0]\n        return ''\n    finally:\n        connection.close()\n\n# 定义工具：从网络上搜索数据\n@mcp.tool()\ndef get_web_data(query: str) -> str:\n    \"\"\"Search the web for current information on a topic\"\"\"\n    \n    # 使用 Google 搜索 API\n\n# 运行 MCP 服务器\nif __name__ == \"__main__\":\n    mcp.run()\n\n```\n定义完工具之后，我们可以运行 MCP 服务器，让它监听来自客户端的请求。\n\n#### ** 测试MCP Server **\n使用 MCP Inspector 我们可以查看服务器的状态和工具列表，同时对工具进行调试。\n```bash\nmcp dev server.py\n```\n看到如下输出，说明服务器已经启动成功\n![运行中](./images/mcp/running.png)\n然后我们就可以通过访问Inspector的地址来查看服务器的状态和工具列表。\n![Inspector](./images/mcp/inspector.png)\n\n\n#### **实现客户端**\n\n```python\nclass MCPClient:\n    def __init__(self):\n        self.servers = []\n        self.tools = []\n        self.exit_stack = AsyncExitStack()\n        self.ollama = AsyncClient('127.0.0.1')\n\n    async def initialize(self):\n        server_config = None\n        with open(\"servers_config.json\", \"r\") as f:\n            server_config = json.load(f)\n        # 列出服务器提供的工具\n        print(\"可用的工具:\", self.tools)\n\n    async def chat_loop(self):\n        \"\"\"Run an interactive chat loop\"\"\"\n        print(\"\\nMCP Client Started!\")\n        print(\"Type your queries or 'quit' to exit.\")\n        \n        while True:\n            try:\n                response = await self.process_query(query)\n                print(\"\\n\" + response)\n                    \n            except Exception as e:\n                print(f\"\\nError: {str(e)}\")\n\n\n    async def process_query(self, query: str) -> str:\n        \"\"\"Process a query using Claude and available tools\"\"\"\n\n        tools_description = \"\\n\".join([tool.format_for_llm() for tool in self.tools])\n\n        system_message = (\n                \"You are a helpful assistant with access to these tools:\\n\\n\"\n                f\"{tools_description}\\n\"\n                ...\n            )\n\n        messages = [{\"role\": \"system\", \"content\": system_message}]\n        messages.append({\"role\": \"user\", \"content\": query})\n\n        llm_response = await self.ollama.chat(\n            'qwen2.5:0.5b',        \n            messages=messages\n        )\n        \n        result = await self.process_llm_response(llm_response)\n\n        if result != llm_response:\n            messages.append({\"role\": \"assistant\", \"content\": llm_response})\n            messages.append({\"role\": \"system\", \"content\": result})\n\n            final_response = await self.ollama.chat(\n                'qwen2.5:0.5b',        \n                messages=messages\n            )\n            final_response = final_response.message['content']\n            logging.info(\"\\nFinal response: %s\", final_response)\n            messages.append(\n                {\"role\": \"assistant\", \"content\": final_response}\n            )\n        else:\n            messages.append({\"role\": \"assistant\", \"content\": llm_response})\n\n\n        return final_response\n\n\nasync def main():\n    client = MCPClient()\n    try:\n        await client.initialize()\n        await client.chat_loop()\n    finally:\n        await client.cleanup()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n```\n\n#### **运行效果**\n通过上述代码，我们可以实现一个简单的 AI 对话系统，它可以使用 MCP 服务器提供的工具来获取上下文信息，并与用户进行交互。\n![运行效果](./images/mcp/result1.png)\n\n![运行效果](./images/mcp/result3.png)\n\n---\n\n##  关于 MCP 与 Function Call 机制的关系（补充说明）\n### MCP Client 如何决定调用哪个工具？\n在实际应用中，MCP 客户端判断调用哪个工具主要有两种实现方式：\n\n1. 利用 LLM 平台原生的 Function Call 功能\n\n这种方式依赖 LLM 平台自带的函数调用能力，例如 OpenAI 的 Function Call API。具体流程为：\n\n- 模型识别用户意图，返回指定的函数调用请求。\n\n- 客户端接收到函数调用指令后，通过 MCP 协议访问具体数据或服务。\n\n优点是模型能够直接识别调用意图，调用精准度较高。\n缺点是不同模型平台之间存在 API 差异，切换模型可能需要额外适配。\n\n2. 通过特定的 Prompt 结构（Prompt Engineering）来实现调用判断\n\n通过向模型提供明确、结构化的 system prompt（如下面示例），指导模型在需要调用外部工具时输出指定格式的 JSON 指令：\n\n```\n\"You are a helpful assistant with access to these tools:\\n\\n\"\nf\"{tools_description}\\n\"\n\"Choose the appropriate tool based on the user's question. \"\n\"If no tool is needed, reply directly.\\n\\n\"\n\"IMPORTANT: When you need to use a tool, you must ONLY respond with \"\n\"the exact JSON object format below, nothing else:\\n\"\n\"{\\n\"\n'    \"tool\": \"tool-name\",\\n'\n'    \"arguments\": {\\n'\n'        \"argument-name\": \"value\"\\n'\n\"    }\\n\"\n\"}\\n\\n\"\n\"After receiving a tool's response:\\n\"\n\"1. Transform the raw data into a natural, conversational response\\n\"\n\"2. Keep responses concise but informative\\n\"\n\"3. Focus on the most relevant information\\n\"\n\"4. Use appropriate context from the user's question\\n\"\n\"5. Avoid simply repeating the raw data\\n\\n\"\n\"Please use only the tools that are explicitly defined above.\"\n```\n在这种方法中：\n\n- 模型无需特定的函数调用能力，而是通过 prompt engineering 来判断何时调用工具。\n\n- 客户端解析 JSON 格式指令后调用 MCP 接口访问工具。\n\n优点是对模型平台的 function call API 无依赖，适配性强。\n缺点是依赖 Prompt 结构，模型输出的稳定性可能较差，偶尔需要额外的校验和容错处理。\n\n\n## 总结\n\nMCP（模型上下文协议）提供了一种结构化、高效的方式，使得模型在分布式环境中能够交换上下文信息。它的主要优势包括：\n\n- **标准化的上下文共享**，确保多模型系统的稳定性。\n- **高效可扩展**，适用于不同规模的模型交互需求。\n- **无缝集成**，可通过简单的 API 调用轻松适配现有框架。\n\n通过实现 MCP，开发者可以增强模型之间的协作，减少冗余，并确保模型驱动应用程序中的一致性。如果你正在从事 AI、微服务或分布式计算，MCP 是一个值得考虑的协议！\n\n","slug":"MCP","published":1,"updated":"2025-03-26T12:17:33.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfaw70001rkp1fazm1h1l","content":"<h2 id=\"MCP-出现的背景\"><a href=\"#MCP-出现的背景\" class=\"headerlink\" title=\"MCP 出现的背景\"></a>MCP 出现的背景</h2><p>MCP（Model Context Protocol，模型上下文协议）是一个开放协议，它标准化了应用程序向大语言模型（LLM）提供上下文的方式。可以将 MCP 类比为 AI 应用的 USB-C 端口。就像 USB-C 提供了一种标准化的方式来连接不同设备和配件一样，MCP 也为 AI 模型提供了一种标准化的方式，使其能够与不同的数据源和工具进行交互。这样，开发者可以更轻松地将 MCP 集成到各类 AI 解决方案中，提高模型的上下文获取能力，并增强其对外部数据的适配性。</p>\n<p>本文将深入探讨 MCP 的核心概念、适用场景、架构设计以及如何在实际应用中使用 MCP，并提供具体的代码示例，帮助开发者更好地理解和应用 MCP。</p>\n<h2 id=\"什么是-MCP？\"><a href=\"#什么是-MCP？\" class=\"headerlink\" title=\"什么是 MCP？\"></a>什么是 MCP？</h2><p>MCP（Model Context Protocol，模型上下文协议）是一种协议，旨在促进分布式或模块化系统中模型之间的高效和结构化交互。它定义了一种标准化的方式来交换模型上下文信息，确保一致的数据流和跨不同模型组件的互操作性。</p>\n<p>MCP 在人工智能、微服务和去中心化计算环境中特别有用，这些环境中需要多个模型进行通信并保持上下文一致性。</p>\n<hr>\n<h2 id=\"为什么选择-MCP？\"><a href=\"#为什么选择-MCP？\" class=\"headerlink\" title=\"为什么选择 MCP？\"></a>为什么选择 MCP？</h2><p>MCP 的出现是 Prompt Engineering 发展的产物。更结构化的上下文信息能够显著提升模型的性能。在构造 Prompt 时，我们希望提供更具体的信息（如本地文件、数据库、实时网络数据等）给模型，以便它能够更准确地理解真实场景中的问题。</p>\n<h3 id=\"传统方法的局限性\"><a href=\"#传统方法的局限性\" class=\"headerlink\" title=\"传统方法的局限性\"></a>传统方法的局限性</h3><p>在 MCP 之前，我们通常会手动从数据库中筛选或使用工具检索相关信息，并将其粘贴到 Prompt 中。然而，随着问题的复杂性增加，手动管理这些信息变得越来越困难。</p>\n<p>为了解决这一问题，许多 LLM 平台（如 OpenAI、Google）引入了 <strong>Function Call</strong> 机制，使得模型可以在需要时调用预定义的函数来获取数据或执行操作，从而提升自动化水平。</p>\n<h3 id=\"Function-Call-的局限性\"><a href=\"#Function-Call-的局限性\" class=\"headerlink\" title=\"Function Call 的局限性\"></a>Function Call 的局限性</h3><p>尽管 Function Call 机制带来了便利，但它存在一些关键问题：</p>\n<ul>\n<li><strong>平台依赖性</strong>：不同 LLM 平台的 Function Call API 实现方式各不相同，例如 OpenAI 和 Google 的调用方式不兼容，开发者在切换模型时需要重写代码，增加了适配成本。</li>\n<li><strong>安全性</strong>：Function Call 需要开放额外的接口，可能带来安全隐患。</li>\n<li><strong>交互性</strong>：在部分场景下，Function Call 的交互流程可能较为复杂，影响整体使用体验。<br><img src=\"/blog/./images/mcp/without-mcp.png\" alt=\"没有MCP\"></li>\n</ul>\n<h4 id=\"MCP-如何改进？\"><a href=\"#MCP-如何改进？\" class=\"headerlink\" title=\"MCP 如何改进？\"></a>MCP 如何改进？</h4><ul>\n<li><strong>标准化上下文管理</strong>：MCP 通过提供统一的协议，使应用能够高效地存取和管理上下文，而无需手动管理 Prompt 结构。</li>\n<li><strong>跨平台兼容性</strong>：MCP 作为开放协议，减少了不同 LLM 平台之间的适配成本，开发者可以更轻松地切换底层模型。</li>\n<li><strong>提升自动化水平</strong>：MCP 允许应用程序自动从不同数据源（数据库、API、文件等）动态填充上下文，提高模型的理解能力。</li>\n</ul>\n<p><img src=\"/blog/./images/mcp/with-mcp.png\" alt=\"有MCP\"><br>因此，MCP 的引入为 AI 应用带来了更高效、灵活的上下文管理方式，突破了 Function Call 的局限，使得开发者能够更专注于模型能力的发挥，而非手动适配数据。</p>\n<hr>\n<h2 id=\"MCP-架构解析\"><a href=\"#MCP-架构解析\" class=\"headerlink\" title=\"MCP 架构解析\"></a>MCP 架构解析</h2><p>这里我就直接引入官方给出的架构图吧</p>\n<p><img src=\"/blog/./images/mcp/architecture.png\" alt=\"架构图\"></p>\n<p>MCP 的架构设计清晰地划分为几个核心组件，每个组件都有明确的职责，共同实现上下文信息的标准化交互：</p>\n<ul>\n<li><p>MCP Hosts（宿主程序）：<br>如 Claude Desktop、各类 IDE 或 AI 工具，这些应用程序希望通过 MCP 获取上下文信息或数据，以增强模型的能力。</p>\n</li>\n<li><p>MCP Clients（客户端）：<br>协议中的客户端，负责与 MCP Servers 建立并维护一对一的连接，实现标准化的数据请求与交互。</p>\n</li>\n<li><p>MCP Servers（服务端）：<br>轻量级的服务程序，每个服务端都通过 MCP 协议暴露出特定的能力或数据访问接口，从而满足客户端的不同需求。</p>\n</li>\n<li><p>Local Data Sources（本地数据源）：<br>包括用户计算机上的本地文件、数据库、服务等。这些数据源可通过 MCP Servers 被安全地访问，以提供丰富的上下文信息。</p>\n</li>\n<li><p>Remote Services（远程服务）：<br>指可通过网络访问的外部系统或第三方服务（如 API），MCP Servers 可安全连接到这些服务，以进一步扩展模型所能获取的上下文范围。</p>\n</li>\n</ul>\n<p>通过以上的分层结构，MCP 架构确保了数据访问的安全性、扩展性与灵活性，使得应用程序能轻松、安全地利用多种数据来源提升模型表现。</p>\n<hr>\n<h2 id=\"4-如何使用-MCP（结合代码示例）\"><a href=\"#4-如何使用-MCP（结合代码示例）\" class=\"headerlink\" title=\"4. 如何使用 MCP（结合代码示例）\"></a>4. 如何使用 MCP（结合代码示例）</h2><h3 id=\"示例：在-Python-中使用-MCP-进行-AI-模型交互\"><a href=\"#示例：在-Python-中使用-MCP-进行-AI-模型交互\" class=\"headerlink\" title=\"示例：在 Python 中使用 MCP 进行 AI 模型交互\"></a>示例：在 Python 中使用 MCP 进行 AI 模型交互</h3><p><img src=\"/blog/./images/mcp/architecture2.png\" alt=\"架构图\"></p>\n<h4 id=\"前置工作\"><a href=\"#前置工作\" class=\"headerlink\" title=\"前置工作\"></a>前置工作</h4><ol>\n<li>ollama</li>\n<li>环境配置<a href=\"https://modelcontextprotocol.io/quickstart/server\">（参考官网的推荐配置）</a></li>\n<li>安装 MCP SDK</li>\n</ol>\n<h4 id=\"实现MCP-Server\"><a href=\"#实现MCP-Server\" class=\"headerlink\" title=\"** 实现MCP Server **\"></a>** 实现MCP Server **</h4><p>这里我只实现了两个简单的工具</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 MCP 服务器实例</span></span><br><span class=\"line\">mcp = FastMCP(<span class=\"string\">&quot;DataService&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义工具：从本地 MySQL 数据库获取数据</span></span><br><span class=\"line\"><span class=\"meta\">@mcp.tool()</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_local_data</span>(<span class=\"params\">name: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;执行查询并返回本地 MySQL 数据库中的数据&quot;&quot;&quot;</span></span><br><span class=\"line\">    load_dotenv()</span><br><span class=\"line\">    <span class=\"comment\"># 连接到本地数据库</span></span><br><span class=\"line\">    connection = mysql.connector.connect(</span><br><span class=\"line\">        host=os.getenv(<span class=\"string\">&#x27;db_host&#x27;</span>),</span><br><span class=\"line\">        user=os.getenv(<span class=\"string\">&#x27;db_user&#x27;</span>),</span><br><span class=\"line\">        password=os.getenv(<span class=\"string\">&#x27;db_password&#x27;</span>),</span><br><span class=\"line\">        database=os.getenv(<span class=\"string\">&#x27;db_name&#x27;</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">with</span> connection.cursor() <span class=\"keyword\">as</span> cursor:</span><br><span class=\"line\">            cursor.execute(<span class=\"string\">&quot;select salary from employees where name like %s limit 1&quot;</span>, (<span class=\"string\">f&quot;%<span class=\"subst\">&#123;name&#125;</span>%&quot;</span>,))</span><br><span class=\"line\">            row = cursor.fetchone()</span><br><span class=\"line\">            <span class=\"keyword\">while</span> row <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> row[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        connection.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义工具：从网络上搜索数据</span></span><br><span class=\"line\"><span class=\"meta\">@mcp.tool()</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_web_data</span>(<span class=\"params\">query: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Search the web for current information on a topic&quot;&quot;&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 使用 Google 搜索 API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行 MCP 服务器</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    mcp.run()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>定义完工具之后，我们可以运行 MCP 服务器，让它监听来自客户端的请求。</p>\n<h4 id=\"测试MCP-Server\"><a href=\"#测试MCP-Server\" class=\"headerlink\" title=\"** 测试MCP Server **\"></a>** 测试MCP Server **</h4><p>使用 MCP Inspector 我们可以查看服务器的状态和工具列表，同时对工具进行调试。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mcp dev server.py</span><br></pre></td></tr></table></figure>\n<p>看到如下输出，说明服务器已经启动成功<br><img src=\"/blog/./images/mcp/running.png\" alt=\"运行中\"><br>然后我们就可以通过访问Inspector的地址来查看服务器的状态和工具列表。<br><img src=\"/blog/./images/mcp/inspector.png\" alt=\"Inspector\"></p>\n<h4 id=\"实现客户端\"><a href=\"#实现客户端\" class=\"headerlink\" title=\"实现客户端\"></a><strong>实现客户端</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MCPClient</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.servers = []</span><br><span class=\"line\">        self.tools = []</span><br><span class=\"line\">        self.exit_stack = AsyncExitStack()</span><br><span class=\"line\">        self.ollama = AsyncClient(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">initialize</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        server_config = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;servers_config.json&quot;</span>, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            server_config = json.load(f)</span><br><span class=\"line\">        <span class=\"comment\"># 列出服务器提供的工具</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;可用的工具:&quot;</span>, self.tools)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">chat_loop</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Run an interactive chat loop&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nMCP Client Started!&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Type your queries or &#x27;quit&#x27; to exit.&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                response = <span class=\"keyword\">await</span> self.process_query(query)</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + response)</span><br><span class=\"line\">                    </span><br><span class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\nError: <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">process_query</span>(<span class=\"params\">self, query: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Process a query using Claude and available tools&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        tools_description = <span class=\"string\">&quot;\\n&quot;</span>.join([tool.format_for_llm() <span class=\"keyword\">for</span> tool <span class=\"keyword\">in</span> self.tools])</span><br><span class=\"line\"></span><br><span class=\"line\">        system_message = (</span><br><span class=\"line\">                <span class=\"string\">&quot;You are a helpful assistant with access to these tools:\\n\\n&quot;</span></span><br><span class=\"line\">                <span class=\"string\">f&quot;<span class=\"subst\">&#123;tools_description&#125;</span>\\n&quot;</span></span><br><span class=\"line\">                ...</span><br><span class=\"line\">            )</span><br><span class=\"line\"></span><br><span class=\"line\">        messages = [&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;system&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: system_message&#125;]</span><br><span class=\"line\">        messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: query&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        llm_response = <span class=\"keyword\">await</span> self.ollama.chat(</span><br><span class=\"line\">            <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,        </span><br><span class=\"line\">            messages=messages</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"keyword\">await</span> self.process_llm_response(llm_response)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> result != llm_response:</span><br><span class=\"line\">            messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: llm_response&#125;)</span><br><span class=\"line\">            messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;system&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: result&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            final_response = <span class=\"keyword\">await</span> self.ollama.chat(</span><br><span class=\"line\">                <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,        </span><br><span class=\"line\">                messages=messages</span><br><span class=\"line\">            )</span><br><span class=\"line\">            final_response = final_response.message[<span class=\"string\">&#x27;content&#x27;</span>]</span><br><span class=\"line\">            logging.info(<span class=\"string\">&quot;\\nFinal response: %s&quot;</span>, final_response)</span><br><span class=\"line\">            messages.append(</span><br><span class=\"line\">                &#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: final_response&#125;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: llm_response&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> final_response</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    client = MCPClient()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">await</span> client.initialize()</span><br><span class=\"line\">        <span class=\"keyword\">await</span> client.chat_loop()</span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        <span class=\"keyword\">await</span> client.cleanup()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    asyncio.run(main())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a><strong>运行效果</strong></h4><p>通过上述代码，我们可以实现一个简单的 AI 对话系统，它可以使用 MCP 服务器提供的工具来获取上下文信息，并与用户进行交互。<br><img src=\"/blog/./images/mcp/result1.png\" alt=\"运行效果\"></p>\n<p><img src=\"/blog/./images/mcp/result3.png\" alt=\"运行效果\"></p>\n<hr>\n<h2 id=\"关于-MCP-与-Function-Call-机制的关系（补充说明）\"><a href=\"#关于-MCP-与-Function-Call-机制的关系（补充说明）\" class=\"headerlink\" title=\"关于 MCP 与 Function Call 机制的关系（补充说明）\"></a>关于 MCP 与 Function Call 机制的关系（补充说明）</h2><h3 id=\"MCP-Client-如何决定调用哪个工具？\"><a href=\"#MCP-Client-如何决定调用哪个工具？\" class=\"headerlink\" title=\"MCP Client 如何决定调用哪个工具？\"></a>MCP Client 如何决定调用哪个工具？</h3><p>在实际应用中，MCP 客户端判断调用哪个工具主要有两种实现方式：</p>\n<ol>\n<li>利用 LLM 平台原生的 Function Call 功能</li>\n</ol>\n<p>这种方式依赖 LLM 平台自带的函数调用能力，例如 OpenAI 的 Function Call API。具体流程为：</p>\n<ul>\n<li><p>模型识别用户意图，返回指定的函数调用请求。</p>\n</li>\n<li><p>客户端接收到函数调用指令后，通过 MCP 协议访问具体数据或服务。</p>\n</li>\n</ul>\n<p>优点是模型能够直接识别调用意图，调用精准度较高。<br>缺点是不同模型平台之间存在 API 差异，切换模型可能需要额外适配。</p>\n<ol start=\"2\">\n<li>通过特定的 Prompt 结构（Prompt Engineering）来实现调用判断</li>\n</ol>\n<p>通过向模型提供明确、结构化的 system prompt（如下面示例），指导模型在需要调用外部工具时输出指定格式的 JSON 指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;You are a helpful assistant with access to these tools:\\n\\n&quot;</span><br><span class=\"line\">f&quot;&#123;tools_description&#125;\\n&quot;</span><br><span class=\"line\">&quot;Choose the appropriate tool based on the user&#x27;s question. &quot;</span><br><span class=\"line\">&quot;If no tool is needed, reply directly.\\n\\n&quot;</span><br><span class=\"line\">&quot;IMPORTANT: When you need to use a tool, you must ONLY respond with &quot;</span><br><span class=\"line\">&quot;the exact JSON object format below, nothing else:\\n&quot;</span><br><span class=\"line\">&quot;&#123;\\n&quot;</span><br><span class=\"line\">&#x27;    &quot;tool&quot;: &quot;tool-name&quot;,\\n&#x27;</span><br><span class=\"line\">&#x27;    &quot;arguments&quot;: &#123;\\n&#x27;</span><br><span class=\"line\">&#x27;        &quot;argument-name&quot;: &quot;value&quot;\\n&#x27;</span><br><span class=\"line\">&quot;    &#125;\\n&quot;</span><br><span class=\"line\">&quot;&#125;\\n\\n&quot;</span><br><span class=\"line\">&quot;After receiving a tool&#x27;s response:\\n&quot;</span><br><span class=\"line\">&quot;1. Transform the raw data into a natural, conversational response\\n&quot;</span><br><span class=\"line\">&quot;2. Keep responses concise but informative\\n&quot;</span><br><span class=\"line\">&quot;3. Focus on the most relevant information\\n&quot;</span><br><span class=\"line\">&quot;4. Use appropriate context from the user&#x27;s question\\n&quot;</span><br><span class=\"line\">&quot;5. Avoid simply repeating the raw data\\n\\n&quot;</span><br><span class=\"line\">&quot;Please use only the tools that are explicitly defined above.&quot;</span><br></pre></td></tr></table></figure>\n<p>在这种方法中：</p>\n<ul>\n<li><p>模型无需特定的函数调用能力，而是通过 prompt engineering 来判断何时调用工具。</p>\n</li>\n<li><p>客户端解析 JSON 格式指令后调用 MCP 接口访问工具。</p>\n</li>\n</ul>\n<p>优点是对模型平台的 function call API 无依赖，适配性强。<br>缺点是依赖 Prompt 结构，模型输出的稳定性可能较差，偶尔需要额外的校验和容错处理。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>MCP（模型上下文协议）提供了一种结构化、高效的方式，使得模型在分布式环境中能够交换上下文信息。它的主要优势包括：</p>\n<ul>\n<li><strong>标准化的上下文共享</strong>，确保多模型系统的稳定性。</li>\n<li><strong>高效可扩展</strong>，适用于不同规模的模型交互需求。</li>\n<li><strong>无缝集成</strong>，可通过简单的 API 调用轻松适配现有框架。</li>\n</ul>\n<p>通过实现 MCP，开发者可以增强模型之间的协作，减少冗余，并确保模型驱动应用程序中的一致性。如果你正在从事 AI、微服务或分布式计算，MCP 是一个值得考虑的协议！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MCP-出现的背景\"><a href=\"#MCP-出现的背景\" class=\"headerlink\" title=\"MCP 出现的背景\"></a>MCP 出现的背景</h2><p>MCP（Model Context Protocol，模型上下文协议）是一个开放协议，它标准化了应用程序向大语言模型（LLM）提供上下文的方式。可以将 MCP 类比为 AI 应用的 USB-C 端口。就像 USB-C 提供了一种标准化的方式来连接不同设备和配件一样，MCP 也为 AI 模型提供了一种标准化的方式，使其能够与不同的数据源和工具进行交互。这样，开发者可以更轻松地将 MCP 集成到各类 AI 解决方案中，提高模型的上下文获取能力，并增强其对外部数据的适配性。</p>\n<p>本文将深入探讨 MCP 的核心概念、适用场景、架构设计以及如何在实际应用中使用 MCP，并提供具体的代码示例，帮助开发者更好地理解和应用 MCP。</p>\n<h2 id=\"什么是-MCP？\"><a href=\"#什么是-MCP？\" class=\"headerlink\" title=\"什么是 MCP？\"></a>什么是 MCP？</h2><p>MCP（Model Context Protocol，模型上下文协议）是一种协议，旨在促进分布式或模块化系统中模型之间的高效和结构化交互。它定义了一种标准化的方式来交换模型上下文信息，确保一致的数据流和跨不同模型组件的互操作性。</p>\n<p>MCP 在人工智能、微服务和去中心化计算环境中特别有用，这些环境中需要多个模型进行通信并保持上下文一致性。</p>\n<hr>\n<h2 id=\"为什么选择-MCP？\"><a href=\"#为什么选择-MCP？\" class=\"headerlink\" title=\"为什么选择 MCP？\"></a>为什么选择 MCP？</h2><p>MCP 的出现是 Prompt Engineering 发展的产物。更结构化的上下文信息能够显著提升模型的性能。在构造 Prompt 时，我们希望提供更具体的信息（如本地文件、数据库、实时网络数据等）给模型，以便它能够更准确地理解真实场景中的问题。</p>\n<h3 id=\"传统方法的局限性\"><a href=\"#传统方法的局限性\" class=\"headerlink\" title=\"传统方法的局限性\"></a>传统方法的局限性</h3><p>在 MCP 之前，我们通常会手动从数据库中筛选或使用工具检索相关信息，并将其粘贴到 Prompt 中。然而，随着问题的复杂性增加，手动管理这些信息变得越来越困难。</p>\n<p>为了解决这一问题，许多 LLM 平台（如 OpenAI、Google）引入了 <strong>Function Call</strong> 机制，使得模型可以在需要时调用预定义的函数来获取数据或执行操作，从而提升自动化水平。</p>\n<h3 id=\"Function-Call-的局限性\"><a href=\"#Function-Call-的局限性\" class=\"headerlink\" title=\"Function Call 的局限性\"></a>Function Call 的局限性</h3><p>尽管 Function Call 机制带来了便利，但它存在一些关键问题：</p>\n<ul>\n<li><strong>平台依赖性</strong>：不同 LLM 平台的 Function Call API 实现方式各不相同，例如 OpenAI 和 Google 的调用方式不兼容，开发者在切换模型时需要重写代码，增加了适配成本。</li>\n<li><strong>安全性</strong>：Function Call 需要开放额外的接口，可能带来安全隐患。</li>\n<li><strong>交互性</strong>：在部分场景下，Function Call 的交互流程可能较为复杂，影响整体使用体验。<br><img src=\"/blog/./images/mcp/without-mcp.png\" alt=\"没有MCP\"></li>\n</ul>\n<h4 id=\"MCP-如何改进？\"><a href=\"#MCP-如何改进？\" class=\"headerlink\" title=\"MCP 如何改进？\"></a>MCP 如何改进？</h4><ul>\n<li><strong>标准化上下文管理</strong>：MCP 通过提供统一的协议，使应用能够高效地存取和管理上下文，而无需手动管理 Prompt 结构。</li>\n<li><strong>跨平台兼容性</strong>：MCP 作为开放协议，减少了不同 LLM 平台之间的适配成本，开发者可以更轻松地切换底层模型。</li>\n<li><strong>提升自动化水平</strong>：MCP 允许应用程序自动从不同数据源（数据库、API、文件等）动态填充上下文，提高模型的理解能力。</li>\n</ul>\n<p><img src=\"/blog/./images/mcp/with-mcp.png\" alt=\"有MCP\"><br>因此，MCP 的引入为 AI 应用带来了更高效、灵活的上下文管理方式，突破了 Function Call 的局限，使得开发者能够更专注于模型能力的发挥，而非手动适配数据。</p>\n<hr>\n<h2 id=\"MCP-架构解析\"><a href=\"#MCP-架构解析\" class=\"headerlink\" title=\"MCP 架构解析\"></a>MCP 架构解析</h2><p>这里我就直接引入官方给出的架构图吧</p>\n<p><img src=\"/blog/./images/mcp/architecture.png\" alt=\"架构图\"></p>\n<p>MCP 的架构设计清晰地划分为几个核心组件，每个组件都有明确的职责，共同实现上下文信息的标准化交互：</p>\n<ul>\n<li><p>MCP Hosts（宿主程序）：<br>如 Claude Desktop、各类 IDE 或 AI 工具，这些应用程序希望通过 MCP 获取上下文信息或数据，以增强模型的能力。</p>\n</li>\n<li><p>MCP Clients（客户端）：<br>协议中的客户端，负责与 MCP Servers 建立并维护一对一的连接，实现标准化的数据请求与交互。</p>\n</li>\n<li><p>MCP Servers（服务端）：<br>轻量级的服务程序，每个服务端都通过 MCP 协议暴露出特定的能力或数据访问接口，从而满足客户端的不同需求。</p>\n</li>\n<li><p>Local Data Sources（本地数据源）：<br>包括用户计算机上的本地文件、数据库、服务等。这些数据源可通过 MCP Servers 被安全地访问，以提供丰富的上下文信息。</p>\n</li>\n<li><p>Remote Services（远程服务）：<br>指可通过网络访问的外部系统或第三方服务（如 API），MCP Servers 可安全连接到这些服务，以进一步扩展模型所能获取的上下文范围。</p>\n</li>\n</ul>\n<p>通过以上的分层结构，MCP 架构确保了数据访问的安全性、扩展性与灵活性，使得应用程序能轻松、安全地利用多种数据来源提升模型表现。</p>\n<hr>\n<h2 id=\"4-如何使用-MCP（结合代码示例）\"><a href=\"#4-如何使用-MCP（结合代码示例）\" class=\"headerlink\" title=\"4. 如何使用 MCP（结合代码示例）\"></a>4. 如何使用 MCP（结合代码示例）</h2><h3 id=\"示例：在-Python-中使用-MCP-进行-AI-模型交互\"><a href=\"#示例：在-Python-中使用-MCP-进行-AI-模型交互\" class=\"headerlink\" title=\"示例：在 Python 中使用 MCP 进行 AI 模型交互\"></a>示例：在 Python 中使用 MCP 进行 AI 模型交互</h3><p><img src=\"/blog/./images/mcp/architecture2.png\" alt=\"架构图\"></p>\n<h4 id=\"前置工作\"><a href=\"#前置工作\" class=\"headerlink\" title=\"前置工作\"></a>前置工作</h4><ol>\n<li>ollama</li>\n<li>环境配置<a href=\"https://modelcontextprotocol.io/quickstart/server\">（参考官网的推荐配置）</a></li>\n<li>安装 MCP SDK</li>\n</ol>\n<h4 id=\"实现MCP-Server\"><a href=\"#实现MCP-Server\" class=\"headerlink\" title=\"** 实现MCP Server **\"></a>** 实现MCP Server **</h4><p>这里我只实现了两个简单的工具</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建 MCP 服务器实例</span></span><br><span class=\"line\">mcp = FastMCP(<span class=\"string\">&quot;DataService&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义工具：从本地 MySQL 数据库获取数据</span></span><br><span class=\"line\"><span class=\"meta\">@mcp.tool()</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_local_data</span>(<span class=\"params\">name: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;执行查询并返回本地 MySQL 数据库中的数据&quot;&quot;&quot;</span></span><br><span class=\"line\">    load_dotenv()</span><br><span class=\"line\">    <span class=\"comment\"># 连接到本地数据库</span></span><br><span class=\"line\">    connection = mysql.connector.connect(</span><br><span class=\"line\">        host=os.getenv(<span class=\"string\">&#x27;db_host&#x27;</span>),</span><br><span class=\"line\">        user=os.getenv(<span class=\"string\">&#x27;db_user&#x27;</span>),</span><br><span class=\"line\">        password=os.getenv(<span class=\"string\">&#x27;db_password&#x27;</span>),</span><br><span class=\"line\">        database=os.getenv(<span class=\"string\">&#x27;db_name&#x27;</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">with</span> connection.cursor() <span class=\"keyword\">as</span> cursor:</span><br><span class=\"line\">            cursor.execute(<span class=\"string\">&quot;select salary from employees where name like %s limit 1&quot;</span>, (<span class=\"string\">f&quot;%<span class=\"subst\">&#123;name&#125;</span>%&quot;</span>,))</span><br><span class=\"line\">            row = cursor.fetchone()</span><br><span class=\"line\">            <span class=\"keyword\">while</span> row <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> row[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        connection.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义工具：从网络上搜索数据</span></span><br><span class=\"line\"><span class=\"meta\">@mcp.tool()</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_web_data</span>(<span class=\"params\">query: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Search the web for current information on a topic&quot;&quot;&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 使用 Google 搜索 API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行 MCP 服务器</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    mcp.run()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>定义完工具之后，我们可以运行 MCP 服务器，让它监听来自客户端的请求。</p>\n<h4 id=\"测试MCP-Server\"><a href=\"#测试MCP-Server\" class=\"headerlink\" title=\"** 测试MCP Server **\"></a>** 测试MCP Server **</h4><p>使用 MCP Inspector 我们可以查看服务器的状态和工具列表，同时对工具进行调试。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mcp dev server.py</span><br></pre></td></tr></table></figure>\n<p>看到如下输出，说明服务器已经启动成功<br><img src=\"/blog/./images/mcp/running.png\" alt=\"运行中\"><br>然后我们就可以通过访问Inspector的地址来查看服务器的状态和工具列表。<br><img src=\"/blog/./images/mcp/inspector.png\" alt=\"Inspector\"></p>\n<h4 id=\"实现客户端\"><a href=\"#实现客户端\" class=\"headerlink\" title=\"实现客户端\"></a><strong>实现客户端</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MCPClient</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.servers = []</span><br><span class=\"line\">        self.tools = []</span><br><span class=\"line\">        self.exit_stack = AsyncExitStack()</span><br><span class=\"line\">        self.ollama = AsyncClient(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">initialize</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        server_config = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;servers_config.json&quot;</span>, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            server_config = json.load(f)</span><br><span class=\"line\">        <span class=\"comment\"># 列出服务器提供的工具</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;可用的工具:&quot;</span>, self.tools)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">chat_loop</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Run an interactive chat loop&quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nMCP Client Started!&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Type your queries or &#x27;quit&#x27; to exit.&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                response = <span class=\"keyword\">await</span> self.process_query(query)</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\n&quot;</span> + response)</span><br><span class=\"line\">                    </span><br><span class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\nError: <span class=\"subst\">&#123;<span class=\"built_in\">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">process_query</span>(<span class=\"params\">self, query: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;Process a query using Claude and available tools&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        tools_description = <span class=\"string\">&quot;\\n&quot;</span>.join([tool.format_for_llm() <span class=\"keyword\">for</span> tool <span class=\"keyword\">in</span> self.tools])</span><br><span class=\"line\"></span><br><span class=\"line\">        system_message = (</span><br><span class=\"line\">                <span class=\"string\">&quot;You are a helpful assistant with access to these tools:\\n\\n&quot;</span></span><br><span class=\"line\">                <span class=\"string\">f&quot;<span class=\"subst\">&#123;tools_description&#125;</span>\\n&quot;</span></span><br><span class=\"line\">                ...</span><br><span class=\"line\">            )</span><br><span class=\"line\"></span><br><span class=\"line\">        messages = [&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;system&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: system_message&#125;]</span><br><span class=\"line\">        messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: query&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        llm_response = <span class=\"keyword\">await</span> self.ollama.chat(</span><br><span class=\"line\">            <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,        </span><br><span class=\"line\">            messages=messages</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        result = <span class=\"keyword\">await</span> self.process_llm_response(llm_response)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> result != llm_response:</span><br><span class=\"line\">            messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: llm_response&#125;)</span><br><span class=\"line\">            messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;system&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: result&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            final_response = <span class=\"keyword\">await</span> self.ollama.chat(</span><br><span class=\"line\">                <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,        </span><br><span class=\"line\">                messages=messages</span><br><span class=\"line\">            )</span><br><span class=\"line\">            final_response = final_response.message[<span class=\"string\">&#x27;content&#x27;</span>]</span><br><span class=\"line\">            logging.info(<span class=\"string\">&quot;\\nFinal response: %s&quot;</span>, final_response)</span><br><span class=\"line\">            messages.append(</span><br><span class=\"line\">                &#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: final_response&#125;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            messages.append(&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;assistant&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: llm_response&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> final_response</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    client = MCPClient()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">await</span> client.initialize()</span><br><span class=\"line\">        <span class=\"keyword\">await</span> client.chat_loop()</span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        <span class=\"keyword\">await</span> client.cleanup()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    asyncio.run(main())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a><strong>运行效果</strong></h4><p>通过上述代码，我们可以实现一个简单的 AI 对话系统，它可以使用 MCP 服务器提供的工具来获取上下文信息，并与用户进行交互。<br><img src=\"/blog/./images/mcp/result1.png\" alt=\"运行效果\"></p>\n<p><img src=\"/blog/./images/mcp/result3.png\" alt=\"运行效果\"></p>\n<hr>\n<h2 id=\"关于-MCP-与-Function-Call-机制的关系（补充说明）\"><a href=\"#关于-MCP-与-Function-Call-机制的关系（补充说明）\" class=\"headerlink\" title=\"关于 MCP 与 Function Call 机制的关系（补充说明）\"></a>关于 MCP 与 Function Call 机制的关系（补充说明）</h2><h3 id=\"MCP-Client-如何决定调用哪个工具？\"><a href=\"#MCP-Client-如何决定调用哪个工具？\" class=\"headerlink\" title=\"MCP Client 如何决定调用哪个工具？\"></a>MCP Client 如何决定调用哪个工具？</h3><p>在实际应用中，MCP 客户端判断调用哪个工具主要有两种实现方式：</p>\n<ol>\n<li>利用 LLM 平台原生的 Function Call 功能</li>\n</ol>\n<p>这种方式依赖 LLM 平台自带的函数调用能力，例如 OpenAI 的 Function Call API。具体流程为：</p>\n<ul>\n<li><p>模型识别用户意图，返回指定的函数调用请求。</p>\n</li>\n<li><p>客户端接收到函数调用指令后，通过 MCP 协议访问具体数据或服务。</p>\n</li>\n</ul>\n<p>优点是模型能够直接识别调用意图，调用精准度较高。<br>缺点是不同模型平台之间存在 API 差异，切换模型可能需要额外适配。</p>\n<ol start=\"2\">\n<li>通过特定的 Prompt 结构（Prompt Engineering）来实现调用判断</li>\n</ol>\n<p>通过向模型提供明确、结构化的 system prompt（如下面示例），指导模型在需要调用外部工具时输出指定格式的 JSON 指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;You are a helpful assistant with access to these tools:\\n\\n&quot;</span><br><span class=\"line\">f&quot;&#123;tools_description&#125;\\n&quot;</span><br><span class=\"line\">&quot;Choose the appropriate tool based on the user&#x27;s question. &quot;</span><br><span class=\"line\">&quot;If no tool is needed, reply directly.\\n\\n&quot;</span><br><span class=\"line\">&quot;IMPORTANT: When you need to use a tool, you must ONLY respond with &quot;</span><br><span class=\"line\">&quot;the exact JSON object format below, nothing else:\\n&quot;</span><br><span class=\"line\">&quot;&#123;\\n&quot;</span><br><span class=\"line\">&#x27;    &quot;tool&quot;: &quot;tool-name&quot;,\\n&#x27;</span><br><span class=\"line\">&#x27;    &quot;arguments&quot;: &#123;\\n&#x27;</span><br><span class=\"line\">&#x27;        &quot;argument-name&quot;: &quot;value&quot;\\n&#x27;</span><br><span class=\"line\">&quot;    &#125;\\n&quot;</span><br><span class=\"line\">&quot;&#125;\\n\\n&quot;</span><br><span class=\"line\">&quot;After receiving a tool&#x27;s response:\\n&quot;</span><br><span class=\"line\">&quot;1. Transform the raw data into a natural, conversational response\\n&quot;</span><br><span class=\"line\">&quot;2. Keep responses concise but informative\\n&quot;</span><br><span class=\"line\">&quot;3. Focus on the most relevant information\\n&quot;</span><br><span class=\"line\">&quot;4. Use appropriate context from the user&#x27;s question\\n&quot;</span><br><span class=\"line\">&quot;5. Avoid simply repeating the raw data\\n\\n&quot;</span><br><span class=\"line\">&quot;Please use only the tools that are explicitly defined above.&quot;</span><br></pre></td></tr></table></figure>\n<p>在这种方法中：</p>\n<ul>\n<li><p>模型无需特定的函数调用能力，而是通过 prompt engineering 来判断何时调用工具。</p>\n</li>\n<li><p>客户端解析 JSON 格式指令后调用 MCP 接口访问工具。</p>\n</li>\n</ul>\n<p>优点是对模型平台的 function call API 无依赖，适配性强。<br>缺点是依赖 Prompt 结构，模型输出的稳定性可能较差，偶尔需要额外的校验和容错处理。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>MCP（模型上下文协议）提供了一种结构化、高效的方式，使得模型在分布式环境中能够交换上下文信息。它的主要优势包括：</p>\n<ul>\n<li><strong>标准化的上下文共享</strong>，确保多模型系统的稳定性。</li>\n<li><strong>高效可扩展</strong>，适用于不同规模的模型交互需求。</li>\n<li><strong>无缝集成</strong>，可通过简单的 API 调用轻松适配现有框架。</li>\n</ul>\n<p>通过实现 MCP，开发者可以增强模型之间的协作，减少冗余，并确保模型驱动应用程序中的一致性。如果你正在从事 AI、微服务或分布式计算，MCP 是一个值得考虑的协议！</p>\n"},{"title":"深入解析消息队列中的死信队列","date":"2024-05-22T07:37:54.000Z","_content":"\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","source":"_posts/dead-message.md","raw":"---\ntitle: 深入解析消息队列中的死信队列\ndate: 2024-05-22 15:37:54\ntags:\n---\n\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","slug":"dead-message","published":1,"updated":"2024-05-25T09:23:07.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfaw80002rkp17dwke9gu","content":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/blog/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/blog/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/blog/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/blog/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/blog/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/blog/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/blog/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/blog/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n"},{"title":"Kubernetes DaemonSet – 它是什么以及如何使用","date":"2024-08-01T00:54:53.000Z","_content":"\n当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。\n\n# 什么是 DaemonSet？\n![daemonset](/images/daemonset/DaemonSets.png)\n\nDaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。\n\nDaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。\n\n# DaemonSet 的工作原理\n\nDaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。\n\n此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。\n\nDaemonSet 的工作原理非常简单直观：\n\n+ Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。\n\n+ Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。\n\n+ 更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。\n\n# 常见用途\n\nDaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：\n\n1. 日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。\n\n> 由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。\n\n2. 网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。\n\n> 说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。\n    ![daemonset-1](/images/daemonset/daemonset-1.png)\n\n3. 存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。\n\n# 实战探索\n\n随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。\n\n前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 \n\n### 背景和挑战\n\n容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：\n\n+ 分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。\n+ 高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。\n+ 数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。\n\n模拟环境总共3个node，一个master和两个工作节点。\n\n![节点](/images/daemonset/nodes.png)\n\n我们希望能够把我们的监控程序部署在每个工作节点中。\n\n### 架构设计\n我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。\n\n1. 监控数据生成和收集\n\n    自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。\n\n    数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。\n\n2. 数据传输和安全性保障\n\n    安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。\n\n3. 云端存储和管理\n\n    数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。\n\n4. 数据分析和可视化\n\n    数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。\n\n    可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应\n\n### Kubernetes部署\n1、DaemonSet 配置文件\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: acr/txclientx:5.24.10729.10\n        ports:\n        - containerPort: 80  # 如果你的应用有服务端口，请替换为实际端口\n        env:\n        - name: KhGuid\n          value: \"xxx\"\n        - name: TxCloudSite_Url\n          value: \"https://domain.com\"\n        - name: HttpJsonWriter_Target_Url\n          value: \"http://domain.com/v20/api/loggate/save/{datatype}\"\n        - name: NebulaFides_Url\n          value: \"http://domain.com\"\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"200Mi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"400Mi\"\n\n```\n2、部署到Kubernetes集群\n```bash\nkubectl apply -f agent-daemonset.yaml\n```\n\n3、部署结果\n我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序\n![监控pod](/images/daemonset/daemonset-pods.png)\n\n\n# 结语\n\n通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。","source":"_posts/daemonset.md","raw":"---\ntitle: Kubernetes DaemonSet – 它是什么以及如何使用\ndate: 2024-08-01 08:54:53\ntags:\n---\n\n当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。\n\n# 什么是 DaemonSet？\n![daemonset](/images/daemonset/DaemonSets.png)\n\nDaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。\n\nDaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。\n\n# DaemonSet 的工作原理\n\nDaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。\n\n此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。\n\nDaemonSet 的工作原理非常简单直观：\n\n+ Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。\n\n+ Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。\n\n+ 更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。\n\n# 常见用途\n\nDaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：\n\n1. 日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。\n\n> 由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。\n\n2. 网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。\n\n> 说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。\n    ![daemonset-1](/images/daemonset/daemonset-1.png)\n\n3. 存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。\n\n# 实战探索\n\n随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。\n\n前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 \n\n### 背景和挑战\n\n容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：\n\n+ 分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。\n+ 高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。\n+ 数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。\n\n模拟环境总共3个node，一个master和两个工作节点。\n\n![节点](/images/daemonset/nodes.png)\n\n我们希望能够把我们的监控程序部署在每个工作节点中。\n\n### 架构设计\n我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。\n\n1. 监控数据生成和收集\n\n    自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。\n\n    数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。\n\n2. 数据传输和安全性保障\n\n    安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。\n\n3. 云端存储和管理\n\n    数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。\n\n4. 数据分析和可视化\n\n    数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。\n\n    可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应\n\n### Kubernetes部署\n1、DaemonSet 配置文件\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: acr/txclientx:5.24.10729.10\n        ports:\n        - containerPort: 80  # 如果你的应用有服务端口，请替换为实际端口\n        env:\n        - name: KhGuid\n          value: \"xxx\"\n        - name: TxCloudSite_Url\n          value: \"https://domain.com\"\n        - name: HttpJsonWriter_Target_Url\n          value: \"http://domain.com/v20/api/loggate/save/{datatype}\"\n        - name: NebulaFides_Url\n          value: \"http://domain.com\"\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"200Mi\"\n          limits:\n            cpu: \"200m\"\n            memory: \"400Mi\"\n\n```\n2、部署到Kubernetes集群\n```bash\nkubectl apply -f agent-daemonset.yaml\n```\n\n3、部署结果\n我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序\n![监控pod](/images/daemonset/daemonset-pods.png)\n\n\n# 结语\n\n通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。","slug":"daemonset","published":1,"updated":"2024-08-02T10:01:08.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfaw90003rkp1f8rva2k2","content":"<p>当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。</p>\n<h1 id=\"什么是-DaemonSet？\"><a href=\"#什么是-DaemonSet？\" class=\"headerlink\" title=\"什么是 DaemonSet？\"></a>什么是 DaemonSet？</h1><p><img src=\"/blog/images/daemonset/DaemonSets.png\" alt=\"daemonset\"></p>\n<p>DaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。</p>\n<p>DaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。</p>\n<h1 id=\"DaemonSet-的工作原理\"><a href=\"#DaemonSet-的工作原理\" class=\"headerlink\" title=\"DaemonSet 的工作原理\"></a>DaemonSet 的工作原理</h1><p>DaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。</p>\n<p>此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。</p>\n<p>DaemonSet 的工作原理非常简单直观：</p>\n<ul>\n<li><p>Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。</p>\n</li>\n<li><p>Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。</p>\n</li>\n<li><p>更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。</p>\n</li>\n</ul>\n<h1 id=\"常见用途\"><a href=\"#常见用途\" class=\"headerlink\" title=\"常见用途\"></a>常见用途</h1><p>DaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：</p>\n<ol>\n<li>日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。</li>\n</ol>\n<blockquote>\n<p>由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。</p>\n</blockquote>\n<ol start=\"2\">\n<li>网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。</li>\n</ol>\n<blockquote>\n<p>说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。<br>    <img src=\"/blog/images/daemonset/daemonset-1.png\" alt=\"daemonset-1\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。</li>\n</ol>\n<h1 id=\"实战探索\"><a href=\"#实战探索\" class=\"headerlink\" title=\"实战探索\"></a>实战探索</h1><p>随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。</p>\n<p>前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 </p>\n<h3 id=\"背景和挑战\"><a href=\"#背景和挑战\" class=\"headerlink\" title=\"背景和挑战\"></a>背景和挑战</h3><p>容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：</p>\n<ul>\n<li>分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。</li>\n<li>高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。</li>\n<li>数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。</li>\n</ul>\n<p>模拟环境总共3个node，一个master和两个工作节点。</p>\n<p><img src=\"/blog/images/daemonset/nodes.png\" alt=\"节点\"></p>\n<p>我们希望能够把我们的监控程序部署在每个工作节点中。</p>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。</p>\n<ol>\n<li><p>监控数据生成和收集</p>\n<p> 自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。</p>\n<p> 数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。</p>\n</li>\n<li><p>数据传输和安全性保障</p>\n<p> 安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。</p>\n</li>\n<li><p>云端存储和管理</p>\n<p> 数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。</p>\n</li>\n<li><p>数据分析和可视化</p>\n<p> 数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。</p>\n<p> 可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应</p>\n</li>\n</ol>\n<h3 id=\"Kubernetes部署\"><a href=\"#Kubernetes部署\" class=\"headerlink\" title=\"Kubernetes部署\"></a>Kubernetes部署</h3><p>1、DaemonSet 配置文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">acr/txclientx:5.24.10729.10</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 如果你的应用有服务端口，请替换为实际端口</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxCloudSite_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">HttpJsonWriter_Target_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com/v20/api/loggate/save/&#123;datatype&#125;&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">NebulaFides_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">resources:</span></span><br><span class=\"line\">          <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;100m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;200Mi&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">limits:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;200m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;400Mi&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、部署到Kubernetes集群</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f agent-daemonset.yaml</span><br></pre></td></tr></table></figure>\n\n<p>3、部署结果<br>我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序<br><img src=\"/blog/images/daemonset/daemonset-pods.png\" alt=\"监控pod\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>当谈论 Kubernetes 中的 DaemonSet（守护进程集）时，我们通常在分布式系统中需要确保某些特定的 Pod 在集群的每个Node上运行。DaemonSet 就是为了满足这种需求而设计的 Kubernetes 控制器。本文将探讨 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。</p>\n<h1 id=\"什么是-DaemonSet？\"><a href=\"#什么是-DaemonSet？\" class=\"headerlink\" title=\"什么是 DaemonSet？\"></a>什么是 DaemonSet？</h1><p><img src=\"/blog/images/daemonset/DaemonSets.png\" alt=\"daemonset\"></p>\n<p>DaemonSet 是 Kubernetes 的一个控制器类型，用于确保集群中的每个节点上都运行一个 Pod 的副本。每个节点上只会有一个该类型的 Pod 实例，如果有新的节点加入集群，它会自动在新节点上创建一个新的 Pod 实例；如果节点从集群中移除，它会相应地删除该节点上的 Pod 实例。</p>\n<p>DaemonSet 主要用于在每个节点上运行一些系统级别的服务或者需要全局唯一性的 Pod，如日志收集器（Fluentd、Filebeat）、监控代理（Prometheus Node Exporter）、网络代理（kube-proxy）等。</p>\n<h1 id=\"DaemonSet-的工作原理\"><a href=\"#DaemonSet-的工作原理\" class=\"headerlink\" title=\"DaemonSet 的工作原理\"></a>DaemonSet 的工作原理</h1><p>DaemonSets 自动执行此过程，确保每个节点在加入集群后无需任何人工干预即可纳入监控范围。</p>\n<p>此外，DaemonSet管理每个节点上这些工具的生命周期。当从集群中删除节点时，DaemonSet 会确保相关监控工具也被彻底删除，从而使集群保持整洁高效。</p>\n<p>DaemonSet 的工作原理非常简单直观：</p>\n<ul>\n<li><p>Pod 创建与删除： 当 DaemonSet 被创建或更新时，Kubernetes 会为每个现有节点创建一个 Pod。新加入的节点也会自动创建对应的 Pod。当节点从集群中删除时，Kubernetes 会删除该节点上的 Pod 实例。</p>\n</li>\n<li><p>Pod 调度规则： DaemonSet 可以通过节点选择器（Node Selector）或者节点亲和性（Node Affinity）来控制 Pod 的调度。可以使用这些选项来限制 Pod 只在特定的节点上运行。</p>\n</li>\n<li><p>更新策略： 当 DaemonSet 的 Pod 模板更新时，Kubernetes 会自动处理更新策略。可以选择逐个节点更新（默认）或者批量更新，确保在更新过程中集群的稳定性。</p>\n</li>\n</ul>\n<h1 id=\"常见用途\"><a href=\"#常见用途\" class=\"headerlink\" title=\"常见用途\"></a>常见用途</h1><p>DaemonSet 在 Kubernetes 中有许多实际应用场景，包括但不限于：</p>\n<ol>\n<li>日志收集与监控： 如 Fluentd、Filebeat、Prometheus Node Exporter 等，这些组件需要在每个节点上收集和发送数据。</li>\n</ol>\n<blockquote>\n<p>由于k8s里面pod都是短暂的，所以我们把日志存储在容器内部是毫无意义的，容器重启后日志就丢失了。这就是为什么有必要从每个节点收集日志并将其发送到 Kubernetes 集群之外的某个中心位置进行持久化和后续分析。</p>\n</blockquote>\n<ol start=\"2\">\n<li>网络代理： 如 kube-proxy，负责管理节点上的网络规则和流量转发。</li>\n</ol>\n<blockquote>\n<p>说到网络代理，部署过k8s的老铁们应该会注意到。我们用到的CNI插件通常就是用DaemonSet的方式部署的。<br>    <img src=\"/blog/images/daemonset/daemonset-1.png\" alt=\"daemonset-1\"></p>\n</blockquote>\n<ol start=\"3\">\n<li>存储和数据处理： 某些情况下需要在每个节点上运行特定的数据处理任务或者存储服务。</li>\n</ol>\n<h1 id=\"实战探索\"><a href=\"#实战探索\" class=\"headerlink\" title=\"实战探索\"></a>实战探索</h1><p>随着我们团队将部署基础架构迁移到容器中，监控和日志记录方法发生了很大变化。将日志存储在容器或虚拟机中毫无意义——它们都是暂时性的。这就是 Kubernetes DaemonSet 等解决方案的用武之地。</p>\n<p>前面说到Kubernetes 中的 DaemonSet 是一种特定类型的工作负载控制器，可确保 Pod 的副本在集群内的所有或某些指定节点上运行。它会自动将 Pod 添加到新节点，并从已移除的节点中移除 Pod。这使得 DaemonSet 非常适合在每个节点上监控、记录或运行网络代理等任务。 </p>\n<h3 id=\"背景和挑战\"><a href=\"#背景和挑战\" class=\"headerlink\" title=\"背景和挑战\"></a>背景和挑战</h3><p>容器化和微服务架构中，对集群节点的实时监控是确保系统稳定性和性能优化的关键。典型的挑战包括：</p>\n<ul>\n<li>分布式环境： 集群中的节点数量和位置随时可能发生变化，需要实时监控每个节点的状态和资源使用情况。</li>\n<li>高可用性需求： 监控代理需要高可用地运行在每个节点上，即使部分节点故障也要保持数据的连续性。</li>\n<li>数据安全和隔离： 监控数据的收集和传输需要安全可靠，避免泄露和未经授权访问。</li>\n</ul>\n<p>模拟环境总共3个node，一个master和两个工作节点。</p>\n<p><img src=\"/blog/images/daemonset/nodes.png\" alt=\"节点\"></p>\n<p>我们希望能够把我们的监控程序部署在每个工作节点中。</p>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>我们将使用自研的客户端程序实现节点监控，通过 DaemonSet 在每个 Kubernetes 节点上部署 Node Exporter，将节点的指标数据推送到云端数据存储和查询系统。</p>\n<ol>\n<li><p>监控数据生成和收集</p>\n<p> 自研监控工具： 开发和部署自研的监控工具，用于收集 Kubernetes 集群中的各项指标数据，如节点资源使用情况、Pod 健康状态、应用程序性能指标等。</p>\n<p> 数据聚合和处理： 在每个节点上运行监控代理，负责实时收集和聚合监控数据。数据聚合过程中确保数据的时序性和准确性。</p>\n</li>\n<li><p>数据传输和安全性保障</p>\n<p> 安全传输协议： 使用安全的传输协议，如 HTTPS 或者其他加密传输协议，确保监控数据在传输过程中的机密性和完整性。</p>\n</li>\n<li><p>云端存储和管理</p>\n<p> 数据存储和管理： 将监控数据存储在云端的时序数据库中，使用数据库的特性进行数据分区、索引和备份，以支持高效的数据存储和检索。</p>\n</li>\n<li><p>数据分析和可视化</p>\n<p> 数据分析和报表： 基于存储在时序数据库中的监控数据，开发数据分析和报表功能，以便实时监控和历史数据分析，支持决策和优化操作。</p>\n<p> 可视化和警报： 使用数据可视化工具创建仪表盘和报表，实时展示监控指标的趋势和变化，设置警报规则以便及时响应</p>\n</li>\n</ol>\n<h3 id=\"Kubernetes部署\"><a href=\"#Kubernetes部署\" class=\"headerlink\" title=\"Kubernetes部署\"></a>Kubernetes部署</h3><p>1、DaemonSet 配置文件</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">acr/txclientx:5.24.10729.10</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 如果你的应用有服务端口，请替换为实际端口</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxCloudSite_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">HttpJsonWriter_Target_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com/v20/api/loggate/save/&#123;datatype&#125;&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">NebulaFides_Url</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;http://domain.com&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">resources:</span></span><br><span class=\"line\">          <span class=\"attr\">requests:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;100m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;200Mi&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">limits:</span></span><br><span class=\"line\">            <span class=\"attr\">cpu:</span> <span class=\"string\">&quot;200m&quot;</span></span><br><span class=\"line\">            <span class=\"attr\">memory:</span> <span class=\"string\">&quot;400Mi&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2、部署到Kubernetes集群</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f agent-daemonset.yaml</span><br></pre></td></tr></table></figure>\n\n<p>3、部署结果<br>我们可以看到k8s已经自动为我们的两个工作节点部署了监控程序<br><img src=\"/blog/images/daemonset/daemonset-pods.png\" alt=\"监控pod\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文，我们介绍了 Kubernetes 中 DaemonSet 的定义、工作原理、常见用途以及如何在实际场景中使用 DaemonSet。DaemonSet 是 Kubernetes 中非常实用且强大的一个控制器类型，适用于需要在每个节点上运行特定 Pod 的场景，如日志收集、监控、网络代理等。通过灵活使用 DaemonSet，可以有效地管理和部署分布式系统中的服务。</p>\n"},{"title":"Docker隐藏在细节中的技术基础","date":"2024-07-05T11:59:06.000Z","_content":"## 引言\nDocker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。\n\n开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转[Docker教程](https://www.runoob.com/docker/docker-tutorial.html)\n\n## 为什么需要Docker\n![multi-envs](/images/docker-1/multi-env.png)\n软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？\n\n用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。\n\n如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：\"它在我的机器上是正常的呀\"，言下之意就是，其他机器很可能跑不了。\n\n环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。\n\n## 虚拟机与容器：理解深层次差异\n### 资源隔离与共享\n+ 虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。\n+ 容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。\n\n### 常见误区：容器的隔离性\n很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。\n\n## 文件系统与存储卷：隐形的性能瓶颈\n### Union File System\nDocker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。\n\n### 联合文件系统的分层结构\n联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。\n\n### 分层文件系统与写操作\n在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：\n\n1. 读取原始文件：从只读层读取文件内容。\n2. 复制到可写层：将读取的文件内容复制到可写层。\n3. 修改文件：在可写层中修改文件内容。\n\n### 性能下降的原因\n1. 写时复制操作\n每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I/O操作的开销，尤其是在频繁写入或修改大量文件时。\n\n2. 层次结构复杂性\n分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。\n\n3. 合并视图的开销\n联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。\n\n\n### 实际案例：大量文件写入操作\n如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。\n\n在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。\n\n```dockerfile\n# Dockerfile 示例\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nVOLUME /app/data\nCMD [\"python\", \"app.py\"]\n```\n\n在docker-compose.yml中配置卷挂载：\n\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    volumes:\n      - ./data:/app/data\n```\n\n## 网络与安全：看不见的陷阱\n### 网络模式选择\nDocker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。\n\n### 安全隐患：默认桥接网络\n默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。\n\n```bash\n# 创建用户自定义桥接网络\ndocker network create --driver bridge my_bridge_network\n\n# 启动容器时指定网络\ndocker run --network my_bridge_network my_app\n```\n\n## 镜像管理：隐形的资源浪费\n### 镜像层叠与大小控制\nDocker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。\n\n### 实践建议：定期清理\n定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n\n# 清理未使用的卷\ndocker volume prune\n\n# 清理未使用的网络\ndocker network prune\n```\n\n## 日志管理：忽视的存储负担\n### 日志驱动与存储策略\nDocker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。\n\n### 实践建议：日志轮转与外部存储\n配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n或者将日志发送到外部系统，如ELK堆栈：\n\n```json\n{\n  \"log-driver\": \"gelf\",\n  \"log-opts\": {\n    \"gelf-address\": \"udp://logstash:12201\"\n  }\n}\n```\n\n## 结语\n通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。\n\n***\n\n希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/docker-1.md","raw":"---\ntitle: Docker隐藏在细节中的技术基础\ndate: 2024-07-05 19:59:06\ntags:\n---\n## 引言\nDocker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。\n\n开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转[Docker教程](https://www.runoob.com/docker/docker-tutorial.html)\n\n## 为什么需要Docker\n![multi-envs](/images/docker-1/multi-env.png)\n软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？\n\n用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。\n\n如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：\"它在我的机器上是正常的呀\"，言下之意就是，其他机器很可能跑不了。\n\n环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。\n\n## 虚拟机与容器：理解深层次差异\n### 资源隔离与共享\n+ 虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。\n+ 容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。\n\n### 常见误区：容器的隔离性\n很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。\n\n## 文件系统与存储卷：隐形的性能瓶颈\n### Union File System\nDocker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。\n\n### 联合文件系统的分层结构\n联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。\n\n### 分层文件系统与写操作\n在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：\n\n1. 读取原始文件：从只读层读取文件内容。\n2. 复制到可写层：将读取的文件内容复制到可写层。\n3. 修改文件：在可写层中修改文件内容。\n\n### 性能下降的原因\n1. 写时复制操作\n每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I/O操作的开销，尤其是在频繁写入或修改大量文件时。\n\n2. 层次结构复杂性\n分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。\n\n3. 合并视图的开销\n联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。\n\n\n### 实际案例：大量文件写入操作\n如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。\n\n在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。\n\n```dockerfile\n# Dockerfile 示例\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nVOLUME /app/data\nCMD [\"python\", \"app.py\"]\n```\n\n在docker-compose.yml中配置卷挂载：\n\n```yaml\nversion: '3.8'\nservices:\n  app:\n    build: .\n    volumes:\n      - ./data:/app/data\n```\n\n## 网络与安全：看不见的陷阱\n### 网络模式选择\nDocker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。\n\n### 安全隐患：默认桥接网络\n默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。\n\n```bash\n# 创建用户自定义桥接网络\ndocker network create --driver bridge my_bridge_network\n\n# 启动容器时指定网络\ndocker run --network my_bridge_network my_app\n```\n\n## 镜像管理：隐形的资源浪费\n### 镜像层叠与大小控制\nDocker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。\n\n### 实践建议：定期清理\n定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n\n# 清理未使用的卷\ndocker volume prune\n\n# 清理未使用的网络\ndocker network prune\n```\n\n## 日志管理：忽视的存储负担\n### 日志驱动与存储策略\nDocker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。\n\n### 实践建议：日志轮转与外部存储\n配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。\n\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n或者将日志发送到外部系统，如ELK堆栈：\n\n```json\n{\n  \"log-driver\": \"gelf\",\n  \"log-opts\": {\n    \"gelf-address\": \"udp://logstash:12201\"\n  }\n}\n```\n\n## 结语\n通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。\n\n***\n\n希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！","slug":"docker-1","published":1,"updated":"2024-07-06T08:46:28.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfaw90004rkp1f4zs1qqx","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Docker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。</p>\n<p>开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转<a href=\"https://www.runoob.com/docker/docker-tutorial.html\">Docker教程</a></p>\n<h2 id=\"为什么需要Docker\"><a href=\"#为什么需要Docker\" class=\"headerlink\" title=\"为什么需要Docker\"></a>为什么需要Docker</h2><p><img src=\"/blog/images/docker-1/multi-env.png\" alt=\"multi-envs\"><br>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？</p>\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。</p>\n<p>如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：”它在我的机器上是正常的呀”，言下之意就是，其他机器很可能跑不了。</p>\n<p>环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n<h2 id=\"虚拟机与容器：理解深层次差异\"><a href=\"#虚拟机与容器：理解深层次差异\" class=\"headerlink\" title=\"虚拟机与容器：理解深层次差异\"></a>虚拟机与容器：理解深层次差异</h2><h3 id=\"资源隔离与共享\"><a href=\"#资源隔离与共享\" class=\"headerlink\" title=\"资源隔离与共享\"></a>资源隔离与共享</h3><ul>\n<li>虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。</li>\n<li>容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。</li>\n</ul>\n<h3 id=\"常见误区：容器的隔离性\"><a href=\"#常见误区：容器的隔离性\" class=\"headerlink\" title=\"常见误区：容器的隔离性\"></a>常见误区：容器的隔离性</h3><p>很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。</p>\n<h2 id=\"文件系统与存储卷：隐形的性能瓶颈\"><a href=\"#文件系统与存储卷：隐形的性能瓶颈\" class=\"headerlink\" title=\"文件系统与存储卷：隐形的性能瓶颈\"></a>文件系统与存储卷：隐形的性能瓶颈</h2><h3 id=\"Union-File-System\"><a href=\"#Union-File-System\" class=\"headerlink\" title=\"Union File System\"></a>Union File System</h3><p>Docker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。</p>\n<h3 id=\"联合文件系统的分层结构\"><a href=\"#联合文件系统的分层结构\" class=\"headerlink\" title=\"联合文件系统的分层结构\"></a>联合文件系统的分层结构</h3><p>联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。</p>\n<h3 id=\"分层文件系统与写操作\"><a href=\"#分层文件系统与写操作\" class=\"headerlink\" title=\"分层文件系统与写操作\"></a>分层文件系统与写操作</h3><p>在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：</p>\n<ol>\n<li>读取原始文件：从只读层读取文件内容。</li>\n<li>复制到可写层：将读取的文件内容复制到可写层。</li>\n<li>修改文件：在可写层中修改文件内容。</li>\n</ol>\n<h3 id=\"性能下降的原因\"><a href=\"#性能下降的原因\" class=\"headerlink\" title=\"性能下降的原因\"></a>性能下降的原因</h3><ol>\n<li><p>写时复制操作<br>每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I&#x2F;O操作的开销，尤其是在频繁写入或修改大量文件时。</p>\n</li>\n<li><p>层次结构复杂性<br>分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。</p>\n</li>\n<li><p>合并视图的开销<br>联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。</p>\n</li>\n</ol>\n<h3 id=\"实际案例：大量文件写入操作\"><a href=\"#实际案例：大量文件写入操作\" class=\"headerlink\" title=\"实际案例：大量文件写入操作\"></a>实际案例：大量文件写入操作</h3><p>如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。</p>\n<p>在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile 示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/data</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>在docker-compose.yml中配置卷挂载：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data:/app/data</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络与安全：看不见的陷阱\"><a href=\"#网络与安全：看不见的陷阱\" class=\"headerlink\" title=\"网络与安全：看不见的陷阱\"></a>网络与安全：看不见的陷阱</h2><h3 id=\"网络模式选择\"><a href=\"#网络模式选择\" class=\"headerlink\" title=\"网络模式选择\"></a>网络模式选择</h3><p>Docker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。</p>\n<h3 id=\"安全隐患：默认桥接网络\"><a href=\"#安全隐患：默认桥接网络\" class=\"headerlink\" title=\"安全隐患：默认桥接网络\"></a>安全隐患：默认桥接网络</h3><p>默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户自定义桥接网络</span></span><br><span class=\"line\">docker network create --driver bridge my_bridge_network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时指定网络</span></span><br><span class=\"line\">docker run --network my_bridge_network my_app</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"镜像管理：隐形的资源浪费\"><a href=\"#镜像管理：隐形的资源浪费\" class=\"headerlink\" title=\"镜像管理：隐形的资源浪费\"></a>镜像管理：隐形的资源浪费</h2><h3 id=\"镜像层叠与大小控制\"><a href=\"#镜像层叠与大小控制\" class=\"headerlink\" title=\"镜像层叠与大小控制\"></a>镜像层叠与大小控制</h3><p>Docker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。</p>\n<h3 id=\"实践建议：定期清理\"><a href=\"#实践建议：定期清理\" class=\"headerlink\" title=\"实践建议：定期清理\"></a>实践建议：定期清理</h3><p>定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的卷</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的网络</span></span><br><span class=\"line\">docker network prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志管理：忽视的存储负担\"><a href=\"#日志管理：忽视的存储负担\" class=\"headerlink\" title=\"日志管理：忽视的存储负担\"></a>日志管理：忽视的存储负担</h2><h3 id=\"日志驱动与存储策略\"><a href=\"#日志驱动与存储策略\" class=\"headerlink\" title=\"日志驱动与存储策略\"></a>日志驱动与存储策略</h3><p>Docker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。</p>\n<h3 id=\"实践建议：日志轮转与外部存储\"><a href=\"#实践建议：日志轮转与外部存储\" class=\"headerlink\" title=\"实践建议：日志轮转与外部存储\"></a>实践建议：日志轮转与外部存储</h3><p>配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>或者将日志发送到外部系统，如ELK堆栈：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gelf&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;gelf-address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;udp://logstash:12201&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。</p>\n<hr>\n<p>希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Docker已经成为现代软件开发中的一项关键技术，但在学习和使用过程中，许多新手开发者常常会遇到一些不易察觉的问题。本文将从一些不太常见的角度，探讨Docker背后的技术基础和实际应用中容易忽视的问题。</p>\n<p>开始本片文章之前默认读者已经对docker有了基本的认识，如果不是可以选择先出门右转<a href=\"https://www.runoob.com/docker/docker-tutorial.html\">Docker教程</a></p>\n<h2 id=\"为什么需要Docker\"><a href=\"#为什么需要Docker\" class=\"headerlink\" title=\"为什么需要Docker\"></a>为什么需要Docker</h2><p><img src=\"/blog/images/docker-1/multi-env.png\" alt=\"multi-envs\"><br>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自己的程序能在生产的服务器上跑起来？</p>\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 .net 应用，计算机必须有对应版本的.net运行时，还必须有各种依赖，可能还要配置环境变量。</p>\n<p>如果某些插件与当前环境不兼容，程序也没办法正常运行。这个时候开发常常会说：”它在我的机器上是正常的呀”，言下之意就是，其他机器很可能跑不了。</p>\n<p>环境配置如此麻烦，换一台机器，就要重来一次，费时费力。特别是很多企业级的应用，配置更是无比的复杂。这个时候就要想，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n<h2 id=\"虚拟机与容器：理解深层次差异\"><a href=\"#虚拟机与容器：理解深层次差异\" class=\"headerlink\" title=\"虚拟机与容器：理解深层次差异\"></a>虚拟机与容器：理解深层次差异</h2><h3 id=\"资源隔离与共享\"><a href=\"#资源隔离与共享\" class=\"headerlink\" title=\"资源隔离与共享\"></a>资源隔离与共享</h3><ul>\n<li>虚拟机：每个虚拟机运行一个完整的操作系统实例，资源隔离性强，但资源开销大。</li>\n<li>容器：容器共享主机操作系统的内核，通过名称空间和控制组（cgroups）实现资源隔离。这种方式极大地减少了资源开销，但也引发了一些隔离性不足的问题。</li>\n</ul>\n<h3 id=\"常见误区：容器的隔离性\"><a href=\"#常见误区：容器的隔离性\" class=\"headerlink\" title=\"常见误区：容器的隔离性\"></a>常见误区：容器的隔离性</h3><p>很多人认为容器与虚拟机一样，具有完全的隔离性。然而，容器的隔离性依赖于主机操作系统，如果主机内核存在漏洞，所有容器都可能受到影响。因此，在使用Docker时，保持主机系统和Docker引擎的更新至关重要。</p>\n<h2 id=\"文件系统与存储卷：隐形的性能瓶颈\"><a href=\"#文件系统与存储卷：隐形的性能瓶颈\" class=\"headerlink\" title=\"文件系统与存储卷：隐形的性能瓶颈\"></a>文件系统与存储卷：隐形的性能瓶颈</h2><h3 id=\"Union-File-System\"><a href=\"#Union-File-System\" class=\"headerlink\" title=\"Union File System\"></a>Union File System</h3><p>Docker镜像基于联合文件系统（UnionFS），如AUFS、OverlayFS等，允许镜像分层构建。这带来了便捷的同时，也可能引发性能问题。</p>\n<h3 id=\"联合文件系统的分层结构\"><a href=\"#联合文件系统的分层结构\" class=\"headerlink\" title=\"联合文件系统的分层结构\"></a>联合文件系统的分层结构</h3><p>联合文件系统通过将多个文件系统层联合在一起，呈现为一个单一文件系统。Docker镜像由多层只读层组成，每一层都是前一层的增量更新。容器启动时，Docker在镜像层的顶部添加一个可写层，这一层称为容器层。</p>\n<h3 id=\"分层文件系统与写操作\"><a href=\"#分层文件系统与写操作\" class=\"headerlink\" title=\"分层文件系统与写操作\"></a>分层文件系统与写操作</h3><p>在联合文件系统中，当进行写操作时，实际的写入发生在容器的可写层。如果写入的数据涉及到底层只读层的数据，系统会执行一个“写时复制”（Copy-on-Write，CoW）操作：</p>\n<ol>\n<li>读取原始文件：从只读层读取文件内容。</li>\n<li>复制到可写层：将读取的文件内容复制到可写层。</li>\n<li>修改文件：在可写层中修改文件内容。</li>\n</ol>\n<h3 id=\"性能下降的原因\"><a href=\"#性能下降的原因\" class=\"headerlink\" title=\"性能下降的原因\"></a>性能下降的原因</h3><ol>\n<li><p>写时复制操作<br>每次写操作都需要执行“写时复制”，这意味着每次写入一个文件时，必须先读取并复制该文件的内容到可写层，再进行修改。这一过程显著增加了I&#x2F;O操作的开销，尤其是在频繁写入或修改大量文件时。</p>\n</li>\n<li><p>层次结构复杂性<br>分层结构使得文件系统的元数据管理变得复杂。每一层都需要管理自己的文件和目录，当有大量写操作时，元数据的处理会成为性能瓶颈。</p>\n</li>\n<li><p>合并视图的开销<br>联合文件系统需要合并多个层的视图，以呈现给用户一个统一的文件系统视图。在频繁写操作的场景下，合并视图的开销也会显著增加。</p>\n</li>\n</ol>\n<h3 id=\"实际案例：大量文件写入操作\"><a href=\"#实际案例：大量文件写入操作\" class=\"headerlink\" title=\"实际案例：大量文件写入操作\"></a>实际案例：大量文件写入操作</h3><p>如果容器中的应用程序频繁进行大量文件写入操作，联合文件系统的分层结构可能导致性能下降。</p>\n<p>在这种情况下，使用Docker卷（Volume）来存储数据可以显著提升性能，因为卷直接挂载到主机文件系统，避免了分层开销。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile 示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> /app/data</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<p>在docker-compose.yml中配置卷挂载：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./data:/app/data</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络与安全：看不见的陷阱\"><a href=\"#网络与安全：看不见的陷阱\" class=\"headerlink\" title=\"网络与安全：看不见的陷阱\"></a>网络与安全：看不见的陷阱</h2><h3 id=\"网络模式选择\"><a href=\"#网络模式选择\" class=\"headerlink\" title=\"网络模式选择\"></a>网络模式选择</h3><p>Docker提供了多种网络模式：bridge、host、overlay等。不同模式适用于不同场景，但选择不当可能引发安全和性能问题。</p>\n<h3 id=\"安全隐患：默认桥接网络\"><a href=\"#安全隐患：默认桥接网络\" class=\"headerlink\" title=\"安全隐患：默认桥接网络\"></a>安全隐患：默认桥接网络</h3><p>默认的桥接网络模式容易遭受ARP欺骗攻击，因为所有容器共享同一个桥接网络。在生产环境中，建议使用用户自定义桥接网络或覆盖网络，并启用网络隔离。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建用户自定义桥接网络</span></span><br><span class=\"line\">docker network create --driver bridge my_bridge_network</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器时指定网络</span></span><br><span class=\"line\">docker run --network my_bridge_network my_app</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"镜像管理：隐形的资源浪费\"><a href=\"#镜像管理：隐形的资源浪费\" class=\"headerlink\" title=\"镜像管理：隐形的资源浪费\"></a>镜像管理：隐形的资源浪费</h2><h3 id=\"镜像层叠与大小控制\"><a href=\"#镜像层叠与大小控制\" class=\"headerlink\" title=\"镜像层叠与大小控制\"></a>镜像层叠与大小控制</h3><p>Docker镜像的分层结构可能导致镜像体积过大，尤其在频繁构建和更新镜像时。如果不注意清理，磁盘空间可能很快耗尽。</p>\n<h3 id=\"实践建议：定期清理\"><a href=\"#实践建议：定期清理\" class=\"headerlink\" title=\"实践建议：定期清理\"></a>实践建议：定期清理</h3><p>定期清理未使用的镜像、容器和卷，可以有效管理磁盘空间。使用以下命令清理无用资源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的卷</span></span><br><span class=\"line\">docker volume prune</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的网络</span></span><br><span class=\"line\">docker network prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日志管理：忽视的存储负担\"><a href=\"#日志管理：忽视的存储负担\" class=\"headerlink\" title=\"日志管理：忽视的存储负担\"></a>日志管理：忽视的存储负担</h2><h3 id=\"日志驱动与存储策略\"><a href=\"#日志驱动与存储策略\" class=\"headerlink\" title=\"日志驱动与存储策略\"></a>日志驱动与存储策略</h3><p>Docker默认将容器日志存储在主机文件系统中，这可能导致日志文件过大，影响系统性能。</p>\n<h3 id=\"实践建议：日志轮转与外部存储\"><a href=\"#实践建议：日志轮转与外部存储\" class=\"headerlink\" title=\"实践建议：日志轮转与外部存储\"></a>实践建议：日志轮转与外部存储</h3><p>配置Docker日志轮转策略或使用外部日志存储系统，可以有效管理日志文件大小。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>或者将日志发送到外部系统，如ELK堆栈：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;gelf&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;gelf-address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;udp://logstash:12201&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过深入探讨虚拟机与容器的差异、文件系统与存储卷的性能瓶颈、网络与安全的隐患、镜像管理的资源浪费以及日志管理的存储负担，我们希望帮助读者更全面地理解Docker背后的技术基础和实际应用中的常见问题。在后续的文章中，我们将继续探讨Docker的高级特性和优化策略，帮助你在实际项目中更好地应用这一强大的容器化技术。</p>\n<hr>\n<p>希望这篇文章能帮助你理解Docker背后的技术基础。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"Cursor平替：把 DeepSeek 接入 VS Code","date":"2025-02-12T01:50:46.000Z","_content":"提到春节最火热的两件事，一定是”哪吒“和”DeepSeek“了。\n![哪吒](./images/deepseek-2/hot.png)\n\n趁着这波热潮，作为开发人员的我们怎么利用上这波红利呢？\n\n提到AI代码编辑器就不得不提到Cursor，它不仅仅是一个开发环境（IDE），融合了最先进 AI 技术的智能助手。无论你是经验丰富的程序员，还是对编程一窍不通的普通用户，Cursor 都能为你带来前所未有的效率提升和创新可能。但是价格。。。\n\n![价格](./images/deepseek-2/price.png)\n\n而VS Code作为当下最流行的编辑器之一，提供了丰富的插件生态，可以让开发者轻松集成各种外部工具。今天，我们将介绍如何通过Roo Code插件将DeepSeek接入VS Code，助力开发者更高效地进行开发工作。\n\n# 什么是 Roo Code\nRoo Code (prev. Roo Cline) 是一个 VS Code 插件，旨在帮助开发人员更高效地进行代码导航、重构和代码操作。它的主要功能是增强代码编辑体验，特别是在类和方法的跳转、重命名以及快速定位方面提供帮助。\n\n以下是 Roo Code 插件的一些主要特点和功能：\n\n1. 智能代码导航：\n   - 支持快速跳转到类、方法或变量的定义。\n   - 提供返回和前进导航功能，让开发者可以在多个位置之间轻松跳转。\n\n2. 重构工具：\n   - 支持重命名类、方法、变量等代码元素，可以自动调整所有引用的位置，确保代码一致性。\n\n3. 代码片段：\n   - 提供代码片段功能，帮助开发者在常用代码模式中快速生成代码模板。\n\n4. 增强的代码补全：\n   - 提供智能提示，能够根据上下文提供更加精确的代码补全建议，提升编程效率。\n\n总的来说，Roo Code 是一个强大的辅助工具，特别适合那些需要频繁进行代码导航、重构和优化的开发人员。如果你正在使用 VS Code 进行日常开发工作，安装并配置这个插件能大大提高开发效率。\n\n# 安装 Roo Code 插件\n\n打开 VS Code。\n进入扩展市场（左侧栏的 Extensions 图标）。\n在搜索框中输入 \"Roo Code\"。\n![价格](./images/deepseek-2/search.png)\n点击 Install 按钮，安装插件。\n安装完成后，你将在 VS Code 的活动栏上看到一个 DeepSeek 图标，表示插件已成功安装。\n![价格](./images/deepseek-2/installed.png)\n可以看到插件迭代的非常快。\n\n# 配置 Roo Code\n## 申请 DeepSeek API 密钥\n在使用 DeepSeek 之前，你需要先在 DeepSeek 官网注册并获取 API 密钥。\n\n将复制的 API 密钥保存好，你将在后续的配置中使用它。\n![价格](./images/deepseek-2/apikeys.png)\n\n## 配置 Roo Code 插件\n打开 VS Code 设置（点击右下角齿轮图标，然后选择 \"Settings\"）。\n\n这里需要使用上面的 API 密钥。\n![价格](./images/deepseek-2/settings.png)\n\n# 使用 Roo Code 插件\n这里我新建了一个空项目，然后让DeepSeek帮我用python写一个简单的命令行的”2048小游戏“项目。\n![游戏](./images/deepseek-2/generating.gif)\n可以看到DeepSeek已经帮我写好了，并且还把这次对话产生的费用也返回给了我。\n![游戏](./images/deepseek-2/game1.png)\n\n下面我直接运行DeepSeek生成的代码，不做任何修改。不出意外的话，意外就要发生了。\n![错误](./images/deepseek-2/error.png)\n\n然后我直接把错误信息再次发给DeepSeek，让它帮我修改。\n![修改](./images/deepseek-2/feedback.png)\n可以看到DeepSeek已经帮我修改好了，并且还把这次对话产生的费用也返回给了我。\n\n再次运行修改后的代码，发现可以正常运行了。\n![运行](./images/deepseek-2/running.gif)\n整个过程可以说是非常的流畅。爽！\n\n# 总结\n将 DeepSeek 集成到 VS Code 中，不仅能让开发者更加方便地进行代码搜索和分析，还能有效提高开发效率。通过 VS Code 扩展与 DeepSeek 的结合，我们能够在熟悉的开发环境中直接使用强大的代码分析工具，从而提升开发体验。\n\n希望这篇文章能帮助你顺利将 DeepSeek 接入 VS Code，享受更高效的开发流程。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/deepseek-vscode.md","raw":"---\ntitle: Cursor平替：把 DeepSeek 接入 VS Code\ndate: 2025-02-12 09:50:46\ntags:\n---\n提到春节最火热的两件事，一定是”哪吒“和”DeepSeek“了。\n![哪吒](./images/deepseek-2/hot.png)\n\n趁着这波热潮，作为开发人员的我们怎么利用上这波红利呢？\n\n提到AI代码编辑器就不得不提到Cursor，它不仅仅是一个开发环境（IDE），融合了最先进 AI 技术的智能助手。无论你是经验丰富的程序员，还是对编程一窍不通的普通用户，Cursor 都能为你带来前所未有的效率提升和创新可能。但是价格。。。\n\n![价格](./images/deepseek-2/price.png)\n\n而VS Code作为当下最流行的编辑器之一，提供了丰富的插件生态，可以让开发者轻松集成各种外部工具。今天，我们将介绍如何通过Roo Code插件将DeepSeek接入VS Code，助力开发者更高效地进行开发工作。\n\n# 什么是 Roo Code\nRoo Code (prev. Roo Cline) 是一个 VS Code 插件，旨在帮助开发人员更高效地进行代码导航、重构和代码操作。它的主要功能是增强代码编辑体验，特别是在类和方法的跳转、重命名以及快速定位方面提供帮助。\n\n以下是 Roo Code 插件的一些主要特点和功能：\n\n1. 智能代码导航：\n   - 支持快速跳转到类、方法或变量的定义。\n   - 提供返回和前进导航功能，让开发者可以在多个位置之间轻松跳转。\n\n2. 重构工具：\n   - 支持重命名类、方法、变量等代码元素，可以自动调整所有引用的位置，确保代码一致性。\n\n3. 代码片段：\n   - 提供代码片段功能，帮助开发者在常用代码模式中快速生成代码模板。\n\n4. 增强的代码补全：\n   - 提供智能提示，能够根据上下文提供更加精确的代码补全建议，提升编程效率。\n\n总的来说，Roo Code 是一个强大的辅助工具，特别适合那些需要频繁进行代码导航、重构和优化的开发人员。如果你正在使用 VS Code 进行日常开发工作，安装并配置这个插件能大大提高开发效率。\n\n# 安装 Roo Code 插件\n\n打开 VS Code。\n进入扩展市场（左侧栏的 Extensions 图标）。\n在搜索框中输入 \"Roo Code\"。\n![价格](./images/deepseek-2/search.png)\n点击 Install 按钮，安装插件。\n安装完成后，你将在 VS Code 的活动栏上看到一个 DeepSeek 图标，表示插件已成功安装。\n![价格](./images/deepseek-2/installed.png)\n可以看到插件迭代的非常快。\n\n# 配置 Roo Code\n## 申请 DeepSeek API 密钥\n在使用 DeepSeek 之前，你需要先在 DeepSeek 官网注册并获取 API 密钥。\n\n将复制的 API 密钥保存好，你将在后续的配置中使用它。\n![价格](./images/deepseek-2/apikeys.png)\n\n## 配置 Roo Code 插件\n打开 VS Code 设置（点击右下角齿轮图标，然后选择 \"Settings\"）。\n\n这里需要使用上面的 API 密钥。\n![价格](./images/deepseek-2/settings.png)\n\n# 使用 Roo Code 插件\n这里我新建了一个空项目，然后让DeepSeek帮我用python写一个简单的命令行的”2048小游戏“项目。\n![游戏](./images/deepseek-2/generating.gif)\n可以看到DeepSeek已经帮我写好了，并且还把这次对话产生的费用也返回给了我。\n![游戏](./images/deepseek-2/game1.png)\n\n下面我直接运行DeepSeek生成的代码，不做任何修改。不出意外的话，意外就要发生了。\n![错误](./images/deepseek-2/error.png)\n\n然后我直接把错误信息再次发给DeepSeek，让它帮我修改。\n![修改](./images/deepseek-2/feedback.png)\n可以看到DeepSeek已经帮我修改好了，并且还把这次对话产生的费用也返回给了我。\n\n再次运行修改后的代码，发现可以正常运行了。\n![运行](./images/deepseek-2/running.gif)\n整个过程可以说是非常的流畅。爽！\n\n# 总结\n将 DeepSeek 集成到 VS Code 中，不仅能让开发者更加方便地进行代码搜索和分析，还能有效提高开发效率。通过 VS Code 扩展与 DeepSeek 的结合，我们能够在熟悉的开发环境中直接使用强大的代码分析工具，从而提升开发体验。\n\n希望这篇文章能帮助你顺利将 DeepSeek 接入 VS Code，享受更高效的开发流程。如果你有任何问题或建议，欢迎留言讨论！","slug":"deepseek-vscode","published":1,"updated":"2025-02-12T07:42:31.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfaw90005rkp16bd64ep5","content":"<p>提到春节最火热的两件事，一定是”哪吒“和”DeepSeek“了。<br><img src=\"/blog/./images/deepseek-2/hot.png\" alt=\"哪吒\"></p>\n<p>趁着这波热潮，作为开发人员的我们怎么利用上这波红利呢？</p>\n<p>提到AI代码编辑器就不得不提到Cursor，它不仅仅是一个开发环境（IDE），融合了最先进 AI 技术的智能助手。无论你是经验丰富的程序员，还是对编程一窍不通的普通用户，Cursor 都能为你带来前所未有的效率提升和创新可能。但是价格。。。</p>\n<p><img src=\"/blog/./images/deepseek-2/price.png\" alt=\"价格\"></p>\n<p>而VS Code作为当下最流行的编辑器之一，提供了丰富的插件生态，可以让开发者轻松集成各种外部工具。今天，我们将介绍如何通过Roo Code插件将DeepSeek接入VS Code，助力开发者更高效地进行开发工作。</p>\n<h1 id=\"什么是-Roo-Code\"><a href=\"#什么是-Roo-Code\" class=\"headerlink\" title=\"什么是 Roo Code\"></a>什么是 Roo Code</h1><p>Roo Code (prev. Roo Cline) 是一个 VS Code 插件，旨在帮助开发人员更高效地进行代码导航、重构和代码操作。它的主要功能是增强代码编辑体验，特别是在类和方法的跳转、重命名以及快速定位方面提供帮助。</p>\n<p>以下是 Roo Code 插件的一些主要特点和功能：</p>\n<ol>\n<li><p>智能代码导航：</p>\n<ul>\n<li>支持快速跳转到类、方法或变量的定义。</li>\n<li>提供返回和前进导航功能，让开发者可以在多个位置之间轻松跳转。</li>\n</ul>\n</li>\n<li><p>重构工具：</p>\n<ul>\n<li>支持重命名类、方法、变量等代码元素，可以自动调整所有引用的位置，确保代码一致性。</li>\n</ul>\n</li>\n<li><p>代码片段：</p>\n<ul>\n<li>提供代码片段功能，帮助开发者在常用代码模式中快速生成代码模板。</li>\n</ul>\n</li>\n<li><p>增强的代码补全：</p>\n<ul>\n<li>提供智能提示，能够根据上下文提供更加精确的代码补全建议，提升编程效率。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，Roo Code 是一个强大的辅助工具，特别适合那些需要频繁进行代码导航、重构和优化的开发人员。如果你正在使用 VS Code 进行日常开发工作，安装并配置这个插件能大大提高开发效率。</p>\n<h1 id=\"安装-Roo-Code-插件\"><a href=\"#安装-Roo-Code-插件\" class=\"headerlink\" title=\"安装 Roo Code 插件\"></a>安装 Roo Code 插件</h1><p>打开 VS Code。<br>进入扩展市场（左侧栏的 Extensions 图标）。<br>在搜索框中输入 “Roo Code”。<br><img src=\"/blog/./images/deepseek-2/search.png\" alt=\"价格\"><br>点击 Install 按钮，安装插件。<br>安装完成后，你将在 VS Code 的活动栏上看到一个 DeepSeek 图标，表示插件已成功安装。<br><img src=\"/blog/./images/deepseek-2/installed.png\" alt=\"价格\"><br>可以看到插件迭代的非常快。</p>\n<h1 id=\"配置-Roo-Code\"><a href=\"#配置-Roo-Code\" class=\"headerlink\" title=\"配置 Roo Code\"></a>配置 Roo Code</h1><h2 id=\"申请-DeepSeek-API-密钥\"><a href=\"#申请-DeepSeek-API-密钥\" class=\"headerlink\" title=\"申请 DeepSeek API 密钥\"></a>申请 DeepSeek API 密钥</h2><p>在使用 DeepSeek 之前，你需要先在 DeepSeek 官网注册并获取 API 密钥。</p>\n<p>将复制的 API 密钥保存好，你将在后续的配置中使用它。<br><img src=\"/blog/./images/deepseek-2/apikeys.png\" alt=\"价格\"></p>\n<h2 id=\"配置-Roo-Code-插件\"><a href=\"#配置-Roo-Code-插件\" class=\"headerlink\" title=\"配置 Roo Code 插件\"></a>配置 Roo Code 插件</h2><p>打开 VS Code 设置（点击右下角齿轮图标，然后选择 “Settings”）。</p>\n<p>这里需要使用上面的 API 密钥。<br><img src=\"/blog/./images/deepseek-2/settings.png\" alt=\"价格\"></p>\n<h1 id=\"使用-Roo-Code-插件\"><a href=\"#使用-Roo-Code-插件\" class=\"headerlink\" title=\"使用 Roo Code 插件\"></a>使用 Roo Code 插件</h1><p>这里我新建了一个空项目，然后让DeepSeek帮我用python写一个简单的命令行的”2048小游戏“项目。<br><img src=\"/blog/./images/deepseek-2/generating.gif\" alt=\"游戏\"><br>可以看到DeepSeek已经帮我写好了，并且还把这次对话产生的费用也返回给了我。<br><img src=\"/blog/./images/deepseek-2/game1.png\" alt=\"游戏\"></p>\n<p>下面我直接运行DeepSeek生成的代码，不做任何修改。不出意外的话，意外就要发生了。<br><img src=\"/blog/./images/deepseek-2/error.png\" alt=\"错误\"></p>\n<p>然后我直接把错误信息再次发给DeepSeek，让它帮我修改。<br><img src=\"/blog/./images/deepseek-2/feedback.png\" alt=\"修改\"><br>可以看到DeepSeek已经帮我修改好了，并且还把这次对话产生的费用也返回给了我。</p>\n<p>再次运行修改后的代码，发现可以正常运行了。<br><img src=\"/blog/./images/deepseek-2/running.gif\" alt=\"运行\"><br>整个过程可以说是非常的流畅。爽！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>将 DeepSeek 集成到 VS Code 中，不仅能让开发者更加方便地进行代码搜索和分析，还能有效提高开发效率。通过 VS Code 扩展与 DeepSeek 的结合，我们能够在熟悉的开发环境中直接使用强大的代码分析工具，从而提升开发体验。</p>\n<p>希望这篇文章能帮助你顺利将 DeepSeek 接入 VS Code，享受更高效的开发流程。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>提到春节最火热的两件事，一定是”哪吒“和”DeepSeek“了。<br><img src=\"/blog/./images/deepseek-2/hot.png\" alt=\"哪吒\"></p>\n<p>趁着这波热潮，作为开发人员的我们怎么利用上这波红利呢？</p>\n<p>提到AI代码编辑器就不得不提到Cursor，它不仅仅是一个开发环境（IDE），融合了最先进 AI 技术的智能助手。无论你是经验丰富的程序员，还是对编程一窍不通的普通用户，Cursor 都能为你带来前所未有的效率提升和创新可能。但是价格。。。</p>\n<p><img src=\"/blog/./images/deepseek-2/price.png\" alt=\"价格\"></p>\n<p>而VS Code作为当下最流行的编辑器之一，提供了丰富的插件生态，可以让开发者轻松集成各种外部工具。今天，我们将介绍如何通过Roo Code插件将DeepSeek接入VS Code，助力开发者更高效地进行开发工作。</p>\n<h1 id=\"什么是-Roo-Code\"><a href=\"#什么是-Roo-Code\" class=\"headerlink\" title=\"什么是 Roo Code\"></a>什么是 Roo Code</h1><p>Roo Code (prev. Roo Cline) 是一个 VS Code 插件，旨在帮助开发人员更高效地进行代码导航、重构和代码操作。它的主要功能是增强代码编辑体验，特别是在类和方法的跳转、重命名以及快速定位方面提供帮助。</p>\n<p>以下是 Roo Code 插件的一些主要特点和功能：</p>\n<ol>\n<li><p>智能代码导航：</p>\n<ul>\n<li>支持快速跳转到类、方法或变量的定义。</li>\n<li>提供返回和前进导航功能，让开发者可以在多个位置之间轻松跳转。</li>\n</ul>\n</li>\n<li><p>重构工具：</p>\n<ul>\n<li>支持重命名类、方法、变量等代码元素，可以自动调整所有引用的位置，确保代码一致性。</li>\n</ul>\n</li>\n<li><p>代码片段：</p>\n<ul>\n<li>提供代码片段功能，帮助开发者在常用代码模式中快速生成代码模板。</li>\n</ul>\n</li>\n<li><p>增强的代码补全：</p>\n<ul>\n<li>提供智能提示，能够根据上下文提供更加精确的代码补全建议，提升编程效率。</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，Roo Code 是一个强大的辅助工具，特别适合那些需要频繁进行代码导航、重构和优化的开发人员。如果你正在使用 VS Code 进行日常开发工作，安装并配置这个插件能大大提高开发效率。</p>\n<h1 id=\"安装-Roo-Code-插件\"><a href=\"#安装-Roo-Code-插件\" class=\"headerlink\" title=\"安装 Roo Code 插件\"></a>安装 Roo Code 插件</h1><p>打开 VS Code。<br>进入扩展市场（左侧栏的 Extensions 图标）。<br>在搜索框中输入 “Roo Code”。<br><img src=\"/blog/./images/deepseek-2/search.png\" alt=\"价格\"><br>点击 Install 按钮，安装插件。<br>安装完成后，你将在 VS Code 的活动栏上看到一个 DeepSeek 图标，表示插件已成功安装。<br><img src=\"/blog/./images/deepseek-2/installed.png\" alt=\"价格\"><br>可以看到插件迭代的非常快。</p>\n<h1 id=\"配置-Roo-Code\"><a href=\"#配置-Roo-Code\" class=\"headerlink\" title=\"配置 Roo Code\"></a>配置 Roo Code</h1><h2 id=\"申请-DeepSeek-API-密钥\"><a href=\"#申请-DeepSeek-API-密钥\" class=\"headerlink\" title=\"申请 DeepSeek API 密钥\"></a>申请 DeepSeek API 密钥</h2><p>在使用 DeepSeek 之前，你需要先在 DeepSeek 官网注册并获取 API 密钥。</p>\n<p>将复制的 API 密钥保存好，你将在后续的配置中使用它。<br><img src=\"/blog/./images/deepseek-2/apikeys.png\" alt=\"价格\"></p>\n<h2 id=\"配置-Roo-Code-插件\"><a href=\"#配置-Roo-Code-插件\" class=\"headerlink\" title=\"配置 Roo Code 插件\"></a>配置 Roo Code 插件</h2><p>打开 VS Code 设置（点击右下角齿轮图标，然后选择 “Settings”）。</p>\n<p>这里需要使用上面的 API 密钥。<br><img src=\"/blog/./images/deepseek-2/settings.png\" alt=\"价格\"></p>\n<h1 id=\"使用-Roo-Code-插件\"><a href=\"#使用-Roo-Code-插件\" class=\"headerlink\" title=\"使用 Roo Code 插件\"></a>使用 Roo Code 插件</h1><p>这里我新建了一个空项目，然后让DeepSeek帮我用python写一个简单的命令行的”2048小游戏“项目。<br><img src=\"/blog/./images/deepseek-2/generating.gif\" alt=\"游戏\"><br>可以看到DeepSeek已经帮我写好了，并且还把这次对话产生的费用也返回给了我。<br><img src=\"/blog/./images/deepseek-2/game1.png\" alt=\"游戏\"></p>\n<p>下面我直接运行DeepSeek生成的代码，不做任何修改。不出意外的话，意外就要发生了。<br><img src=\"/blog/./images/deepseek-2/error.png\" alt=\"错误\"></p>\n<p>然后我直接把错误信息再次发给DeepSeek，让它帮我修改。<br><img src=\"/blog/./images/deepseek-2/feedback.png\" alt=\"修改\"><br>可以看到DeepSeek已经帮我修改好了，并且还把这次对话产生的费用也返回给了我。</p>\n<p>再次运行修改后的代码，发现可以正常运行了。<br><img src=\"/blog/./images/deepseek-2/running.gif\" alt=\"运行\"><br>整个过程可以说是非常的流畅。爽！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>将 DeepSeek 集成到 VS Code 中，不仅能让开发者更加方便地进行代码搜索和分析，还能有效提高开发效率。通过 VS Code 扩展与 DeepSeek 的结合，我们能够在熟悉的开发环境中直接使用强大的代码分析工具，从而提升开发体验。</p>\n<p>希望这篇文章能帮助你顺利将 DeepSeek 接入 VS Code，享受更高效的开发流程。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"DeepSeek + RAG： 让大模型更智能、更精准","date":"2025-03-14T08:10:51.000Z","_content":"\n\n在大模型应用中，**如何保证答案的准确性和实时性** 一直是一个难题。尽管 LLM（Large Language Models）具有强大的生成能力，但它们的知识存在 **时间局限性**，并且容易产生“幻觉”（hallucination）。为了解决这些问题，**RAG（检索增强生成）** 方案应运而生，在 RAG（检索增强生成）中，检索机制负责获取相关信息，而 LLM 负责生成最终答案。**DeepSeek** 作为国内领先的大模型之一，可以在 RAG 体系中作为生成部分，为检索增强的上下文提供自然、准确的回答。本文将带你了解 DeepSeek 与 RAG 的结合，并提供代码示例。\n\n---\n\n## ** 什么是 RAG（检索增强生成）？**\n\n**RAG（Retrieval-Augmented Generation）** 是一种将 **信息检索（Retrieval）** 与 **大模型生成（Generation）** 结合的技术，主要分为 **两步：**\n\n1. **检索（Retrieve）**: 在外部知识库（如文档数据库、向量数据库）中找到与用户问题相关的信息。\n2. **生成（Generate）**: 将检索到的内容作为上下文输入给大模型，提高回答的准确性。\n\n**优点：**\n- 让 LLM 能够利用**最新的**外部知识，不再局限于训练数据。\n- 降低 LLM **胡编乱造（幻觉）** 的概率。\n- 提供**可验证的答案来源**，提高可靠性。\n\n![hallucination](./images/deepseek-rag/hallucination.png)\n\n---\n\n## ** 为什么选择 DeepSeek 作为 RAG 模型？**\n\n[DeepSeek](https://deepseek.com/) 是一个强大的国产 LLM，具备以下特点：\n- **支持中文优化**，相比 GPT-4/Claude，在中文场景下表现更佳。\n- **更开放的 API**，可以免费试用，并且提供了本地部署版本。\n- **模型能力强**，支持 **代码、数学推理、知识问答等任务**，适合 RAG 场景。\n\n此外，DeepSeek 提供 **DeepSeek-VL（视觉+文本）** 以及 **DeepSeek-Coder（代码生成）** 版本，使其在 **技术文档问答、代码辅助、金融分析等领域** 表现优异。当然最重要的一点是，DeepSeek 是 **开源** 的，这意味着你可以在本地部署它，并且可以根据自己的需求进行定制。谁能拒绝白嫖呢？![DeepSeek](./images/deepseek-rag/baipiao.jpg)\n\n---\n\n## ** 如何实现 DeepSeek + RAG？**\n\n我们可以结合 **DeepSeek + Qdrant 向量数据库** 来实现一个简单的 RAG 系统：\n\n前置条件：\n- 本地部署ollama。\n- ollama运行DeepSeek。\n- 一个 Qdrant 实例。\n\n> 对于部署以上环境部署有疑问的老铁可以参考老夫之前的介绍\n>\n> [《DeepSeek 本地部署+web端访问 指南》](https://mp.weixin.qq.com/s/EmNzMrH1L52IWcEdROWehQ)\n> \n> [《Qdrant：开启高效相似性搜索的先锋》](https://mp.weixin.qq.com/s/vrwbpo3cUrSKN1OX9LjgOw)\n\n### **架构**\n\n1. **数据预处理**：\n   - 将文档（如 PDF、网页）分割成小段，并向量化存储。\n2. **用户输入查询**：\n   - 计算输入问题的向量，并检索相似的文档片段。\n3. **DeepSeek 生成回答**：\n   - 将检索到的文档片段和用户问题一起输入 DeepSeek，生成最终答案。\n\n![架构](./images/deepseek-rag/RAG-system-architecture.png)\n\n### **代码实现**\n\n这里我们使用 `Qdrant` 作为向量数据库，并结合 `DeepSeek` 进行 RAG 任务。\n\n#### **安装依赖**\n\n```bash\npip install qdrant-client openai tiktoken\n```\n\n#### **1️⃣ 数据预处理（文本向量化 + 存入 Qdrant）**\n\n```python\nimport Qdrant\nimport numpy as np\nfrom openai import OpenAI\n\n# 配置参数\nCOLLECTION_NAME = \"deepseek_rag\"\nQDRANT_URL = \"http://localhost:6333\"\n\n# 连接 Qdrant\nclient = QdrantClient(QDRANT_URL)\nollamaClient = ollama.Client(host=\"http://127.0.0.1:11434\")\n\n# 假设我们有一些文本需要存入 Qdrant\ndocs = [\n        \"DeepSeek 是一个强大的大模型，支持代码生成和中文优化。\",\n        \"RAG 是结合检索与生成的技术，能够提升大模型回答的准确性。\",\n        \"Qdrant 是一个高效的向量数据库，适用于大规模检索。\",\n        \"ITProHub是一个致力于信息技术领域，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训的社区交流平台。\",\n]\n\n# 向量化\ndoc_vectors = []\nfor doc in docs:\n     \"\"\" 使用本地 Ollama 计算文本嵌入向量 \"\"\"\n    response = ollamaClient.embeddings(model=\"mxbai-embed-large\", prompt=text)\n    vector = response.embeddingresponse.data[0].embedding\n    doc_vectors.append(vector)\n\n# 存入 Qdrant\npoints = [\n    PointStruct(id=i, vector=vectors[i], payload={\"text\": docs[i]})\n    for i in range(len(docs))\n]\nclient.upsert(collection_name=COLLECTION_NAME, points=points)\nprint(f\"📥 已存入 {len(docs)} 篇文档\")\n```\n\n#### **2️⃣ 用户查询 + 向量检索**\n\n```python\ndef retrieve_similar_docs(query, top_k=2):\n    \"\"\" 从 Qdrant 中检索与查询最相似的文档 \"\"\"\n    query_vector = get_embedding(query)\n    search_result = client.search(\n        collection_name=COLLECTION_NAME, query_vector=query_vector, limit=top_k\n    )\n    return [hit.payload[\"text\"] for hit in search_result]\n\n# 示例查询\nquery = \"你知道ITProHub么？\"\nretrieved_docs = retrieve_similar_docs(query)\nprint(\"检索到的相关文档：\", retrieved_docs)\n```\n\n#### **3️⃣ DeepSeek 生成答案**\n\n```python\ndef generate_answer(query, retrieved_docs):\n    \"\"\" 使用 DeepSeek 结合检索内容生成答案 \"\"\"\n    context = \"\\n\".join(retrieved_docs)\n    prompt = f\"根据以下信息回答用户问题：\\n{context}\\n\\n用户问题：{query}\"\n\n    response = ollamaClient.chat(\n        model=\"deepseek-r1:1.5b\",\n        messages=[{\"role\": \"user\", \"content\": prompt}],\n    )\n    return response[\"message\"][\"content\"]\n\n# 生成答案\nfinal_answer = generate_answer(query, retrieved_docs)\nprint(\"DeepSeek 生成的答案：\", final_answer)\n```\n\n#### ** 4️⃣ 看看效果**\n\n1. 原始搜索结果\n提出问题：\"你知道ITProHub?\" 显然在原始模型的数据里面是没有关于本公众号的任何信息的，所以你可以看到deepseek针对这个问题开始胡言乱语了\n![效果](./images/deepseek-rag/raw-result.png)\n可以看到针对 `ITProHub` 这个问题，原始的模型并不知道是啥。\n2. 接入RAG之后的效果\n接入RAG之后，模型可以根据检索到的内容，生成更准确的答案。\n![效果](./images/deepseek-rag/rag-result.png)\n---\n\n## **4. 典型应用场景**\n\n1. **企业知识库问答**（客户支持、内部文档搜索）\n2. **AIOps**（通过 RAG，结合实时运维数据，快速定位和分析故障原因）\n3. **代码辅助**（自动补全、代码文档解析）\n4. **学术研究**（查询特定文献，生成摘要）\n\n---\n\n## **5. 总结**\n\nRAG 作为一种 **结合外部知识和大模型的增强技术**，极大提高了回答的**准确性和可解释性**。DeepSeek 作为国产 LLM，在 **中文优化、API 兼容性、代码生成能力** 方面有独特优势，适合作为 RAG 系统的核心组件。\n\n**未来，我们可以探索更多优化方案，比如：**\n- **结合 LlamaIndex / LangChain** 进行更复杂的检索。\n- **使用 Milvus / Weaviate** 等更强大的向量数据库。\n- **本地化部署 DeepSeek**，提升数据安全性。\n\n如果你对 RAG 和 DeepSeek 感兴趣，可以尝试在自己的项目中落地应用，让 AI 变得更智能、更可靠！🚀\n完整示例代码可访问老夫的[GitHub](https://github.com/ItProHub/rag)\n\n","source":"_posts/deepseek-rag.md","raw":"---\ntitle: DeepSeek + RAG： 让大模型更智能、更精准\ndate: 2025-03-14 16:10:51\ntags:\n---\n\n\n在大模型应用中，**如何保证答案的准确性和实时性** 一直是一个难题。尽管 LLM（Large Language Models）具有强大的生成能力，但它们的知识存在 **时间局限性**，并且容易产生“幻觉”（hallucination）。为了解决这些问题，**RAG（检索增强生成）** 方案应运而生，在 RAG（检索增强生成）中，检索机制负责获取相关信息，而 LLM 负责生成最终答案。**DeepSeek** 作为国内领先的大模型之一，可以在 RAG 体系中作为生成部分，为检索增强的上下文提供自然、准确的回答。本文将带你了解 DeepSeek 与 RAG 的结合，并提供代码示例。\n\n---\n\n## ** 什么是 RAG（检索增强生成）？**\n\n**RAG（Retrieval-Augmented Generation）** 是一种将 **信息检索（Retrieval）** 与 **大模型生成（Generation）** 结合的技术，主要分为 **两步：**\n\n1. **检索（Retrieve）**: 在外部知识库（如文档数据库、向量数据库）中找到与用户问题相关的信息。\n2. **生成（Generate）**: 将检索到的内容作为上下文输入给大模型，提高回答的准确性。\n\n**优点：**\n- 让 LLM 能够利用**最新的**外部知识，不再局限于训练数据。\n- 降低 LLM **胡编乱造（幻觉）** 的概率。\n- 提供**可验证的答案来源**，提高可靠性。\n\n![hallucination](./images/deepseek-rag/hallucination.png)\n\n---\n\n## ** 为什么选择 DeepSeek 作为 RAG 模型？**\n\n[DeepSeek](https://deepseek.com/) 是一个强大的国产 LLM，具备以下特点：\n- **支持中文优化**，相比 GPT-4/Claude，在中文场景下表现更佳。\n- **更开放的 API**，可以免费试用，并且提供了本地部署版本。\n- **模型能力强**，支持 **代码、数学推理、知识问答等任务**，适合 RAG 场景。\n\n此外，DeepSeek 提供 **DeepSeek-VL（视觉+文本）** 以及 **DeepSeek-Coder（代码生成）** 版本，使其在 **技术文档问答、代码辅助、金融分析等领域** 表现优异。当然最重要的一点是，DeepSeek 是 **开源** 的，这意味着你可以在本地部署它，并且可以根据自己的需求进行定制。谁能拒绝白嫖呢？![DeepSeek](./images/deepseek-rag/baipiao.jpg)\n\n---\n\n## ** 如何实现 DeepSeek + RAG？**\n\n我们可以结合 **DeepSeek + Qdrant 向量数据库** 来实现一个简单的 RAG 系统：\n\n前置条件：\n- 本地部署ollama。\n- ollama运行DeepSeek。\n- 一个 Qdrant 实例。\n\n> 对于部署以上环境部署有疑问的老铁可以参考老夫之前的介绍\n>\n> [《DeepSeek 本地部署+web端访问 指南》](https://mp.weixin.qq.com/s/EmNzMrH1L52IWcEdROWehQ)\n> \n> [《Qdrant：开启高效相似性搜索的先锋》](https://mp.weixin.qq.com/s/vrwbpo3cUrSKN1OX9LjgOw)\n\n### **架构**\n\n1. **数据预处理**：\n   - 将文档（如 PDF、网页）分割成小段，并向量化存储。\n2. **用户输入查询**：\n   - 计算输入问题的向量，并检索相似的文档片段。\n3. **DeepSeek 生成回答**：\n   - 将检索到的文档片段和用户问题一起输入 DeepSeek，生成最终答案。\n\n![架构](./images/deepseek-rag/RAG-system-architecture.png)\n\n### **代码实现**\n\n这里我们使用 `Qdrant` 作为向量数据库，并结合 `DeepSeek` 进行 RAG 任务。\n\n#### **安装依赖**\n\n```bash\npip install qdrant-client openai tiktoken\n```\n\n#### **1️⃣ 数据预处理（文本向量化 + 存入 Qdrant）**\n\n```python\nimport Qdrant\nimport numpy as np\nfrom openai import OpenAI\n\n# 配置参数\nCOLLECTION_NAME = \"deepseek_rag\"\nQDRANT_URL = \"http://localhost:6333\"\n\n# 连接 Qdrant\nclient = QdrantClient(QDRANT_URL)\nollamaClient = ollama.Client(host=\"http://127.0.0.1:11434\")\n\n# 假设我们有一些文本需要存入 Qdrant\ndocs = [\n        \"DeepSeek 是一个强大的大模型，支持代码生成和中文优化。\",\n        \"RAG 是结合检索与生成的技术，能够提升大模型回答的准确性。\",\n        \"Qdrant 是一个高效的向量数据库，适用于大规模检索。\",\n        \"ITProHub是一个致力于信息技术领域，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训的社区交流平台。\",\n]\n\n# 向量化\ndoc_vectors = []\nfor doc in docs:\n     \"\"\" 使用本地 Ollama 计算文本嵌入向量 \"\"\"\n    response = ollamaClient.embeddings(model=\"mxbai-embed-large\", prompt=text)\n    vector = response.embeddingresponse.data[0].embedding\n    doc_vectors.append(vector)\n\n# 存入 Qdrant\npoints = [\n    PointStruct(id=i, vector=vectors[i], payload={\"text\": docs[i]})\n    for i in range(len(docs))\n]\nclient.upsert(collection_name=COLLECTION_NAME, points=points)\nprint(f\"📥 已存入 {len(docs)} 篇文档\")\n```\n\n#### **2️⃣ 用户查询 + 向量检索**\n\n```python\ndef retrieve_similar_docs(query, top_k=2):\n    \"\"\" 从 Qdrant 中检索与查询最相似的文档 \"\"\"\n    query_vector = get_embedding(query)\n    search_result = client.search(\n        collection_name=COLLECTION_NAME, query_vector=query_vector, limit=top_k\n    )\n    return [hit.payload[\"text\"] for hit in search_result]\n\n# 示例查询\nquery = \"你知道ITProHub么？\"\nretrieved_docs = retrieve_similar_docs(query)\nprint(\"检索到的相关文档：\", retrieved_docs)\n```\n\n#### **3️⃣ DeepSeek 生成答案**\n\n```python\ndef generate_answer(query, retrieved_docs):\n    \"\"\" 使用 DeepSeek 结合检索内容生成答案 \"\"\"\n    context = \"\\n\".join(retrieved_docs)\n    prompt = f\"根据以下信息回答用户问题：\\n{context}\\n\\n用户问题：{query}\"\n\n    response = ollamaClient.chat(\n        model=\"deepseek-r1:1.5b\",\n        messages=[{\"role\": \"user\", \"content\": prompt}],\n    )\n    return response[\"message\"][\"content\"]\n\n# 生成答案\nfinal_answer = generate_answer(query, retrieved_docs)\nprint(\"DeepSeek 生成的答案：\", final_answer)\n```\n\n#### ** 4️⃣ 看看效果**\n\n1. 原始搜索结果\n提出问题：\"你知道ITProHub?\" 显然在原始模型的数据里面是没有关于本公众号的任何信息的，所以你可以看到deepseek针对这个问题开始胡言乱语了\n![效果](./images/deepseek-rag/raw-result.png)\n可以看到针对 `ITProHub` 这个问题，原始的模型并不知道是啥。\n2. 接入RAG之后的效果\n接入RAG之后，模型可以根据检索到的内容，生成更准确的答案。\n![效果](./images/deepseek-rag/rag-result.png)\n---\n\n## **4. 典型应用场景**\n\n1. **企业知识库问答**（客户支持、内部文档搜索）\n2. **AIOps**（通过 RAG，结合实时运维数据，快速定位和分析故障原因）\n3. **代码辅助**（自动补全、代码文档解析）\n4. **学术研究**（查询特定文献，生成摘要）\n\n---\n\n## **5. 总结**\n\nRAG 作为一种 **结合外部知识和大模型的增强技术**，极大提高了回答的**准确性和可解释性**。DeepSeek 作为国产 LLM，在 **中文优化、API 兼容性、代码生成能力** 方面有独特优势，适合作为 RAG 系统的核心组件。\n\n**未来，我们可以探索更多优化方案，比如：**\n- **结合 LlamaIndex / LangChain** 进行更复杂的检索。\n- **使用 Milvus / Weaviate** 等更强大的向量数据库。\n- **本地化部署 DeepSeek**，提升数据安全性。\n\n如果你对 RAG 和 DeepSeek 感兴趣，可以尝试在自己的项目中落地应用，让 AI 变得更智能、更可靠！🚀\n完整示例代码可访问老夫的[GitHub](https://github.com/ItProHub/rag)\n\n","slug":"deepseek-rag","published":1,"updated":"2025-03-18T03:10:22.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawa0006rkp1f7ajfy1r","content":"<p>在大模型应用中，<strong>如何保证答案的准确性和实时性</strong> 一直是一个难题。尽管 LLM（Large Language Models）具有强大的生成能力，但它们的知识存在 <strong>时间局限性</strong>，并且容易产生“幻觉”（hallucination）。为了解决这些问题，<strong>RAG（检索增强生成）</strong> 方案应运而生，在 RAG（检索增强生成）中，检索机制负责获取相关信息，而 LLM 负责生成最终答案。<strong>DeepSeek</strong> 作为国内领先的大模型之一，可以在 RAG 体系中作为生成部分，为检索增强的上下文提供自然、准确的回答。本文将带你了解 DeepSeek 与 RAG 的结合，并提供代码示例。</p>\n<hr>\n<h2 id=\"什么是-RAG（检索增强生成）？\"><a href=\"#什么是-RAG（检索增强生成）？\" class=\"headerlink\" title=\"** 什么是 RAG（检索增强生成）？**\"></a>** 什么是 RAG（检索增强生成）？**</h2><p><strong>RAG（Retrieval-Augmented Generation）</strong> 是一种将 <strong>信息检索（Retrieval）</strong> 与 <strong>大模型生成（Generation）</strong> 结合的技术，主要分为 <strong>两步：</strong></p>\n<ol>\n<li><strong>检索（Retrieve）</strong>: 在外部知识库（如文档数据库、向量数据库）中找到与用户问题相关的信息。</li>\n<li><strong>生成（Generate）</strong>: 将检索到的内容作为上下文输入给大模型，提高回答的准确性。</li>\n</ol>\n<p><strong>优点：</strong></p>\n<ul>\n<li>让 LLM 能够利用<strong>最新的</strong>外部知识，不再局限于训练数据。</li>\n<li>降低 LLM <strong>胡编乱造（幻觉）</strong> 的概率。</li>\n<li>提供<strong>可验证的答案来源</strong>，提高可靠性。</li>\n</ul>\n<p><img src=\"/blog/./images/deepseek-rag/hallucination.png\" alt=\"hallucination\"></p>\n<hr>\n<h2 id=\"为什么选择-DeepSeek-作为-RAG-模型？\"><a href=\"#为什么选择-DeepSeek-作为-RAG-模型？\" class=\"headerlink\" title=\"** 为什么选择 DeepSeek 作为 RAG 模型？**\"></a>** 为什么选择 DeepSeek 作为 RAG 模型？**</h2><p><a href=\"https://deepseek.com/\">DeepSeek</a> 是一个强大的国产 LLM，具备以下特点：</p>\n<ul>\n<li><strong>支持中文优化</strong>，相比 GPT-4&#x2F;Claude，在中文场景下表现更佳。</li>\n<li><strong>更开放的 API</strong>，可以免费试用，并且提供了本地部署版本。</li>\n<li><strong>模型能力强</strong>，支持 <strong>代码、数学推理、知识问答等任务</strong>，适合 RAG 场景。</li>\n</ul>\n<p>此外，DeepSeek 提供 <strong>DeepSeek-VL（视觉+文本）</strong> 以及 <strong>DeepSeek-Coder（代码生成）</strong> 版本，使其在 <strong>技术文档问答、代码辅助、金融分析等领域</strong> 表现优异。当然最重要的一点是，DeepSeek 是 <strong>开源</strong> 的，这意味着你可以在本地部署它，并且可以根据自己的需求进行定制。谁能拒绝白嫖呢？<img src=\"/blog/./images/deepseek-rag/baipiao.jpg\" alt=\"DeepSeek\"></p>\n<hr>\n<h2 id=\"如何实现-DeepSeek-RAG？\"><a href=\"#如何实现-DeepSeek-RAG？\" class=\"headerlink\" title=\"** 如何实现 DeepSeek + RAG？**\"></a>** 如何实现 DeepSeek + RAG？**</h2><p>我们可以结合 <strong>DeepSeek + Qdrant 向量数据库</strong> 来实现一个简单的 RAG 系统：</p>\n<p>前置条件：</p>\n<ul>\n<li>本地部署ollama。</li>\n<li>ollama运行DeepSeek。</li>\n<li>一个 Qdrant 实例。</li>\n</ul>\n<blockquote>\n<p>对于部署以上环境部署有疑问的老铁可以参考老夫之前的介绍</p>\n<p><a href=\"https://mp.weixin.qq.com/s/EmNzMrH1L52IWcEdROWehQ\">《DeepSeek 本地部署+web端访问 指南》</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/vrwbpo3cUrSKN1OX9LjgOw\">《Qdrant：开启高效相似性搜索的先锋》</a></p>\n</blockquote>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a><strong>架构</strong></h3><ol>\n<li><strong>数据预处理</strong>：<ul>\n<li>将文档（如 PDF、网页）分割成小段，并向量化存储。</li>\n</ul>\n</li>\n<li><strong>用户输入查询</strong>：<ul>\n<li>计算输入问题的向量，并检索相似的文档片段。</li>\n</ul>\n</li>\n<li><strong>DeepSeek 生成回答</strong>：<ul>\n<li>将检索到的文档片段和用户问题一起输入 DeepSeek，生成最终答案。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/blog/./images/deepseek-rag/RAG-system-architecture.png\" alt=\"架构\"></p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h3><p>这里我们使用 <code>Qdrant</code> 作为向量数据库，并结合 <code>DeepSeek</code> 进行 RAG 任务。</p>\n<h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a><strong>安装依赖</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install qdrant-client openai tiktoken</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1️⃣-数据预处理（文本向量化-存入-Qdrant）\"><a href=\"#1️⃣-数据预处理（文本向量化-存入-Qdrant）\" class=\"headerlink\" title=\"1️⃣ 数据预处理（文本向量化 + 存入 Qdrant）\"></a><strong>1️⃣ 数据预处理（文本向量化 + 存入 Qdrant）</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Qdrant</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> openai <span class=\"keyword\">import</span> OpenAI</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置参数</span></span><br><span class=\"line\">COLLECTION_NAME = <span class=\"string\">&quot;deepseek_rag&quot;</span></span><br><span class=\"line\">QDRANT_URL = <span class=\"string\">&quot;http://localhost:6333&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连接 Qdrant</span></span><br><span class=\"line\">client = QdrantClient(QDRANT_URL)</span><br><span class=\"line\">ollamaClient = ollama.Client(host=<span class=\"string\">&quot;http://127.0.0.1:11434&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 假设我们有一些文本需要存入 Qdrant</span></span><br><span class=\"line\">docs = [</span><br><span class=\"line\">        <span class=\"string\">&quot;DeepSeek 是一个强大的大模型，支持代码生成和中文优化。&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;RAG 是结合检索与生成的技术，能够提升大模型回答的准确性。&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Qdrant 是一个高效的向量数据库，适用于大规模检索。&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ITProHub是一个致力于信息技术领域，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训的社区交流平台。&quot;</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 向量化</span></span><br><span class=\"line\">doc_vectors = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> doc <span class=\"keyword\">in</span> docs:</span><br><span class=\"line\">     <span class=\"string\">&quot;&quot;&quot; 使用本地 Ollama 计算文本嵌入向量 &quot;&quot;&quot;</span></span><br><span class=\"line\">    response = ollamaClient.embeddings(model=<span class=\"string\">&quot;mxbai-embed-large&quot;</span>, prompt=text)</span><br><span class=\"line\">    vector = response.embeddingresponse.data[<span class=\"number\">0</span>].embedding</span><br><span class=\"line\">    doc_vectors.append(vector)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存入 Qdrant</span></span><br><span class=\"line\">points = [</span><br><span class=\"line\">    PointStruct(<span class=\"built_in\">id</span>=i, vector=vectors[i], payload=&#123;<span class=\"string\">&quot;text&quot;</span>: docs[i]&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(docs))</span><br><span class=\"line\">]</span><br><span class=\"line\">client.upsert(collection_name=COLLECTION_NAME, points=points)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;📥 已存入 <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(docs)&#125;</span> 篇文档&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2️⃣-用户查询-向量检索\"><a href=\"#2️⃣-用户查询-向量检索\" class=\"headerlink\" title=\"2️⃣ 用户查询 + 向量检索\"></a><strong>2️⃣ 用户查询 + 向量检索</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">retrieve_similar_docs</span>(<span class=\"params\">query, top_k=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot; 从 Qdrant 中检索与查询最相似的文档 &quot;&quot;&quot;</span></span><br><span class=\"line\">    query_vector = get_embedding(query)</span><br><span class=\"line\">    search_result = client.search(</span><br><span class=\"line\">        collection_name=COLLECTION_NAME, query_vector=query_vector, limit=top_k</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [hit.payload[<span class=\"string\">&quot;text&quot;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例查询</span></span><br><span class=\"line\">query = <span class=\"string\">&quot;你知道ITProHub么？&quot;</span></span><br><span class=\"line\">retrieved_docs = retrieve_similar_docs(query)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;检索到的相关文档：&quot;</span>, retrieved_docs)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3️⃣-DeepSeek-生成答案\"><a href=\"#3️⃣-DeepSeek-生成答案\" class=\"headerlink\" title=\"3️⃣ DeepSeek 生成答案\"></a><strong>3️⃣ DeepSeek 生成答案</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generate_answer</span>(<span class=\"params\">query, retrieved_docs</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot; 使用 DeepSeek 结合检索内容生成答案 &quot;&quot;&quot;</span></span><br><span class=\"line\">    context = <span class=\"string\">&quot;\\n&quot;</span>.join(retrieved_docs)</span><br><span class=\"line\">    prompt = <span class=\"string\">f&quot;根据以下信息回答用户问题：\\n<span class=\"subst\">&#123;context&#125;</span>\\n\\n用户问题：<span class=\"subst\">&#123;query&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    response = ollamaClient.chat(</span><br><span class=\"line\">        model=<span class=\"string\">&quot;deepseek-r1:1.5b&quot;</span>,</span><br><span class=\"line\">        messages=[&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: prompt&#125;],</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response[<span class=\"string\">&quot;message&quot;</span>][<span class=\"string\">&quot;content&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成答案</span></span><br><span class=\"line\">final_answer = generate_answer(query, retrieved_docs)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;DeepSeek 生成的答案：&quot;</span>, final_answer)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4️⃣-看看效果\"><a href=\"#4️⃣-看看效果\" class=\"headerlink\" title=\"** 4️⃣ 看看效果**\"></a>** 4️⃣ 看看效果**</h4><ol>\n<li>原始搜索结果<br>提出问题：”你知道ITProHub?” 显然在原始模型的数据里面是没有关于本公众号的任何信息的，所以你可以看到deepseek针对这个问题开始胡言乱语了<br><img src=\"/blog/./images/deepseek-rag/raw-result.png\" alt=\"效果\"><br>可以看到针对 <code>ITProHub</code> 这个问题，原始的模型并不知道是啥。</li>\n<li>接入RAG之后的效果<br>接入RAG之后，模型可以根据检索到的内容，生成更准确的答案。<br><img src=\"/blog/./images/deepseek-rag/rag-result.png\" alt=\"效果\"></li>\n</ol>\n<hr>\n<h2 id=\"4-典型应用场景\"><a href=\"#4-典型应用场景\" class=\"headerlink\" title=\"4. 典型应用场景\"></a><strong>4. 典型应用场景</strong></h2><ol>\n<li><strong>企业知识库问答</strong>（客户支持、内部文档搜索）</li>\n<li><strong>AIOps</strong>（通过 RAG，结合实时运维数据，快速定位和分析故障原因）</li>\n<li><strong>代码辅助</strong>（自动补全、代码文档解析）</li>\n<li><strong>学术研究</strong>（查询特定文献，生成摘要）</li>\n</ol>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a><strong>5. 总结</strong></h2><p>RAG 作为一种 <strong>结合外部知识和大模型的增强技术</strong>，极大提高了回答的<strong>准确性和可解释性</strong>。DeepSeek 作为国产 LLM，在 <strong>中文优化、API 兼容性、代码生成能力</strong> 方面有独特优势，适合作为 RAG 系统的核心组件。</p>\n<p><strong>未来，我们可以探索更多优化方案，比如：</strong></p>\n<ul>\n<li><strong>结合 LlamaIndex &#x2F; LangChain</strong> 进行更复杂的检索。</li>\n<li><strong>使用 Milvus &#x2F; Weaviate</strong> 等更强大的向量数据库。</li>\n<li><strong>本地化部署 DeepSeek</strong>，提升数据安全性。</li>\n</ul>\n<p>如果你对 RAG 和 DeepSeek 感兴趣，可以尝试在自己的项目中落地应用，让 AI 变得更智能、更可靠！🚀<br>完整示例代码可访问老夫的<a href=\"https://github.com/ItProHub/rag\">GitHub</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在大模型应用中，<strong>如何保证答案的准确性和实时性</strong> 一直是一个难题。尽管 LLM（Large Language Models）具有强大的生成能力，但它们的知识存在 <strong>时间局限性</strong>，并且容易产生“幻觉”（hallucination）。为了解决这些问题，<strong>RAG（检索增强生成）</strong> 方案应运而生，在 RAG（检索增强生成）中，检索机制负责获取相关信息，而 LLM 负责生成最终答案。<strong>DeepSeek</strong> 作为国内领先的大模型之一，可以在 RAG 体系中作为生成部分，为检索增强的上下文提供自然、准确的回答。本文将带你了解 DeepSeek 与 RAG 的结合，并提供代码示例。</p>\n<hr>\n<h2 id=\"什么是-RAG（检索增强生成）？\"><a href=\"#什么是-RAG（检索增强生成）？\" class=\"headerlink\" title=\"** 什么是 RAG（检索增强生成）？**\"></a>** 什么是 RAG（检索增强生成）？**</h2><p><strong>RAG（Retrieval-Augmented Generation）</strong> 是一种将 <strong>信息检索（Retrieval）</strong> 与 <strong>大模型生成（Generation）</strong> 结合的技术，主要分为 <strong>两步：</strong></p>\n<ol>\n<li><strong>检索（Retrieve）</strong>: 在外部知识库（如文档数据库、向量数据库）中找到与用户问题相关的信息。</li>\n<li><strong>生成（Generate）</strong>: 将检索到的内容作为上下文输入给大模型，提高回答的准确性。</li>\n</ol>\n<p><strong>优点：</strong></p>\n<ul>\n<li>让 LLM 能够利用<strong>最新的</strong>外部知识，不再局限于训练数据。</li>\n<li>降低 LLM <strong>胡编乱造（幻觉）</strong> 的概率。</li>\n<li>提供<strong>可验证的答案来源</strong>，提高可靠性。</li>\n</ul>\n<p><img src=\"/blog/./images/deepseek-rag/hallucination.png\" alt=\"hallucination\"></p>\n<hr>\n<h2 id=\"为什么选择-DeepSeek-作为-RAG-模型？\"><a href=\"#为什么选择-DeepSeek-作为-RAG-模型？\" class=\"headerlink\" title=\"** 为什么选择 DeepSeek 作为 RAG 模型？**\"></a>** 为什么选择 DeepSeek 作为 RAG 模型？**</h2><p><a href=\"https://deepseek.com/\">DeepSeek</a> 是一个强大的国产 LLM，具备以下特点：</p>\n<ul>\n<li><strong>支持中文优化</strong>，相比 GPT-4&#x2F;Claude，在中文场景下表现更佳。</li>\n<li><strong>更开放的 API</strong>，可以免费试用，并且提供了本地部署版本。</li>\n<li><strong>模型能力强</strong>，支持 <strong>代码、数学推理、知识问答等任务</strong>，适合 RAG 场景。</li>\n</ul>\n<p>此外，DeepSeek 提供 <strong>DeepSeek-VL（视觉+文本）</strong> 以及 <strong>DeepSeek-Coder（代码生成）</strong> 版本，使其在 <strong>技术文档问答、代码辅助、金融分析等领域</strong> 表现优异。当然最重要的一点是，DeepSeek 是 <strong>开源</strong> 的，这意味着你可以在本地部署它，并且可以根据自己的需求进行定制。谁能拒绝白嫖呢？<img src=\"/blog/./images/deepseek-rag/baipiao.jpg\" alt=\"DeepSeek\"></p>\n<hr>\n<h2 id=\"如何实现-DeepSeek-RAG？\"><a href=\"#如何实现-DeepSeek-RAG？\" class=\"headerlink\" title=\"** 如何实现 DeepSeek + RAG？**\"></a>** 如何实现 DeepSeek + RAG？**</h2><p>我们可以结合 <strong>DeepSeek + Qdrant 向量数据库</strong> 来实现一个简单的 RAG 系统：</p>\n<p>前置条件：</p>\n<ul>\n<li>本地部署ollama。</li>\n<li>ollama运行DeepSeek。</li>\n<li>一个 Qdrant 实例。</li>\n</ul>\n<blockquote>\n<p>对于部署以上环境部署有疑问的老铁可以参考老夫之前的介绍</p>\n<p><a href=\"https://mp.weixin.qq.com/s/EmNzMrH1L52IWcEdROWehQ\">《DeepSeek 本地部署+web端访问 指南》</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/vrwbpo3cUrSKN1OX9LjgOw\">《Qdrant：开启高效相似性搜索的先锋》</a></p>\n</blockquote>\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a><strong>架构</strong></h3><ol>\n<li><strong>数据预处理</strong>：<ul>\n<li>将文档（如 PDF、网页）分割成小段，并向量化存储。</li>\n</ul>\n</li>\n<li><strong>用户输入查询</strong>：<ul>\n<li>计算输入问题的向量，并检索相似的文档片段。</li>\n</ul>\n</li>\n<li><strong>DeepSeek 生成回答</strong>：<ul>\n<li>将检索到的文档片段和用户问题一起输入 DeepSeek，生成最终答案。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/blog/./images/deepseek-rag/RAG-system-architecture.png\" alt=\"架构\"></p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a><strong>代码实现</strong></h3><p>这里我们使用 <code>Qdrant</code> 作为向量数据库，并结合 <code>DeepSeek</code> 进行 RAG 任务。</p>\n<h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a><strong>安装依赖</strong></h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install qdrant-client openai tiktoken</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1️⃣-数据预处理（文本向量化-存入-Qdrant）\"><a href=\"#1️⃣-数据预处理（文本向量化-存入-Qdrant）\" class=\"headerlink\" title=\"1️⃣ 数据预处理（文本向量化 + 存入 Qdrant）\"></a><strong>1️⃣ 数据预处理（文本向量化 + 存入 Qdrant）</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Qdrant</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> openai <span class=\"keyword\">import</span> OpenAI</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置参数</span></span><br><span class=\"line\">COLLECTION_NAME = <span class=\"string\">&quot;deepseek_rag&quot;</span></span><br><span class=\"line\">QDRANT_URL = <span class=\"string\">&quot;http://localhost:6333&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连接 Qdrant</span></span><br><span class=\"line\">client = QdrantClient(QDRANT_URL)</span><br><span class=\"line\">ollamaClient = ollama.Client(host=<span class=\"string\">&quot;http://127.0.0.1:11434&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 假设我们有一些文本需要存入 Qdrant</span></span><br><span class=\"line\">docs = [</span><br><span class=\"line\">        <span class=\"string\">&quot;DeepSeek 是一个强大的大模型，支持代码生成和中文优化。&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;RAG 是结合检索与生成的技术，能够提升大模型回答的准确性。&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Qdrant 是一个高效的向量数据库，适用于大规模检索。&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;ITProHub是一个致力于信息技术领域，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训的社区交流平台。&quot;</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 向量化</span></span><br><span class=\"line\">doc_vectors = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> doc <span class=\"keyword\">in</span> docs:</span><br><span class=\"line\">     <span class=\"string\">&quot;&quot;&quot; 使用本地 Ollama 计算文本嵌入向量 &quot;&quot;&quot;</span></span><br><span class=\"line\">    response = ollamaClient.embeddings(model=<span class=\"string\">&quot;mxbai-embed-large&quot;</span>, prompt=text)</span><br><span class=\"line\">    vector = response.embeddingresponse.data[<span class=\"number\">0</span>].embedding</span><br><span class=\"line\">    doc_vectors.append(vector)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 存入 Qdrant</span></span><br><span class=\"line\">points = [</span><br><span class=\"line\">    PointStruct(<span class=\"built_in\">id</span>=i, vector=vectors[i], payload=&#123;<span class=\"string\">&quot;text&quot;</span>: docs[i]&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(docs))</span><br><span class=\"line\">]</span><br><span class=\"line\">client.upsert(collection_name=COLLECTION_NAME, points=points)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;📥 已存入 <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(docs)&#125;</span> 篇文档&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2️⃣-用户查询-向量检索\"><a href=\"#2️⃣-用户查询-向量检索\" class=\"headerlink\" title=\"2️⃣ 用户查询 + 向量检索\"></a><strong>2️⃣ 用户查询 + 向量检索</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">retrieve_similar_docs</span>(<span class=\"params\">query, top_k=<span class=\"number\">2</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot; 从 Qdrant 中检索与查询最相似的文档 &quot;&quot;&quot;</span></span><br><span class=\"line\">    query_vector = get_embedding(query)</span><br><span class=\"line\">    search_result = client.search(</span><br><span class=\"line\">        collection_name=COLLECTION_NAME, query_vector=query_vector, limit=top_k</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [hit.payload[<span class=\"string\">&quot;text&quot;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例查询</span></span><br><span class=\"line\">query = <span class=\"string\">&quot;你知道ITProHub么？&quot;</span></span><br><span class=\"line\">retrieved_docs = retrieve_similar_docs(query)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;检索到的相关文档：&quot;</span>, retrieved_docs)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3️⃣-DeepSeek-生成答案\"><a href=\"#3️⃣-DeepSeek-生成答案\" class=\"headerlink\" title=\"3️⃣ DeepSeek 生成答案\"></a><strong>3️⃣ DeepSeek 生成答案</strong></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generate_answer</span>(<span class=\"params\">query, retrieved_docs</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot; 使用 DeepSeek 结合检索内容生成答案 &quot;&quot;&quot;</span></span><br><span class=\"line\">    context = <span class=\"string\">&quot;\\n&quot;</span>.join(retrieved_docs)</span><br><span class=\"line\">    prompt = <span class=\"string\">f&quot;根据以下信息回答用户问题：\\n<span class=\"subst\">&#123;context&#125;</span>\\n\\n用户问题：<span class=\"subst\">&#123;query&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    response = ollamaClient.chat(</span><br><span class=\"line\">        model=<span class=\"string\">&quot;deepseek-r1:1.5b&quot;</span>,</span><br><span class=\"line\">        messages=[&#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: prompt&#125;],</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response[<span class=\"string\">&quot;message&quot;</span>][<span class=\"string\">&quot;content&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成答案</span></span><br><span class=\"line\">final_answer = generate_answer(query, retrieved_docs)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;DeepSeek 生成的答案：&quot;</span>, final_answer)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4️⃣-看看效果\"><a href=\"#4️⃣-看看效果\" class=\"headerlink\" title=\"** 4️⃣ 看看效果**\"></a>** 4️⃣ 看看效果**</h4><ol>\n<li>原始搜索结果<br>提出问题：”你知道ITProHub?” 显然在原始模型的数据里面是没有关于本公众号的任何信息的，所以你可以看到deepseek针对这个问题开始胡言乱语了<br><img src=\"/blog/./images/deepseek-rag/raw-result.png\" alt=\"效果\"><br>可以看到针对 <code>ITProHub</code> 这个问题，原始的模型并不知道是啥。</li>\n<li>接入RAG之后的效果<br>接入RAG之后，模型可以根据检索到的内容，生成更准确的答案。<br><img src=\"/blog/./images/deepseek-rag/rag-result.png\" alt=\"效果\"></li>\n</ol>\n<hr>\n<h2 id=\"4-典型应用场景\"><a href=\"#4-典型应用场景\" class=\"headerlink\" title=\"4. 典型应用场景\"></a><strong>4. 典型应用场景</strong></h2><ol>\n<li><strong>企业知识库问答</strong>（客户支持、内部文档搜索）</li>\n<li><strong>AIOps</strong>（通过 RAG，结合实时运维数据，快速定位和分析故障原因）</li>\n<li><strong>代码辅助</strong>（自动补全、代码文档解析）</li>\n<li><strong>学术研究</strong>（查询特定文献，生成摘要）</li>\n</ol>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a><strong>5. 总结</strong></h2><p>RAG 作为一种 <strong>结合外部知识和大模型的增强技术</strong>，极大提高了回答的<strong>准确性和可解释性</strong>。DeepSeek 作为国产 LLM，在 <strong>中文优化、API 兼容性、代码生成能力</strong> 方面有独特优势，适合作为 RAG 系统的核心组件。</p>\n<p><strong>未来，我们可以探索更多优化方案，比如：</strong></p>\n<ul>\n<li><strong>结合 LlamaIndex &#x2F; LangChain</strong> 进行更复杂的检索。</li>\n<li><strong>使用 Milvus &#x2F; Weaviate</strong> 等更强大的向量数据库。</li>\n<li><strong>本地化部署 DeepSeek</strong>，提升数据安全性。</li>\n</ul>\n<p>如果你对 RAG 和 DeepSeek 感兴趣，可以尝试在自己的项目中落地应用，让 AI 变得更智能、更可靠！🚀<br>完整示例代码可访问老夫的<a href=\"https://github.com/ItProHub/rag\">GitHub</a></p>\n"},{"title":"DeepSeek 本地部署+web端访问 指南","date":"2025-02-07T01:33:25.000Z","_content":"去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。\n\n这不，老夫也算是起了个大早，赶了个晚集。\n这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。\n![迟到](./images/deepseek-1/late.jpg)\n\n在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。\n\n# 本地部署DeepSeek\n## 下载并安装Ollama\n首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。\n\nWindows/macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。\n\n![下载](./images/deepseek-1/download.png)\n\nLinux用户：需要通过命令行执行以下命令来安装：\n```bash\ncurl -fsSL https://ollama.com/install.sh | sh\n```\n\n以下是我的电脑的配置，后面所有的安装都是基于以下配置完成的\n\n![下载](./images/deepseek-1/environment.png)\n\n<font color=\"#dd0000\">建议看到这里的小伙子们，先去下载Ollama, 然后回来继续看下去。因为Ollama下载真的慢。</font>\n\n## 选择DeepSeek模型\n安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。\n\n![模型](./images/deepseek-1/models.png)\n\n7B版本：命令为 ollama run deepseek-r1:7b\n1.5B版本：命令为 ollama run deepseek-r1:1.5b\n\n![deepseek模型](./images/deepseek-1/deepseek-models.png)\n\n这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。\n\n## 运行命令\n选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。\n\n## 效果测试\n一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。\n\n![安装完成](./images/deepseek-1/success.png)\n\n最后我们再用一个稍微复杂点的问题简单试试本地DeepSeek的速度和资源占用情况。\n> ”10克铅头钩和5克铅头钩挂相同的T尾软饵，软饵是塑料材质长度9cm重3克，近似于圆柱体外形，它们在同一片平静水域中下沉的速度有多大差别？\n请按物理学定理或公式给出推理过程以及计算结果。“\n\n![回答速度](./images/deepseek-1/speed.gif)\n可以看到，DeepSeek的回答速度还算让人满意。\n\n不过在回答稍微复杂问题的时候感觉明显主机开始烧开水了。\n![资源使用情况](./images/deepseek-1/resource.png)\n\n\n# 使用Chatbox进行网页端访问\n命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。\n\n![安装完成](./images/deepseek-1/cmd-effect.png)\n通过上图可以看到，浮力公式和很多markdown格式都没有正常渲染出来。\n\n## 环境变量配置\n默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：\n\n- OLLAMA_HOST：设置为 0.0.0.0\n- OLLAMA_ORIGINS：设置为 *\n\n在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。\n\n![deepseek模型](./images/deepseek-1/env_var.png)\n\n保存设置后，从Windows开始菜单启动Ollama。\n\n## 配置Chatbox\n完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。\n\n打开[Chatbox](https://web.chatboxai.app/)官网，并选择启动网页版。\n![ChatBox](./images/deepseek-1/chatboxai.png)\n选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。\n在设置中选择Ollama API。\n\n选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。\n点击“DISPLAY”选项，选择简体中文，并点击保存按钮。\n\n![deepseek模型](./images/deepseek-1/chatbox-setting3.png)\n\n完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。\n\n这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。\n![deepseek模型](./images/deepseek-1/chatbox-answer.png)\n\n\n# 总结\n通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。\n\n希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！","source":"_posts/deepseek-1.md","raw":"---\ntitle: DeepSeek 本地部署+web端访问 指南\ndate: 2025-02-07 09:33:25\ntags:\n---\n去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。\n\n这不，老夫也算是起了个大早，赶了个晚集。\n这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。\n![迟到](./images/deepseek-1/late.jpg)\n\n在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。\n\n# 本地部署DeepSeek\n## 下载并安装Ollama\n首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。\n\nWindows/macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。\n\n![下载](./images/deepseek-1/download.png)\n\nLinux用户：需要通过命令行执行以下命令来安装：\n```bash\ncurl -fsSL https://ollama.com/install.sh | sh\n```\n\n以下是我的电脑的配置，后面所有的安装都是基于以下配置完成的\n\n![下载](./images/deepseek-1/environment.png)\n\n<font color=\"#dd0000\">建议看到这里的小伙子们，先去下载Ollama, 然后回来继续看下去。因为Ollama下载真的慢。</font>\n\n## 选择DeepSeek模型\n安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。\n\n![模型](./images/deepseek-1/models.png)\n\n7B版本：命令为 ollama run deepseek-r1:7b\n1.5B版本：命令为 ollama run deepseek-r1:1.5b\n\n![deepseek模型](./images/deepseek-1/deepseek-models.png)\n\n这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。\n\n## 运行命令\n选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。\n\n## 效果测试\n一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。\n\n![安装完成](./images/deepseek-1/success.png)\n\n最后我们再用一个稍微复杂点的问题简单试试本地DeepSeek的速度和资源占用情况。\n> ”10克铅头钩和5克铅头钩挂相同的T尾软饵，软饵是塑料材质长度9cm重3克，近似于圆柱体外形，它们在同一片平静水域中下沉的速度有多大差别？\n请按物理学定理或公式给出推理过程以及计算结果。“\n\n![回答速度](./images/deepseek-1/speed.gif)\n可以看到，DeepSeek的回答速度还算让人满意。\n\n不过在回答稍微复杂问题的时候感觉明显主机开始烧开水了。\n![资源使用情况](./images/deepseek-1/resource.png)\n\n\n# 使用Chatbox进行网页端访问\n命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。\n\n![安装完成](./images/deepseek-1/cmd-effect.png)\n通过上图可以看到，浮力公式和很多markdown格式都没有正常渲染出来。\n\n## 环境变量配置\n默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：\n\n- OLLAMA_HOST：设置为 0.0.0.0\n- OLLAMA_ORIGINS：设置为 *\n\n在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。\n\n![deepseek模型](./images/deepseek-1/env_var.png)\n\n保存设置后，从Windows开始菜单启动Ollama。\n\n## 配置Chatbox\n完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。\n\n打开[Chatbox](https://web.chatboxai.app/)官网，并选择启动网页版。\n![ChatBox](./images/deepseek-1/chatboxai.png)\n选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。\n在设置中选择Ollama API。\n\n选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。\n点击“DISPLAY”选项，选择简体中文，并点击保存按钮。\n\n![deepseek模型](./images/deepseek-1/chatbox-setting3.png)\n\n完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。\n\n这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。\n![deepseek模型](./images/deepseek-1/chatbox-answer.png)\n\n\n# 总结\n通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。\n\n希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！","slug":"deepseek-1","published":1,"updated":"2025-02-10T07:34:40.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawa0007rkp14ek3grt9","content":"<p>去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。</p>\n<p>这不，老夫也算是起了个大早，赶了个晚集。<br>这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。<br><img src=\"/blog/./images/deepseek-1/late.jpg\" alt=\"迟到\"></p>\n<p>在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。</p>\n<h1 id=\"本地部署DeepSeek\"><a href=\"#本地部署DeepSeek\" class=\"headerlink\" title=\"本地部署DeepSeek\"></a>本地部署DeepSeek</h1><h2 id=\"下载并安装Ollama\"><a href=\"#下载并安装Ollama\" class=\"headerlink\" title=\"下载并安装Ollama\"></a>下载并安装Ollama</h2><p>首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。</p>\n<p>Windows&#x2F;macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。</p>\n<p><img src=\"/blog/./images/deepseek-1/download.png\" alt=\"下载\"></p>\n<p>Linux用户：需要通过命令行执行以下命令来安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>以下是我的电脑的配置，后面所有的安装都是基于以下配置完成的</p>\n<p><img src=\"/blog/./images/deepseek-1/environment.png\" alt=\"下载\"></p>\n<p><font color=\"#dd0000\">建议看到这里的小伙子们，先去下载Ollama, 然后回来继续看下去。因为Ollama下载真的慢。</font></p>\n<h2 id=\"选择DeepSeek模型\"><a href=\"#选择DeepSeek模型\" class=\"headerlink\" title=\"选择DeepSeek模型\"></a>选择DeepSeek模型</h2><p>安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。</p>\n<p><img src=\"/blog/./images/deepseek-1/models.png\" alt=\"模型\"></p>\n<p>7B版本：命令为 ollama run deepseek-r1:7b<br>1.5B版本：命令为 ollama run deepseek-r1:1.5b</p>\n<p><img src=\"/blog/./images/deepseek-1/deepseek-models.png\" alt=\"deepseek模型\"></p>\n<p>这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。</p>\n<h2 id=\"运行命令\"><a href=\"#运行命令\" class=\"headerlink\" title=\"运行命令\"></a>运行命令</h2><p>选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。</p>\n<h2 id=\"效果测试\"><a href=\"#效果测试\" class=\"headerlink\" title=\"效果测试\"></a>效果测试</h2><p>一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。</p>\n<p><img src=\"/blog/./images/deepseek-1/success.png\" alt=\"安装完成\"></p>\n<p>最后我们再用一个稍微复杂点的问题简单试试本地DeepSeek的速度和资源占用情况。</p>\n<blockquote>\n<p>”10克铅头钩和5克铅头钩挂相同的T尾软饵，软饵是塑料材质长度9cm重3克，近似于圆柱体外形，它们在同一片平静水域中下沉的速度有多大差别？<br>请按物理学定理或公式给出推理过程以及计算结果。“</p>\n</blockquote>\n<p><img src=\"/blog/./images/deepseek-1/speed.gif\" alt=\"回答速度\"><br>可以看到，DeepSeek的回答速度还算让人满意。</p>\n<p>不过在回答稍微复杂问题的时候感觉明显主机开始烧开水了。<br><img src=\"/blog/./images/deepseek-1/resource.png\" alt=\"资源使用情况\"></p>\n<h1 id=\"使用Chatbox进行网页端访问\"><a href=\"#使用Chatbox进行网页端访问\" class=\"headerlink\" title=\"使用Chatbox进行网页端访问\"></a>使用Chatbox进行网页端访问</h1><p>命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。</p>\n<p><img src=\"/blog/./images/deepseek-1/cmd-effect.png\" alt=\"安装完成\"><br>通过上图可以看到，浮力公式和很多markdown格式都没有正常渲染出来。</p>\n<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：</p>\n<ul>\n<li>OLLAMA_HOST：设置为 0.0.0.0</li>\n<li>OLLAMA_ORIGINS：设置为 *</li>\n</ul>\n<p>在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。</p>\n<p><img src=\"/blog/./images/deepseek-1/env_var.png\" alt=\"deepseek模型\"></p>\n<p>保存设置后，从Windows开始菜单启动Ollama。</p>\n<h2 id=\"配置Chatbox\"><a href=\"#配置Chatbox\" class=\"headerlink\" title=\"配置Chatbox\"></a>配置Chatbox</h2><p>完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。</p>\n<p>打开<a href=\"https://web.chatboxai.app/\">Chatbox</a>官网，并选择启动网页版。<br><img src=\"/blog/./images/deepseek-1/chatboxai.png\" alt=\"ChatBox\"><br>选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。<br>在设置中选择Ollama API。</p>\n<p>选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。<br>点击“DISPLAY”选项，选择简体中文，并点击保存按钮。</p>\n<p><img src=\"/blog/./images/deepseek-1/chatbox-setting3.png\" alt=\"deepseek模型\"></p>\n<p>完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。</p>\n<p>这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。<br><img src=\"/blog/./images/deepseek-1/chatbox-answer.png\" alt=\"deepseek模型\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。</p>\n<p>希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>去年了解到DeepSeek的时候，它在大模型排行榜上已经是第7名了，而且它还是前10名里面唯一一个开源的。想不到经过一个春节，DeepSeek更是火出了天际。‌DeepSeek在美国苹果应用商店和中国苹果应用商店的免费应用排行榜上均排名第一‌。DeepSeek在1月27日赶超OpenAI的ChatGPT，在美国苹果应用商店免费应用排行榜上排名第一。在中国苹果应用商店，DeepSeek同样排名第一‌。</p>\n<p>这不，老夫也算是起了个大早，赶了个晚集。<br>这两天才有时间把前段时间部署DeepSeek的文档整理出来，做一个简单的分享。<br><img src=\"/blog/./images/deepseek-1/late.jpg\" alt=\"迟到\"></p>\n<p>在本篇博客中，我将分享如何在本地部署和使用DeepSeek模型，并结合Chatbox网页端进行交互，以提升使用体验。以下是部署的详细步骤。</p>\n<h1 id=\"本地部署DeepSeek\"><a href=\"#本地部署DeepSeek\" class=\"headerlink\" title=\"本地部署DeepSeek\"></a>本地部署DeepSeek</h1><h2 id=\"下载并安装Ollama\"><a href=\"#下载并安装Ollama\" class=\"headerlink\" title=\"下载并安装Ollama\"></a>下载并安装Ollama</h2><p>首先，我们需要安装Ollama，这是一个支持多种AI模型的本地化部署工具。Ollama支持Windows、macOS和Linux系统，选择适合你操作系统的版本。</p>\n<p>Windows&#x2F;macOS用户：可以直接访问Ollama官网，下载适合操作系统的安装包并进行安装。</p>\n<p><img src=\"/blog/./images/deepseek-1/download.png\" alt=\"下载\"></p>\n<p>Linux用户：需要通过命令行执行以下命令来安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>以下是我的电脑的配置，后面所有的安装都是基于以下配置完成的</p>\n<p><img src=\"/blog/./images/deepseek-1/environment.png\" alt=\"下载\"></p>\n<p><font color=\"#dd0000\">建议看到这里的小伙子们，先去下载Ollama, 然后回来继续看下去。因为Ollama下载真的慢。</font></p>\n<h2 id=\"选择DeepSeek模型\"><a href=\"#选择DeepSeek模型\" class=\"headerlink\" title=\"选择DeepSeek模型\"></a>选择DeepSeek模型</h2><p>安装完成后，打开Ollama应用程序，点击界面上的“Models”选项。你会看到“deepseek-r1”模型列表，可以选择不同版本的模型，具体选择哪个版本，取决于你硬件设备的配置。</p>\n<p><img src=\"/blog/./images/deepseek-1/models.png\" alt=\"模型\"></p>\n<p>7B版本：命令为 ollama run deepseek-r1:7b<br>1.5B版本：命令为 ollama run deepseek-r1:1.5b</p>\n<p><img src=\"/blog/./images/deepseek-1/deepseek-models.png\" alt=\"deepseek模型\"></p>\n<p>这里，我选择了1.5B版本，因为其配置适合普通的电脑。需要注意的是，参数量越大的模型通常更强大，但也需要更多计算资源。如果你的硬件设备较为强大，可以选择更大的版本。</p>\n<h2 id=\"运行命令\"><a href=\"#运行命令\" class=\"headerlink\" title=\"运行命令\"></a>运行命令</h2><p>选择完合适的模型后，输入相应的命令来启动DeepSeek模型。系统会显示“success”表示安装成功。</p>\n<h2 id=\"效果测试\"><a href=\"#效果测试\" class=\"headerlink\" title=\"效果测试\"></a>效果测试</h2><p>一旦安装成功，你可以开始与DeepSeek进行交互。例如，输入“Hello World!”模型将返回相应的答案。如果一切正常，说明安装成功。</p>\n<p><img src=\"/blog/./images/deepseek-1/success.png\" alt=\"安装完成\"></p>\n<p>最后我们再用一个稍微复杂点的问题简单试试本地DeepSeek的速度和资源占用情况。</p>\n<blockquote>\n<p>”10克铅头钩和5克铅头钩挂相同的T尾软饵，软饵是塑料材质长度9cm重3克，近似于圆柱体外形，它们在同一片平静水域中下沉的速度有多大差别？<br>请按物理学定理或公式给出推理过程以及计算结果。“</p>\n</blockquote>\n<p><img src=\"/blog/./images/deepseek-1/speed.gif\" alt=\"回答速度\"><br>可以看到，DeepSeek的回答速度还算让人满意。</p>\n<p>不过在回答稍微复杂问题的时候感觉明显主机开始烧开水了。<br><img src=\"/blog/./images/deepseek-1/resource.png\" alt=\"资源使用情况\"></p>\n<h1 id=\"使用Chatbox进行网页端访问\"><a href=\"#使用Chatbox进行网页端访问\" class=\"headerlink\" title=\"使用Chatbox进行网页端访问\"></a>使用Chatbox进行网页端访问</h1><p>命令行界面虽然可以使用，但相对不够直观, 很多格式都没办法正常展示出来。如果你希望更方便地与DeepSeek进行交互，可以使用Chatbox来通过网页端访问模型。</p>\n<p><img src=\"/blog/./images/deepseek-1/cmd-effect.png\" alt=\"安装完成\"><br>通过上图可以看到，浮力公式和很多markdown格式都没有正常渲染出来。</p>\n<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>默认情况下，Ollama服务仅在本地运行，不对外提供服务。为了让Ollama能够对外提供服务，需要设置以下环境变量：</p>\n<ul>\n<li>OLLAMA_HOST：设置为 0.0.0.0</li>\n<li>OLLAMA_ORIGINS：设置为 *</li>\n</ul>\n<p>在Windows系统上，你需要先退出Ollama应用程序，然后配置环境变量。</p>\n<p><img src=\"/blog/./images/deepseek-1/env_var.png\" alt=\"deepseek模型\"></p>\n<p>保存设置后，从Windows开始菜单启动Ollama。</p>\n<h2 id=\"配置Chatbox\"><a href=\"#配置Chatbox\" class=\"headerlink\" title=\"配置Chatbox\"></a>配置Chatbox</h2><p>完成环境变量配置后，接下来配置Chatbox以访问本地的Ollama模型。</p>\n<p>打开<a href=\"https://web.chatboxai.app/\">Chatbox</a>官网，并选择启动网页版。<br><img src=\"/blog/./images/deepseek-1/chatboxai.png\" alt=\"ChatBox\"><br>选择“本地模型”，如果没有找到本地模型，点击左侧的设置按钮。<br>在设置中选择Ollama API。</p>\n<p>选择你已经安装并运行的模型，Chatbox会自动识别到本地运行的模型，直接选择即可。<br>点击“DISPLAY”选项，选择简体中文，并点击保存按钮。</p>\n<p><img src=\"/blog/./images/deepseek-1/chatbox-setting3.png\" alt=\"deepseek模型\"></p>\n<p>完成配置后，可以在聊天窗口输入问题进行测试，体验与DeepSeek的交互。</p>\n<p>这个时候，我们可以看到之前在命令行无法正常显示的格式都可以正常显示了。<br><img src=\"/blog/./images/deepseek-1/chatbox-answer.png\" alt=\"deepseek模型\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，你可以成功在本地部署DeepSeek，并使用Chatbox网页端进行交互。无论是命令行还是网页端，Ollama和DeepSeek都能提供强大的AI模型支持，帮助你完成各种任务。使用Chatbox作为前端应用，可以使与模型的交互更加直观和友好。</p>\n<p>希望这篇部署分享对你有所帮助，祝你在使用DeepSeek时能够获得愉快的体验！</p>\n"},{"title":"Docker镜像构建优化","date":"2024-07-08T01:20:55.000Z","_content":"\n# 引言\n在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。\n\n# Dockerfile中的层定义\n在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。\n\n```dockerfile\n# 每一条指令都会创建一个新层\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\nCMD [\"python\", \"app.py\"]\n```\n上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。\n\n\n在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：\n\n1. 新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。\n\n2. 修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。\n\n3. 删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。\n\n4. 文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。\n\n为了更具体地说明，下面是一个示例Dockerfile及其解释：\n\n```dockerfile\nFROM ubuntu:20.04\n\n# 第一层\nRUN apt-get update && apt-get install -y curl\n\n# 第二层\nRUN echo \"Hello, World!\" > /hello.txt\n\n# 第三层\nRUN chmod 644 /hello.txt\n```\n在这个示例中，每个RUN指令都会创建一个新的层：\n\n1. 第一层：RUN apt-get update && apt-get install -y curl：\n- 这一层包含了更新包索引文件和安装curl工具所做的所有更改。\n- 新增了curl工具的相关文件和目录。\n- 修改了包管理器的状态文件。\n2. 第二层：RUN echo \"Hello, World!\" > /hello.txt：\n- 这一层包含了创建/hello.txt文件并向其中写入\"Hello, World!\"的操作。\n- 新增了文件/hello.txt。\n\n3. 第三层：RUN chmod 644 /hello.txt：\n- 这一层包含了对文件/hello.txt的权限更改。\n- 修改了文件/hello.txt的权限信息。\n\n每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。\n\n# 层带来的好处\nDocker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。\n\n## 层的重用机制\n层的重用主要是通过以下几个步骤实现的：\n\n1. 层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。\n\n2. 层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。\n\n3. 层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。\n\n## 层的重用示例\n假设我们有一个简单的 Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"python\", \"app.py\"]\n```\n为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容\n```\n# requirements.txt 示例\nflask\nrequests\n```\n根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR /app、COPY . . 和 CMD [\"python\", \"app.py\"]）由于没有变化，可以直接从缓存中重用。\n\n构建完镜像以后，让我们inspect一下镜像\n![inspect1](/images/docker-2/inspect1.png)![inspect2](/images/docker-2/inspect2.png)\n\n我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。\n![inspect3](/images/docker-2/inspect3.png)\n\n\n# 层数多带来的问题\n层数多会导致以下几个问题：\n\n1. 镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。\n2. 构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。\n3. 性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I/O操作的开销。\n\n# 减少Dockerfile层数的方法\n合并指令\n将多个指令合并到一个RUN指令中，可以显著减少层数。例如：\n\n```dockerfile\n# 将多个RUN指令合并到一个\nRUN apt-get update && \\\n    apt-get install -y package1 package2 && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n```\n\n减少临时文件\n在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：\n\n```dockerfile\n# 使用多行命令避免临时文件\nRUN wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination\n```\n使用.dockerignore\n类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。\n\n```dockerignore\n# .dockerignore 文件示例\nnode_modules\n.git\n.tmp\n```\n\n# 实际案例：优化一个Dockerfile\n原始Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nRUN apt-get update\nRUN apt-get install -y curl\nRUN apt-get clean\nCMD [\"python\", \"app.py\"]\n```\n优化后的Dockerfile：\n\n```dockerfile\n# 优化后的Dockerfile，减少层数\nFROM python:3.8-slim\n\nWORKDIR /app\n\n# 合并COPY和RUN指令\nCOPY requirements.txt ./\nRUN apt-get update && \\\n    apt-get install -y curl && \\\n    pip install -r requirements.txt && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n\n# 使用.dockerignore忽略不必要的文件\nCOPY . .\n\nCMD [\"python\", \"app.py\"]\n```\n我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。\n![优化dockerfile](/images/docker-2/after.png)\n\n\n# 其他优化技巧\n## 使用多阶段构建\n多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。\n通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。\n\n```dockerfile\n# 多阶段构建示例\nFROM net8-sdk AS build\nWORKDIR /app\n# 拷贝项目文件并还原依赖项\nCOPY . .\n# 构建发布版本\nRUN dotnet publish \"src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj\" -c Release -o /app/publish\n\n# 设置运行时镜像\nFROM net8-runtime\nWORKDIR /app\n# 从构建镜像阶段复制发布的文件到运行时镜像\nCOPY --from=build /app/publish .\n\nEXPOSE 80\nENTRYPOINT [\"dotnet\", \"Uranus.DatacenterMH.dll\"]\n```\n\n\n## 定期清理镜像和容器\n定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n```\n\n结语\n通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/docker-2.md","raw":"---\ntitle: Docker镜像构建优化\ndate: 2024-07-08 09:20:55\ntags:\n---\n\n# 引言\n在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。\n\n# Dockerfile中的层定义\n在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。\n\n```dockerfile\n# 每一条指令都会创建一个新层\nFROM python:3.8-slim\nWORKDIR /app\nCOPY . .\nRUN pip install -r requirements.txt\nCMD [\"python\", \"app.py\"]\n```\n上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。\n\n\n在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：\n\n1. 新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。\n\n2. 修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。\n\n3. 删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。\n\n4. 文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。\n\n为了更具体地说明，下面是一个示例Dockerfile及其解释：\n\n```dockerfile\nFROM ubuntu:20.04\n\n# 第一层\nRUN apt-get update && apt-get install -y curl\n\n# 第二层\nRUN echo \"Hello, World!\" > /hello.txt\n\n# 第三层\nRUN chmod 644 /hello.txt\n```\n在这个示例中，每个RUN指令都会创建一个新的层：\n\n1. 第一层：RUN apt-get update && apt-get install -y curl：\n- 这一层包含了更新包索引文件和安装curl工具所做的所有更改。\n- 新增了curl工具的相关文件和目录。\n- 修改了包管理器的状态文件。\n2. 第二层：RUN echo \"Hello, World!\" > /hello.txt：\n- 这一层包含了创建/hello.txt文件并向其中写入\"Hello, World!\"的操作。\n- 新增了文件/hello.txt。\n\n3. 第三层：RUN chmod 644 /hello.txt：\n- 这一层包含了对文件/hello.txt的权限更改。\n- 修改了文件/hello.txt的权限信息。\n\n每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。\n\n# 层带来的好处\nDocker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。\n\n## 层的重用机制\n层的重用主要是通过以下几个步骤实现的：\n\n1. 层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。\n\n2. 层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。\n\n3. 层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。\n\n## 层的重用示例\n假设我们有一个简单的 Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nCMD [\"python\", \"app.py\"]\n```\n为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容\n```\n# requirements.txt 示例\nflask\nrequests\n```\n根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR /app、COPY . . 和 CMD [\"python\", \"app.py\"]）由于没有变化，可以直接从缓存中重用。\n\n构建完镜像以后，让我们inspect一下镜像\n![inspect1](/images/docker-2/inspect1.png)![inspect2](/images/docker-2/inspect2.png)\n\n我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。\n![inspect3](/images/docker-2/inspect3.png)\n\n\n# 层数多带来的问题\n层数多会导致以下几个问题：\n\n1. 镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。\n2. 构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。\n3. 性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I/O操作的开销。\n\n# 减少Dockerfile层数的方法\n合并指令\n将多个指令合并到一个RUN指令中，可以显著减少层数。例如：\n\n```dockerfile\n# 将多个RUN指令合并到一个\nRUN apt-get update && \\\n    apt-get install -y package1 package2 && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n```\n\n减少临时文件\n在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：\n\n```dockerfile\n# 使用多行命令避免临时文件\nRUN wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination\n```\n使用.dockerignore\n类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。\n\n```dockerignore\n# .dockerignore 文件示例\nnode_modules\n.git\n.tmp\n```\n\n# 实际案例：优化一个Dockerfile\n原始Dockerfile：\n\n```dockerfile\nFROM python:3.8-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\nCOPY . .\nRUN apt-get update\nRUN apt-get install -y curl\nRUN apt-get clean\nCMD [\"python\", \"app.py\"]\n```\n优化后的Dockerfile：\n\n```dockerfile\n# 优化后的Dockerfile，减少层数\nFROM python:3.8-slim\n\nWORKDIR /app\n\n# 合并COPY和RUN指令\nCOPY requirements.txt ./\nRUN apt-get update && \\\n    apt-get install -y curl && \\\n    pip install -r requirements.txt && \\\n    apt-get clean && \\\n    rm -rf /var/lib/apt/lists/*\n\n# 使用.dockerignore忽略不必要的文件\nCOPY . .\n\nCMD [\"python\", \"app.py\"]\n```\n我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。\n![优化dockerfile](/images/docker-2/after.png)\n\n\n# 其他优化技巧\n## 使用多阶段构建\n多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。\n通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。\n\n```dockerfile\n# 多阶段构建示例\nFROM net8-sdk AS build\nWORKDIR /app\n# 拷贝项目文件并还原依赖项\nCOPY . .\n# 构建发布版本\nRUN dotnet publish \"src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj\" -c Release -o /app/publish\n\n# 设置运行时镜像\nFROM net8-runtime\nWORKDIR /app\n# 从构建镜像阶段复制发布的文件到运行时镜像\nCOPY --from=build /app/publish .\n\nEXPOSE 80\nENTRYPOINT [\"dotnet\", \"Uranus.DatacenterMH.dll\"]\n```\n\n\n## 定期清理镜像和容器\n定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。\n\n```bash\n# 清理未使用的镜像\ndocker image prune -a\n\n# 清理未使用的容器\ndocker container prune\n```\n\n结语\n通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","slug":"docker-2","published":1,"updated":"2024-07-08T13:19:28.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawa0008rkp16g1bdrrj","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。</p>\n<h1 id=\"Dockerfile中的层定义\"><a href=\"#Dockerfile中的层定义\" class=\"headerlink\" title=\"Dockerfile中的层定义\"></a>Dockerfile中的层定义</h1><p>在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 每一条指令都会创建一个新层</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。</p>\n<p>在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：</p>\n<ol>\n<li><p>新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。</p>\n</li>\n<li><p>修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。</p>\n</li>\n<li><p>删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。</p>\n</li>\n<li><p>文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。</p>\n</li>\n</ol>\n<p>为了更具体地说明，下面是一个示例Dockerfile及其解释：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">20.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span> &gt; /hello.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">chmod</span> 644 /hello.txt</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，每个RUN指令都会创建一个新的层：</p>\n<ol>\n<li>第一层：RUN apt-get update &amp;&amp; apt-get install -y curl：</li>\n</ol>\n<ul>\n<li>这一层包含了更新包索引文件和安装curl工具所做的所有更改。</li>\n<li>新增了curl工具的相关文件和目录。</li>\n<li>修改了包管理器的状态文件。</li>\n</ul>\n<ol start=\"2\">\n<li>第二层：RUN echo “Hello, World!” &gt; &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了创建&#x2F;hello.txt文件并向其中写入”Hello, World!”的操作。</li>\n<li>新增了文件&#x2F;hello.txt。</li>\n</ul>\n<ol start=\"3\">\n<li>第三层：RUN chmod 644 &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了对文件&#x2F;hello.txt的权限更改。</li>\n<li>修改了文件&#x2F;hello.txt的权限信息。</li>\n</ul>\n<p>每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。</p>\n<h1 id=\"层带来的好处\"><a href=\"#层带来的好处\" class=\"headerlink\" title=\"层带来的好处\"></a>层带来的好处</h1><p>Docker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。</p>\n<h2 id=\"层的重用机制\"><a href=\"#层的重用机制\" class=\"headerlink\" title=\"层的重用机制\"></a>层的重用机制</h2><p>层的重用主要是通过以下几个步骤实现的：</p>\n<ol>\n<li><p>层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。</p>\n</li>\n<li><p>层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。</p>\n</li>\n<li><p>层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。</p>\n</li>\n</ol>\n<h2 id=\"层的重用示例\"><a href=\"#层的重用示例\" class=\"headerlink\" title=\"层的重用示例\"></a>层的重用示例</h2><p>假设我们有一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># requirements.txt 示例</span><br><span class=\"line\">flask</span><br><span class=\"line\">requests</span><br></pre></td></tr></table></figure>\n<p>根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR &#x2F;app、COPY . . 和 CMD [“python”, “app.py”]）由于没有变化，可以直接从缓存中重用。</p>\n<p>构建完镜像以后，让我们inspect一下镜像<br><img src=\"/blog/images/docker-2/inspect1.png\" alt=\"inspect1\"><img src=\"/blog/images/docker-2/inspect2.png\" alt=\"inspect2\"></p>\n<p>我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。<br><img src=\"/blog/images/docker-2/inspect3.png\" alt=\"inspect3\"></p>\n<h1 id=\"层数多带来的问题\"><a href=\"#层数多带来的问题\" class=\"headerlink\" title=\"层数多带来的问题\"></a>层数多带来的问题</h1><p>层数多会导致以下几个问题：</p>\n<ol>\n<li>镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。</li>\n<li>构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。</li>\n<li>性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I&#x2F;O操作的开销。</li>\n</ol>\n<h1 id=\"减少Dockerfile层数的方法\"><a href=\"#减少Dockerfile层数的方法\" class=\"headerlink\" title=\"减少Dockerfile层数的方法\"></a>减少Dockerfile层数的方法</h1><p>合并指令<br>将多个指令合并到一个RUN指令中，可以显著减少层数。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将多个RUN指令合并到一个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y package1 package2 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>\n\n<p>减少临时文件<br>在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用多行命令避免临时文件</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination</span></span><br></pre></td></tr></table></figure>\n<p>使用.dockerignore<br>类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .dockerignore 文件示例</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">.git</span><br><span class=\"line\">.tmp</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际案例：优化一个Dockerfile\"><a href=\"#实际案例：优化一个Dockerfile\" class=\"headerlink\" title=\"实际案例：优化一个Dockerfile\"></a>实际案例：优化一个Dockerfile</h1><p>原始Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get clean</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>优化后的Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 优化后的Dockerfile，减少层数</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并COPY和RUN指令</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y curl &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    pip install -r requirements.txt &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用.dockerignore忽略不必要的文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。<br><img src=\"/blog/images/docker-2/after.png\" alt=\"优化dockerfile\"></p>\n<h1 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h1><h2 id=\"使用多阶段构建\"><a href=\"#使用多阶段构建\" class=\"headerlink\" title=\"使用多阶段构建\"></a>使用多阶段构建</h2><p>多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。<br>通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多阶段构建示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-sdk AS build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 拷贝项目文件并还原依赖项</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"comment\"># 构建发布版本</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> dotnet publish <span class=\"string\">&quot;src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj&quot;</span> -c Release -o /app/publish</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-runtime</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 从构建镜像阶段复制发布的文件到运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /app/publish .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;dotnet&quot;</span>, <span class=\"string\">&quot;Uranus.DatacenterMH.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"定期清理镜像和容器\"><a href=\"#定期清理镜像和容器\" class=\"headerlink\" title=\"定期清理镜像和容器\"></a>定期清理镜像和容器</h2><p>定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>结语<br>通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。</p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在构建Docker镜像时，Dockerfile的层数对镜像的性能和大小有显著影响。本文将深入探讨Dockerfile中的层定义、层数多带来的问题，以及如何通过优化Dockerfile来减少层数，提高构建效率和运行性能。</p>\n<h1 id=\"Dockerfile中的层定义\"><a href=\"#Dockerfile中的层定义\" class=\"headerlink\" title=\"Dockerfile中的层定义\"></a>Dockerfile中的层定义</h1><p>在Dockerfile中，每一个指令（如RUN、COPY、ADD等）都会创建一个新的层。Docker采用联合文件系统（UnionFS），每一层都是只读的，只有最顶层是可写的。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 每一条指令都会创建一个新层</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>上面的Dockerfile创建了四个层：FROM、WORKDIR、COPY和RUN。</p>\n<p>在Docker中，每个RUN指令都会创建一个新的层，这个层主要包含的是该指令执行过程中对文件系统所做的更改。具体来说，一个RUN指令会生成一个文件系统层，其中包含以下内容：</p>\n<ol>\n<li><p>新增的文件和目录：RUN指令中执行的命令可能会创建新的文件和目录。例如，使用RUN apt-get install命令安装软件包时，会在文件系统中创建新的文件和目录来存放这些软件包。</p>\n</li>\n<li><p>修改的文件和目录：如果RUN指令修改了已有的文件或目录，这些修改也会被记录在这一层中。例如，修改配置文件或更新现有的软件包。</p>\n</li>\n<li><p>删除的文件和目录：如果RUN指令删除了某些文件或目录，这些删除操作也会记录在这一层中。</p>\n</li>\n<li><p>文件权限的更改：RUN指令可能会改变文件或目录的权限，这些权限更改也会包含在这一层中。</p>\n</li>\n</ol>\n<p>为了更具体地说明，下面是一个示例Dockerfile及其解释：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">20.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; apt-get install -y curl</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Hello, World!&quot;</span> &gt; /hello.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第三层</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">chmod</span> 644 /hello.txt</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，每个RUN指令都会创建一个新的层：</p>\n<ol>\n<li>第一层：RUN apt-get update &amp;&amp; apt-get install -y curl：</li>\n</ol>\n<ul>\n<li>这一层包含了更新包索引文件和安装curl工具所做的所有更改。</li>\n<li>新增了curl工具的相关文件和目录。</li>\n<li>修改了包管理器的状态文件。</li>\n</ul>\n<ol start=\"2\">\n<li>第二层：RUN echo “Hello, World!” &gt; &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了创建&#x2F;hello.txt文件并向其中写入”Hello, World!”的操作。</li>\n<li>新增了文件&#x2F;hello.txt。</li>\n</ul>\n<ol start=\"3\">\n<li>第三层：RUN chmod 644 &#x2F;hello.txt：</li>\n</ol>\n<ul>\n<li>这一层包含了对文件&#x2F;hello.txt的权限更改。</li>\n<li>修改了文件&#x2F;hello.txt的权限信息。</li>\n</ul>\n<p>每一层都会记录该层创建时的文件系统快照。Docker通过这种层级方式，使得每一层都可以被缓存和重用，从而提高构建速度和效率。</p>\n<h1 id=\"层带来的好处\"><a href=\"#层带来的好处\" class=\"headerlink\" title=\"层带来的好处\"></a>层带来的好处</h1><p>Docker 镜像由多个只读层组成，这些层通过 Union File System（联合文件系统）组合在一起，形成一个统一的文件系统视图。每一层对应 Dockerfile 中的一条指令，并且每一层都是前一层的增量变化。这些层被称为镜像层。</p>\n<h2 id=\"层的重用机制\"><a href=\"#层的重用机制\" class=\"headerlink\" title=\"层的重用机制\"></a>层的重用机制</h2><p>层的重用主要是通过以下几个步骤实现的：</p>\n<ol>\n<li><p>层的哈希值：当 Docker 执行一条指令时，会计算这条指令生成的文件系统变化的哈希值。这个哈希值用于唯一标识这层内容。如果相同的指令生成了相同的文件系统变化，那么它们的哈希值也会相同。</p>\n</li>\n<li><p>层缓存：Docker 会在本地存储层缓存，这些缓存是基于层的哈希值存储的。当构建新的镜像时，Docker 会检查本地是否已经存在相同哈希值的层。如果存在，Docker 就会重用这个层，而不是重新创建。</p>\n</li>\n<li><p>层的共享：由于每个层是只读的，因此多个镜像可以共享相同的层。这样不仅节省了存储空间，还加快了镜像的构建速度。</p>\n</li>\n</ol>\n<h2 id=\"层的重用示例\"><a href=\"#层的重用示例\" class=\"headerlink\" title=\"层的重用示例\"></a>层的重用示例</h2><p>假设我们有一个简单的 Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>为了验证，这里我们构建了两个镜像。第一个requirements.txt是空的，而第二个镜像构建之前，我们在requirements.txt里面输入如下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># requirements.txt 示例</span><br><span class=\"line\">flask</span><br><span class=\"line\">requests</span><br></pre></td></tr></table></figure>\n<p>根据我们上面说所的，如果我们修改了 requirements.txt 文件，那么对应的 COPY requirements.txt . 和 RUN pip install -r requirements.txt 这两条指令会生成新的层。然而，其余的层（比如 FROM python:3.8-slim、WORKDIR &#x2F;app、COPY . . 和 CMD [“python”, “app.py”]）由于没有变化，可以直接从缓存中重用。</p>\n<p>构建完镜像以后，让我们inspect一下镜像<br><img src=\"/blog/images/docker-2/inspect1.png\" alt=\"inspect1\"><img src=\"/blog/images/docker-2/inspect2.png\" alt=\"inspect2\"></p>\n<p>我们对比一下这些层hash，可以清晰的看到没有变化的层的hash也是一样的。由此可见，这些层确实重用了。<br><img src=\"/blog/images/docker-2/inspect3.png\" alt=\"inspect3\"></p>\n<h1 id=\"层数多带来的问题\"><a href=\"#层数多带来的问题\" class=\"headerlink\" title=\"层数多带来的问题\"></a>层数多带来的问题</h1><p>层数多会导致以下几个问题：</p>\n<ol>\n<li>镜像大小增加：每一层都会增加镜像的总体大小，特别是在有大量中间层的情况下。</li>\n<li>构建时间增加：每一层都需要单独构建和缓存，层数越多，构建时间越长。</li>\n<li>性能开销：在运行容器时，Docker需要处理每一层的文件系统，这会增加I&#x2F;O操作的开销。</li>\n</ol>\n<h1 id=\"减少Dockerfile层数的方法\"><a href=\"#减少Dockerfile层数的方法\" class=\"headerlink\" title=\"减少Dockerfile层数的方法\"></a>减少Dockerfile层数的方法</h1><p>合并指令<br>将多个指令合并到一个RUN指令中，可以显著减少层数。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将多个RUN指令合并到一个</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y package1 package2 &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>\n\n<p>减少临时文件<br>在构建过程中，避免创建不必要的临时文件，可以减少层的大小。例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用多行命令避免临时文件</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> wget -qO- https://example.com/file.tar.gz | tar xz -C /path/to/destination</span></span><br></pre></td></tr></table></figure>\n<p>使用.dockerignore<br>类似于.gitignore，.dockerignore文件可以指定在构建镜像时忽略哪些文件和目录，从而减少不必要的层。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .dockerignore 文件示例</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">.git</span><br><span class=\"line\">.tmp</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际案例：优化一个Dockerfile\"><a href=\"#实际案例：优化一个Dockerfile\" class=\"headerlink\" title=\"实际案例：优化一个Dockerfile\"></a>实际案例：优化一个Dockerfile</h1><p>原始Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> pip install -r requirements.txt</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get install -y curl</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get clean</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>优化后的Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 优化后的Dockerfile，减少层数</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> python:<span class=\"number\">3.8</span>-slim</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并COPY和RUN指令</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> requirements.txt ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get install -y curl &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    pip install -r requirements.txt &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    apt-get clean &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"language-bash\">    <span class=\"built_in\">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用.dockerignore忽略不必要的文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;python&quot;</span>, <span class=\"string\">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n<p>我们来看看优化前后镜像的大小。从下图可以看到，仅仅是很小的改动，镜像就小了20M。<br><img src=\"/blog/images/docker-2/after.png\" alt=\"优化dockerfile\"></p>\n<h1 id=\"其他优化技巧\"><a href=\"#其他优化技巧\" class=\"headerlink\" title=\"其他优化技巧\"></a>其他优化技巧</h1><h2 id=\"使用多阶段构建\"><a href=\"#使用多阶段构建\" class=\"headerlink\" title=\"使用多阶段构建\"></a>使用多阶段构建</h2><p>多阶段构建允许你在一个Dockerfile中使用多个FROM指令，从而在构建过程中只保留最终阶段的镜像，减少不必要的层。下面这个例子中，我们将.net项目的编译和运行分开构建。<br>通过这样的方式，我们在最后运行的镜像里面不需要包含.net sdk，而只有运行时，从而缩小镜像的大小。</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 多阶段构建示例</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-sdk AS build</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 拷贝项目文件并还原依赖项</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"><span class=\"comment\"># 构建发布版本</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> dotnet publish <span class=\"string\">&quot;src/Uranus.DatacenterMH/Uranus.DatacenterMH.csproj&quot;</span> -c Release -o /app/publish</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> net8-runtime</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"><span class=\"comment\"># 从构建镜像阶段复制发布的文件到运行时镜像</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> --from=build /app/publish .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;dotnet&quot;</span>, <span class=\"string\">&quot;Uranus.DatacenterMH.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"定期清理镜像和容器\"><a href=\"#定期清理镜像和容器\" class=\"headerlink\" title=\"定期清理镜像和容器\"></a>定期清理镜像和容器</h2><p>定期清理未使用的镜像和容器，可以保持Docker环境的干净，避免不必要的存储开销。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理未使用的镜像</span></span><br><span class=\"line\">docker image prune -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理未使用的容器</span></span><br><span class=\"line\">docker container prune</span><br></pre></td></tr></table></figure>\n\n<p>结语<br>通过理解Dockerfile中的层定义和层数对性能的影响，可以更好地优化镜像构建过程。合并指令、减少临时文件、使用.dockerignore以及多阶段构建都是有效的减少层数的方法。希望本文能帮助你在实际项目中更高效地使用Docker，构建更轻量级、更快速的容器镜像。</p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"减少 Docker 日志大小：实用的日志管理指南","date":"2025-02-05T07:40:48.000Z","_content":"之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。\n\n在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。\n\n# Docker 日志机制概述\nDocker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 /var/lib/docker/containers/[container-id]/ 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。\n\nDocker 提供了多种日志驱动方式，例如：\n\n- json-file（默认）\n- syslog\n- journald\n- fluentd\n- gelf\n- awslogs\n- none（不记录日志）\n\n通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。\n\n# 为什么 Docker 日志会膨胀？\n让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。\n\n发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。\n\n同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。\n\n\n# 减少 Docker 日志大小的有效策略\n## 使用合适的日志驱动\n选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。\n\n示例：将 Docker 容器日志发送到 syslog\n```bash\ndocker run --log-driver=syslog --name my-container my-image\n```\n## 限制日志文件大小和日志文件数量\nDocker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。\n\n使用 --log-opt 参数可以设置以下选项：\n\n- max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。\n- max-file：设置最多保存多少个轮换的日志文件。\n\n示例：限制日志文件大小和数量\n```bash\ndocker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image\n```\n在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。\n\n也可以通过配置文件（如 /etc/docker/daemon.json）来全局设置日志驱动和日志选项。\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n要应用更改，还需重启 Docker 服务：\n```bash\nsudo systemctl restart docker\n```\n<font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font>\n\n要将更改应用于现有容器，必须先删除它们，然后重新创建它们\n```bash\ndocker rm -f <container_id_or_name>\n```\n\n再次查看容器详情，你会看到日志选项已经被设置。\n![日志文件](./images/docker-log/log5.png)\n\n## 禁用日志\n如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。\n\n示例：禁用日志记录\n```bash\ndocker run --log-driver=none --name my-container my-image\n```\n\n## 定期清理旧日志文件\n虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。\n\n\n### 检查容器日志大小\n\nDocker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：\n\n```bash\n/var/lib/docker/containers/<container-id>/<container-id>-json.log\n```\n每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。\n\n要快速检查所有 Docker 容器日志的大小，可以使用以下命令：\n\n```bash\nfind /var/lib/docker/containers/ -name \"*json.log\" | xargs du -h | sort -rh\n```\n这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。\n\n![日志文件](./images/docker-log/log1.png)\n\n### 根据日志文件 ID 查找容器名称\n现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。\n\n要查找该容器的名称，可以运行以下命令：\n\n```bash\ndocker inspect --format='{{.Name}}' <container_id>\n```\n对于我们的例子：\n\n```bash\ndocker inspect --format='{{.Name}}' 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4\n```\n这将返回容器的名称，如下图。\n![日志文件](./images/docker-log/log2.png)\n\n要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。\n```bash\ndocker inspect registry_registry_1\n```\n\n![日志文件](./images/docker-log/log3.png)\n\n或者直接使用如下命令查看容器日志路径信息\n```bash\ndocker inspect --format='{{.LogPath}}' registry_registry_1\n```\n![日志文件](./images/docker-log/log4.png)\n\n### 清理 Docker 容器日志\n一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。\n\n要清理特定容器的日志文件，可以使用 truncate 命令。例如：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log\n```\n如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/*/*-json.log\n```\n这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。\n\n## 配置容器的标准输出和标准错误输出\nDocker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。\n\n## 使用日志聚合和集中化\n使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：\n\n- Elasticsearch + Logstash + Kibana（ELK）\n- Fluentd\n- Graylog\n- Splunk\n\n这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。\n\n## 使用外部日志存储\n将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：\n\n```bash\ndocker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image\n```\n\n# 监控 Docker 日志大小\n为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。\n\n# 小结\n\nDocker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。\n\n----\n\n这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。","source":"_posts/docker-log.md","raw":"---\ntitle: 减少 Docker 日志大小：实用的日志管理指南\ndate: 2025-02-05 15:40:48\ntags:\n---\n之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。\n\n在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。\n\n# Docker 日志机制概述\nDocker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 /var/lib/docker/containers/[container-id]/ 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。\n\nDocker 提供了多种日志驱动方式，例如：\n\n- json-file（默认）\n- syslog\n- journald\n- fluentd\n- gelf\n- awslogs\n- none（不记录日志）\n\n通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。\n\n# 为什么 Docker 日志会膨胀？\n让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。\n\n发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。\n\n同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。\n\n\n# 减少 Docker 日志大小的有效策略\n## 使用合适的日志驱动\n选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。\n\n示例：将 Docker 容器日志发送到 syslog\n```bash\ndocker run --log-driver=syslog --name my-container my-image\n```\n## 限制日志文件大小和日志文件数量\nDocker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。\n\n使用 --log-opt 参数可以设置以下选项：\n\n- max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。\n- max-file：设置最多保存多少个轮换的日志文件。\n\n示例：限制日志文件大小和数量\n```bash\ndocker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image\n```\n在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。\n\n也可以通过配置文件（如 /etc/docker/daemon.json）来全局设置日志驱动和日志选项。\n```json\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n要应用更改，还需重启 Docker 服务：\n```bash\nsudo systemctl restart docker\n```\n<font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font>\n\n要将更改应用于现有容器，必须先删除它们，然后重新创建它们\n```bash\ndocker rm -f <container_id_or_name>\n```\n\n再次查看容器详情，你会看到日志选项已经被设置。\n![日志文件](./images/docker-log/log5.png)\n\n## 禁用日志\n如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。\n\n示例：禁用日志记录\n```bash\ndocker run --log-driver=none --name my-container my-image\n```\n\n## 定期清理旧日志文件\n虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。\n\n\n### 检查容器日志大小\n\nDocker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：\n\n```bash\n/var/lib/docker/containers/<container-id>/<container-id>-json.log\n```\n每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。\n\n要快速检查所有 Docker 容器日志的大小，可以使用以下命令：\n\n```bash\nfind /var/lib/docker/containers/ -name \"*json.log\" | xargs du -h | sort -rh\n```\n这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。\n\n![日志文件](./images/docker-log/log1.png)\n\n### 根据日志文件 ID 查找容器名称\n现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。\n\n要查找该容器的名称，可以运行以下命令：\n\n```bash\ndocker inspect --format='{{.Name}}' <container_id>\n```\n对于我们的例子：\n\n```bash\ndocker inspect --format='{{.Name}}' 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4\n```\n这将返回容器的名称，如下图。\n![日志文件](./images/docker-log/log2.png)\n\n要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。\n```bash\ndocker inspect registry_registry_1\n```\n\n![日志文件](./images/docker-log/log3.png)\n\n或者直接使用如下命令查看容器日志路径信息\n```bash\ndocker inspect --format='{{.LogPath}}' registry_registry_1\n```\n![日志文件](./images/docker-log/log4.png)\n\n### 清理 Docker 容器日志\n一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。\n\n要清理特定容器的日志文件，可以使用 truncate 命令。例如：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log\n```\n如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：\n\n```bash\ntruncate -s 0 /var/lib/docker/containers/*/*-json.log\n```\n这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。\n\n## 配置容器的标准输出和标准错误输出\nDocker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。\n\n## 使用日志聚合和集中化\n使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：\n\n- Elasticsearch + Logstash + Kibana（ELK）\n- Fluentd\n- Graylog\n- Splunk\n\n这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。\n\n## 使用外部日志存储\n将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：\n\n```bash\ndocker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image\n```\n\n# 监控 Docker 日志大小\n为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。\n\n# 小结\n\nDocker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。\n\n----\n\n这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。","slug":"docker-log","published":1,"updated":"2025-02-06T08:52:43.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawb0009rkp1flnv52tk","content":"<p>之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。</p>\n<p>在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。</p>\n<h1 id=\"Docker-日志机制概述\"><a href=\"#Docker-日志机制概述\" class=\"headerlink\" title=\"Docker 日志机制概述\"></a>Docker 日志机制概述</h1><p>Docker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;[container-id]&#x2F; 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。</p>\n<p>Docker 提供了多种日志驱动方式，例如：</p>\n<ul>\n<li>json-file（默认）</li>\n<li>syslog</li>\n<li>journald</li>\n<li>fluentd</li>\n<li>gelf</li>\n<li>awslogs</li>\n<li>none（不记录日志）</li>\n</ul>\n<p>通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。</p>\n<h1 id=\"为什么-Docker-日志会膨胀？\"><a href=\"#为什么-Docker-日志会膨胀？\" class=\"headerlink\" title=\"为什么 Docker 日志会膨胀？\"></a>为什么 Docker 日志会膨胀？</h1><p>让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。</p>\n<p>发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。</p>\n<p>同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。</p>\n<h1 id=\"减少-Docker-日志大小的有效策略\"><a href=\"#减少-Docker-日志大小的有效策略\" class=\"headerlink\" title=\"减少 Docker 日志大小的有效策略\"></a>减少 Docker 日志大小的有效策略</h1><h2 id=\"使用合适的日志驱动\"><a href=\"#使用合适的日志驱动\" class=\"headerlink\" title=\"使用合适的日志驱动\"></a>使用合适的日志驱动</h2><p>选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。</p>\n<p>示例：将 Docker 容器日志发送到 syslog</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=syslog --name my-container my-image</span><br></pre></td></tr></table></figure>\n<h2 id=\"限制日志文件大小和日志文件数量\"><a href=\"#限制日志文件大小和日志文件数量\" class=\"headerlink\" title=\"限制日志文件大小和日志文件数量\"></a>限制日志文件大小和日志文件数量</h2><p>Docker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。</p>\n<p>使用 –log-opt 参数可以设置以下选项：</p>\n<ul>\n<li>max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。</li>\n<li>max-file：设置最多保存多少个轮换的日志文件。</li>\n</ul>\n<p>示例：限制日志文件大小和数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。</p>\n<p>也可以通过配置文件（如 &#x2F;etc&#x2F;docker&#x2F;daemon.json）来全局设置日志驱动和日志选项。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>要应用更改，还需重启 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font></p>\n<p>要将更改应用于现有容器，必须先删除它们，然后重新创建它们</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> -f &lt;container_id_or_name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>再次查看容器详情，你会看到日志选项已经被设置。<br><img src=\"/blog/./images/docker-log/log5.png\" alt=\"日志文件\"></p>\n<h2 id=\"禁用日志\"><a href=\"#禁用日志\" class=\"headerlink\" title=\"禁用日志\"></a>禁用日志</h2><p>如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。</p>\n<p>示例：禁用日志记录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=none --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定期清理旧日志文件\"><a href=\"#定期清理旧日志文件\" class=\"headerlink\" title=\"定期清理旧日志文件\"></a>定期清理旧日志文件</h2><p>虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。</p>\n<h3 id=\"检查容器日志大小\"><a href=\"#检查容器日志大小\" class=\"headerlink\" title=\"检查容器日志大小\"></a>检查容器日志大小</h3><p>Docker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</span><br></pre></td></tr></table></figure>\n<p>每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。</p>\n<p>要快速检查所有 Docker 容器日志的大小，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /var/lib/docker/containers/ -name <span class=\"string\">&quot;*json.log&quot;</span> | xargs <span class=\"built_in\">du</span> -h | <span class=\"built_in\">sort</span> -rh</span><br></pre></td></tr></table></figure>\n<p>这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。</p>\n<p><img src=\"/blog/./images/docker-log/log1.png\" alt=\"日志文件\"></p>\n<h3 id=\"根据日志文件-ID-查找容器名称\"><a href=\"#根据日志文件-ID-查找容器名称\" class=\"headerlink\" title=\"根据日志文件 ID 查找容器名称\"></a>根据日志文件 ID 查找容器名称</h3><p>现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。</p>\n<p>要查找该容器的名称，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br></pre></td></tr></table></figure>\n<p>对于我们的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4</span><br></pre></td></tr></table></figure>\n<p>这将返回容器的名称，如下图。<br><img src=\"/blog/./images/docker-log/log2.png\" alt=\"日志文件\"></p>\n<p>要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect registry_registry_1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/docker-log/log3.png\" alt=\"日志文件\"></p>\n<p>或者直接使用如下命令查看容器日志路径信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> registry_registry_1</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/docker-log/log4.png\" alt=\"日志文件\"></p>\n<h3 id=\"清理-Docker-容器日志\"><a href=\"#清理-Docker-容器日志\" class=\"headerlink\" title=\"清理 Docker 容器日志\"></a>清理 Docker 容器日志</h3><p>一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。</p>\n<p>要清理特定容器的日志文件，可以使用 truncate 命令。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log</span><br></pre></td></tr></table></figure>\n<p>如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/*/*-json.log</span><br></pre></td></tr></table></figure>\n<p>这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。</p>\n<h2 id=\"配置容器的标准输出和标准错误输出\"><a href=\"#配置容器的标准输出和标准错误输出\" class=\"headerlink\" title=\"配置容器的标准输出和标准错误输出\"></a>配置容器的标准输出和标准错误输出</h2><p>Docker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。</p>\n<h2 id=\"使用日志聚合和集中化\"><a href=\"#使用日志聚合和集中化\" class=\"headerlink\" title=\"使用日志聚合和集中化\"></a>使用日志聚合和集中化</h2><p>使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：</p>\n<ul>\n<li>Elasticsearch + Logstash + Kibana（ELK）</li>\n<li>Fluentd</li>\n<li>Graylog</li>\n<li>Splunk</li>\n</ul>\n<p>这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。</p>\n<h2 id=\"使用外部日志存储\"><a href=\"#使用外部日志存储\" class=\"headerlink\" title=\"使用外部日志存储\"></a>使用外部日志存储</h2><p>将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"监控-Docker-日志大小\"><a href=\"#监控-Docker-日志大小\" class=\"headerlink\" title=\"监控 Docker 日志大小\"></a>监控 Docker 日志大小</h1><p>为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>Docker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。</p>\n<hr>\n<p>这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之所以选择这个主题，是因为最近，我发现我的一台服务器的可用磁盘空间不足，几乎就要满了。经过调查，我发现一个 Docker 容器在短短半年内就积累了 2.7G 的日志文件。</p>\n<p>在现代开发和运维中，Docker 已成为开发者的常用工具，但在高负载和高并发的环境下，Docker 容器生成的日志文件可能会迅速膨胀，占用大量磁盘空间，甚至导致系统性能问题。本文将探讨如何有效地管理和减少 Docker 日志的大小，确保日志的高效存储和易于管理。</p>\n<h1 id=\"Docker-日志机制概述\"><a href=\"#Docker-日志机制概述\" class=\"headerlink\" title=\"Docker 日志机制概述\"></a>Docker 日志机制概述</h1><p>Docker 默认使用 json-file 日志驱动来记录容器的标准输出和标准错误输出。这些日志通常会存储在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;[container-id]&#x2F; 路径下，文件名为 container-id-json.log。随着容器的运行，日志文件会不断增长，甚至变得庞大无比。</p>\n<p>Docker 提供了多种日志驱动方式，例如：</p>\n<ul>\n<li>json-file（默认）</li>\n<li>syslog</li>\n<li>journald</li>\n<li>fluentd</li>\n<li>gelf</li>\n<li>awslogs</li>\n<li>none（不记录日志）</li>\n</ul>\n<p>通过选择合适的日志驱动并配置日志管理策略，能够帮助我们避免日志文件的无限膨胀。</p>\n<h1 id=\"为什么-Docker-日志会膨胀？\"><a href=\"#为什么-Docker-日志会膨胀？\" class=\"headerlink\" title=\"为什么 Docker 日志会膨胀？\"></a>为什么 Docker 日志会膨胀？</h1><p>让我们回到上面我自己的案例。在过去的半年里，服务器已经重启多次，这意味着 Docker 容器也曾被停止和启动过。然而，它们的日志文件一直存在并且持续增长。</p>\n<p>发生这种情况的原因在于我的容器是重新启动，而不是重新创建容器。当服务器重新启动时，Docker 守护进程会正常关闭正在运行的容器，并在启动后自动启动它们。</p>\n<p>同样，使用“systemctl restart docker”命令手动重启 Docker 服务时，行为也是一样的。重要的是要了解，只有在删除并重新创建 Docker 容器时，Docker 日志才会重置。简单地停止并启动容器不会重置日志。</p>\n<h1 id=\"减少-Docker-日志大小的有效策略\"><a href=\"#减少-Docker-日志大小的有效策略\" class=\"headerlink\" title=\"减少 Docker 日志大小的有效策略\"></a>减少 Docker 日志大小的有效策略</h1><h2 id=\"使用合适的日志驱动\"><a href=\"#使用合适的日志驱动\" class=\"headerlink\" title=\"使用合适的日志驱动\"></a>使用合适的日志驱动</h2><p>选择正确的日志驱动是管理日志文件大小的第一步。如果你不需要将日志保留在本地磁盘，可以选择将日志直接转发到远程服务器或日志聚合系统。常见的日志驱动如 syslog 和 fluentd 可以将日志发送到外部日志管理平台，如 Elasticsearch、Logstash 或 Kibana（ELK），或者云端服务。</p>\n<p>示例：将 Docker 容器日志发送到 syslog</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=syslog --name my-container my-image</span><br></pre></td></tr></table></figure>\n<h2 id=\"限制日志文件大小和日志文件数量\"><a href=\"#限制日志文件大小和日志文件数量\" class=\"headerlink\" title=\"限制日志文件大小和日志文件数量\"></a>限制日志文件大小和日志文件数量</h2><p>Docker 允许你在启动容器时设置日志的最大文件大小和最大日志文件数。这有助于防止日志文件无限增长，从而节省磁盘空间。</p>\n<p>使用 –log-opt 参数可以设置以下选项：</p>\n<ul>\n<li>max-size：设置日志文件的最大大小，超过该大小时会自动轮换日志文件。</li>\n<li>max-file：设置最多保存多少个轮换的日志文件。</li>\n</ul>\n<p>示例：限制日志文件大小和数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=json-file --log-opt max-size=10m --log-opt max-file=3 --name my-container my-image</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，每个日志文件的最大大小为 10MB，当文件达到该大小时会进行轮换，最多保存 3 个轮换文件。</p>\n<p>也可以通过配置文件（如 &#x2F;etc&#x2F;docker&#x2F;daemon.json）来全局设置日志驱动和日志选项。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-driver&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;json-file&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;log-opts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-size&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10m&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;max-file&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>要应用更改，还需重启 Docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">需要注意的是，这些更改只会影响新创建的 Docker 容器，而不会影响已经运行的容器</font></p>\n<p>要将更改应用于现有容器，必须先删除它们，然后重新创建它们</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> -f &lt;container_id_or_name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>再次查看容器详情，你会看到日志选项已经被设置。<br><img src=\"/blog/./images/docker-log/log5.png\" alt=\"日志文件\"></p>\n<h2 id=\"禁用日志\"><a href=\"#禁用日志\" class=\"headerlink\" title=\"禁用日志\"></a>禁用日志</h2><p>如果容器的日志完全不需要存储，或者你决定将日志流转到其他地方，可以选择禁用 Docker 容器的日志记录。这种做法适合那些对于日志并不重要的应用。</p>\n<p>示例：禁用日志记录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=none --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定期清理旧日志文件\"><a href=\"#定期清理旧日志文件\" class=\"headerlink\" title=\"定期清理旧日志文件\"></a>定期清理旧日志文件</h2><p>虽然 Docker 提供了日志轮换功能，但一些过期的日志文件可能会积累在磁盘上。定期清理旧日志文件可以确保磁盘空间得到合理利用。</p>\n<h3 id=\"检查容器日志大小\"><a href=\"#检查容器日志大小\" class=\"headerlink\" title=\"检查容器日志大小\"></a>检查容器日志大小</h3><p>Docker 日志通常保存在主机上的以下目录中（除非你更改了默认路径）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</span><br></pre></td></tr></table></figure>\n<p>每个 Docker 容器都有自己的目录，且在该目录下，你会找到一个以 -json.log 结尾的文件。这个文件包含该容器的标准输出（stdout）和标准错误（stderr）流。</p>\n<p>要快速检查所有 Docker 容器日志的大小，可以使用以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /var/lib/docker/containers/ -name <span class=\"string\">&quot;*json.log&quot;</span> | xargs <span class=\"built_in\">du</span> -h | <span class=\"built_in\">sort</span> -rh</span><br></pre></td></tr></table></figure>\n<p>这个命令将显示所有 Docker 容器日志的大小，并按从大到小的顺序排序，帮助你找出哪个容器占用了最多的磁盘空间。</p>\n<p><img src=\"/blog/./images/docker-log/log1.png\" alt=\"日志文件\"></p>\n<h3 id=\"根据日志文件-ID-查找容器名称\"><a href=\"#根据日志文件-ID-查找容器名称\" class=\"headerlink\" title=\"根据日志文件 ID 查找容器名称\"></a>根据日志文件 ID 查找容器名称</h3><p>现在我们知道了日志文件的大小，接下来是将容器 ID 与实际容器名称匹配。例如，假设你发现了一个非常大的日志文件，容器 ID 是 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4。</p>\n<p>要查找该容器的名称，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br></pre></td></tr></table></figure>\n<p>对于我们的例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.Name&#125;&#125;&#x27;</span> 3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4</span><br></pre></td></tr></table></figure>\n<p>这将返回容器的名称，如下图。<br><img src=\"/blog/./images/docker-log/log2.png\" alt=\"日志文件\"></p>\n<p>要再次检查这是否是生成日志文件的正确容器，您可以使用命令docker inspect <container_name>获取有关它的更多详细信息并确认它是日志文件的来源。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect registry_registry_1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/docker-log/log3.png\" alt=\"日志文件\"></p>\n<p>或者直接使用如下命令查看容器日志路径信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect --format=<span class=\"string\">&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27;</span> registry_registry_1</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/docker-log/log4.png\" alt=\"日志文件\"></p>\n<h3 id=\"清理-Docker-容器日志\"><a href=\"#清理-Docker-容器日志\" class=\"headerlink\" title=\"清理 Docker 容器日志\"></a>清理 Docker 容器日志</h3><p>一旦你确认了哪个容器导致了日志文件膨胀，接下来就可以清理这些日志文件以释放磁盘空间。</p>\n<p>要清理特定容器的日志文件，可以使用 truncate 命令。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4/3908b66962bca22ddb818a8df1a61c9003a23283a932d44d1c91631d9de7e3e4-json.log</span><br></pre></td></tr></table></figure>\n<p>如果你想一次性清理所有 Docker 容器的日志，可以运行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">truncate</span> -s 0 /var/lib/docker/containers/*/*-json.log</span><br></pre></td></tr></table></figure>\n<p>这个命令会清理所有容器的日志文件。使用之前请确保理解其影响，因为这将删除所有日志。</p>\n<h2 id=\"配置容器的标准输出和标准错误输出\"><a href=\"#配置容器的标准输出和标准错误输出\" class=\"headerlink\" title=\"配置容器的标准输出和标准错误输出\"></a>配置容器的标准输出和标准错误输出</h2><p>Docker 容器的标准输出和标准错误输出可能包含大量日志。你可以在容器内部或应用程序中通过配置日志框架来限制日志的级别（例如，设置日志级别为 ERROR，避免 DEBUG 和 INFO 级别的日志输出）。</p>\n<h2 id=\"使用日志聚合和集中化\"><a href=\"#使用日志聚合和集中化\" class=\"headerlink\" title=\"使用日志聚合和集中化\"></a>使用日志聚合和集中化</h2><p>使用集中化日志系统可以将日志存储和管理集中化，避免了每个 Docker 容器在本地存储大量日志。常见的日志聚合系统有：</p>\n<ul>\n<li>Elasticsearch + Logstash + Kibana（ELK）</li>\n<li>Fluentd</li>\n<li>Graylog</li>\n<li>Splunk</li>\n</ul>\n<p>这些系统不仅可以帮助你管理日志文件大小，还能为你提供强大的日志搜索、过滤和分析功能。</p>\n<h2 id=\"使用外部日志存储\"><a href=\"#使用外部日志存储\" class=\"headerlink\" title=\"使用外部日志存储\"></a>使用外部日志存储</h2><p>将 Docker 日志输出到外部存储系统，可以有效减少本地磁盘的使用。例如，AWS 提供了 awslogs 日志驱动，可以将日志直接发送到 CloudWatch 中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --log-driver=awslogs --log-opt awslogs-group=my-log-group --log-opt awslogs-stream=my-log-stream --name my-container my-image</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"监控-Docker-日志大小\"><a href=\"#监控-Docker-日志大小\" class=\"headerlink\" title=\"监控 Docker 日志大小\"></a>监控 Docker 日志大小</h1><p>为了及时发现日志文件异常增长，建议对 Docker 容器的日志大小进行监控。可以使用一些开源工具（如 logrotate）来自动清理过期日志，也可以结合 Prometheus 等监控工具来实时监控日志文件的大小。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>Docker 日志管理是一项关键的运维任务，尤其是在生产环境中，日志文件的大小和数量会直接影响系统的稳定性和可维护性。通过选择合适的日志驱动、配置日志轮换、定期清理旧日志以及利用集中化日志系统，可以有效地管理和减少 Docker 日志的大小。希望本文的技巧和策略能帮助你更好地管理 Docker 容器日志，保持系统的高效运行。</p>\n<hr>\n<p>这篇博客概述了减少 Docker 日志大小的几种实用方法，包括选择合适的日志驱动、设置日志轮换策略、禁用日志记录、定期清理过期日志等。你可以根据实际需求，调整策略来优化你的 Docker 环境。</p>\n"},{"title":"深入理解容器镜像层","date":"2024-08-08T06:58:18.000Z","_content":"\n之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！\n\n容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。\n\n# 构建分层图像\n创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：\n```\nFROM alpine\nRUN echo \"hello\" > /usr/file1.txt\nCOPY requirements.txt /usr/file2.txt\nRUN rm -rf /usr/file1.txt\n```\n在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。\n\n让我们逐步了解一种可能的实施方法的示例。\n\n1. FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示/img/layer1。\n\n2. 创建第二个目录/img/layer2。从/img/layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入/img/layer2/usr/file1.txt。这是第二层。\n\n3. 创建第三个目录/img/layer3。从img/layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。\n\n4. 最后，创建第四个目录/img/layer4。从img/layer3中拷贝所有内容。下一个命令删除消息文件img/layer4/usr/file1.txt。这是第四层。\n\n要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。\n\n继续我们的例子，压缩文件将包含：\n\n|文件|内容|\n|  ----  | ----  |\n|layer1.tar.gz|\t精简的linux基础环境|\n|layer2.tar.gz|\t包含/usr/file1.txt|\n|layer3.tar.gz|\t包含/usr/file2.txt（因为file1.txt未被修改）|\n|layer4.tar.gz|\t包含/usr/.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。|\n\n以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。\n\n为了使结果可重现，还需要一件事---一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。\n\n引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY --link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。\n\n# 快照\n在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。\n\n创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。\n\n使用我们之前的例子：\n\n1. 初始层，FROM alpine基础的linux环境；\n\n2. 创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含/work/file1.txt 的目录。这是第一个提交的快照。\n\n3. 创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含/work/file1.txt和/work/file2.txt的目录。这是第二个已提交的快照。\n\n4. 创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 /work/.wh.file1.txt，并删除/work/file1.txt。这样就只剩下/work/file2.txt。这是第三个已提交的快照。\n\n5. 由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。\n\n如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：\n\n```\n \"RootFS\": {\n    \"Type\": \"layers\",\n    \"Layers\": [\n        \"sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07\",\n        \"sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091\",\n        \"sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e\",\n        \"sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399\"\n    ]\n},\n``` \n\n实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。\n\n# 叠加层\n用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容\n![文件系统](/images/docker-layer/filesystem.png)\n\n\n看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？\n\n在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。\n\n每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。\n\n如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。\n\n这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100= 30GB 的文件。并且需要占用 30GB 的磁盘空间。\n\n当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。\n\n\n这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。\n\n事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。\n\n在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。\n\n虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。\n\n## 测试与分析\n下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：\n\n1. 创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）\n```\nmkdir /mytmpfs\nmount -t tmpfs tmpfs /mytmpfs\n```\n\n2. 为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。\n```\nsudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录\nsudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上\nsudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录\nsudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录\n```\n\n3. 为实验创建一些文件。\n```\ncd /mytmpfs\necho hello > lowerdir/hello.txt\necho \"delete me\" > lowerdir/delete-me.txt\necho message > upperdir/upper-message.txt\n```\n4. 将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork\n```\nmount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged\n```\n\n5. 查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：\n![merged](/images/docker-layer/merged.png)\n```\nrm -rf merged/delete-me.txt\necho \"I'm new one\" > merged/new.txt\necho world >> merged/hello.txt\n```\n6. 正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：\n![directory tree](/images/docker-layer/tree.png)\n\n当你在 merged 目录中执行 rm -rf merged/delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。\n   \n\n## 最终结果：\n\nupperdir/ 的文件结构：\n\n执行ls -l upperdir 可以看到如下结果\n![directory tree](/images/docker-layer/ls_upper.png)\n\n+ delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。\n+ hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。\n+ new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。\n+ upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。\n\n可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。\n\n\n希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/docker-layer.md","raw":"---\ntitle: 深入理解容器镜像层\ndate: 2024-08-08 14:58:18\ntags:\n---\n\n之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！\n\n容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。\n\n# 构建分层图像\n创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：\n```\nFROM alpine\nRUN echo \"hello\" > /usr/file1.txt\nCOPY requirements.txt /usr/file2.txt\nRUN rm -rf /usr/file1.txt\n```\n在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。\n\n让我们逐步了解一种可能的实施方法的示例。\n\n1. FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示/img/layer1。\n\n2. 创建第二个目录/img/layer2。从/img/layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入/img/layer2/usr/file1.txt。这是第二层。\n\n3. 创建第三个目录/img/layer3。从img/layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。\n\n4. 最后，创建第四个目录/img/layer4。从img/layer3中拷贝所有内容。下一个命令删除消息文件img/layer4/usr/file1.txt。这是第四层。\n\n要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。\n\n继续我们的例子，压缩文件将包含：\n\n|文件|内容|\n|  ----  | ----  |\n|layer1.tar.gz|\t精简的linux基础环境|\n|layer2.tar.gz|\t包含/usr/file1.txt|\n|layer3.tar.gz|\t包含/usr/file2.txt（因为file1.txt未被修改）|\n|layer4.tar.gz|\t包含/usr/.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。|\n\n以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。\n\n为了使结果可重现，还需要一件事---一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。\n\n引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY --link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。\n\n# 快照\n在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。\n\n创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。\n\n使用我们之前的例子：\n\n1. 初始层，FROM alpine基础的linux环境；\n\n2. 创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含/work/file1.txt 的目录。这是第一个提交的快照。\n\n3. 创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含/work/file1.txt和/work/file2.txt的目录。这是第二个已提交的快照。\n\n4. 创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 /work/.wh.file1.txt，并删除/work/file1.txt。这样就只剩下/work/file2.txt。这是第三个已提交的快照。\n\n5. 由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。\n\n如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：\n\n```\n \"RootFS\": {\n    \"Type\": \"layers\",\n    \"Layers\": [\n        \"sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07\",\n        \"sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091\",\n        \"sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e\",\n        \"sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399\"\n    ]\n},\n``` \n\n实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。\n\n# 叠加层\n用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容\n![文件系统](/images/docker-layer/filesystem.png)\n\n\n看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？\n\n在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。\n\n每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。\n\n如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。\n\n这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100= 30GB 的文件。并且需要占用 30GB 的磁盘空间。\n\n当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。\n\n\n这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。\n\n事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。\n\n在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。\n\n虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。\n\n## 测试与分析\n下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：\n\n1. 创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）\n```\nmkdir /mytmpfs\nmount -t tmpfs tmpfs /mytmpfs\n```\n\n2. 为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。\n```\nsudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录\nsudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上\nsudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录\nsudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录\n```\n\n3. 为实验创建一些文件。\n```\ncd /mytmpfs\necho hello > lowerdir/hello.txt\necho \"delete me\" > lowerdir/delete-me.txt\necho message > upperdir/upper-message.txt\n```\n4. 将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork\n```\nmount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged\n```\n\n5. 查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：\n![merged](/images/docker-layer/merged.png)\n```\nrm -rf merged/delete-me.txt\necho \"I'm new one\" > merged/new.txt\necho world >> merged/hello.txt\n```\n6. 正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：\n![directory tree](/images/docker-layer/tree.png)\n\n当你在 merged 目录中执行 rm -rf merged/delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。\n   \n\n## 最终结果：\n\nupperdir/ 的文件结构：\n\n执行ls -l upperdir 可以看到如下结果\n![directory tree](/images/docker-layer/ls_upper.png)\n\n+ delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。\n+ hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。\n+ new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。\n+ upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。\n\n可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。\n\n\n希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"docker-layer","published":1,"updated":"2024-08-12T07:41:01.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawb000arkp13klp0nhk","content":"<p>之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！</p>\n<p>容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。</p>\n<h1 id=\"构建分层图像\"><a href=\"#构建分层图像\" class=\"headerlink\" title=\"构建分层图像\"></a>构建分层图像</h1><p>创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine</span><br><span class=\"line\">RUN echo &quot;hello&quot; &gt; /usr/file1.txt</span><br><span class=\"line\">COPY requirements.txt /usr/file2.txt</span><br><span class=\"line\">RUN rm -rf /usr/file1.txt</span><br></pre></td></tr></table></figure>\n<p>在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。</p>\n<p>让我们逐步了解一种可能的实施方法的示例。</p>\n<ol>\n<li><p>FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示&#x2F;img&#x2F;layer1。</p>\n</li>\n<li><p>创建第二个目录&#x2F;img&#x2F;layer2。从&#x2F;img&#x2F;layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入&#x2F;img&#x2F;layer2&#x2F;usr&#x2F;file1.txt。这是第二层。</p>\n</li>\n<li><p>创建第三个目录&#x2F;img&#x2F;layer3。从img&#x2F;layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。</p>\n</li>\n<li><p>最后，创建第四个目录&#x2F;img&#x2F;layer4。从img&#x2F;layer3中拷贝所有内容。下一个命令删除消息文件img&#x2F;layer4&#x2F;usr&#x2F;file1.txt。这是第四层。</p>\n</li>\n</ol>\n<p>要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。</p>\n<p>继续我们的例子，压缩文件将包含：</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layer1.tar.gz</td>\n<td>精简的linux基础环境</td>\n</tr>\n<tr>\n<td>layer2.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file1.txt</td>\n</tr>\n<tr>\n<td>layer3.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file2.txt（因为file1.txt未被修改）</td>\n</tr>\n<tr>\n<td>layer4.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。</td>\n</tr>\n</tbody></table>\n<p>以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。</p>\n<p>为了使结果可重现，还需要一件事—一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。</p>\n<p>引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY –link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。</p>\n<h1 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h1><p>在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。</p>\n<p>创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。</p>\n<p>使用我们之前的例子：</p>\n<ol>\n<li><p>初始层，FROM alpine基础的linux环境；</p>\n</li>\n<li><p>创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含&#x2F;work&#x2F;file1.txt 的目录。这是第一个提交的快照。</p>\n</li>\n<li><p>创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含&#x2F;work&#x2F;file1.txt和&#x2F;work&#x2F;file2.txt的目录。这是第二个已提交的快照。</p>\n</li>\n<li><p>创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 &#x2F;work&#x2F;.wh.file1.txt，并删除&#x2F;work&#x2F;file1.txt。这样就只剩下&#x2F;work&#x2F;file2.txt。这是第三个已提交的快照。</p>\n</li>\n<li><p>由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。</p>\n</li>\n</ol>\n<p>如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;RootFS&quot;: &#123;</span><br><span class=\"line\">    &quot;Type&quot;: &quot;layers&quot;,</span><br><span class=\"line\">    &quot;Layers&quot;: [</span><br><span class=\"line\">        &quot;sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07&quot;,</span><br><span class=\"line\">        &quot;sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091&quot;,</span><br><span class=\"line\">        &quot;sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e&quot;,</span><br><span class=\"line\">        &quot;sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。</p>\n<h1 id=\"叠加层\"><a href=\"#叠加层\" class=\"headerlink\" title=\"叠加层\"></a>叠加层</h1><p>用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容<br><img src=\"/blog/images/docker-layer/filesystem.png\" alt=\"文件系统\"></p>\n<p>看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？</p>\n<p>在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。</p>\n<p>每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。</p>\n<p>如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。</p>\n<p>这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100&#x3D; 30GB 的文件。并且需要占用 30GB 的磁盘空间。</p>\n<p>当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。</p>\n<p>这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。</p>\n<p>事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。</p>\n<p>在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。</p>\n<p>虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。</p>\n<h2 id=\"测试与分析\"><a href=\"#测试与分析\" class=\"headerlink\" title=\"测试与分析\"></a>测试与分析</h2><p>下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：</p>\n<ol>\n<li><p>创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /mytmpfs</span><br><span class=\"line\">mount -t tmpfs tmpfs /mytmpfs</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为实验创建一些文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /mytmpfs</span><br><span class=\"line\">echo hello &gt; lowerdir/hello.txt</span><br><span class=\"line\">echo &quot;delete me&quot; &gt; lowerdir/delete-me.txt</span><br><span class=\"line\">echo message &gt; upperdir/upper-message.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：<br><img src=\"/blog/images/docker-layer/merged.png\" alt=\"merged\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf merged/delete-me.txt</span><br><span class=\"line\">echo &quot;I&#x27;m new one&quot; &gt; merged/new.txt</span><br><span class=\"line\">echo world &gt;&gt; merged/hello.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：<br><img src=\"/blog/images/docker-layer/tree.png\" alt=\"directory tree\"></p>\n</li>\n</ol>\n<p>当你在 merged 目录中执行 rm -rf merged&#x2F;delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。</p>\n<h2 id=\"最终结果：\"><a href=\"#最终结果：\" class=\"headerlink\" title=\"最终结果：\"></a>最终结果：</h2><p>upperdir&#x2F; 的文件结构：</p>\n<p>执行ls -l upperdir 可以看到如下结果<br><img src=\"/blog/images/docker-layer/ls_upper.png\" alt=\"directory tree\"></p>\n<ul>\n<li>delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。</li>\n<li>hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。</li>\n<li>new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。</li>\n<li>upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。</li>\n</ul>\n<p>可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。</p>\n<p>希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前我写了一篇博客《Docker镜像构建优化》，里面讲到了Docker里面的层，但是始终觉得差了点什么。今天这篇就算是补充一下吧！</p>\n<p>容器非常神奇。它们允许简单的进程像虚拟机一样运行。在这种优雅的背后是一套模式和实践，最终使一切正常运转。设计的根源是层。层是存储和分发容器化文件系统内容的基本方式。这种设计既出奇的简单，又非常强大。在今天的文章中，我将解释什么是层以及它们在概念上是如何工作的。</p>\n<h1 id=\"构建分层图像\"><a href=\"#构建分层图像\" class=\"headerlink\" title=\"构建分层图像\"></a>构建分层图像</h1><p>创建镜像时，通常使用 来Dockerfile定义容器的内容。它包含一系列命令，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM alpine</span><br><span class=\"line\">RUN echo &quot;hello&quot; &gt; /usr/file1.txt</span><br><span class=\"line\">COPY requirements.txt /usr/file2.txt</span><br><span class=\"line\">RUN rm -rf /usr/file1.txt</span><br></pre></td></tr></table></figure>\n<p>在幕后，容器引擎将按顺序执行这些命令，为每个命令创建一个“层”。但实际情况是什么？最简单的方法是将每个层视为一个包含所有修改文件的目录。</p>\n<p>让我们逐步了解一种可能的实施方法的示例。</p>\n<ol>\n<li><p>FROM alpine表示此容器从无内容开始。这是第一层，可以用空目录来表示&#x2F;img&#x2F;layer1。</p>\n</li>\n<li><p>创建第二个目录&#x2F;img&#x2F;layer2。从&#x2F;img&#x2F;layer1中拷贝所有内容。然后，从 Dockerfile 执行下一个命令，将“hello”写入&#x2F;img&#x2F;layer2&#x2F;usr&#x2F;file1.txt。这是第二层。</p>\n</li>\n<li><p>创建第三个目录&#x2F;img&#x2F;layer3。从img&#x2F;layer2中拷贝所有内容。从主机复制requirement.txt到该目录。这是第三层。</p>\n</li>\n<li><p>最后，创建第四个目录&#x2F;img&#x2F;layer4。从img&#x2F;layer3中拷贝所有内容。下一个命令删除消息文件img&#x2F;layer4&#x2F;usr&#x2F;file1.txt。这是第四层。</p>\n</li>\n</ol>\n<p>要共享这些层，最简单的方法是为每个目录创建一个压缩文件.tar.gz。为了减少总文件大小，任何未修改的来自前一层的数据副本的文件都将被删除。为了清楚地说明文件何时被删除，可以使用“空白文件”作为占位符。该文件只需.wh.作为原始文件名的前缀。例如，第四层将用名为 .wh.file1.txt 的占位符替换已删除的文件。当解压一个层时，可以删除任何以 .wh. 开头的文件。</p>\n<p>继续我们的例子，压缩文件将包含：</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>layer1.tar.gz</td>\n<td>精简的linux基础环境</td>\n</tr>\n<tr>\n<td>layer2.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file1.txt</td>\n</tr>\n<tr>\n<td>layer3.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;file2.txt（因为file1.txt未被修改）</td>\n</tr>\n<tr>\n<td>layer4.tar.gz</td>\n<td>包含&#x2F;usr&#x2F;.wh.file1.txt（因为file1.txt已被删除）。该文件file2.txt未被修改，因此不包含在内。</td>\n</tr>\n</tbody></table>\n<p>以这种方式构建大量镜像将产生大量“layer1”目录。为了确保名称唯一，压缩文件基于内容摘要命名。这类似于 Git 的工作方式。它的好处是可以在下载时识别文件损坏的同时识别相同的内容。如果内容摘要与文件名不匹配，则文件已损坏。</p>\n<p>为了使结果可重现，还需要一件事—一个解释如何对图层进行排序的文件（清单）。清单将标识要下载哪些文件以及解压它们的顺序。这可以重新创建目录结构。它还提供了一个重要的好处：图层可以在图像之间重复使用和共享。这最大限度地减少了本地存储控件。</p>\n<p>引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，可最大限度地减少构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用COPY –link来指示该层不需要删除或修改前一层的任何文件。这允许与其他步骤并行创建压缩层文件。</p>\n<h1 id=\"快照\"><a href=\"#快照\" class=\"headerlink\" title=\"快照\"></a>快照</h1><p>在容器运行之前，它需要挂载一个文件系统。本质上，它需要一个包含所有可用文件的目录。压缩层文件包含文件系统的组件，但不能直接挂载和使用。相反，它们需要解压并组织成一个文件系统。这个解压后的目录称为快照。</p>\n<p>创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每个层，都会创建一个目录，其中包含该层父级的内容。此目录称为活动快照。接下来，差异识别程序负责解压压缩的层文件并将更改应用于活动快照。生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。</p>\n<p>使用我们之前的例子：</p>\n<ol>\n<li><p>初始层，FROM alpine基础的linux环境；</p>\n</li>\n<li><p>创建一个目录layer2。这个空目录现在是一个活动快照。文件layer2.tar.gz被下载、验证（通过将摘要与文件名进行比较）并解压到目录中。结果是一个包含&#x2F;work&#x2F;file1.txt 的目录。这是第一个提交的快照。</p>\n</li>\n<li><p>创建一个目录layer3，并将layer2的内容复制到其中。这是一个新的活动快照。文件layer3.tar.gz下载、验证和解压。结果是一个包含&#x2F;work&#x2F;file1.txt和&#x2F;work&#x2F;file2.txt的目录。这是第二个已提交的快照。</p>\n</li>\n<li><p>创建的目录layer4，并将layer3 的内容复制到其中。layer4.tar.gz下载、验证和解压文件。diff applier识别 whiteout 文件 &#x2F;work&#x2F;.wh.file1.txt，并删除&#x2F;work&#x2F;file1.txt。这样就只剩下&#x2F;work&#x2F;file2.txt。这是第三个已提交的快照。</p>\n</li>\n<li><p>由于layer4是最后一层，因此它是容器的基础。为了使其支持读写操作，将创建一个新的快照目录并将的内容layer4复制到其中。此目录将挂载为容器的文件系统。正在运行的容器所做的任何更改都将在此目录中发生。</p>\n</li>\n</ol>\n<p>如果这些目录中的任何一个已经存在，则表明另一个映像具有相同的依赖关系。因此，引擎可以跳过下载和 差异识别。它可以按原样使用该层。实际上，这些目录和文件中的每一个都根据内容摘要命名，以便于识别。例如，一组快照可能如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;RootFS&quot;: &#123;</span><br><span class=\"line\">    &quot;Type&quot;: &quot;layers&quot;,</span><br><span class=\"line\">    &quot;Layers&quot;: [</span><br><span class=\"line\">        &quot;sha256:78561cef0761903dd2f7d09856150a6d4fb48967a8f113f3e33d79effbf59a07&quot;,</span><br><span class=\"line\">        &quot;sha256:48dcbf93fac08ef430c39a4924c0622c13f17548cec0ca5588a665a773f5d091&quot;,</span><br><span class=\"line\">        &quot;sha256:53e113db23922a5cc6d6c916a2a796f87e8db900d5a8ece3237cbcc4db9e5b7e&quot;,</span><br><span class=\"line\">        &quot;sha256:df7fa7c302ca914532aaa453ec101e5f21b1c3bb81b2f5046321aa40f2de1399&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许快照预先组合和解包，从而加快该过程。这允许快照远程存储。它还允许进行特殊优化，例如即时下载所需的文件和层。</p>\n<h1 id=\"叠加层\"><a href=\"#叠加层\" class=\"headerlink\" title=\"叠加层\"></a>叠加层</h1><p>用上面的镜像运行容器，并在容器内部查看文件系统可以看到类似下图内容<br><img src=\"/blog/images/docker-layer/filesystem.png\" alt=\"文件系统\"></p>\n<p>看到这里老铁们可能会有疑问，Overlay 是一个什么样的文件系统呢？</p>\n<p>在解释之前，我们先来假设有这么一个场景。在一个宿主机上需要运行 100 个容器。</p>\n<p>每个容器都需要一个镜像，这个镜像就把容器中程序需要运行的二进制文件、配置文件和其他的依赖文件等全部都打包成一个镜像文件。</p>\n<p>如果只是普通的 ext4 或者 xfs 文件系统，那么每次运行一个容器，就需要把一个镜像文件下载并且存储在宿主机上。</p>\n<p>这样一来，如果一个镜像文件的大小是 300MB，那么 100 个容器的话，就要下载 300MB*100&#x3D; 30GB 的文件。并且需要占用 30GB 的磁盘空间。</p>\n<p>当我们分析这下载的 30GB 的内容，不难发现，在绝大部分的操作系统里，库文件都是差不多的。而且，在容器运行的时候，这类文件也不会被改动，基本上都是只读的。特别是当我们这 100 个容器镜像都是基于同样的操作系统的时候，每个容器镜像只是额外复制了几十兆自己的应用程序系统里，那么就是说在这30GB的数据里，大部分数据都是重复的。</p>\n<p>这个时候就会想，如果宿主机上只下载一份Linux系统，而其他所有基于相同系统的镜像容器都可以共享这一份通用的部分。这样设置的话，不同容器启动的时候，只需要下载自己独特的程序部分就可以。这是不是就非常完美。</p>\n<p>事实上确实是这样的！不过我们既要共享底层系统，又要保护底层系统不被破坏。</p>\n<p>在容器或虚拟环境中，使用 tmpfs 和 overlayfs 结合的方案提供临时写入空间的同时保护底层的只读系统。这种方法允许在容器内进行文件操作，而不改变底层文件系统的内容。</p>\n<p>虽然挂载起来很容易，但我们刚刚描述的方法会产生大量文件变动和大量重复文件。这会减慢首次启动容器的速度并浪费空间。幸运的是，这是文件系统可以处理的容器化过程的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。</p>\n<h2 id=\"测试与分析\"><a href=\"#测试与分析\" class=\"headerlink\" title=\"测试与分析\"></a>测试与分析</h2><p>下面我们来看一个简单的例子，来帮助我们理解整个覆盖过程：</p>\n<ol>\n<li><p>创建tmpfs挂载（基于内存的文件系统，将用于探索覆盖过程）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /mytmpfs</span><br><span class=\"line\">mount -t tmpfs tmpfs /mytmpfs</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为我们的进程创建目录。我们将使用lowerdir下层（父层）、upperdir上层（子层）、workdir文件系统的工作目录以及merged包含合并的文件系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /mytmpfs/lowerdir   # 这是只读的下层目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/upperdir   # 这是可写的上层目录，将放在 tmpfs 上</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/workdir    # 这是 overlayfs 的工作目录</span><br><span class=\"line\">sudo mkdir -p /mytmpfs/merged     # 这是最终的合并目录</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为实验创建一些文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /mytmpfs</span><br><span class=\"line\">echo hello &gt; lowerdir/hello.txt</span><br><span class=\"line\">echo &quot;delete me&quot; &gt; lowerdir/delete-me.txt</span><br><span class=\"line\">echo message &gt; upperdir/upper-message.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>将这些目录挂载为overlay类型文件系统。这将在目录中创建一个新的文件系统，其中包含和目录merged的组合内容。该目录将用于跟踪文件系统的更改。lowerupperwork</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t overlay overlay -o lowerdir=lowerdir,upperdir=upperdir,workdir=workdir merged</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看文件系统。会注意到merged包含了upper和lower的组合内容。然后进行一些更改：<br><img src=\"/blog/images/docker-layer/merged.png\" alt=\"merged\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf merged/delete-me.txt</span><br><span class=\"line\">echo &quot;I&#x27;m new one&quot; &gt; merged/new.txt</span><br><span class=\"line\">echo world &gt;&gt; merged/hello.txt</span><br></pre></td></tr></table></figure></li>\n<li><p>正如预期的那样，delete-me.txt被删除，并且在merged目录中创建了一个新文件new.txt。如果你查看目录，你会看到一些有趣的东西：<br><img src=\"/blog/images/docker-layer/tree.png\" alt=\"directory tree\"></p>\n</li>\n</ol>\n<p>当你在 merged 目录中执行 rm -rf merged&#x2F;delete-me.txt 时，overlayfs 并不会直接删除 lowerdir 中的文件。相反，它会在 upperdir 中创建一个对应的白名单文件，通常命名为 .wh.delete-me.txt，表示这个文件在视图中已经被删除。</p>\n<h2 id=\"最终结果：\"><a href=\"#最终结果：\" class=\"headerlink\" title=\"最终结果：\"></a>最终结果：</h2><p>upperdir&#x2F; 的文件结构：</p>\n<p>执行ls -l upperdir 可以看到如下结果<br><img src=\"/blog/images/docker-layer/ls_upper.png\" alt=\"directory tree\"></p>\n<ul>\n<li>delete-me.txt：这是从 lowerdir 复制过来的文件，并未实际删除。取而代之的 .wh.delete-me.txt 白名单文件。</li>\n<li>hello.txt：这是从 lowerdir 复制过来的文件，因为在它上面执行了追加操作。</li>\n<li>new.txt：这是你在 merged 目录中新创建的文件，直接存放在 upperdir。</li>\n<li>upper-message.txt：这是最早在 upperdir 中创建的文件，保持不变。</li>\n</ul>\n<p>可以看到这种方法也可以用于实现快照系统。mount命令可以本机接受lowerdir路径列表，所有这些路径都合并到单个文件系统中。这是现代容器的一部分本质 — 容器是通过操作系统的本地功能来构建的。</p>\n<p>希望这篇博客能帮助你更好地理解容器镜像层。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"Dump分析入门指南","date":"2024-04-28T06:18:14.000Z","_content":"\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","source":"_posts/dump.md","raw":"---\ntitle: Dump分析入门指南\ndate: 2024-04-28 14:18:14\ntags: dump 性能 异常\n---\n\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","slug":"dump","published":1,"updated":"2024-05-08T08:37:58.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawc000brkp1hw0i6x6i","content":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/blog/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/blog/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/blog/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/blog/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/blog/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/blog/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/blog/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/blog/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/blog/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/blog/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n"},{"title":"加密、哈希与签名：基本原理与区别解析","date":"2024-11-06T03:19:23.000Z","_content":"\n*前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！*\n***\n\n在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。\n\n# 1. 什么是加密？\n![签名](./images/encrypt-hash-signature/rsa.png)\n## 基本原理\n加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。\n\n加密有两种常见的类型：\n\n+ 对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。\n\n+ 非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。\n\n## 应用场景\n+ 数据保密性：在通信过程中保护数据不被窃取。\n+ HTTPS：通过 SSL/TLS 协议加密 web 请求和响应，确保数据的安全传输。\n+ 加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。\n\n# 2. 什么是哈希？\n![签名](./images/encrypt-hash-signature/md5.png)\n## 基本原理\n哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。\n\n哈希的关键特性包括：\n\n+ 固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。\n+ 碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。\n+ 单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。\n## 应用场景\n+ 数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。\n+ 密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。\n+ 数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。\n\n# 3. 什么是数字签名？\n![签名](./images/encrypt-hash-signature/certificate.png)\n## 基本原理\n数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。\n\n## 应用场景\n+ 身份验证：用于确保消息发送者的身份。\n+ 数据完整性：确保数据在传输过程中没有被篡改。\n+ 电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。\n\n# 4. 加密、哈希与签名的区别\n虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。\n\n|特性|加密|哈希|签名|\n|---|---|---|---|\n|目的|保证数据保密性|确保数据完整性|确保数据来源和完整性\n|是否可逆|可逆（通过密钥解密）|不可逆|可验证（但不可逆）\n|涉及的密钥|对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥|不涉及密钥|使用私钥生成签名，公钥验证签名|\n|应用场景|保护数据隐私|校验数据是否被篡改|确保数据未被篡改且来源可信|\n|输出形式|密文（加密后的数据）|固定长度的哈希值|数字签名（通过私钥加密的哈希值）|\n\n## 关键区别总结\n1. 加密 是为了保护数据的机密性，使数据只能由授权方读取。\n2. 哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。\n3. 签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。\n\n# 5. 加密、哈希与签名的综合应用\n在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：\n\n- 加密 用于加密传输的数据，保护数据的隐私。\n- 哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。\n- 签名 用于验证服务器的身份，确保与合法服务器进行通信。\n\n在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。\n\n# 结语\n加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。\n\n----\n\n希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！","source":"_posts/encrypt-hash-signature.md","raw":"---\ntitle: 加密、哈希与签名：基本原理与区别解析\ndate: 2024-11-06 11:19:23\ntags:\n---\n\n*前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！*\n***\n\n在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。\n\n# 1. 什么是加密？\n![签名](./images/encrypt-hash-signature/rsa.png)\n## 基本原理\n加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。\n\n加密有两种常见的类型：\n\n+ 对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。\n\n+ 非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。\n\n## 应用场景\n+ 数据保密性：在通信过程中保护数据不被窃取。\n+ HTTPS：通过 SSL/TLS 协议加密 web 请求和响应，确保数据的安全传输。\n+ 加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。\n\n# 2. 什么是哈希？\n![签名](./images/encrypt-hash-signature/md5.png)\n## 基本原理\n哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。\n\n哈希的关键特性包括：\n\n+ 固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。\n+ 碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。\n+ 单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。\n## 应用场景\n+ 数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。\n+ 密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。\n+ 数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。\n\n# 3. 什么是数字签名？\n![签名](./images/encrypt-hash-signature/certificate.png)\n## 基本原理\n数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。\n\n## 应用场景\n+ 身份验证：用于确保消息发送者的身份。\n+ 数据完整性：确保数据在传输过程中没有被篡改。\n+ 电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。\n\n# 4. 加密、哈希与签名的区别\n虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。\n\n|特性|加密|哈希|签名|\n|---|---|---|---|\n|目的|保证数据保密性|确保数据完整性|确保数据来源和完整性\n|是否可逆|可逆（通过密钥解密）|不可逆|可验证（但不可逆）\n|涉及的密钥|对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥|不涉及密钥|使用私钥生成签名，公钥验证签名|\n|应用场景|保护数据隐私|校验数据是否被篡改|确保数据未被篡改且来源可信|\n|输出形式|密文（加密后的数据）|固定长度的哈希值|数字签名（通过私钥加密的哈希值）|\n\n## 关键区别总结\n1. 加密 是为了保护数据的机密性，使数据只能由授权方读取。\n2. 哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。\n3. 签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。\n\n# 5. 加密、哈希与签名的综合应用\n在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：\n\n- 加密 用于加密传输的数据，保护数据的隐私。\n- 哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。\n- 签名 用于验证服务器的身份，确保与合法服务器进行通信。\n\n在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。\n\n# 结语\n加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。\n\n----\n\n希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！","slug":"encrypt-hash-signature","published":1,"updated":"2024-11-06T07:38:33.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawc000crkp1fmhwf5zb","content":"<p><em>前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！</em></p>\n<hr>\n<p>在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。</p>\n<h1 id=\"1-什么是加密？\"><a href=\"#1-什么是加密？\" class=\"headerlink\" title=\"1. 什么是加密？\"></a>1. 什么是加密？</h1><p><img src=\"/blog/./images/encrypt-hash-signature/rsa.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。</p>\n<p>加密有两种常见的类型：</p>\n<ul>\n<li><p>对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。</p>\n</li>\n<li><p>非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。</p>\n</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据保密性：在通信过程中保护数据不被窃取。</li>\n<li>HTTPS：通过 SSL&#x2F;TLS 协议加密 web 请求和响应，确保数据的安全传输。</li>\n<li>加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。</li>\n</ul>\n<h1 id=\"2-什么是哈希？\"><a href=\"#2-什么是哈希？\" class=\"headerlink\" title=\"2. 什么是哈希？\"></a>2. 什么是哈希？</h1><p><img src=\"/blog/./images/encrypt-hash-signature/md5.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-1\"><a href=\"#基本原理-1\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。</p>\n<p>哈希的关键特性包括：</p>\n<ul>\n<li>固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。</li>\n<li>碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。</li>\n<li>单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。</li>\n</ul>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。</li>\n<li>密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。</li>\n<li>数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。</li>\n</ul>\n<h1 id=\"3-什么是数字签名？\"><a href=\"#3-什么是数字签名？\" class=\"headerlink\" title=\"3. 什么是数字签名？\"></a>3. 什么是数字签名？</h1><p><img src=\"/blog/./images/encrypt-hash-signature/certificate.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-2\"><a href=\"#基本原理-2\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。</p>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>身份验证：用于确保消息发送者的身份。</li>\n<li>数据完整性：确保数据在传输过程中没有被篡改。</li>\n<li>电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。</li>\n</ul>\n<h1 id=\"4-加密、哈希与签名的区别\"><a href=\"#4-加密、哈希与签名的区别\" class=\"headerlink\" title=\"4. 加密、哈希与签名的区别\"></a>4. 加密、哈希与签名的区别</h1><p>虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>加密</th>\n<th>哈希</th>\n<th>签名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>目的</td>\n<td>保证数据保密性</td>\n<td>确保数据完整性</td>\n<td>确保数据来源和完整性</td>\n</tr>\n<tr>\n<td>是否可逆</td>\n<td>可逆（通过密钥解密）</td>\n<td>不可逆</td>\n<td>可验证（但不可逆）</td>\n</tr>\n<tr>\n<td>涉及的密钥</td>\n<td>对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥</td>\n<td>不涉及密钥</td>\n<td>使用私钥生成签名，公钥验证签名</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>保护数据隐私</td>\n<td>校验数据是否被篡改</td>\n<td>确保数据未被篡改且来源可信</td>\n</tr>\n<tr>\n<td>输出形式</td>\n<td>密文（加密后的数据）</td>\n<td>固定长度的哈希值</td>\n<td>数字签名（通过私钥加密的哈希值）</td>\n</tr>\n</tbody></table>\n<h2 id=\"关键区别总结\"><a href=\"#关键区别总结\" class=\"headerlink\" title=\"关键区别总结\"></a>关键区别总结</h2><ol>\n<li>加密 是为了保护数据的机密性，使数据只能由授权方读取。</li>\n<li>哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。</li>\n<li>签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。</li>\n</ol>\n<h1 id=\"5-加密、哈希与签名的综合应用\"><a href=\"#5-加密、哈希与签名的综合应用\" class=\"headerlink\" title=\"5. 加密、哈希与签名的综合应用\"></a>5. 加密、哈希与签名的综合应用</h1><p>在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：</p>\n<ul>\n<li>加密 用于加密传输的数据，保护数据的隐私。</li>\n<li>哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。</li>\n<li>签名 用于验证服务器的身份，确保与合法服务器进行通信。</li>\n</ul>\n<p>在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。</p>\n<hr>\n<p>希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>前几天跟公司的几个小伙子聊天，提到了加密、哈希与签名，他们的回答让我很意外。加密、哈希和签名是软件开发过程中非常重要的概念，它们在信息安全、数据保护和身份验证等领域有着广泛的应用。但是他们似乎对这几个概念很混乱，搞不清楚其中的区别。加密 和 哈希 不是一回事 ！！！</em></p>\n<hr>\n<p>在信息技术中，加密、哈希和数字签名是保障数据安全和隐私的核心技术。这三者在实现信息保护、身份验证和数据完整性检查中扮演着重要角色。虽然它们常常被一同提及，但它们在工作原理和应用场景上有着显著的区别。本文将带你了解加密、哈希和签名的基本原理，并探讨它们之间的区别与联系。</p>\n<h1 id=\"1-什么是加密？\"><a href=\"#1-什么是加密？\" class=\"headerlink\" title=\"1. 什么是加密？\"></a>1. 什么是加密？</h1><p><img src=\"/blog/./images/encrypt-hash-signature/rsa.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>加密是一种将明文信息转换为密文的过程，目的是确保数据在传输和存储过程中不会被未授权的人员查看。加密算法通常依赖于一个密钥，只有拥有正确密钥的接收方才能解密数据，还原为原始的明文。</p>\n<p>加密有两种常见的类型：</p>\n<ul>\n<li><p>对称加密：加密和解密使用相同的密钥。常见的对称加密算法包括 AES（高级加密标准）、DES（数据加密标准）等。对称加密的优点是速度快，但密钥的分发和管理存在一定的挑战。</p>\n</li>\n<li><p>非对称加密：加密和解密使用不同的密钥。通常，发送方使用接收方的公钥加密数据，接收方则使用自己的私钥解密数据。常见的非对称加密算法包括 RSA、ECC（椭圆曲线加密）等。非对称加密虽然更安全，但相对较慢。</p>\n</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据保密性：在通信过程中保护数据不被窃取。</li>\n<li>HTTPS：通过 SSL&#x2F;TLS 协议加密 web 请求和响应，确保数据的安全传输。</li>\n<li>加密存储：保护存储的数据，防止硬盘被盗取时泄露敏感信息。</li>\n</ul>\n<h1 id=\"2-什么是哈希？\"><a href=\"#2-什么是哈希？\" class=\"headerlink\" title=\"2. 什么是哈希？\"></a>2. 什么是哈希？</h1><p><img src=\"/blog/./images/encrypt-hash-signature/md5.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-1\"><a href=\"#基本原理-1\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>哈希（Hash）是一种将任意长度的输入数据（如文本、文件等）通过哈希算法转换为固定长度的输出值的过程。哈希值通常是一个独特的字符串，且哈希算法的输出不可逆——即无法从哈希值推算出原始输入。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。</p>\n<p>哈希的关键特性包括：</p>\n<ul>\n<li>固定输出长度：无论输入数据多长，输出的哈希值长度始终是固定的。</li>\n<li>碰撞性：不同的输入数据不能产生相同的哈希值（理想情况下）。然而，现实中由于输出空间的限制，哈希函数总是存在碰撞的可能性（即不同输入有相同的哈希值）。</li>\n<li>单向性：哈希函数是单向的，意味着从哈希值无法推算出原始数据。</li>\n</ul>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>数据完整性：通过哈希值检查数据在传输或存储过程中是否被篡改。</li>\n<li>密码存储：将用户密码通过哈希算法加密后存储，避免直接存储明文密码。</li>\n<li>数字指纹：通过哈希值标识文件或数据的唯一性，常用于数据去重。</li>\n</ul>\n<h1 id=\"3-什么是数字签名？\"><a href=\"#3-什么是数字签名？\" class=\"headerlink\" title=\"3. 什么是数字签名？\"></a>3. 什么是数字签名？</h1><p><img src=\"/blog/./images/encrypt-hash-signature/certificate.png\" alt=\"签名\"></p>\n<h2 id=\"基本原理-2\"><a href=\"#基本原理-2\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>数字签名是用于验证消息或文件来源以及完整性的一种技术。它结合了哈希和非对称加密。在数字签名中，首先对消息进行哈希运算，然后用发送方的私钥对哈希值进行加密，生成签名。接收方则使用发送方的公钥解密签名，获得哈希值，并与消息自身计算的哈希值进行比对，以确保消息未被篡改，且确实来自于持有私钥的发送方。</p>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>身份验证：用于确保消息发送者的身份。</li>\n<li>数据完整性：确保数据在传输过程中没有被篡改。</li>\n<li>电子合同：为合同或交易提供不可篡改的签名，确保合同的法律效力。</li>\n</ul>\n<h1 id=\"4-加密、哈希与签名的区别\"><a href=\"#4-加密、哈希与签名的区别\" class=\"headerlink\" title=\"4. 加密、哈希与签名的区别\"></a>4. 加密、哈希与签名的区别</h1><p>虽然加密、哈希和签名在数据安全中都扮演着重要角色，但它们各自的目的和使用方式有所不同。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>加密</th>\n<th>哈希</th>\n<th>签名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>目的</td>\n<td>保证数据保密性</td>\n<td>确保数据完整性</td>\n<td>确保数据来源和完整性</td>\n</tr>\n<tr>\n<td>是否可逆</td>\n<td>可逆（通过密钥解密）</td>\n<td>不可逆</td>\n<td>可验证（但不可逆）</td>\n</tr>\n<tr>\n<td>涉及的密钥</td>\n<td>对称加密使用同一密钥，非对称加密使用一对密钥（公钥和私钥</td>\n<td>不涉及密钥</td>\n<td>使用私钥生成签名，公钥验证签名</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>保护数据隐私</td>\n<td>校验数据是否被篡改</td>\n<td>确保数据未被篡改且来源可信</td>\n</tr>\n<tr>\n<td>输出形式</td>\n<td>密文（加密后的数据）</td>\n<td>固定长度的哈希值</td>\n<td>数字签名（通过私钥加密的哈希值）</td>\n</tr>\n</tbody></table>\n<h2 id=\"关键区别总结\"><a href=\"#关键区别总结\" class=\"headerlink\" title=\"关键区别总结\"></a>关键区别总结</h2><ol>\n<li>加密 是为了保护数据的机密性，使数据只能由授权方读取。</li>\n<li>哈希 是为了确保数据在传输和存储过程中的完整性，确保数据没有被篡改。</li>\n<li>签名 是为了验证数据的来源和完整性，确保数据在传输过程中没有被修改，并且确实来自于声称的发送者。</li>\n</ol>\n<h1 id=\"5-加密、哈希与签名的综合应用\"><a href=\"#5-加密、哈希与签名的综合应用\" class=\"headerlink\" title=\"5. 加密、哈希与签名的综合应用\"></a>5. 加密、哈希与签名的综合应用</h1><p>在现代技术中，加密、哈希和签名经常被结合使用，形成安全通信的完整解决方案。例如，在 HTTPS 中：</p>\n<ul>\n<li>加密 用于加密传输的数据，保护数据的隐私。</li>\n<li>哈希 用于生成消息摘要，确保数据在传输过程中没有被篡改。</li>\n<li>签名 用于验证服务器的身份，确保与合法服务器进行通信。</li>\n</ul>\n<p>在 区块链 中，数字签名用于确认交易的发起者和防止交易的篡改，哈希则用于确保区块链的数据结构的完整性。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>加密、哈希和签名在信息安全中有着不可或缺的作用，它们通过不同的方式保障数据的机密性、完整性和可靠性。理解它们的基本原理和区别，不仅能帮助我们更好地保护自己的数据，也能为我们设计更加安全的系统和应用提供理论基础。</p>\n<hr>\n<p>希望这篇文章帮助你清晰地理解了加密、哈希和签名的原理及其在现代应用中的重要性！</p>\n"},{"title":"让AI模型不再只是“说话”——探索AI模型的函数调用","date":"2025-02-21T06:02:30.000Z","_content":"# 引入\n在当今数字化时代，人工智能（AI）技术已经成为我们生活中不可或缺的一部分。从语音助手到智能客服，AI模型已经成为我们日常生活中不可或缺的一部分。然而，随着AI技术的不断发展，我们面临了一个新的挑战：如何让AI模型真正“做事”？\n\n![AI](./images/function-calling/labour.jpg)\n\n在过去，AI模型主要被训练为生成文字，回答问题，或者提供信息。然而，随着AI模型的不断发展，我们开始看到它能够执行更复杂的任务，如自动化任务、数据处理、决策支持等。这一趋势的一个关键驱动力是**函数调用**的引入。\n\n如果现在的你还只会使用AI模型来生成文字，那么作为一个开发人员，你已经OUT了！\n![AI](./images/function-calling/out.jpg)\n\n生成式人工智能的一个显著优点是它能够使用自然语言与用户进行互动。然而，对于那些希望将人工智能的响应与其他应用程序进行集成的开发者来说，这可能成为一项挑战。通常，开发者不得不依赖正则表达式（Regex）或精心设计的提示工程，将输出转换为所需格式，才能顺利地将数据传递给其他系统。\n\n为了解决这一问题，OpenAI 引入了一个创新的概念——函数调用（function calling）。本文，我将结合具体的例子，详细阐释这一概念。\n\n# 什么是函数调用？\n随着人工智能技术的快速发展，AI模型已经不再仅仅是生成文字的工具。通过引入**函数调用**，大型语言模型（LLM）不仅能理解用户的输入，还能够执行实际操作，调用外部工具和API，获取实时数据，从而解决实际问题。在这篇博客中，我们将深入探讨函数调用的概念及其实际应用，展示如何通过AI模型的函数调用，让AI真正成为一个动态的助手，协助用户完成复杂任务。\n\n\n例如，传统的AI模型可能仅仅会生成“今天的天气如何”这类问题的文本回答，但有了函数调用，AI可以直接从天气API获取实时数据，并返回具体的天气情况。这样，AI不仅仅是回答问题，而是通过执行外部操作提供精确、实时的服务。\n\n# 函数调用的工作流程\n函数调用通常包括以下几个步骤：\n\n1. 用户请求：用户发出查询或要求一个操作，如“明天的天气如何？”或者“检查库存是否充足？”\n2. AI处理：AI模型分析用户的请求，并判断是否需要外部数据或执行外部任务。如果是，它将决定执行函数调用。\n3. 函数调用决策：\n    - API调用：通过外部API获取数据。例如，调用天气API获取实时天气数据。\n    - 自定义函数：访问内部工具或数据库。例如，查询库存数据库检查产品的库存。\n4. 数据获取与集成：AI模型从外部工具或API获取数据后，整合结果并生成适合的响应。\n\n![AI](./images/function-calling/process.png)\n\n通过这种方式，AI模型不仅限于生成答案，还能自动执行操作，极大增强了其功能和实用性。\n\n# 函数调用的示例：创建一个实时查询工具\n为了更直观地展示函数调用如何发挥作用，我们将创建一个简单的AI工具，它可以根据用户的输入实时查询网络信息或者查询本地数据库。我们将使用一个Python库，以及AI模型来实现这一功能。\n\n1. 查询API和LLM模型\n   首先，我们需要一个网络查询API，并将其与AI模型连接。在本示例中，我们使用Google Search API来获取网络数据。\n\n   本地用Ollama启动模型qwen2.5:0.5b，当然也可以使用其他模型。不过在选择模型的时候记得选择支持函数调用的模型。\n   ![函数调用模型](./images/function-calling/search.png)\n\n2. 定义函数调用\nAI模型通过判断用户请求是否涉及网络搜索或者查询本地数据库 来决定是否使用tool 或者说 使用哪个tool。下面是我们定义的函数调用逻辑：\n\n```python\nsearch_web_tool = {\n        'type': 'function',\n        'function': {\n            'name': 'search_web',\n            'description': 'Search the web for current information on a topic',\n            'parameters': {\n                'type': 'object',\n                'required': ['query'],\n                'properties': {\n                    'query': {\n                        'type': 'string',\n                        'description': 'The search query to look up'\n                    }\n                }\n            }\n        }\n    }\n\n# MySQL查询工具\nsearch_db_tool = {\n    'type': 'function',\n    'function': {\n        'name': 'search_db',\n        'description': 'Query inventory quantity of a product from a local MySQL database.',\n        'parameters': {\n            'type': 'object',\n            'required': ['product_name'],\n            'properties': {\n                'query': {\n                    'type': 'string',\n                    'description': 'The product name to query .'\n                }\n            }\n        }\n    }\n}\n\n```\n\n3. 函数的具体实现\n我们定义了两个函数，分别用于网络搜索和查询本地数据库。这些函数会被AI模型调用，获取所需的数据。\n```python\ndef search_web(query):\n    # 调用网络查询API获取数据\n    ...\ndef search_db(query):\n    # 调用本地数据库查询API获取数据\n    ...\n```\n\n4. 连接AI模型和函数调用\n当用户输入查询语句时，AI模型分析请求，决定是否调用函数获取数据，并将返回的信息结合自然语言生成响应：\n\n```python\nclient = AsyncClient('127.0.0.1')\n\n# First, let Ollama decide if it needs to search\nresponse = await client.chat(\n    'qwen2.5:0.5b',        \n    messages=[{\n        'role': 'user',\n        'content': f'Answer this question: {query}'\n    }],\n    tools=[search_web_tool, search_db_tool]\n)\n\nif response.message.tool_calls:\n    print(\"Searching by tools...\")\n\n    for tool in response.message.tool_calls:\n        if function_to_call := available_functions.get(tool.function.name):\n            # Call the search function\n            search_results = function_to_call(**tool.function.arguments)\n\n            ...\n\n            # Get final response from Ollama with the search results\n            final_response = await client.chat(\n                'qwen2.5:0.5b',\n                messages=messages\n            )\n            return final_response.message.content  \n   \n```\n\n4. 获取实时数据并返回给用户\n通过这种方式，AI模型不仅仅是生成“天气好坏”的模糊回答，而是调用API获取实时数据，并返回具体的天气信息，让用户得到更加准确的答案。\n\n5. 运行示例\n现在，我们可以运行这个示例，看看AI模型是如何根据用户的输入实时查询网络信息或者查询本地数据库的。\n![运行示例](./images/function-calling/result.gif)\n\n上面的代码示例因为篇幅原因，仅给出了大致结构。如果需要完整代码，可以在我的[github](https://github.com/ItProHub/function-calling)上下载。\n# 结论\n函数调用的引入使得AI模型不仅仅局限于生成文本，而是能够真正“做事”。通过与外部工具和API的交互，AI可以获取实时数据、自动化任务、集成多种服务，从而更好地满足用户需求，提升应用的实用性和效率。无论是在个人助理、智能客服，还是在更复杂的企业系统中，函数调用都能极大增强AI的功能，改变我们与AI的互动方式。\n\n你是否已经开始在你的AI应用中使用函数调用了呢？如果有任何问题，欢迎在评论区与我们讨论！\n\n希望这篇博客能够帮助你更好地理解函数调用的概念及其应用，助力你在开发AI驱动的应用时做出更高效、智能的解决方案！","source":"_posts/function-calling.md","raw":"---\ntitle: 让AI模型不再只是“说话”——探索AI模型的函数调用\ndate: 2025-02-21 14:02:30\ntags:\n---\n# 引入\n在当今数字化时代，人工智能（AI）技术已经成为我们生活中不可或缺的一部分。从语音助手到智能客服，AI模型已经成为我们日常生活中不可或缺的一部分。然而，随着AI技术的不断发展，我们面临了一个新的挑战：如何让AI模型真正“做事”？\n\n![AI](./images/function-calling/labour.jpg)\n\n在过去，AI模型主要被训练为生成文字，回答问题，或者提供信息。然而，随着AI模型的不断发展，我们开始看到它能够执行更复杂的任务，如自动化任务、数据处理、决策支持等。这一趋势的一个关键驱动力是**函数调用**的引入。\n\n如果现在的你还只会使用AI模型来生成文字，那么作为一个开发人员，你已经OUT了！\n![AI](./images/function-calling/out.jpg)\n\n生成式人工智能的一个显著优点是它能够使用自然语言与用户进行互动。然而，对于那些希望将人工智能的响应与其他应用程序进行集成的开发者来说，这可能成为一项挑战。通常，开发者不得不依赖正则表达式（Regex）或精心设计的提示工程，将输出转换为所需格式，才能顺利地将数据传递给其他系统。\n\n为了解决这一问题，OpenAI 引入了一个创新的概念——函数调用（function calling）。本文，我将结合具体的例子，详细阐释这一概念。\n\n# 什么是函数调用？\n随着人工智能技术的快速发展，AI模型已经不再仅仅是生成文字的工具。通过引入**函数调用**，大型语言模型（LLM）不仅能理解用户的输入，还能够执行实际操作，调用外部工具和API，获取实时数据，从而解决实际问题。在这篇博客中，我们将深入探讨函数调用的概念及其实际应用，展示如何通过AI模型的函数调用，让AI真正成为一个动态的助手，协助用户完成复杂任务。\n\n\n例如，传统的AI模型可能仅仅会生成“今天的天气如何”这类问题的文本回答，但有了函数调用，AI可以直接从天气API获取实时数据，并返回具体的天气情况。这样，AI不仅仅是回答问题，而是通过执行外部操作提供精确、实时的服务。\n\n# 函数调用的工作流程\n函数调用通常包括以下几个步骤：\n\n1. 用户请求：用户发出查询或要求一个操作，如“明天的天气如何？”或者“检查库存是否充足？”\n2. AI处理：AI模型分析用户的请求，并判断是否需要外部数据或执行外部任务。如果是，它将决定执行函数调用。\n3. 函数调用决策：\n    - API调用：通过外部API获取数据。例如，调用天气API获取实时天气数据。\n    - 自定义函数：访问内部工具或数据库。例如，查询库存数据库检查产品的库存。\n4. 数据获取与集成：AI模型从外部工具或API获取数据后，整合结果并生成适合的响应。\n\n![AI](./images/function-calling/process.png)\n\n通过这种方式，AI模型不仅限于生成答案，还能自动执行操作，极大增强了其功能和实用性。\n\n# 函数调用的示例：创建一个实时查询工具\n为了更直观地展示函数调用如何发挥作用，我们将创建一个简单的AI工具，它可以根据用户的输入实时查询网络信息或者查询本地数据库。我们将使用一个Python库，以及AI模型来实现这一功能。\n\n1. 查询API和LLM模型\n   首先，我们需要一个网络查询API，并将其与AI模型连接。在本示例中，我们使用Google Search API来获取网络数据。\n\n   本地用Ollama启动模型qwen2.5:0.5b，当然也可以使用其他模型。不过在选择模型的时候记得选择支持函数调用的模型。\n   ![函数调用模型](./images/function-calling/search.png)\n\n2. 定义函数调用\nAI模型通过判断用户请求是否涉及网络搜索或者查询本地数据库 来决定是否使用tool 或者说 使用哪个tool。下面是我们定义的函数调用逻辑：\n\n```python\nsearch_web_tool = {\n        'type': 'function',\n        'function': {\n            'name': 'search_web',\n            'description': 'Search the web for current information on a topic',\n            'parameters': {\n                'type': 'object',\n                'required': ['query'],\n                'properties': {\n                    'query': {\n                        'type': 'string',\n                        'description': 'The search query to look up'\n                    }\n                }\n            }\n        }\n    }\n\n# MySQL查询工具\nsearch_db_tool = {\n    'type': 'function',\n    'function': {\n        'name': 'search_db',\n        'description': 'Query inventory quantity of a product from a local MySQL database.',\n        'parameters': {\n            'type': 'object',\n            'required': ['product_name'],\n            'properties': {\n                'query': {\n                    'type': 'string',\n                    'description': 'The product name to query .'\n                }\n            }\n        }\n    }\n}\n\n```\n\n3. 函数的具体实现\n我们定义了两个函数，分别用于网络搜索和查询本地数据库。这些函数会被AI模型调用，获取所需的数据。\n```python\ndef search_web(query):\n    # 调用网络查询API获取数据\n    ...\ndef search_db(query):\n    # 调用本地数据库查询API获取数据\n    ...\n```\n\n4. 连接AI模型和函数调用\n当用户输入查询语句时，AI模型分析请求，决定是否调用函数获取数据，并将返回的信息结合自然语言生成响应：\n\n```python\nclient = AsyncClient('127.0.0.1')\n\n# First, let Ollama decide if it needs to search\nresponse = await client.chat(\n    'qwen2.5:0.5b',        \n    messages=[{\n        'role': 'user',\n        'content': f'Answer this question: {query}'\n    }],\n    tools=[search_web_tool, search_db_tool]\n)\n\nif response.message.tool_calls:\n    print(\"Searching by tools...\")\n\n    for tool in response.message.tool_calls:\n        if function_to_call := available_functions.get(tool.function.name):\n            # Call the search function\n            search_results = function_to_call(**tool.function.arguments)\n\n            ...\n\n            # Get final response from Ollama with the search results\n            final_response = await client.chat(\n                'qwen2.5:0.5b',\n                messages=messages\n            )\n            return final_response.message.content  \n   \n```\n\n4. 获取实时数据并返回给用户\n通过这种方式，AI模型不仅仅是生成“天气好坏”的模糊回答，而是调用API获取实时数据，并返回具体的天气信息，让用户得到更加准确的答案。\n\n5. 运行示例\n现在，我们可以运行这个示例，看看AI模型是如何根据用户的输入实时查询网络信息或者查询本地数据库的。\n![运行示例](./images/function-calling/result.gif)\n\n上面的代码示例因为篇幅原因，仅给出了大致结构。如果需要完整代码，可以在我的[github](https://github.com/ItProHub/function-calling)上下载。\n# 结论\n函数调用的引入使得AI模型不仅仅局限于生成文本，而是能够真正“做事”。通过与外部工具和API的交互，AI可以获取实时数据、自动化任务、集成多种服务，从而更好地满足用户需求，提升应用的实用性和效率。无论是在个人助理、智能客服，还是在更复杂的企业系统中，函数调用都能极大增强AI的功能，改变我们与AI的互动方式。\n\n你是否已经开始在你的AI应用中使用函数调用了呢？如果有任何问题，欢迎在评论区与我们讨论！\n\n希望这篇博客能够帮助你更好地理解函数调用的概念及其应用，助力你在开发AI驱动的应用时做出更高效、智能的解决方案！","slug":"function-calling","published":1,"updated":"2025-02-25T07:50:27.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawe000erkp1hemeeygm","content":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>在当今数字化时代，人工智能（AI）技术已经成为我们生活中不可或缺的一部分。从语音助手到智能客服，AI模型已经成为我们日常生活中不可或缺的一部分。然而，随着AI技术的不断发展，我们面临了一个新的挑战：如何让AI模型真正“做事”？</p>\n<p><img src=\"/blog/./images/function-calling/labour.jpg\" alt=\"AI\"></p>\n<p>在过去，AI模型主要被训练为生成文字，回答问题，或者提供信息。然而，随着AI模型的不断发展，我们开始看到它能够执行更复杂的任务，如自动化任务、数据处理、决策支持等。这一趋势的一个关键驱动力是<strong>函数调用</strong>的引入。</p>\n<p>如果现在的你还只会使用AI模型来生成文字，那么作为一个开发人员，你已经OUT了！<br><img src=\"/blog/./images/function-calling/out.jpg\" alt=\"AI\"></p>\n<p>生成式人工智能的一个显著优点是它能够使用自然语言与用户进行互动。然而，对于那些希望将人工智能的响应与其他应用程序进行集成的开发者来说，这可能成为一项挑战。通常，开发者不得不依赖正则表达式（Regex）或精心设计的提示工程，将输出转换为所需格式，才能顺利地将数据传递给其他系统。</p>\n<p>为了解决这一问题，OpenAI 引入了一个创新的概念——函数调用（function calling）。本文，我将结合具体的例子，详细阐释这一概念。</p>\n<h1 id=\"什么是函数调用？\"><a href=\"#什么是函数调用？\" class=\"headerlink\" title=\"什么是函数调用？\"></a>什么是函数调用？</h1><p>随着人工智能技术的快速发展，AI模型已经不再仅仅是生成文字的工具。通过引入<strong>函数调用</strong>，大型语言模型（LLM）不仅能理解用户的输入，还能够执行实际操作，调用外部工具和API，获取实时数据，从而解决实际问题。在这篇博客中，我们将深入探讨函数调用的概念及其实际应用，展示如何通过AI模型的函数调用，让AI真正成为一个动态的助手，协助用户完成复杂任务。</p>\n<p>例如，传统的AI模型可能仅仅会生成“今天的天气如何”这类问题的文本回答，但有了函数调用，AI可以直接从天气API获取实时数据，并返回具体的天气情况。这样，AI不仅仅是回答问题，而是通过执行外部操作提供精确、实时的服务。</p>\n<h1 id=\"函数调用的工作流程\"><a href=\"#函数调用的工作流程\" class=\"headerlink\" title=\"函数调用的工作流程\"></a>函数调用的工作流程</h1><p>函数调用通常包括以下几个步骤：</p>\n<ol>\n<li>用户请求：用户发出查询或要求一个操作，如“明天的天气如何？”或者“检查库存是否充足？”</li>\n<li>AI处理：AI模型分析用户的请求，并判断是否需要外部数据或执行外部任务。如果是，它将决定执行函数调用。</li>\n<li>函数调用决策：<ul>\n<li>API调用：通过外部API获取数据。例如，调用天气API获取实时天气数据。</li>\n<li>自定义函数：访问内部工具或数据库。例如，查询库存数据库检查产品的库存。</li>\n</ul>\n</li>\n<li>数据获取与集成：AI模型从外部工具或API获取数据后，整合结果并生成适合的响应。</li>\n</ol>\n<p><img src=\"/blog/./images/function-calling/process.png\" alt=\"AI\"></p>\n<p>通过这种方式，AI模型不仅限于生成答案，还能自动执行操作，极大增强了其功能和实用性。</p>\n<h1 id=\"函数调用的示例：创建一个实时查询工具\"><a href=\"#函数调用的示例：创建一个实时查询工具\" class=\"headerlink\" title=\"函数调用的示例：创建一个实时查询工具\"></a>函数调用的示例：创建一个实时查询工具</h1><p>为了更直观地展示函数调用如何发挥作用，我们将创建一个简单的AI工具，它可以根据用户的输入实时查询网络信息或者查询本地数据库。我们将使用一个Python库，以及AI模型来实现这一功能。</p>\n<ol>\n<li><p>查询API和LLM模型<br>首先，我们需要一个网络查询API，并将其与AI模型连接。在本示例中，我们使用Google Search API来获取网络数据。</p>\n<p>本地用Ollama启动模型qwen2.5:0.5b，当然也可以使用其他模型。不过在选择模型的时候记得选择支持函数调用的模型。<br><img src=\"/blog/./images/function-calling/search.png\" alt=\"函数调用模型\"></p>\n</li>\n<li><p>定义函数调用<br>AI模型通过判断用户请求是否涉及网络搜索或者查询本地数据库 来决定是否使用tool 或者说 使用哪个tool。下面是我们定义的函数调用逻辑：</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search_web_tool = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;function&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;function&#x27;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;search_web&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;Search the web for current information on a topic&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;parameters&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;object&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;required&#x27;</span>: [<span class=\"string\">&#x27;query&#x27;</span>],</span><br><span class=\"line\">                <span class=\"string\">&#x27;properties&#x27;</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">&#x27;query&#x27;</span>: &#123;</span><br><span class=\"line\">                        <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;string&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;The search query to look up&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># MySQL查询工具</span></span><br><span class=\"line\">search_db_tool = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;function&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;function&#x27;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;search_db&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;Query inventory quantity of a product from a local MySQL database.&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;parameters&#x27;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;object&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;required&#x27;</span>: [<span class=\"string\">&#x27;product_name&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;properties&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;query&#x27;</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;string&#x27;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;The product name to query .&#x27;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>函数的具体实现<br>我们定义了两个函数，分别用于网络搜索和查询本地数据库。这些函数会被AI模型调用，获取所需的数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">search_web</span>(<span class=\"params\">query</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 调用网络查询API获取数据</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">search_db</span>(<span class=\"params\">query</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 调用本地数据库查询API获取数据</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>连接AI模型和函数调用<br>当用户输入查询语句时，AI模型分析请求，决定是否调用函数获取数据，并将返回的信息结合自然语言生成响应：</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client = AsyncClient(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># First, let Ollama decide if it needs to search</span></span><br><span class=\"line\">response = <span class=\"keyword\">await</span> client.chat(</span><br><span class=\"line\">    <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,        </span><br><span class=\"line\">    messages=[&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;role&#x27;</span>: <span class=\"string\">&#x27;user&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;content&#x27;</span>: <span class=\"string\">f&#x27;Answer this question: <span class=\"subst\">&#123;query&#125;</span>&#x27;</span></span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    tools=[search_web_tool, search_db_tool]</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> response.message.tool_calls:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Searching by tools...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> tool <span class=\"keyword\">in</span> response.message.tool_calls:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> function_to_call := available_functions.get(tool.function.name):</span><br><span class=\"line\">            <span class=\"comment\"># Call the search function</span></span><br><span class=\"line\">            search_results = function_to_call(**tool.function.arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># Get final response from Ollama with the search results</span></span><br><span class=\"line\">            final_response = <span class=\"keyword\">await</span> client.chat(</span><br><span class=\"line\">                <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,</span><br><span class=\"line\">                messages=messages</span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> final_response.message.content  </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>获取实时数据并返回给用户<br>通过这种方式，AI模型不仅仅是生成“天气好坏”的模糊回答，而是调用API获取实时数据，并返回具体的天气信息，让用户得到更加准确的答案。</p>\n</li>\n<li><p>运行示例<br>现在，我们可以运行这个示例，看看AI模型是如何根据用户的输入实时查询网络信息或者查询本地数据库的。<br><img src=\"/blog/./images/function-calling/result.gif\" alt=\"运行示例\"></p>\n</li>\n</ol>\n<p>上面的代码示例因为篇幅原因，仅给出了大致结构。如果需要完整代码，可以在我的<a href=\"https://github.com/ItProHub/function-calling\">github</a>上下载。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>函数调用的引入使得AI模型不仅仅局限于生成文本，而是能够真正“做事”。通过与外部工具和API的交互，AI可以获取实时数据、自动化任务、集成多种服务，从而更好地满足用户需求，提升应用的实用性和效率。无论是在个人助理、智能客服，还是在更复杂的企业系统中，函数调用都能极大增强AI的功能，改变我们与AI的互动方式。</p>\n<p>你是否已经开始在你的AI应用中使用函数调用了呢？如果有任何问题，欢迎在评论区与我们讨论！</p>\n<p>希望这篇博客能够帮助你更好地理解函数调用的概念及其应用，助力你在开发AI驱动的应用时做出更高效、智能的解决方案！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><p>在当今数字化时代，人工智能（AI）技术已经成为我们生活中不可或缺的一部分。从语音助手到智能客服，AI模型已经成为我们日常生活中不可或缺的一部分。然而，随着AI技术的不断发展，我们面临了一个新的挑战：如何让AI模型真正“做事”？</p>\n<p><img src=\"/blog/./images/function-calling/labour.jpg\" alt=\"AI\"></p>\n<p>在过去，AI模型主要被训练为生成文字，回答问题，或者提供信息。然而，随着AI模型的不断发展，我们开始看到它能够执行更复杂的任务，如自动化任务、数据处理、决策支持等。这一趋势的一个关键驱动力是<strong>函数调用</strong>的引入。</p>\n<p>如果现在的你还只会使用AI模型来生成文字，那么作为一个开发人员，你已经OUT了！<br><img src=\"/blog/./images/function-calling/out.jpg\" alt=\"AI\"></p>\n<p>生成式人工智能的一个显著优点是它能够使用自然语言与用户进行互动。然而，对于那些希望将人工智能的响应与其他应用程序进行集成的开发者来说，这可能成为一项挑战。通常，开发者不得不依赖正则表达式（Regex）或精心设计的提示工程，将输出转换为所需格式，才能顺利地将数据传递给其他系统。</p>\n<p>为了解决这一问题，OpenAI 引入了一个创新的概念——函数调用（function calling）。本文，我将结合具体的例子，详细阐释这一概念。</p>\n<h1 id=\"什么是函数调用？\"><a href=\"#什么是函数调用？\" class=\"headerlink\" title=\"什么是函数调用？\"></a>什么是函数调用？</h1><p>随着人工智能技术的快速发展，AI模型已经不再仅仅是生成文字的工具。通过引入<strong>函数调用</strong>，大型语言模型（LLM）不仅能理解用户的输入，还能够执行实际操作，调用外部工具和API，获取实时数据，从而解决实际问题。在这篇博客中，我们将深入探讨函数调用的概念及其实际应用，展示如何通过AI模型的函数调用，让AI真正成为一个动态的助手，协助用户完成复杂任务。</p>\n<p>例如，传统的AI模型可能仅仅会生成“今天的天气如何”这类问题的文本回答，但有了函数调用，AI可以直接从天气API获取实时数据，并返回具体的天气情况。这样，AI不仅仅是回答问题，而是通过执行外部操作提供精确、实时的服务。</p>\n<h1 id=\"函数调用的工作流程\"><a href=\"#函数调用的工作流程\" class=\"headerlink\" title=\"函数调用的工作流程\"></a>函数调用的工作流程</h1><p>函数调用通常包括以下几个步骤：</p>\n<ol>\n<li>用户请求：用户发出查询或要求一个操作，如“明天的天气如何？”或者“检查库存是否充足？”</li>\n<li>AI处理：AI模型分析用户的请求，并判断是否需要外部数据或执行外部任务。如果是，它将决定执行函数调用。</li>\n<li>函数调用决策：<ul>\n<li>API调用：通过外部API获取数据。例如，调用天气API获取实时天气数据。</li>\n<li>自定义函数：访问内部工具或数据库。例如，查询库存数据库检查产品的库存。</li>\n</ul>\n</li>\n<li>数据获取与集成：AI模型从外部工具或API获取数据后，整合结果并生成适合的响应。</li>\n</ol>\n<p><img src=\"/blog/./images/function-calling/process.png\" alt=\"AI\"></p>\n<p>通过这种方式，AI模型不仅限于生成答案，还能自动执行操作，极大增强了其功能和实用性。</p>\n<h1 id=\"函数调用的示例：创建一个实时查询工具\"><a href=\"#函数调用的示例：创建一个实时查询工具\" class=\"headerlink\" title=\"函数调用的示例：创建一个实时查询工具\"></a>函数调用的示例：创建一个实时查询工具</h1><p>为了更直观地展示函数调用如何发挥作用，我们将创建一个简单的AI工具，它可以根据用户的输入实时查询网络信息或者查询本地数据库。我们将使用一个Python库，以及AI模型来实现这一功能。</p>\n<ol>\n<li><p>查询API和LLM模型<br>首先，我们需要一个网络查询API，并将其与AI模型连接。在本示例中，我们使用Google Search API来获取网络数据。</p>\n<p>本地用Ollama启动模型qwen2.5:0.5b，当然也可以使用其他模型。不过在选择模型的时候记得选择支持函数调用的模型。<br><img src=\"/blog/./images/function-calling/search.png\" alt=\"函数调用模型\"></p>\n</li>\n<li><p>定义函数调用<br>AI模型通过判断用户请求是否涉及网络搜索或者查询本地数据库 来决定是否使用tool 或者说 使用哪个tool。下面是我们定义的函数调用逻辑：</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search_web_tool = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;function&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;function&#x27;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;search_web&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;Search the web for current information on a topic&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;parameters&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;object&#x27;</span>,</span><br><span class=\"line\">                <span class=\"string\">&#x27;required&#x27;</span>: [<span class=\"string\">&#x27;query&#x27;</span>],</span><br><span class=\"line\">                <span class=\"string\">&#x27;properties&#x27;</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">&#x27;query&#x27;</span>: &#123;</span><br><span class=\"line\">                        <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;string&#x27;</span>,</span><br><span class=\"line\">                        <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;The search query to look up&#x27;</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># MySQL查询工具</span></span><br><span class=\"line\">search_db_tool = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;function&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;function&#x27;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;search_db&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;Query inventory quantity of a product from a local MySQL database.&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;parameters&#x27;</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;object&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;required&#x27;</span>: [<span class=\"string\">&#x27;product_name&#x27;</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;properties&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;query&#x27;</span>: &#123;</span><br><span class=\"line\">                    <span class=\"string\">&#x27;type&#x27;</span>: <span class=\"string\">&#x27;string&#x27;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&#x27;description&#x27;</span>: <span class=\"string\">&#x27;The product name to query .&#x27;</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>函数的具体实现<br>我们定义了两个函数，分别用于网络搜索和查询本地数据库。这些函数会被AI模型调用，获取所需的数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">search_web</span>(<span class=\"params\">query</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 调用网络查询API获取数据</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">search_db</span>(<span class=\"params\">query</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 调用本地数据库查询API获取数据</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>连接AI模型和函数调用<br>当用户输入查询语句时，AI模型分析请求，决定是否调用函数获取数据，并将返回的信息结合自然语言生成响应：</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client = AsyncClient(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># First, let Ollama decide if it needs to search</span></span><br><span class=\"line\">response = <span class=\"keyword\">await</span> client.chat(</span><br><span class=\"line\">    <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,        </span><br><span class=\"line\">    messages=[&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;role&#x27;</span>: <span class=\"string\">&#x27;user&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;content&#x27;</span>: <span class=\"string\">f&#x27;Answer this question: <span class=\"subst\">&#123;query&#125;</span>&#x27;</span></span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    tools=[search_web_tool, search_db_tool]</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> response.message.tool_calls:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Searching by tools...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> tool <span class=\"keyword\">in</span> response.message.tool_calls:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> function_to_call := available_functions.get(tool.function.name):</span><br><span class=\"line\">            <span class=\"comment\"># Call the search function</span></span><br><span class=\"line\">            search_results = function_to_call(**tool.function.arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># Get final response from Ollama with the search results</span></span><br><span class=\"line\">            final_response = <span class=\"keyword\">await</span> client.chat(</span><br><span class=\"line\">                <span class=\"string\">&#x27;qwen2.5:0.5b&#x27;</span>,</span><br><span class=\"line\">                messages=messages</span><br><span class=\"line\">            )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> final_response.message.content  </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>获取实时数据并返回给用户<br>通过这种方式，AI模型不仅仅是生成“天气好坏”的模糊回答，而是调用API获取实时数据，并返回具体的天气信息，让用户得到更加准确的答案。</p>\n</li>\n<li><p>运行示例<br>现在，我们可以运行这个示例，看看AI模型是如何根据用户的输入实时查询网络信息或者查询本地数据库的。<br><img src=\"/blog/./images/function-calling/result.gif\" alt=\"运行示例\"></p>\n</li>\n</ol>\n<p>上面的代码示例因为篇幅原因，仅给出了大致结构。如果需要完整代码，可以在我的<a href=\"https://github.com/ItProHub/function-calling\">github</a>上下载。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>函数调用的引入使得AI模型不仅仅局限于生成文本，而是能够真正“做事”。通过与外部工具和API的交互，AI可以获取实时数据、自动化任务、集成多种服务，从而更好地满足用户需求，提升应用的实用性和效率。无论是在个人助理、智能客服，还是在更复杂的企业系统中，函数调用都能极大增强AI的功能，改变我们与AI的互动方式。</p>\n<p>你是否已经开始在你的AI应用中使用函数调用了呢？如果有任何问题，欢迎在评论区与我们讨论！</p>\n<p>希望这篇博客能够帮助你更好地理解函数调用的概念及其应用，助力你在开发AI驱动的应用时做出更高效、智能的解决方案！</p>\n"},{"title":"Garnet，缓存的新选择！","date":"2024-04-07T07:24:24.000Z","_content":"\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/garnet.md","raw":"---\ntitle: Garnet，缓存的新选择！\ndate: 2024-04-07 15:24:24\ntags: Garnet 缓存 微软\n---\n\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"garnet","published":1,"updated":"2024-04-26T03:07:22.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawe000frkp11ai57hru","content":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/blog/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/blog/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/blog/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/blog/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/blog/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/blog/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/blog/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/blog/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"欢迎来到 ITProHub！","_content":"![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/hello-world.md","raw":"---\ntitle: 欢迎来到 ITProHub！\n---\n![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"hello-world","published":1,"date":"2024-03-13T07:54:13.172Z","updated":"2024-04-26T03:07:16.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawf000grkp13kdh2nrk","content":"<p><img src=\"/blog/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/blog/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"HTTPS的工作原理以及安装","date":"2024-04-11T07:36:46.000Z","_content":"\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/https.md","raw":"---\ntitle: HTTPS的工作原理以及安装\ndate: 2024-04-11 15:36:46\ntags: https http ssl tls\n---\n\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"https","published":1,"updated":"2024-04-26T03:06:40.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawf000jrkp1hyzzcmso","content":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/blog/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/blog/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/blog/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/blog/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/blog/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/blog/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/blog/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/blog/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/blog/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/blog/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/blog/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/blog/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/blog/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/blog/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/blog/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/blog/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"深入理解 HTTP Connection 头","date":"2024-03-19T08:11:52.000Z","_content":"HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/http.md","raw":"---\ntitle: 深入理解 HTTP Connection 头\ndate: 2024-03-19 16:11:52\ntags: http http协议 Connection\n---\nHTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"http","published":1,"updated":"2024-04-26T03:06:44.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawg000krkp1d6492mnk","content":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/blog/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/blog/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/blog/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/blog/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/blog/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/blog/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"👨‍💻 十年开发老兵，从.NET到Java：我为何选择重新出发？ 🚀","date":"2025-04-02T07:48:33.000Z","_content":"\n🌱 **初心依旧，岁月如梭**\n\n3️⃣4️⃣岁的我，作为一名软件开发工程师，已经在这个行业整整🔟年。过去的职业生涯中，我曾以.NET（C#）作为自己的主要技术方向。诚然，C#语言优雅的语法、强大的生态系统以及微软对.NET的持续优化，都曾给我带来极佳的开发体验。然而，最近我却做出一个令朋友们感到意外的决定：**从.NET（C#）转向Java开发。**\n![程序员](./images/java-init/me.png)\n为什么我要从看似舒适的技术领域跳出，踏入另一个全新的生态圈呢？我想在这里分享一下我的真实想法和背后的原因。\n\n🌧️ **瓶颈浮现，渴望成长**\n\n回想刚进入职场时，我最先接触的是PHP。没错，就是那个被戏称为“世界上最好的语言”的PHP。当时的技术门槛相对较低，我主要负责基础网站开发，日复一日重复简单的任务，很快让我感到成长遇到了瓶颈。为了突破现状，我不断自学新知识，积极尝试各种新的技术和框架，渴望找到更广阔的发展空间。\n\n🌠 **机缘巧合，开启.NET之路**\n\n后来，在一次偶然的机会下，我接触到了.NET开发。伴随公司业务的迅猛增长，我的技术视野和项目经验迅速扩展。从初期的简单网页开发，到后来的企业级业务系统，再到复杂的分布式应用架构，我逐渐成为团队中独当一面的核心技术人员。这十年，我见证了技术的快速发展，也经历了职业的起伏与挑战，让我对技术领域的艰辛与魅力有了更加深刻的认识。\n\n🍂 **中年危机，思考未来**\n\n然而，步入中年后，现实的问题不断提醒着我：仅靠过去的技术经验无法长期立足，必须关注市场变化和未来发展趋势。同时，作为家庭的支柱，肩负着上有老、下有小的重担，这种焦虑和压力不断迫使我重新审视自己的职业规划。\n![程序员](./images/java-init/mid-life-cris.jpg)\n\n朋友曾对我说：“我们改变不了环境，唯一能做的，就是以不变应万变。而这个唯一的【不变】就是持续提升自身核心竞争力”这句话深深触动了我，也成为我决定转型的动力。\n\n🌊 **风暴来袭，职场动荡**\n\n近两年，全球经济动荡不安，各行业都经历了裁员潮。我所在的公司也未能幸免，频繁的大规模裁员让身边熟悉的同事陆续离开，甚至包括一些共事多年的老员工。曾经有一段时间，公司内部人心惶惶。这些变动让我意识到：被裁员可能只是时间问题，或是因为公司业务变动，或是因为年龄。\n\n偶然看到一个同事的企业微信签名：“Do the right thing, wait to get fired.” 这句话触动了我：做正确的事， 等被裁员。裁员之后呢？我是否准备好迎接下一次机会？\n\n🏙️ **市场转变，重新启程**\n\n与此同时，我所在的城市，.NET相关岗位明显减少，薪资待遇也随之下降。越来越多企业开始转向Java或其他技术领域，市场的变化让我不得不考虑新的出路。\n\n面对家庭的经济压力与责任，我不敢让自己陷入职场空档期，必须快速做出战略性调整。经过深入的调研和慎重思考，我决定放弃深耕多年的.NET领域，全面转向Java开发。\n\n🌳 **为何选择Java？未来可期**\n\n选择Java的原因，一方面是因为Java技术生态极为成熟，社区庞大且资源丰富，市场需求持续旺盛，岗位稳定且待遇较佳；另一方面，Java广泛应用于云计算、大数据、微服务、企业级应用和移动互联网领域，发展潜力巨大。此外，更重要的是，在我生活的城市，Java相关岗位更加丰富，提供了更多职业发展机会。\n![程序员](./images/java-init/java.png)\n🌟 **从零开始，重塑自己**\n\n做出转型决定后，我迅速投入到紧张而充实的学习中。尽管积累了多年开发经验，但转型Java仍意味着一切从零开始。从基础知识到高级框架，从Spring、Spring Boot到微服务架构，每一步都充满了挑战与压力。\n\n幸运的是，多年编程经验帮助我快速适应新技术。学习过程中，每一次掌握新知识点带来的成就感，都让我倍感欣喜，也成为我不断坚持的动力。\n\n✍️ **分享交流，共同成长**\n\n接下来，我会不定期（主要看心情😜）分享学习Java过程中觉得有趣、有收获的内容。曾经看到网上调侃的“Java从入门到放弃”，我想亲身体验一下这个过程究竟如何。至于最终是坚持到底，还是中途放弃，让我们一起拭目以待吧！\n\n🌅 **未来可期，砥砺前行**\n\n3️⃣4️⃣岁重新出发绝非易事，但我相信人生充满无限可能。愿我们每个人都能找到适合自己的职业道路，勇敢前行，迎接更加美好的未来。\n![程序员](./images/java-init/future.png)\n\n📌 **下期预告**：下一篇，我将详细介绍从.NET转向Java前的准备工作与学习路径规划，敬请期待！\n\n愿与各位技术同仁共同成长，探索技术世界更广阔的天地！\n\n","source":"_posts/java-init.md","raw":"---\ntitle: 👨‍💻 十年开发老兵，从.NET到Java：我为何选择重新出发？ 🚀\ndate: 2025-04-02 15:48:33\ntags:\n---\n\n🌱 **初心依旧，岁月如梭**\n\n3️⃣4️⃣岁的我，作为一名软件开发工程师，已经在这个行业整整🔟年。过去的职业生涯中，我曾以.NET（C#）作为自己的主要技术方向。诚然，C#语言优雅的语法、强大的生态系统以及微软对.NET的持续优化，都曾给我带来极佳的开发体验。然而，最近我却做出一个令朋友们感到意外的决定：**从.NET（C#）转向Java开发。**\n![程序员](./images/java-init/me.png)\n为什么我要从看似舒适的技术领域跳出，踏入另一个全新的生态圈呢？我想在这里分享一下我的真实想法和背后的原因。\n\n🌧️ **瓶颈浮现，渴望成长**\n\n回想刚进入职场时，我最先接触的是PHP。没错，就是那个被戏称为“世界上最好的语言”的PHP。当时的技术门槛相对较低，我主要负责基础网站开发，日复一日重复简单的任务，很快让我感到成长遇到了瓶颈。为了突破现状，我不断自学新知识，积极尝试各种新的技术和框架，渴望找到更广阔的发展空间。\n\n🌠 **机缘巧合，开启.NET之路**\n\n后来，在一次偶然的机会下，我接触到了.NET开发。伴随公司业务的迅猛增长，我的技术视野和项目经验迅速扩展。从初期的简单网页开发，到后来的企业级业务系统，再到复杂的分布式应用架构，我逐渐成为团队中独当一面的核心技术人员。这十年，我见证了技术的快速发展，也经历了职业的起伏与挑战，让我对技术领域的艰辛与魅力有了更加深刻的认识。\n\n🍂 **中年危机，思考未来**\n\n然而，步入中年后，现实的问题不断提醒着我：仅靠过去的技术经验无法长期立足，必须关注市场变化和未来发展趋势。同时，作为家庭的支柱，肩负着上有老、下有小的重担，这种焦虑和压力不断迫使我重新审视自己的职业规划。\n![程序员](./images/java-init/mid-life-cris.jpg)\n\n朋友曾对我说：“我们改变不了环境，唯一能做的，就是以不变应万变。而这个唯一的【不变】就是持续提升自身核心竞争力”这句话深深触动了我，也成为我决定转型的动力。\n\n🌊 **风暴来袭，职场动荡**\n\n近两年，全球经济动荡不安，各行业都经历了裁员潮。我所在的公司也未能幸免，频繁的大规模裁员让身边熟悉的同事陆续离开，甚至包括一些共事多年的老员工。曾经有一段时间，公司内部人心惶惶。这些变动让我意识到：被裁员可能只是时间问题，或是因为公司业务变动，或是因为年龄。\n\n偶然看到一个同事的企业微信签名：“Do the right thing, wait to get fired.” 这句话触动了我：做正确的事， 等被裁员。裁员之后呢？我是否准备好迎接下一次机会？\n\n🏙️ **市场转变，重新启程**\n\n与此同时，我所在的城市，.NET相关岗位明显减少，薪资待遇也随之下降。越来越多企业开始转向Java或其他技术领域，市场的变化让我不得不考虑新的出路。\n\n面对家庭的经济压力与责任，我不敢让自己陷入职场空档期，必须快速做出战略性调整。经过深入的调研和慎重思考，我决定放弃深耕多年的.NET领域，全面转向Java开发。\n\n🌳 **为何选择Java？未来可期**\n\n选择Java的原因，一方面是因为Java技术生态极为成熟，社区庞大且资源丰富，市场需求持续旺盛，岗位稳定且待遇较佳；另一方面，Java广泛应用于云计算、大数据、微服务、企业级应用和移动互联网领域，发展潜力巨大。此外，更重要的是，在我生活的城市，Java相关岗位更加丰富，提供了更多职业发展机会。\n![程序员](./images/java-init/java.png)\n🌟 **从零开始，重塑自己**\n\n做出转型决定后，我迅速投入到紧张而充实的学习中。尽管积累了多年开发经验，但转型Java仍意味着一切从零开始。从基础知识到高级框架，从Spring、Spring Boot到微服务架构，每一步都充满了挑战与压力。\n\n幸运的是，多年编程经验帮助我快速适应新技术。学习过程中，每一次掌握新知识点带来的成就感，都让我倍感欣喜，也成为我不断坚持的动力。\n\n✍️ **分享交流，共同成长**\n\n接下来，我会不定期（主要看心情😜）分享学习Java过程中觉得有趣、有收获的内容。曾经看到网上调侃的“Java从入门到放弃”，我想亲身体验一下这个过程究竟如何。至于最终是坚持到底，还是中途放弃，让我们一起拭目以待吧！\n\n🌅 **未来可期，砥砺前行**\n\n3️⃣4️⃣岁重新出发绝非易事，但我相信人生充满无限可能。愿我们每个人都能找到适合自己的职业道路，勇敢前行，迎接更加美好的未来。\n![程序员](./images/java-init/future.png)\n\n📌 **下期预告**：下一篇，我将详细介绍从.NET转向Java前的准备工作与学习路径规划，敬请期待！\n\n愿与各位技术同仁共同成长，探索技术世界更广阔的天地！\n\n","slug":"java-init","published":1,"updated":"2025-04-07T03:15:32.610Z","_id":"cm96gfawg000lrkp1hwqagquh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>🌱 <strong>初心依旧，岁月如梭</strong></p>\n<p>3️⃣4️⃣岁的我，作为一名软件开发工程师，已经在这个行业整整🔟年。过去的职业生涯中，我曾以.NET（C#）作为自己的主要技术方向。诚然，C#语言优雅的语法、强大的生态系统以及微软对.NET的持续优化，都曾给我带来极佳的开发体验。然而，最近我却做出一个令朋友们感到意外的决定：<strong>从.NET（C#）转向Java开发。</strong><br><img src=\"/blog/./images/java-init/me.png\" alt=\"程序员\"><br>为什么我要从看似舒适的技术领域跳出，踏入另一个全新的生态圈呢？我想在这里分享一下我的真实想法和背后的原因。</p>\n<p>🌧️ <strong>瓶颈浮现，渴望成长</strong></p>\n<p>回想刚进入职场时，我最先接触的是PHP。没错，就是那个被戏称为“世界上最好的语言”的PHP。当时的技术门槛相对较低，我主要负责基础网站开发，日复一日重复简单的任务，很快让我感到成长遇到了瓶颈。为了突破现状，我不断自学新知识，积极尝试各种新的技术和框架，渴望找到更广阔的发展空间。</p>\n<p>🌠 <strong>机缘巧合，开启.NET之路</strong></p>\n<p>后来，在一次偶然的机会下，我接触到了.NET开发。伴随公司业务的迅猛增长，我的技术视野和项目经验迅速扩展。从初期的简单网页开发，到后来的企业级业务系统，再到复杂的分布式应用架构，我逐渐成为团队中独当一面的核心技术人员。这十年，我见证了技术的快速发展，也经历了职业的起伏与挑战，让我对技术领域的艰辛与魅力有了更加深刻的认识。</p>\n<p>🍂 <strong>中年危机，思考未来</strong></p>\n<p>然而，步入中年后，现实的问题不断提醒着我：仅靠过去的技术经验无法长期立足，必须关注市场变化和未来发展趋势。同时，作为家庭的支柱，肩负着上有老、下有小的重担，这种焦虑和压力不断迫使我重新审视自己的职业规划。<br><img src=\"/blog/./images/java-init/mid-life-cris.jpg\" alt=\"程序员\"></p>\n<p>朋友曾对我说：“我们改变不了环境，唯一能做的，就是以不变应万变。而这个唯一的【不变】就是持续提升自身核心竞争力”这句话深深触动了我，也成为我决定转型的动力。</p>\n<p>🌊 <strong>风暴来袭，职场动荡</strong></p>\n<p>近两年，全球经济动荡不安，各行业都经历了裁员潮。我所在的公司也未能幸免，频繁的大规模裁员让身边熟悉的同事陆续离开，甚至包括一些共事多年的老员工。曾经有一段时间，公司内部人心惶惶。这些变动让我意识到：被裁员可能只是时间问题，或是因为公司业务变动，或是因为年龄。</p>\n<p>偶然看到一个同事的企业微信签名：“Do the right thing, wait to get fired.” 这句话触动了我：做正确的事， 等被裁员。裁员之后呢？我是否准备好迎接下一次机会？</p>\n<p>🏙️ <strong>市场转变，重新启程</strong></p>\n<p>与此同时，我所在的城市，.NET相关岗位明显减少，薪资待遇也随之下降。越来越多企业开始转向Java或其他技术领域，市场的变化让我不得不考虑新的出路。</p>\n<p>面对家庭的经济压力与责任，我不敢让自己陷入职场空档期，必须快速做出战略性调整。经过深入的调研和慎重思考，我决定放弃深耕多年的.NET领域，全面转向Java开发。</p>\n<p>🌳 <strong>为何选择Java？未来可期</strong></p>\n<p>选择Java的原因，一方面是因为Java技术生态极为成熟，社区庞大且资源丰富，市场需求持续旺盛，岗位稳定且待遇较佳；另一方面，Java广泛应用于云计算、大数据、微服务、企业级应用和移动互联网领域，发展潜力巨大。此外，更重要的是，在我生活的城市，Java相关岗位更加丰富，提供了更多职业发展机会。<br><img src=\"/blog/./images/java-init/java.png\" alt=\"程序员\"><br>🌟 <strong>从零开始，重塑自己</strong></p>\n<p>做出转型决定后，我迅速投入到紧张而充实的学习中。尽管积累了多年开发经验，但转型Java仍意味着一切从零开始。从基础知识到高级框架，从Spring、Spring Boot到微服务架构，每一步都充满了挑战与压力。</p>\n<p>幸运的是，多年编程经验帮助我快速适应新技术。学习过程中，每一次掌握新知识点带来的成就感，都让我倍感欣喜，也成为我不断坚持的动力。</p>\n<p>✍️ <strong>分享交流，共同成长</strong></p>\n<p>接下来，我会不定期（主要看心情😜）分享学习Java过程中觉得有趣、有收获的内容。曾经看到网上调侃的“Java从入门到放弃”，我想亲身体验一下这个过程究竟如何。至于最终是坚持到底，还是中途放弃，让我们一起拭目以待吧！</p>\n<p>🌅 <strong>未来可期，砥砺前行</strong></p>\n<p>3️⃣4️⃣岁重新出发绝非易事，但我相信人生充满无限可能。愿我们每个人都能找到适合自己的职业道路，勇敢前行，迎接更加美好的未来。<br><img src=\"/blog/./images/java-init/future.png\" alt=\"程序员\"></p>\n<p>📌 <strong>下期预告</strong>：下一篇，我将详细介绍从.NET转向Java前的准备工作与学习路径规划，敬请期待！</p>\n<p>愿与各位技术同仁共同成长，探索技术世界更广阔的天地！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>🌱 <strong>初心依旧，岁月如梭</strong></p>\n<p>3️⃣4️⃣岁的我，作为一名软件开发工程师，已经在这个行业整整🔟年。过去的职业生涯中，我曾以.NET（C#）作为自己的主要技术方向。诚然，C#语言优雅的语法、强大的生态系统以及微软对.NET的持续优化，都曾给我带来极佳的开发体验。然而，最近我却做出一个令朋友们感到意外的决定：<strong>从.NET（C#）转向Java开发。</strong><br><img src=\"/blog/./images/java-init/me.png\" alt=\"程序员\"><br>为什么我要从看似舒适的技术领域跳出，踏入另一个全新的生态圈呢？我想在这里分享一下我的真实想法和背后的原因。</p>\n<p>🌧️ <strong>瓶颈浮现，渴望成长</strong></p>\n<p>回想刚进入职场时，我最先接触的是PHP。没错，就是那个被戏称为“世界上最好的语言”的PHP。当时的技术门槛相对较低，我主要负责基础网站开发，日复一日重复简单的任务，很快让我感到成长遇到了瓶颈。为了突破现状，我不断自学新知识，积极尝试各种新的技术和框架，渴望找到更广阔的发展空间。</p>\n<p>🌠 <strong>机缘巧合，开启.NET之路</strong></p>\n<p>后来，在一次偶然的机会下，我接触到了.NET开发。伴随公司业务的迅猛增长，我的技术视野和项目经验迅速扩展。从初期的简单网页开发，到后来的企业级业务系统，再到复杂的分布式应用架构，我逐渐成为团队中独当一面的核心技术人员。这十年，我见证了技术的快速发展，也经历了职业的起伏与挑战，让我对技术领域的艰辛与魅力有了更加深刻的认识。</p>\n<p>🍂 <strong>中年危机，思考未来</strong></p>\n<p>然而，步入中年后，现实的问题不断提醒着我：仅靠过去的技术经验无法长期立足，必须关注市场变化和未来发展趋势。同时，作为家庭的支柱，肩负着上有老、下有小的重担，这种焦虑和压力不断迫使我重新审视自己的职业规划。<br><img src=\"/blog/./images/java-init/mid-life-cris.jpg\" alt=\"程序员\"></p>\n<p>朋友曾对我说：“我们改变不了环境，唯一能做的，就是以不变应万变。而这个唯一的【不变】就是持续提升自身核心竞争力”这句话深深触动了我，也成为我决定转型的动力。</p>\n<p>🌊 <strong>风暴来袭，职场动荡</strong></p>\n<p>近两年，全球经济动荡不安，各行业都经历了裁员潮。我所在的公司也未能幸免，频繁的大规模裁员让身边熟悉的同事陆续离开，甚至包括一些共事多年的老员工。曾经有一段时间，公司内部人心惶惶。这些变动让我意识到：被裁员可能只是时间问题，或是因为公司业务变动，或是因为年龄。</p>\n<p>偶然看到一个同事的企业微信签名：“Do the right thing, wait to get fired.” 这句话触动了我：做正确的事， 等被裁员。裁员之后呢？我是否准备好迎接下一次机会？</p>\n<p>🏙️ <strong>市场转变，重新启程</strong></p>\n<p>与此同时，我所在的城市，.NET相关岗位明显减少，薪资待遇也随之下降。越来越多企业开始转向Java或其他技术领域，市场的变化让我不得不考虑新的出路。</p>\n<p>面对家庭的经济压力与责任，我不敢让自己陷入职场空档期，必须快速做出战略性调整。经过深入的调研和慎重思考，我决定放弃深耕多年的.NET领域，全面转向Java开发。</p>\n<p>🌳 <strong>为何选择Java？未来可期</strong></p>\n<p>选择Java的原因，一方面是因为Java技术生态极为成熟，社区庞大且资源丰富，市场需求持续旺盛，岗位稳定且待遇较佳；另一方面，Java广泛应用于云计算、大数据、微服务、企业级应用和移动互联网领域，发展潜力巨大。此外，更重要的是，在我生活的城市，Java相关岗位更加丰富，提供了更多职业发展机会。<br><img src=\"/blog/./images/java-init/java.png\" alt=\"程序员\"><br>🌟 <strong>从零开始，重塑自己</strong></p>\n<p>做出转型决定后，我迅速投入到紧张而充实的学习中。尽管积累了多年开发经验，但转型Java仍意味着一切从零开始。从基础知识到高级框架，从Spring、Spring Boot到微服务架构，每一步都充满了挑战与压力。</p>\n<p>幸运的是，多年编程经验帮助我快速适应新技术。学习过程中，每一次掌握新知识点带来的成就感，都让我倍感欣喜，也成为我不断坚持的动力。</p>\n<p>✍️ <strong>分享交流，共同成长</strong></p>\n<p>接下来，我会不定期（主要看心情😜）分享学习Java过程中觉得有趣、有收获的内容。曾经看到网上调侃的“Java从入门到放弃”，我想亲身体验一下这个过程究竟如何。至于最终是坚持到底，还是中途放弃，让我们一起拭目以待吧！</p>\n<p>🌅 <strong>未来可期，砥砺前行</strong></p>\n<p>3️⃣4️⃣岁重新出发绝非易事，但我相信人生充满无限可能。愿我们每个人都能找到适合自己的职业道路，勇敢前行，迎接更加美好的未来。<br><img src=\"/blog/./images/java-init/future.png\" alt=\"程序员\"></p>\n<p>📌 <strong>下期预告</strong>：下一篇，我将详细介绍从.NET转向Java前的准备工作与学习路径规划，敬请期待！</p>\n<p>愿与各位技术同仁共同成长，探索技术世界更广阔的天地！</p>\n"},{"title":"JavaScript 信号：如何将响应式功能带到普通 Web 开发中","date":"2024-10-30T08:06:01.000Z","_content":"在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。\n\n# 信号是什么？\n信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。\n\n## 举个例子\n如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用\n```javascript\nimport { h } from 'preact';\nimport { signal, computed } from '@preact/signals';\nimport style from './style.css';\n\nconst username = signal('');\nconst password = signal('');\nconst message = computed(() => `用户名：${username.value} / 密码：${password.value}`);\nconst Test = ({ user }) => {\n\tconst submitForm = () => {\n\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<h2>用户注册</h2>\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tplaceholder=\"用户名\"\n\t\t\t\tonInput={(e) => username.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<input\n\t\t\t\ttype=\"password\"\n\t\t\t\tplaceholder=\"密码\"\n\t\t\t\tonInput={(e) => password.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<button onClick={submitForm}>提交</button>\n\t\t\t<p>{message}</p>\n\t\t</div>\n\t);\n};\n\nexport default Test;\n```\n运行上面preact的例子，我们可以看到如下效果\n![效果](./images/js-signal/responsive.gif)\n\n# 从零开始实现信号\n虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n}\n\n\nconst signal = new Signal('Initial Value');\nconsole.log(signal.value);\nsignal.addEventListener('change', (event) => {\n    console.log(`信号的新值是：${event.detail}`);\n});\n\nsignal.value = 'Updated Value'; // 输出：信号的新值是：Updated Value\nsignal.value = 'Another Value'; // 输出：信号的新值是：Another Value\n```\n这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：\n\n![效果](./images/js-signal/EventTarget.png)\n这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。\n\n# 增强功能：更简洁的 API\n我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n```\n现在，我们可以通过 effect 来简化代码：\n\n```javascript\nconst signal = new Signal('Initial Value');\nsignal.effect(() => console.log(`信号的新值是：${signal.value}`)); \nsignal.value = 'Updated Value'; \n```\n在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。\n![效果](./images/js-signal/EventTarget2.png)\n\n# 计算信号：依赖多个信号的计算\n有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n\n\nclass ComputedSignal extends Signal {\n    constructor(calculateFn, deps) {\n        super(calculateFn(...deps));\n        this.deps = deps;\n\n        deps.forEach(dep => {\n            dep.addEventListener('change', () => {\n                this.value = calculateFn(...deps);\n            });\n        });\n    }\n}\n\nconst name = new Signal('Thor');\nconst surname = new Signal('Odinson');\n\nconst fullName = new ComputedSignal((first, last) => `${first} ${last}`, [name, surname]);\n\nfullName.addEventListener('change', () => {\n    console.log(`计算后的全名是：${fullName.value}`);\n});\n\nname.value = 'Bruce'; // 输出：计算后的全名是：Bruce Odinson\nsurname.value = 'Banner'; // 输出：计算后的全名是：Bruce Banner\n```\n在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。\n![效果](./images/js-signal/EventTarget3.png)\n\n# 将信号与 Web 组件结合使用\n信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n}\n\ncustomElements.define('theme-switcher', class extends HTMLElement {\n    constructor() {\n        super();\n        this.darkThemeSignal = new Signal(false); // 默认为亮色主题\n    }\n\n    connectedCallback() {\n        // 创建主题切换按钮\n        this.innerHTML = `\n            <button id=\"light\">亮色主题</button>\n            <button id=\"dark\">暗色主题</button>\n            <p>当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}</p>\n        `;\n\n        // 获取按钮元素\n        const lightButton = this.querySelector('#light');\n        const darkButton = this.querySelector('#dark');\n        const statusText = this.querySelector('p');\n\n        // 监听按钮点击事件，切换主题\n        lightButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = false; // 切换到亮色主题\n        });\n\n        darkButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = true; // 切换到暗色主题\n        });\n\n        // 监听信号变化，更新主题\n        this.darkThemeSignal.effect(() => {\n            document.body.style.backgroundColor = this.darkThemeSignal.value ? 'black' : 'white';\n            document.body.style.color = this.darkThemeSignal.value ? 'white' : 'black';\n            statusText.textContent = `当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}`;\n        });\n    }\n});\n```\n这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。\n![切换主题](./images/js-signal/switch-theme.gif)\n\n# vue？\n通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。\n\n# 结语\n信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！","source":"_posts/js-signal.md","raw":"---\ntitle: JavaScript 信号：如何将响应式功能带到普通 Web 开发中\ndate: 2024-10-30 16:06:01\ntags:\n---\n在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。\n\n# 信号是什么？\n信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。\n\n## 举个例子\n如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用\n```javascript\nimport { h } from 'preact';\nimport { signal, computed } from '@preact/signals';\nimport style from './style.css';\n\nconst username = signal('');\nconst password = signal('');\nconst message = computed(() => `用户名：${username.value} / 密码：${password.value}`);\nconst Test = ({ user }) => {\n\tconst submitForm = () => {\n\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<h2>用户注册</h2>\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tplaceholder=\"用户名\"\n\t\t\t\tonInput={(e) => username.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<input\n\t\t\t\ttype=\"password\"\n\t\t\t\tplaceholder=\"密码\"\n\t\t\t\tonInput={(e) => password.value = e.target.value}\n\t\t\t/><br/>\n\t\t\t<button onClick={submitForm}>提交</button>\n\t\t\t<p>{message}</p>\n\t\t</div>\n\t);\n};\n\nexport default Test;\n```\n运行上面preact的例子，我们可以看到如下效果\n![效果](./images/js-signal/responsive.gif)\n\n# 从零开始实现信号\n虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n}\n\n\nconst signal = new Signal('Initial Value');\nconsole.log(signal.value);\nsignal.addEventListener('change', (event) => {\n    console.log(`信号的新值是：${event.detail}`);\n});\n\nsignal.value = 'Updated Value'; // 输出：信号的新值是：Updated Value\nsignal.value = 'Another Value'; // 输出：信号的新值是：Another Value\n```\n这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：\n\n![效果](./images/js-signal/EventTarget.png)\n这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。\n\n# 增强功能：更简洁的 API\n我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n```\n现在，我们可以通过 effect 来简化代码：\n\n```javascript\nconst signal = new Signal('Initial Value');\nsignal.effect(() => console.log(`信号的新值是：${signal.value}`)); \nsignal.value = 'Updated Value'; \n```\n在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。\n![效果](./images/js-signal/EventTarget2.png)\n\n# 计算信号：依赖多个信号的计算\n有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    valueOf () { return this.#value; }\n    toString () { return String(this.#value); }\n}\n\n\nclass ComputedSignal extends Signal {\n    constructor(calculateFn, deps) {\n        super(calculateFn(...deps));\n        this.deps = deps;\n\n        deps.forEach(dep => {\n            dep.addEventListener('change', () => {\n                this.value = calculateFn(...deps);\n            });\n        });\n    }\n}\n\nconst name = new Signal('Thor');\nconst surname = new Signal('Odinson');\n\nconst fullName = new ComputedSignal((first, last) => `${first} ${last}`, [name, surname]);\n\nfullName.addEventListener('change', () => {\n    console.log(`计算后的全名是：${fullName.value}`);\n});\n\nname.value = 'Bruce'; // 输出：计算后的全名是：Bruce Odinson\nsurname.value = 'Banner'; // 输出：计算后的全名是：Bruce Banner\n```\n在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。\n![效果](./images/js-signal/EventTarget3.png)\n\n# 将信号与 Web 组件结合使用\n信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。\n\n```javascript\nclass Signal extends EventTarget {\n    #value;\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n    get value() {\n        return this.#value;\n    }\n\n    set value(newValue) {\n        if (this.#value !== newValue) {\n            this.#value = newValue;\n            this.dispatchEvent(new CustomEvent('change', { detail: newValue }));\n        }\n    }\n\n    effect(fn) {\n        fn();\n        this.addEventListener('change', fn);\n        return () => this.removeEventListener('change', fn);\n    }\n}\n\ncustomElements.define('theme-switcher', class extends HTMLElement {\n    constructor() {\n        super();\n        this.darkThemeSignal = new Signal(false); // 默认为亮色主题\n    }\n\n    connectedCallback() {\n        // 创建主题切换按钮\n        this.innerHTML = `\n            <button id=\"light\">亮色主题</button>\n            <button id=\"dark\">暗色主题</button>\n            <p>当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}</p>\n        `;\n\n        // 获取按钮元素\n        const lightButton = this.querySelector('#light');\n        const darkButton = this.querySelector('#dark');\n        const statusText = this.querySelector('p');\n\n        // 监听按钮点击事件，切换主题\n        lightButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = false; // 切换到亮色主题\n        });\n\n        darkButton.addEventListener('click', () => {\n            this.darkThemeSignal.value = true; // 切换到暗色主题\n        });\n\n        // 监听信号变化，更新主题\n        this.darkThemeSignal.effect(() => {\n            document.body.style.backgroundColor = this.darkThemeSignal.value ? 'black' : 'white';\n            document.body.style.color = this.darkThemeSignal.value ? 'white' : 'black';\n            statusText.textContent = `当前主题：${this.darkThemeSignal.value ? '暗色' : '亮色'}`;\n        });\n    }\n});\n```\n这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。\n![切换主题](./images/js-signal/switch-theme.gif)\n\n# vue？\n通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。\n\n# 结语\n信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！","slug":"js-signal","published":1,"updated":"2024-11-05T07:08:38.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawh000orkp12lflcor3","content":"<p>在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。</p>\n<h1 id=\"信号是什么？\"><a href=\"#信号是什么？\" class=\"headerlink\" title=\"信号是什么？\"></a>信号是什么？</h1><p>信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。</p>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; h &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;preact&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; signal, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@preact/signals&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./style.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> username = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> password = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> <span class=\"string\">`用户名：<span class=\"subst\">$&#123;username.value&#125;</span> / 密码：<span class=\"subst\">$&#123;password.value&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Test</span> = (<span class=\"params\">&#123; user &#125;</span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"title function_\">submitForm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>用户注册<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;用户名&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> username.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;密码&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> password.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;submitForm&#125;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;message&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Test</span>;</span><br></pre></td></tr></table></figure>\n<p>运行上面preact的例子，我们可以看到如下效果<br><img src=\"/blog/./images/js-signal/responsive.gif\" alt=\"效果\"></p>\n<h1 id=\"从零开始实现信号\"><a href=\"#从零开始实现信号\" class=\"headerlink\" title=\"从零开始实现信号\"></a>从零开始实现信号</h1><p>虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(signal.<span class=\"property\">value</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;event.detail&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Updated Value</span></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Another Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Another Value</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：</p>\n<p><img src=\"/blog/./images/js-signal/EventTarget.png\" alt=\"效果\"><br>这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。</p>\n<h1 id=\"增强功能：更简洁的-API\"><a href=\"#增强功能：更简洁的-API\" class=\"headerlink\" title=\"增强功能：更简洁的 API\"></a>增强功能：更简洁的 API</h1><p>我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以通过 effect 来简化代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;signal.value&#125;</span>`</span>)); </span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<p>在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。<br><img src=\"/blog/./images/js-signal/EventTarget2.png\" alt=\"效果\"></p>\n<h1 id=\"计算信号：依赖多个信号的计算\"><a href=\"#计算信号：依赖多个信号的计算\" class=\"headerlink\" title=\"计算信号：依赖多个信号的计算\"></a>计算信号：依赖多个信号的计算</h1><p>有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputedSignal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Signal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">calculateFn, deps</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(<span class=\"title function_\">calculateFn</span>(...deps));</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">deps</span> = deps;</span><br><span class=\"line\"></span><br><span class=\"line\">        deps.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">dep</span> =&gt;</span> &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"title function_\">calculateFn</span>(...deps);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Thor&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> surname = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Odinson&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fullName = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedSignal</span>(<span class=\"function\">(<span class=\"params\">first, last</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>`</span>, [name, surname]);</span><br><span class=\"line\"></span><br><span class=\"line\">fullName.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`计算后的全名是：<span class=\"subst\">$&#123;fullName.value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">name.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Bruce&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Odinson</span></span><br><span class=\"line\">surname.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Banner&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Banner</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。<br><img src=\"/blog/./images/js-signal/EventTarget3.png\" alt=\"效果\"></p>\n<h1 id=\"将信号与-Web-组件结合使用\"><a href=\"#将信号与-Web-组件结合使用\" class=\"headerlink\" title=\"将信号与 Web 组件结合使用\"></a>将信号与 Web 组件结合使用</h1><p>信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;theme-switcher&#x27;</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">HTMLElement</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// 默认为亮色主题</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建主题切换按钮</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;light&quot;&gt;亮色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;dark&quot;&gt;暗色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;p&gt;当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取按钮元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> lightButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#light&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> darkButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#dark&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> statusText = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听按钮点击事件，切换主题</span></span><br><span class=\"line\">        lightButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">false</span>; <span class=\"comment\">// 切换到亮色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        darkButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 切换到暗色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听信号变化，更新主题</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;black&#x27;</span> : <span class=\"string\">&#x27;white&#x27;</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;white&#x27;</span> : <span class=\"string\">&#x27;black&#x27;</span>;</span><br><span class=\"line\">            statusText.<span class=\"property\">textContent</span> = <span class=\"string\">`当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>`</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。<br><img src=\"/blog/./images/js-signal/switch-theme.gif\" alt=\"切换主题\"></p>\n<h1 id=\"vue？\"><a href=\"#vue？\" class=\"headerlink\" title=\"vue？\"></a>vue？</h1><p>通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在现代前端框架中，信号（Signals）正变得越来越流行。从 Angular 到 Solid、Preact，几乎所有主流框架都在使用信号，甚至有提案将其作为语言的核心功能。如果这个提案通过，那么框架中内置信号将是时间问题，而对于普通的 Web 开发者来说，信号也不再是遥不可及的技术。</p>\n<h1 id=\"信号是什么？\"><a href=\"#信号是什么？\" class=\"headerlink\" title=\"信号是什么？\"></a>信号是什么？</h1><p>信号本质上是一个可以包装值并在值发生变化时发出事件的机制。在更现代的框架中，信号通过捕捉数据的变化并以响应的方式进行操作，避免了像传统 DOM 更新那样的重绘操作，从而提高了性能和开发效率。它的最大特点是能够简洁、高效地处理响应式状态，而不需要像 React 那样频繁地重新渲染整个组件。</p>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>如果你对前端不是很熟悉，或者与世隔绝很久了，我们先通过下面的例子来简单了解一下信号的作用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; h &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;preact&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; signal, computed &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@preact/signals&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> style <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./style.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> username = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> password = <span class=\"title function_\">signal</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> <span class=\"string\">`用户名：<span class=\"subst\">$&#123;username.value&#125;</span> / 密码：<span class=\"subst\">$&#123;password.value&#125;</span>`</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Test</span> = (<span class=\"params\">&#123; user &#125;</span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"title function_\">submitForm</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (</span><br><span class=\"line\">\t\t<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>用户注册<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;用户名&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> username.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;密码&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">\t\t\t\t<span class=\"attr\">onInput</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> password.value = e.target.value&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t/&gt;<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;submitForm&#125;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;message&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">\t);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Test</span>;</span><br></pre></td></tr></table></figure>\n<p>运行上面preact的例子，我们可以看到如下效果<br><img src=\"/blog/./images/js-signal/responsive.gif\" alt=\"效果\"></p>\n<h1 id=\"从零开始实现信号\"><a href=\"#从零开始实现信号\" class=\"headerlink\" title=\"从零开始实现信号\"></a>从零开始实现信号</h1><p>虽然信号在大多数现代框架中已经成为标准，但对于普通的 Web 开发者来说，我们可以通过一些简单的技巧在普通的 JavaScript 环境中实现类似的功能。我们通过 EventTarget 基类来封装信号，简单的包装便能实现信号机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(signal.<span class=\"property\">value</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;event.detail&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Updated Value</span></span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Another Value&#x27;</span>; <span class=\"comment\">// 输出：信号的新值是：Another Value</span></span><br></pre></td></tr></table></figure>\n<p>这段代码使用了 EventTarget 来监听和分发变化事件。通过 value 属性，我们可以轻松地读取和更新信号值，而当信号值改变时，会触发一个 change 事件。我们可以通过 addEventListener 来订阅信号变化：</p>\n<p><img src=\"/blog/./images/js-signal/EventTarget.png\" alt=\"效果\"><br>这只是信号的基本实现，接下来，我们可以通过添加一些语法糖来简化其使用体验。</p>\n<h1 id=\"增强功能：更简洁的-API\"><a href=\"#增强功能：更简洁的-API\" class=\"headerlink\" title=\"增强功能：更简洁的 API\"></a>增强功能：更简洁的 API</h1><p>我们可以为 Signal 添加一些额外的方法，简化订阅和取消订阅的操作。例如，effect 方法可以直接订阅信号的变化并执行相应的回调。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以通过 effect 来简化代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> signal = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Initial Value&#x27;</span>);</span><br><span class=\"line\">signal.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`信号的新值是：<span class=\"subst\">$&#123;signal.value&#125;</span>`</span>)); </span><br><span class=\"line\">signal.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Updated Value&#x27;</span>; </span><br></pre></td></tr></table></figure>\n<p>在这个例子中，effect 方法会立即执行一次回调，并订阅 change 事件。返回的取消函数可以让我们在不需要时取消对信号的订阅。<br><img src=\"/blog/./images/js-signal/EventTarget2.png\" alt=\"效果\"></p>\n<h1 id=\"计算信号：依赖多个信号的计算\"><a href=\"#计算信号：依赖多个信号的计算\" class=\"headerlink\" title=\"计算信号：依赖多个信号的计算\"></a>计算信号：依赖多个信号的计算</h1><p>有时我们需要基于多个信号来计算一个新值，这时候我们就需要计算信号。计算信号会基于其他信号的变化，自动重新计算自己的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    valueOf () &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value; &#125;</span><br><span class=\"line\">    toString () &#123; <span class=\"keyword\">return</span> <span class=\"title class_\">String</span>(<span class=\"variable language_\">this</span>.#value); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ComputedSignal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Signal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">calculateFn, deps</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(<span class=\"title function_\">calculateFn</span>(...deps));</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">deps</span> = deps;</span><br><span class=\"line\"></span><br><span class=\"line\">        deps.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">dep</span> =&gt;</span> &#123;</span><br><span class=\"line\">            dep.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">value</span> = <span class=\"title function_\">calculateFn</span>(...deps);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Thor&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> surname = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"string\">&#x27;Odinson&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fullName = <span class=\"keyword\">new</span> <span class=\"title class_\">ComputedSignal</span>(<span class=\"function\">(<span class=\"params\">first, last</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>`</span>, [name, surname]);</span><br><span class=\"line\"></span><br><span class=\"line\">fullName.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`计算后的全名是：<span class=\"subst\">$&#123;fullName.value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">name.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Bruce&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Odinson</span></span><br><span class=\"line\">surname.<span class=\"property\">value</span> = <span class=\"string\">&#x27;Banner&#x27;</span>; <span class=\"comment\">// 输出：计算后的全名是：Bruce Banner</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，fullName 会根据 name 和 surname 信号的变化自动更新。当 name 改变时，fullName 也会重新计算。<br><img src=\"/blog/./images/js-signal/EventTarget3.png\" alt=\"效果\"></p>\n<h1 id=\"将信号与-Web-组件结合使用\"><a href=\"#将信号与-Web-组件结合使用\" class=\"headerlink\" title=\"将信号与 Web 组件结合使用\"></a>将信号与 Web 组件结合使用</h1><p>信号的一个非常有趣的应用是在 Web 组件中。我们可以通过信号将状态和 UI 更新绑定在一起，从而避免直接操作 DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signal</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">EventTarget</span> &#123;</span><br><span class=\"line\">    #value;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.#value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.#value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">value</span>(<span class=\"params\">newValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.#value !== newValue) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.#value = newValue;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;change&#x27;</span>, &#123; <span class=\"attr\">detail</span>: newValue &#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">effect</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">&#x27;change&#x27;</span>, fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;theme-switcher&#x27;</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">HTMLElement</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Signal</span>(<span class=\"literal\">false</span>); <span class=\"comment\">// 默认为亮色主题</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建主题切换按钮</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;light&quot;&gt;亮色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;button id=&quot;dark&quot;&gt;暗色主题&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;p&gt;当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取按钮元素</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> lightButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#light&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> darkButton = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#dark&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> statusText = <span class=\"variable language_\">this</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听按钮点击事件，切换主题</span></span><br><span class=\"line\">        lightButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">false</span>; <span class=\"comment\">// 切换到亮色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        darkButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> = <span class=\"literal\">true</span>; <span class=\"comment\">// 切换到暗色主题</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听信号变化，更新主题</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;black&#x27;</span> : <span class=\"string\">&#x27;white&#x27;</span>;</span><br><span class=\"line\">            <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">darkThemeSignal</span>.<span class=\"property\">value</span> ? <span class=\"string\">&#x27;white&#x27;</span> : <span class=\"string\">&#x27;black&#x27;</span>;</span><br><span class=\"line\">            statusText.<span class=\"property\">textContent</span> = <span class=\"string\">`当前主题：<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.darkThemeSignal.value ? <span class=\"string\">&#x27;暗色&#x27;</span> : <span class=\"string\">&#x27;亮色&#x27;</span>&#125;</span>`</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个例子中，实现一个简单的主题切换器，允许用户在“暗色”和“亮色”主题之间切换。信号将用于存储当前主题，Web 组件将用于渲染和切换主题。<br><img src=\"/blog/./images/js-signal/switch-theme.gif\" alt=\"切换主题\"></p>\n<h1 id=\"vue？\"><a href=\"#vue？\" class=\"headerlink\" title=\"vue？\"></a>vue？</h1><p>通过上面实现的效果很容易让我们联想到双向绑定的vue。但是需要注意的是，vue3的响应式系统是基于Proxy实现的（vue2是Object.defineProperty），而我们实现的信号是基于EventTarget实现的。因此，虽然它们都能实现响应式，但它们的实现原理和使用方式是不同的。虽然 Vue 使用了类似于事件的机制来通知视图更新（当数据发生变化时，通知组件重新渲染），但 Vue 的核心机制并不是基于 EventTarget。Vue 更侧重于数据响应和依赖跟踪。EventTarget 通常用于事件处理（如 DOM 事件），而 Vue 更专注于数据绑定和自动更新，并通过依赖收集和更新机制来触发视图的变化。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>信号提供了一种简洁且高效的方式来响应数据变化，在现代 Web 开发中大有可为。通过简单的 JavaScript，我们可以将信号机制引入到应用中，不再依赖大型框架即可享受响应式的编程体验。如果你还没尝试过信号，赶快开始吧！</p>\n"},{"title":"从入门到实战：一文搞定JS无埋点监控方案","description":"本文将详细介绍如何利用JavaScript实现前端无埋点监控，并重点探讨Ajax请求监控和用户点击事件监控的具体技术方案及其应用案例。","date":"2025-03-28T03:27:18.000Z","_content":"\n在前端性能与用户行为分析愈发重要的今天，埋点监控成为各类业务不可或缺的基础设施。但传统手动埋点方式存在维护成本高、容易遗漏等问题。本文将带你从0到1构建一套JavaScript无埋点监控方案，真正实现自动上报用户行为与性能数据。\n\n## 什么是无埋点监控？\n\n无埋点监控，指的是在不修改业务代码的前提下，通过全局监听或劫持的方式自动采集用户行为与性能数据。常见的采集内容包括：\n\n- 页面访问（PV）和跳转（UV）\n- 用户点击行为\n- 控件输入行为\n- JS错误和Promise异常\n- 页面性能数据（如白屏、DOM加载时间等）\n\n无埋点监控通常具备以下优势：\n\n- 减少开发和维护成本；\n- 实时自动化捕捉用户行为；\n- 高效适应业务需求的变化；\n\n## 为什么需要前端监控？\n\n- 快速定位问题：前端监控可以帮助开发人员快速定位问题，减少调试时间和成本。\n- 提高用户体验：通过监控用户行为，开发人员可以及时发现并解决用户体验问题，提升用户满意度。\n- 数据分析：前端监控可以收集用户行为数据，用于数据分析和产品优化。\n- 安全防护：监控可以帮助开发人员及时发现和修复安全风险，保护用户数据安全。\n\n## 实现思路\n\n无埋点监控的核心思路是：**通过劫持浏览器原生API + DOM事件监听 + 拦截网络请求**等手段，在不侵入业务逻辑的前提下采集信息并上报。\n\n具体模块划分如下：\n\n1. **基础信息采集模块**：获取设备信息、浏览器、分辨率等\n2. **行为采集模块**：\n   - 劫持 `addEventListener` 捕捉点击、输入等事件\n   - 劫持 `history.pushState` 和 `popstate` 监听页面跳转\n3. **异常采集模块**：监听 JS 错误、资源加载失败、Promise 异常\n4. **性能采集模块**：基于 `performance.timing` 和 `PerformanceObserver`\n5. **上报模块**：采用 `navigator.sendBeacon` 或 `fetch` 将数据发送到监控服务\n\n这是一张典型的JS无埋点监控方案流程图，从App启动到退出的整个生命周期，用户行为与应用运行过程中的各种事件都被精准记录下来。\n\n![前端监控的技术方案](./images/js-monitoring/flow_diagram.png)\n\n1. 应用启动（App Launch）\n    应用启动时，系统自动生成用户标识（UID）和会话标识（Sid），用于标记用户与会话之间的关联关系，贯穿用户全程行为的监控与分析。\n\n2. 页面展示（Page Show）与用户交互（Click）\n    当用户进入页面（Page Show）以及进行点击等交互行为（Click）时，无埋点方案自动捕获相关DOM元素信息与交互细节，并通过TraceID与Sid关联到具体会话与用户。\n\n3. 页面跳转与接口请求\n    用户发生页面跳转或发起接口请求时，监控系统自动捕获当前页面的路径、请求参数、响应信息和交互上下文。这些数据可用于后续的问题定位和用户行为分析。\n\n4. 错误监控（API报错与JS报错）\n    当应用运行时出现API接口异常或JavaScript错误时，监控系统会即时捕获异常信息，包括接口快照、现场信息与错误堆栈，为开发人员提供完整的错误现场还原能力，便于快速排查与修复。\n\n5. 服务端异常追踪\n    通过统一网关（例如Nginx）进行请求分发与TraceID记录，可以将客户端行为与服务端请求进行关联。当服务端出现异常时（例如Service C），能够快速定位并溯源到具体用户行为与请求，形成完整的链路监控与问题诊断机制。\n\n6. 页面隐藏（Page Hide）与应用退出（App Exit）\n    页面隐藏和用户退出应用时，系统记录最终的行为状态，完成一次完整的用户交互周期记录。\n\n## 无埋点监控的局限性及解决方案\n\n1. 数据量大且含噪音\n\n    无埋点监控会自动捕获大量用户交互数据，其中可能包含大量无效或低价值的数据。\n\n    解决方案：\n\n    - 设定合理的数据采样和过滤规则。\n\n    - 利用数据清洗工具对数据进行筛选和去重。\n\n4. 数据隐私问题\n\n    自动化的监控方式可能涉及用户隐私敏感数据。\n\n    解决方案：\n\n    - 在前端进行敏感信息脱敏处理。\n\n    - 制定并遵守严格的数据安全与隐私保护策略。    \n\n## 核心代码实现\n\n### 点击事件监控\n\n用户点击行为是前端应用中最常见且最重要的交互行为之一。我们通过事件冒泡机制统一在document层监听所有点击事件，捕获详细点击信息。\n\n```javascript\n(function() {\n  document.addEventListener('click', function(e) {\n    const target = e.target;\n    const elementInfo = {\n      tag: target.tagName,\n      id: target.id,\n      classList: Array.from(target.classList),\n      text: target.innerText.trim().slice(0, 50), // 限制50字符，避免数据过长\n      timestamp: new Date().toISOString(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    };\n    report({ type: 'Click', elementInfo });\n  }, true);\n})();\n```\n\n![promise](./images/js-monitoring/click.png)\n这种方式极大降低了监控实现的复杂性，同时在出现异常行为或用户反馈问题时，能够提供详细的操作现场数据。   \n\n### 异步请求监控实现\n前端应用中Ajax请求占据了用户体验的重要环节，因此对Ajax请求的监控尤为关键。无埋点监控的核心技术之一便是通过拦截XHR（XMLHttpRequest）和Fetch API的方式实现实时追踪。\n\n通过原型链劫持技术，我们可以实现对原生XHR请求进行统一封装与监控。\n\n```javascript\n(function() {\n  const originalXHR = window.XMLHttpRequest;\n  function MonitorXHR() {\n    const xhrInstance = new originalXHR();\n    xhrInstance.addEventListener('loadend', function() {\n      const { responseURL, status, responseText } = xhrInstance;\n      console.log('监控XHR请求:', { responseURL, status, responseText });\n      report({ type: 'XHR', responseURL, status, responseText });\n    });\n    return xhrInstance;\n  }\n  window.XMLHttpRequest = MonitorXHR;\n})();\n\n// 同理fetch API的监控实现\n// ...\n```\n![promise](./images/js-monitoring/promise.png)\n\n### 全局错误捕获\n通过`window.onerror`方法，我们能够捕获绝大多数运行时JavaScript错误，包括未捕获的异常。\n\n```javascript\nwindow.onerror = function(message, source, lineno, colno, error) {\n  const errorInfo = {\n    message,\n    source,\n    lineno,\n    colno,\n    stack: error ? error.stack : null,\n    timestamp: new Date().toISOString()\n  };\n  report({ type: 'JS Error', errorInfo });\n};\n// 现代JavaScript开发中，异步操作常用Promise实现，但其异常并不会触发`window.onerror`，因此需要额外监听`unhandledrejection`事件。\nwindow.addEventListener('unhandledrejection', function(event) {\n  const errorInfo = {\n    reason: event.reason,\n    timestamp: new Date().toISOString()\n  };\n  report({ type: 'Promise Error', errorInfo });\n});\n```\n通过以上方式，我们能有效地监控并快速定位JavaScript代码中的错误，提升应用稳定性和用户体验。\n\n![error](./images/js-monitoring/error.png)\n\n### 首次有效绘制（FMP）监控\n\n首次有效绘制（FMP）能够更准确地反映用户感知到的页面加载体验。\n\n实现思路：\n\n使用MutationObserver观察DOM变化，记录元素渲染进程。\n\n计算得分变化并识别首次有效绘制的时刻，上报关键绘制时刻数据。\n\n示例代码：\n```js\nconst MO = window.MutationObserver || window.WebKitMutationObserver;\nconst observer = new MO(listener);\nobserver.observe(document, { childList: true, subtree: true });\n\nconst listener = () => {}\n\nfunction reportFMPEvent(fmpInfo) {\n  report({ type: 'fmp', ...fmpInfo });\n}\n```\n![FMP监控](./images/js-monitoring/fmp.png)\n\n\n## 常见问题与解决方案\n\n### 问题一：点击事件目标获取不准？\n**解决方案**：在事件冒泡的捕获阶段监听，并结合 `e.composedPath()` 精准定位 DOM 元素。\n如果某个组件内部调用了 e.stopPropagation()，则事件不会冒泡至 document，你的监听器就捕获不到该点击事件。\n\n```javascript\ndocument.getElementById('error-btn').onclick = function(e) {\n    e.stopPropagation();\n};\n```\n解决方案：使用事件捕获阶段监听（第三个参数设为 true）：\n```javascript\ndocument.addEventListener('click', handler, true);\n```\n\n### 问题二：误监控或不该监控区域被上报？\n**解决方案**：给不希望监控的区域加上 data-no-track 属性；\n\n在代码中主动跳过：\n```javascript\nif (e.target.closest('[data-no-track]')) return;\n```\n\n### 问题三：如何保证数据不丢失？\n**解决方案**：优先使用 `navigator.sendBeacon`，因为它在页面卸载时也能发送数据；或使用 `beforeunload` 提前上报。\n\n### 问题四：对性能影响大吗？\n**解决方案**：\n- 避免频繁上报（如节流、合并多次点击事件）\n- 使用 `requestIdleCallback` 或 `setTimeout` 延迟非关键上报逻辑\n\n## 总结\n\n本文介绍了一套完整的 JS 无埋点监控方案，从基本原理到核心代码，并分析了实际中可能遇到的问题及应对方式。无埋点监控虽然强大，但建议根据业务需要进行裁剪，避免性能和数据隐私上的过度采集。\n\n未来你可以进一步拓展如下能力：\n\n- 录屏回放（如 rrweb）\n- 全埋点可视化配置界面\n- 异常聚合与报警系统对接\n\n希望本文对你构建自己的前端监控体系有所帮助。\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/js-monitoring)仓库。\n","source":"_posts/js-monitoring.md","raw":"---\ntitle: 从入门到实战：一文搞定JS无埋点监控方案\ndescription: 本文将详细介绍如何利用JavaScript实现前端无埋点监控，并重点探讨Ajax请求监控和用户点击事件监控的具体技术方案及其应用案例。\ndate: 2025-03-28 11:27:18\ntags: 前端监控 JavaScript Ajax\n---\n\n在前端性能与用户行为分析愈发重要的今天，埋点监控成为各类业务不可或缺的基础设施。但传统手动埋点方式存在维护成本高、容易遗漏等问题。本文将带你从0到1构建一套JavaScript无埋点监控方案，真正实现自动上报用户行为与性能数据。\n\n## 什么是无埋点监控？\n\n无埋点监控，指的是在不修改业务代码的前提下，通过全局监听或劫持的方式自动采集用户行为与性能数据。常见的采集内容包括：\n\n- 页面访问（PV）和跳转（UV）\n- 用户点击行为\n- 控件输入行为\n- JS错误和Promise异常\n- 页面性能数据（如白屏、DOM加载时间等）\n\n无埋点监控通常具备以下优势：\n\n- 减少开发和维护成本；\n- 实时自动化捕捉用户行为；\n- 高效适应业务需求的变化；\n\n## 为什么需要前端监控？\n\n- 快速定位问题：前端监控可以帮助开发人员快速定位问题，减少调试时间和成本。\n- 提高用户体验：通过监控用户行为，开发人员可以及时发现并解决用户体验问题，提升用户满意度。\n- 数据分析：前端监控可以收集用户行为数据，用于数据分析和产品优化。\n- 安全防护：监控可以帮助开发人员及时发现和修复安全风险，保护用户数据安全。\n\n## 实现思路\n\n无埋点监控的核心思路是：**通过劫持浏览器原生API + DOM事件监听 + 拦截网络请求**等手段，在不侵入业务逻辑的前提下采集信息并上报。\n\n具体模块划分如下：\n\n1. **基础信息采集模块**：获取设备信息、浏览器、分辨率等\n2. **行为采集模块**：\n   - 劫持 `addEventListener` 捕捉点击、输入等事件\n   - 劫持 `history.pushState` 和 `popstate` 监听页面跳转\n3. **异常采集模块**：监听 JS 错误、资源加载失败、Promise 异常\n4. **性能采集模块**：基于 `performance.timing` 和 `PerformanceObserver`\n5. **上报模块**：采用 `navigator.sendBeacon` 或 `fetch` 将数据发送到监控服务\n\n这是一张典型的JS无埋点监控方案流程图，从App启动到退出的整个生命周期，用户行为与应用运行过程中的各种事件都被精准记录下来。\n\n![前端监控的技术方案](./images/js-monitoring/flow_diagram.png)\n\n1. 应用启动（App Launch）\n    应用启动时，系统自动生成用户标识（UID）和会话标识（Sid），用于标记用户与会话之间的关联关系，贯穿用户全程行为的监控与分析。\n\n2. 页面展示（Page Show）与用户交互（Click）\n    当用户进入页面（Page Show）以及进行点击等交互行为（Click）时，无埋点方案自动捕获相关DOM元素信息与交互细节，并通过TraceID与Sid关联到具体会话与用户。\n\n3. 页面跳转与接口请求\n    用户发生页面跳转或发起接口请求时，监控系统自动捕获当前页面的路径、请求参数、响应信息和交互上下文。这些数据可用于后续的问题定位和用户行为分析。\n\n4. 错误监控（API报错与JS报错）\n    当应用运行时出现API接口异常或JavaScript错误时，监控系统会即时捕获异常信息，包括接口快照、现场信息与错误堆栈，为开发人员提供完整的错误现场还原能力，便于快速排查与修复。\n\n5. 服务端异常追踪\n    通过统一网关（例如Nginx）进行请求分发与TraceID记录，可以将客户端行为与服务端请求进行关联。当服务端出现异常时（例如Service C），能够快速定位并溯源到具体用户行为与请求，形成完整的链路监控与问题诊断机制。\n\n6. 页面隐藏（Page Hide）与应用退出（App Exit）\n    页面隐藏和用户退出应用时，系统记录最终的行为状态，完成一次完整的用户交互周期记录。\n\n## 无埋点监控的局限性及解决方案\n\n1. 数据量大且含噪音\n\n    无埋点监控会自动捕获大量用户交互数据，其中可能包含大量无效或低价值的数据。\n\n    解决方案：\n\n    - 设定合理的数据采样和过滤规则。\n\n    - 利用数据清洗工具对数据进行筛选和去重。\n\n4. 数据隐私问题\n\n    自动化的监控方式可能涉及用户隐私敏感数据。\n\n    解决方案：\n\n    - 在前端进行敏感信息脱敏处理。\n\n    - 制定并遵守严格的数据安全与隐私保护策略。    \n\n## 核心代码实现\n\n### 点击事件监控\n\n用户点击行为是前端应用中最常见且最重要的交互行为之一。我们通过事件冒泡机制统一在document层监听所有点击事件，捕获详细点击信息。\n\n```javascript\n(function() {\n  document.addEventListener('click', function(e) {\n    const target = e.target;\n    const elementInfo = {\n      tag: target.tagName,\n      id: target.id,\n      classList: Array.from(target.classList),\n      text: target.innerText.trim().slice(0, 50), // 限制50字符，避免数据过长\n      timestamp: new Date().toISOString(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    };\n    report({ type: 'Click', elementInfo });\n  }, true);\n})();\n```\n\n![promise](./images/js-monitoring/click.png)\n这种方式极大降低了监控实现的复杂性，同时在出现异常行为或用户反馈问题时，能够提供详细的操作现场数据。   \n\n### 异步请求监控实现\n前端应用中Ajax请求占据了用户体验的重要环节，因此对Ajax请求的监控尤为关键。无埋点监控的核心技术之一便是通过拦截XHR（XMLHttpRequest）和Fetch API的方式实现实时追踪。\n\n通过原型链劫持技术，我们可以实现对原生XHR请求进行统一封装与监控。\n\n```javascript\n(function() {\n  const originalXHR = window.XMLHttpRequest;\n  function MonitorXHR() {\n    const xhrInstance = new originalXHR();\n    xhrInstance.addEventListener('loadend', function() {\n      const { responseURL, status, responseText } = xhrInstance;\n      console.log('监控XHR请求:', { responseURL, status, responseText });\n      report({ type: 'XHR', responseURL, status, responseText });\n    });\n    return xhrInstance;\n  }\n  window.XMLHttpRequest = MonitorXHR;\n})();\n\n// 同理fetch API的监控实现\n// ...\n```\n![promise](./images/js-monitoring/promise.png)\n\n### 全局错误捕获\n通过`window.onerror`方法，我们能够捕获绝大多数运行时JavaScript错误，包括未捕获的异常。\n\n```javascript\nwindow.onerror = function(message, source, lineno, colno, error) {\n  const errorInfo = {\n    message,\n    source,\n    lineno,\n    colno,\n    stack: error ? error.stack : null,\n    timestamp: new Date().toISOString()\n  };\n  report({ type: 'JS Error', errorInfo });\n};\n// 现代JavaScript开发中，异步操作常用Promise实现，但其异常并不会触发`window.onerror`，因此需要额外监听`unhandledrejection`事件。\nwindow.addEventListener('unhandledrejection', function(event) {\n  const errorInfo = {\n    reason: event.reason,\n    timestamp: new Date().toISOString()\n  };\n  report({ type: 'Promise Error', errorInfo });\n});\n```\n通过以上方式，我们能有效地监控并快速定位JavaScript代码中的错误，提升应用稳定性和用户体验。\n\n![error](./images/js-monitoring/error.png)\n\n### 首次有效绘制（FMP）监控\n\n首次有效绘制（FMP）能够更准确地反映用户感知到的页面加载体验。\n\n实现思路：\n\n使用MutationObserver观察DOM变化，记录元素渲染进程。\n\n计算得分变化并识别首次有效绘制的时刻，上报关键绘制时刻数据。\n\n示例代码：\n```js\nconst MO = window.MutationObserver || window.WebKitMutationObserver;\nconst observer = new MO(listener);\nobserver.observe(document, { childList: true, subtree: true });\n\nconst listener = () => {}\n\nfunction reportFMPEvent(fmpInfo) {\n  report({ type: 'fmp', ...fmpInfo });\n}\n```\n![FMP监控](./images/js-monitoring/fmp.png)\n\n\n## 常见问题与解决方案\n\n### 问题一：点击事件目标获取不准？\n**解决方案**：在事件冒泡的捕获阶段监听，并结合 `e.composedPath()` 精准定位 DOM 元素。\n如果某个组件内部调用了 e.stopPropagation()，则事件不会冒泡至 document，你的监听器就捕获不到该点击事件。\n\n```javascript\ndocument.getElementById('error-btn').onclick = function(e) {\n    e.stopPropagation();\n};\n```\n解决方案：使用事件捕获阶段监听（第三个参数设为 true）：\n```javascript\ndocument.addEventListener('click', handler, true);\n```\n\n### 问题二：误监控或不该监控区域被上报？\n**解决方案**：给不希望监控的区域加上 data-no-track 属性；\n\n在代码中主动跳过：\n```javascript\nif (e.target.closest('[data-no-track]')) return;\n```\n\n### 问题三：如何保证数据不丢失？\n**解决方案**：优先使用 `navigator.sendBeacon`，因为它在页面卸载时也能发送数据；或使用 `beforeunload` 提前上报。\n\n### 问题四：对性能影响大吗？\n**解决方案**：\n- 避免频繁上报（如节流、合并多次点击事件）\n- 使用 `requestIdleCallback` 或 `setTimeout` 延迟非关键上报逻辑\n\n## 总结\n\n本文介绍了一套完整的 JS 无埋点监控方案，从基本原理到核心代码，并分析了实际中可能遇到的问题及应对方式。无埋点监控虽然强大，但建议根据业务需要进行裁剪，避免性能和数据隐私上的过度采集。\n\n未来你可以进一步拓展如下能力：\n\n- 录屏回放（如 rrweb）\n- 全埋点可视化配置界面\n- 异常聚合与报警系统对接\n\n希望本文对你构建自己的前端监控体系有所帮助。\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/js-monitoring)仓库。\n","slug":"js-monitoring","published":1,"updated":"2025-04-02T03:20:15.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawh000prkp1crrk53rw","content":"<p>在前端性能与用户行为分析愈发重要的今天，埋点监控成为各类业务不可或缺的基础设施。但传统手动埋点方式存在维护成本高、容易遗漏等问题。本文将带你从0到1构建一套JavaScript无埋点监控方案，真正实现自动上报用户行为与性能数据。</p>\n<h2 id=\"什么是无埋点监控？\"><a href=\"#什么是无埋点监控？\" class=\"headerlink\" title=\"什么是无埋点监控？\"></a>什么是无埋点监控？</h2><p>无埋点监控，指的是在不修改业务代码的前提下，通过全局监听或劫持的方式自动采集用户行为与性能数据。常见的采集内容包括：</p>\n<ul>\n<li>页面访问（PV）和跳转（UV）</li>\n<li>用户点击行为</li>\n<li>控件输入行为</li>\n<li>JS错误和Promise异常</li>\n<li>页面性能数据（如白屏、DOM加载时间等）</li>\n</ul>\n<p>无埋点监控通常具备以下优势：</p>\n<ul>\n<li>减少开发和维护成本；</li>\n<li>实时自动化捕捉用户行为；</li>\n<li>高效适应业务需求的变化；</li>\n</ul>\n<h2 id=\"为什么需要前端监控？\"><a href=\"#为什么需要前端监控？\" class=\"headerlink\" title=\"为什么需要前端监控？\"></a>为什么需要前端监控？</h2><ul>\n<li>快速定位问题：前端监控可以帮助开发人员快速定位问题，减少调试时间和成本。</li>\n<li>提高用户体验：通过监控用户行为，开发人员可以及时发现并解决用户体验问题，提升用户满意度。</li>\n<li>数据分析：前端监控可以收集用户行为数据，用于数据分析和产品优化。</li>\n<li>安全防护：监控可以帮助开发人员及时发现和修复安全风险，保护用户数据安全。</li>\n</ul>\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>无埋点监控的核心思路是：<strong>通过劫持浏览器原生API + DOM事件监听 + 拦截网络请求</strong>等手段，在不侵入业务逻辑的前提下采集信息并上报。</p>\n<p>具体模块划分如下：</p>\n<ol>\n<li><strong>基础信息采集模块</strong>：获取设备信息、浏览器、分辨率等</li>\n<li><strong>行为采集模块</strong>：<ul>\n<li>劫持 <code>addEventListener</code> 捕捉点击、输入等事件</li>\n<li>劫持 <code>history.pushState</code> 和 <code>popstate</code> 监听页面跳转</li>\n</ul>\n</li>\n<li><strong>异常采集模块</strong>：监听 JS 错误、资源加载失败、Promise 异常</li>\n<li><strong>性能采集模块</strong>：基于 <code>performance.timing</code> 和 <code>PerformanceObserver</code></li>\n<li><strong>上报模块</strong>：采用 <code>navigator.sendBeacon</code> 或 <code>fetch</code> 将数据发送到监控服务</li>\n</ol>\n<p>这是一张典型的JS无埋点监控方案流程图，从App启动到退出的整个生命周期，用户行为与应用运行过程中的各种事件都被精准记录下来。</p>\n<p><img src=\"/blog/./images/js-monitoring/flow_diagram.png\" alt=\"前端监控的技术方案\"></p>\n<ol>\n<li><p>应用启动（App Launch）<br> 应用启动时，系统自动生成用户标识（UID）和会话标识（Sid），用于标记用户与会话之间的关联关系，贯穿用户全程行为的监控与分析。</p>\n</li>\n<li><p>页面展示（Page Show）与用户交互（Click）<br> 当用户进入页面（Page Show）以及进行点击等交互行为（Click）时，无埋点方案自动捕获相关DOM元素信息与交互细节，并通过TraceID与Sid关联到具体会话与用户。</p>\n</li>\n<li><p>页面跳转与接口请求<br> 用户发生页面跳转或发起接口请求时，监控系统自动捕获当前页面的路径、请求参数、响应信息和交互上下文。这些数据可用于后续的问题定位和用户行为分析。</p>\n</li>\n<li><p>错误监控（API报错与JS报错）<br> 当应用运行时出现API接口异常或JavaScript错误时，监控系统会即时捕获异常信息，包括接口快照、现场信息与错误堆栈，为开发人员提供完整的错误现场还原能力，便于快速排查与修复。</p>\n</li>\n<li><p>服务端异常追踪<br> 通过统一网关（例如Nginx）进行请求分发与TraceID记录，可以将客户端行为与服务端请求进行关联。当服务端出现异常时（例如Service C），能够快速定位并溯源到具体用户行为与请求，形成完整的链路监控与问题诊断机制。</p>\n</li>\n<li><p>页面隐藏（Page Hide）与应用退出（App Exit）<br> 页面隐藏和用户退出应用时，系统记录最终的行为状态，完成一次完整的用户交互周期记录。</p>\n</li>\n</ol>\n<h2 id=\"无埋点监控的局限性及解决方案\"><a href=\"#无埋点监控的局限性及解决方案\" class=\"headerlink\" title=\"无埋点监控的局限性及解决方案\"></a>无埋点监控的局限性及解决方案</h2><ol>\n<li><p>数据量大且含噪音</p>\n<p> 无埋点监控会自动捕获大量用户交互数据，其中可能包含大量无效或低价值的数据。</p>\n<p> 解决方案：</p>\n<ul>\n<li><p>设定合理的数据采样和过滤规则。</p>\n</li>\n<li><p>利用数据清洗工具对数据进行筛选和去重。</p>\n</li>\n</ul>\n</li>\n<li><p>数据隐私问题</p>\n<p> 自动化的监控方式可能涉及用户隐私敏感数据。</p>\n<p> 解决方案：</p>\n<ul>\n<li><p>在前端进行敏感信息脱敏处理。</p>\n</li>\n<li><p>制定并遵守严格的数据安全与隐私保护策略。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"核心代码实现\"><a href=\"#核心代码实现\" class=\"headerlink\" title=\"核心代码实现\"></a>核心代码实现</h2><h3 id=\"点击事件监控\"><a href=\"#点击事件监控\" class=\"headerlink\" title=\"点击事件监控\"></a>点击事件监控</h3><p>用户点击行为是前端应用中最常见且最重要的交互行为之一。我们通过事件冒泡机制统一在document层监听所有点击事件，捕获详细点击信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> target = e.<span class=\"property\">target</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> elementInfo = &#123;</span><br><span class=\"line\">      <span class=\"attr\">tag</span>: target.<span class=\"property\">tagName</span>,</span><br><span class=\"line\">      <span class=\"attr\">id</span>: target.<span class=\"property\">id</span>,</span><br><span class=\"line\">      <span class=\"attr\">classList</span>: <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(target.<span class=\"property\">classList</span>),</span><br><span class=\"line\">      <span class=\"attr\">text</span>: target.<span class=\"property\">innerText</span>.<span class=\"title function_\">trim</span>().<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">50</span>), <span class=\"comment\">// 限制50字符，避免数据过长</span></span><br><span class=\"line\">      <span class=\"attr\">timestamp</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>(),</span><br><span class=\"line\">      <span class=\"attr\">pageX</span>: e.<span class=\"property\">pageX</span>,</span><br><span class=\"line\">      <span class=\"attr\">pageY</span>: e.<span class=\"property\">pageY</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;Click&#x27;</span>, elementInfo &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/js-monitoring/click.png\" alt=\"promise\"><br>这种方式极大降低了监控实现的复杂性，同时在出现异常行为或用户反馈问题时，能够提供详细的操作现场数据。   </p>\n<h3 id=\"异步请求监控实现\"><a href=\"#异步请求监控实现\" class=\"headerlink\" title=\"异步请求监控实现\"></a>异步请求监控实现</h3><p>前端应用中Ajax请求占据了用户体验的重要环节，因此对Ajax请求的监控尤为关键。无埋点监控的核心技术之一便是通过拦截XHR（XMLHttpRequest）和Fetch API的方式实现实时追踪。</p>\n<p>通过原型链劫持技术，我们可以实现对原生XHR请求进行统一封装与监控。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> originalXHR = <span class=\"variable language_\">window</span>.<span class=\"property\">XMLHttpRequest</span>;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">MonitorXHR</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xhrInstance = <span class=\"keyword\">new</span> <span class=\"title function_\">originalXHR</span>();</span><br><span class=\"line\">    xhrInstance.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;loadend&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; responseURL, status, responseText &#125; = xhrInstance;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;监控XHR请求:&#x27;</span>, &#123; responseURL, status, responseText &#125;);</span><br><span class=\"line\">      <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;XHR&#x27;</span>, responseURL, status, responseText &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xhrInstance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"property\">XMLHttpRequest</span> = <span class=\"title class_\">MonitorXHR</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同理fetch API的监控实现</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/js-monitoring/promise.png\" alt=\"promise\"></p>\n<h3 id=\"全局错误捕获\"><a href=\"#全局错误捕获\" class=\"headerlink\" title=\"全局错误捕获\"></a>全局错误捕获</h3><p>通过<code>window.onerror</code>方法，我们能够捕获绝大多数运行时JavaScript错误，包括未捕获的异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span>(<span class=\"params\">message, source, lineno, colno, error</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> errorInfo = &#123;</span><br><span class=\"line\">    message,</span><br><span class=\"line\">    source,</span><br><span class=\"line\">    lineno,</span><br><span class=\"line\">    colno,</span><br><span class=\"line\">    <span class=\"attr\">stack</span>: error ? error.<span class=\"property\">stack</span> : <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">timestamp</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;JS Error&#x27;</span>, errorInfo &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 现代JavaScript开发中，异步操作常用Promise实现，但其异常并不会触发`window.onerror`，因此需要额外监听`unhandledrejection`事件。</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;unhandledrejection&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> errorInfo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">reason</span>: event.<span class=\"property\">reason</span>,</span><br><span class=\"line\">    <span class=\"attr\">timestamp</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;Promise Error&#x27;</span>, errorInfo &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过以上方式，我们能有效地监控并快速定位JavaScript代码中的错误，提升应用稳定性和用户体验。</p>\n<p><img src=\"/blog/./images/js-monitoring/error.png\" alt=\"error\"></p>\n<h3 id=\"首次有效绘制（FMP）监控\"><a href=\"#首次有效绘制（FMP）监控\" class=\"headerlink\" title=\"首次有效绘制（FMP）监控\"></a>首次有效绘制（FMP）监控</h3><p>首次有效绘制（FMP）能够更准确地反映用户感知到的页面加载体验。</p>\n<p>实现思路：</p>\n<p>使用MutationObserver观察DOM变化，记录元素渲染进程。</p>\n<p>计算得分变化并识别首次有效绘制的时刻，上报关键绘制时刻数据。</p>\n<p>示例代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">MO</span> = <span class=\"variable language_\">window</span>.<span class=\"property\">MutationObserver</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">WebKitMutationObserver</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title function_\">MO</span>(listener);</span><br><span class=\"line\">observer.<span class=\"title function_\">observe</span>(<span class=\"variable language_\">document</span>, &#123; <span class=\"attr\">childList</span>: <span class=\"literal\">true</span>, <span class=\"attr\">subtree</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">listener</span> = (<span class=\"params\"></span>) =&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reportFMPEvent</span>(<span class=\"params\">fmpInfo</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;fmp&#x27;</span>, ...fmpInfo &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/js-monitoring/fmp.png\" alt=\"FMP监控\"></p>\n<h2 id=\"常见问题与解决方案\"><a href=\"#常见问题与解决方案\" class=\"headerlink\" title=\"常见问题与解决方案\"></a>常见问题与解决方案</h2><h3 id=\"问题一：点击事件目标获取不准？\"><a href=\"#问题一：点击事件目标获取不准？\" class=\"headerlink\" title=\"问题一：点击事件目标获取不准？\"></a>问题一：点击事件目标获取不准？</h3><p><strong>解决方案</strong>：在事件冒泡的捕获阶段监听，并结合 <code>e.composedPath()</code> 精准定位 DOM 元素。<br>如果某个组件内部调用了 e.stopPropagation()，则事件不会冒泡至 document，你的监听器就捕获不到该点击事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;error-btn&#x27;</span>).<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    e.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解决方案：使用事件捕获阶段监听（第三个参数设为 true）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, handler, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题二：误监控或不该监控区域被上报？\"><a href=\"#问题二：误监控或不该监控区域被上报？\" class=\"headerlink\" title=\"问题二：误监控或不该监控区域被上报？\"></a>问题二：误监控或不该监控区域被上报？</h3><p><strong>解决方案</strong>：给不希望监控的区域加上 data-no-track 属性；</p>\n<p>在代码中主动跳过：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (e.<span class=\"property\">target</span>.<span class=\"title function_\">closest</span>(<span class=\"string\">&#x27;[data-no-track]&#x27;</span>)) <span class=\"keyword\">return</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题三：如何保证数据不丢失？\"><a href=\"#问题三：如何保证数据不丢失？\" class=\"headerlink\" title=\"问题三：如何保证数据不丢失？\"></a>问题三：如何保证数据不丢失？</h3><p><strong>解决方案</strong>：优先使用 <code>navigator.sendBeacon</code>，因为它在页面卸载时也能发送数据；或使用 <code>beforeunload</code> 提前上报。</p>\n<h3 id=\"问题四：对性能影响大吗？\"><a href=\"#问题四：对性能影响大吗？\" class=\"headerlink\" title=\"问题四：对性能影响大吗？\"></a>问题四：对性能影响大吗？</h3><p><strong>解决方案</strong>：</p>\n<ul>\n<li>避免频繁上报（如节流、合并多次点击事件）</li>\n<li>使用 <code>requestIdleCallback</code> 或 <code>setTimeout</code> 延迟非关键上报逻辑</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了一套完整的 JS 无埋点监控方案，从基本原理到核心代码，并分析了实际中可能遇到的问题及应对方式。无埋点监控虽然强大，但建议根据业务需要进行裁剪，避免性能和数据隐私上的过度采集。</p>\n<p>未来你可以进一步拓展如下能力：</p>\n<ul>\n<li>录屏回放（如 rrweb）</li>\n<li>全埋点可视化配置界面</li>\n<li>异常聚合与报警系统对接</li>\n</ul>\n<p>希望本文对你构建自己的前端监控体系有所帮助。</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/js-monitoring\">GitHub</a>仓库。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前端性能与用户行为分析愈发重要的今天，埋点监控成为各类业务不可或缺的基础设施。但传统手动埋点方式存在维护成本高、容易遗漏等问题。本文将带你从0到1构建一套JavaScript无埋点监控方案，真正实现自动上报用户行为与性能数据。</p>\n<h2 id=\"什么是无埋点监控？\"><a href=\"#什么是无埋点监控？\" class=\"headerlink\" title=\"什么是无埋点监控？\"></a>什么是无埋点监控？</h2><p>无埋点监控，指的是在不修改业务代码的前提下，通过全局监听或劫持的方式自动采集用户行为与性能数据。常见的采集内容包括：</p>\n<ul>\n<li>页面访问（PV）和跳转（UV）</li>\n<li>用户点击行为</li>\n<li>控件输入行为</li>\n<li>JS错误和Promise异常</li>\n<li>页面性能数据（如白屏、DOM加载时间等）</li>\n</ul>\n<p>无埋点监控通常具备以下优势：</p>\n<ul>\n<li>减少开发和维护成本；</li>\n<li>实时自动化捕捉用户行为；</li>\n<li>高效适应业务需求的变化；</li>\n</ul>\n<h2 id=\"为什么需要前端监控？\"><a href=\"#为什么需要前端监控？\" class=\"headerlink\" title=\"为什么需要前端监控？\"></a>为什么需要前端监控？</h2><ul>\n<li>快速定位问题：前端监控可以帮助开发人员快速定位问题，减少调试时间和成本。</li>\n<li>提高用户体验：通过监控用户行为，开发人员可以及时发现并解决用户体验问题，提升用户满意度。</li>\n<li>数据分析：前端监控可以收集用户行为数据，用于数据分析和产品优化。</li>\n<li>安全防护：监控可以帮助开发人员及时发现和修复安全风险，保护用户数据安全。</li>\n</ul>\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>无埋点监控的核心思路是：<strong>通过劫持浏览器原生API + DOM事件监听 + 拦截网络请求</strong>等手段，在不侵入业务逻辑的前提下采集信息并上报。</p>\n<p>具体模块划分如下：</p>\n<ol>\n<li><strong>基础信息采集模块</strong>：获取设备信息、浏览器、分辨率等</li>\n<li><strong>行为采集模块</strong>：<ul>\n<li>劫持 <code>addEventListener</code> 捕捉点击、输入等事件</li>\n<li>劫持 <code>history.pushState</code> 和 <code>popstate</code> 监听页面跳转</li>\n</ul>\n</li>\n<li><strong>异常采集模块</strong>：监听 JS 错误、资源加载失败、Promise 异常</li>\n<li><strong>性能采集模块</strong>：基于 <code>performance.timing</code> 和 <code>PerformanceObserver</code></li>\n<li><strong>上报模块</strong>：采用 <code>navigator.sendBeacon</code> 或 <code>fetch</code> 将数据发送到监控服务</li>\n</ol>\n<p>这是一张典型的JS无埋点监控方案流程图，从App启动到退出的整个生命周期，用户行为与应用运行过程中的各种事件都被精准记录下来。</p>\n<p><img src=\"/blog/./images/js-monitoring/flow_diagram.png\" alt=\"前端监控的技术方案\"></p>\n<ol>\n<li><p>应用启动（App Launch）<br> 应用启动时，系统自动生成用户标识（UID）和会话标识（Sid），用于标记用户与会话之间的关联关系，贯穿用户全程行为的监控与分析。</p>\n</li>\n<li><p>页面展示（Page Show）与用户交互（Click）<br> 当用户进入页面（Page Show）以及进行点击等交互行为（Click）时，无埋点方案自动捕获相关DOM元素信息与交互细节，并通过TraceID与Sid关联到具体会话与用户。</p>\n</li>\n<li><p>页面跳转与接口请求<br> 用户发生页面跳转或发起接口请求时，监控系统自动捕获当前页面的路径、请求参数、响应信息和交互上下文。这些数据可用于后续的问题定位和用户行为分析。</p>\n</li>\n<li><p>错误监控（API报错与JS报错）<br> 当应用运行时出现API接口异常或JavaScript错误时，监控系统会即时捕获异常信息，包括接口快照、现场信息与错误堆栈，为开发人员提供完整的错误现场还原能力，便于快速排查与修复。</p>\n</li>\n<li><p>服务端异常追踪<br> 通过统一网关（例如Nginx）进行请求分发与TraceID记录，可以将客户端行为与服务端请求进行关联。当服务端出现异常时（例如Service C），能够快速定位并溯源到具体用户行为与请求，形成完整的链路监控与问题诊断机制。</p>\n</li>\n<li><p>页面隐藏（Page Hide）与应用退出（App Exit）<br> 页面隐藏和用户退出应用时，系统记录最终的行为状态，完成一次完整的用户交互周期记录。</p>\n</li>\n</ol>\n<h2 id=\"无埋点监控的局限性及解决方案\"><a href=\"#无埋点监控的局限性及解决方案\" class=\"headerlink\" title=\"无埋点监控的局限性及解决方案\"></a>无埋点监控的局限性及解决方案</h2><ol>\n<li><p>数据量大且含噪音</p>\n<p> 无埋点监控会自动捕获大量用户交互数据，其中可能包含大量无效或低价值的数据。</p>\n<p> 解决方案：</p>\n<ul>\n<li><p>设定合理的数据采样和过滤规则。</p>\n</li>\n<li><p>利用数据清洗工具对数据进行筛选和去重。</p>\n</li>\n</ul>\n</li>\n<li><p>数据隐私问题</p>\n<p> 自动化的监控方式可能涉及用户隐私敏感数据。</p>\n<p> 解决方案：</p>\n<ul>\n<li><p>在前端进行敏感信息脱敏处理。</p>\n</li>\n<li><p>制定并遵守严格的数据安全与隐私保护策略。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"核心代码实现\"><a href=\"#核心代码实现\" class=\"headerlink\" title=\"核心代码实现\"></a>核心代码实现</h2><h3 id=\"点击事件监控\"><a href=\"#点击事件监控\" class=\"headerlink\" title=\"点击事件监控\"></a>点击事件监控</h3><p>用户点击行为是前端应用中最常见且最重要的交互行为之一。我们通过事件冒泡机制统一在document层监听所有点击事件，捕获详细点击信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> target = e.<span class=\"property\">target</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> elementInfo = &#123;</span><br><span class=\"line\">      <span class=\"attr\">tag</span>: target.<span class=\"property\">tagName</span>,</span><br><span class=\"line\">      <span class=\"attr\">id</span>: target.<span class=\"property\">id</span>,</span><br><span class=\"line\">      <span class=\"attr\">classList</span>: <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(target.<span class=\"property\">classList</span>),</span><br><span class=\"line\">      <span class=\"attr\">text</span>: target.<span class=\"property\">innerText</span>.<span class=\"title function_\">trim</span>().<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">50</span>), <span class=\"comment\">// 限制50字符，避免数据过长</span></span><br><span class=\"line\">      <span class=\"attr\">timestamp</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>(),</span><br><span class=\"line\">      <span class=\"attr\">pageX</span>: e.<span class=\"property\">pageX</span>,</span><br><span class=\"line\">      <span class=\"attr\">pageY</span>: e.<span class=\"property\">pageY</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;Click&#x27;</span>, elementInfo &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/js-monitoring/click.png\" alt=\"promise\"><br>这种方式极大降低了监控实现的复杂性，同时在出现异常行为或用户反馈问题时，能够提供详细的操作现场数据。   </p>\n<h3 id=\"异步请求监控实现\"><a href=\"#异步请求监控实现\" class=\"headerlink\" title=\"异步请求监控实现\"></a>异步请求监控实现</h3><p>前端应用中Ajax请求占据了用户体验的重要环节，因此对Ajax请求的监控尤为关键。无埋点监控的核心技术之一便是通过拦截XHR（XMLHttpRequest）和Fetch API的方式实现实时追踪。</p>\n<p>通过原型链劫持技术，我们可以实现对原生XHR请求进行统一封装与监控。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> originalXHR = <span class=\"variable language_\">window</span>.<span class=\"property\">XMLHttpRequest</span>;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">MonitorXHR</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xhrInstance = <span class=\"keyword\">new</span> <span class=\"title function_\">originalXHR</span>();</span><br><span class=\"line\">    xhrInstance.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;loadend&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; responseURL, status, responseText &#125; = xhrInstance;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;监控XHR请求:&#x27;</span>, &#123; responseURL, status, responseText &#125;);</span><br><span class=\"line\">      <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;XHR&#x27;</span>, responseURL, status, responseText &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xhrInstance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"property\">XMLHttpRequest</span> = <span class=\"title class_\">MonitorXHR</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同理fetch API的监控实现</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/js-monitoring/promise.png\" alt=\"promise\"></p>\n<h3 id=\"全局错误捕获\"><a href=\"#全局错误捕获\" class=\"headerlink\" title=\"全局错误捕获\"></a>全局错误捕获</h3><p>通过<code>window.onerror</code>方法，我们能够捕获绝大多数运行时JavaScript错误，包括未捕获的异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span>(<span class=\"params\">message, source, lineno, colno, error</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> errorInfo = &#123;</span><br><span class=\"line\">    message,</span><br><span class=\"line\">    source,</span><br><span class=\"line\">    lineno,</span><br><span class=\"line\">    colno,</span><br><span class=\"line\">    <span class=\"attr\">stack</span>: error ? error.<span class=\"property\">stack</span> : <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"attr\">timestamp</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;JS Error&#x27;</span>, errorInfo &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 现代JavaScript开发中，异步操作常用Promise实现，但其异常并不会触发`window.onerror`，因此需要额外监听`unhandledrejection`事件。</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;unhandledrejection&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> errorInfo = &#123;</span><br><span class=\"line\">    <span class=\"attr\">reason</span>: event.<span class=\"property\">reason</span>,</span><br><span class=\"line\">    <span class=\"attr\">timestamp</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>()</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;Promise Error&#x27;</span>, errorInfo &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过以上方式，我们能有效地监控并快速定位JavaScript代码中的错误，提升应用稳定性和用户体验。</p>\n<p><img src=\"/blog/./images/js-monitoring/error.png\" alt=\"error\"></p>\n<h3 id=\"首次有效绘制（FMP）监控\"><a href=\"#首次有效绘制（FMP）监控\" class=\"headerlink\" title=\"首次有效绘制（FMP）监控\"></a>首次有效绘制（FMP）监控</h3><p>首次有效绘制（FMP）能够更准确地反映用户感知到的页面加载体验。</p>\n<p>实现思路：</p>\n<p>使用MutationObserver观察DOM变化，记录元素渲染进程。</p>\n<p>计算得分变化并识别首次有效绘制的时刻，上报关键绘制时刻数据。</p>\n<p>示例代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">MO</span> = <span class=\"variable language_\">window</span>.<span class=\"property\">MutationObserver</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">WebKitMutationObserver</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title function_\">MO</span>(listener);</span><br><span class=\"line\">observer.<span class=\"title function_\">observe</span>(<span class=\"variable language_\">document</span>, &#123; <span class=\"attr\">childList</span>: <span class=\"literal\">true</span>, <span class=\"attr\">subtree</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">listener</span> = (<span class=\"params\"></span>) =&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reportFMPEvent</span>(<span class=\"params\">fmpInfo</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">report</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;fmp&#x27;</span>, ...fmpInfo &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/js-monitoring/fmp.png\" alt=\"FMP监控\"></p>\n<h2 id=\"常见问题与解决方案\"><a href=\"#常见问题与解决方案\" class=\"headerlink\" title=\"常见问题与解决方案\"></a>常见问题与解决方案</h2><h3 id=\"问题一：点击事件目标获取不准？\"><a href=\"#问题一：点击事件目标获取不准？\" class=\"headerlink\" title=\"问题一：点击事件目标获取不准？\"></a>问题一：点击事件目标获取不准？</h3><p><strong>解决方案</strong>：在事件冒泡的捕获阶段监听，并结合 <code>e.composedPath()</code> 精准定位 DOM 元素。<br>如果某个组件内部调用了 e.stopPropagation()，则事件不会冒泡至 document，你的监听器就捕获不到该点击事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;error-btn&#x27;</span>).<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    e.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解决方案：使用事件捕获阶段监听（第三个参数设为 true）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, handler, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题二：误监控或不该监控区域被上报？\"><a href=\"#问题二：误监控或不该监控区域被上报？\" class=\"headerlink\" title=\"问题二：误监控或不该监控区域被上报？\"></a>问题二：误监控或不该监控区域被上报？</h3><p><strong>解决方案</strong>：给不希望监控的区域加上 data-no-track 属性；</p>\n<p>在代码中主动跳过：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (e.<span class=\"property\">target</span>.<span class=\"title function_\">closest</span>(<span class=\"string\">&#x27;[data-no-track]&#x27;</span>)) <span class=\"keyword\">return</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题三：如何保证数据不丢失？\"><a href=\"#问题三：如何保证数据不丢失？\" class=\"headerlink\" title=\"问题三：如何保证数据不丢失？\"></a>问题三：如何保证数据不丢失？</h3><p><strong>解决方案</strong>：优先使用 <code>navigator.sendBeacon</code>，因为它在页面卸载时也能发送数据；或使用 <code>beforeunload</code> 提前上报。</p>\n<h3 id=\"问题四：对性能影响大吗？\"><a href=\"#问题四：对性能影响大吗？\" class=\"headerlink\" title=\"问题四：对性能影响大吗？\"></a>问题四：对性能影响大吗？</h3><p><strong>解决方案</strong>：</p>\n<ul>\n<li>避免频繁上报（如节流、合并多次点击事件）</li>\n<li>使用 <code>requestIdleCallback</code> 或 <code>setTimeout</code> 延迟非关键上报逻辑</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了一套完整的 JS 无埋点监控方案，从基本原理到核心代码，并分析了实际中可能遇到的问题及应对方式。无埋点监控虽然强大，但建议根据业务需要进行裁剪，避免性能和数据隐私上的过度采集。</p>\n<p>未来你可以进一步拓展如下能力：</p>\n<ul>\n<li>录屏回放（如 rrweb）</li>\n<li>全埋点可视化配置界面</li>\n<li>异常聚合与报警系统对接</li>\n</ul>\n<p>希望本文对你构建自己的前端监控体系有所帮助。</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/js-monitoring\">GitHub</a>仓库。</p>\n"},{"title":"Kubernetes 分享：如何使用 Helm 优化 Kubernetes 应用部署","date":"2024-12-11T06:22:16.000Z","_content":"\n在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。\n\n今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。\n\n# 什么是 Helm 和 Helm Chart？\n![architecture](./images/helm/helm3-arch.png)\n1. Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。\n\n2. Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。\n\n# 为什么要使用 Helm Chart？\n在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：\n\n- 简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。\n- 模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。\n- 版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。\n- 共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。\n\n# Helm Chart 结构\n一个典型的 Helm Chart 包含以下几个关键部分：\n![helm](./images/helm/new-helm.png)\n\n1. Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。\n2. values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。\n3. templates/目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。\n4. charts/目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。\n5. README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。\n\n# 创建一个简单的 Helm Chart\n假设我们要创建一个监控程序部署 Helm Chart，并且采用[DaemonSet](/2024/08/01/daemonset/)方式部署，步骤如下：\n\n1. 创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：\n\n```bash\nhelm create txclient\n```\n这将生成一个包含上述结构的基本 Chart。\n\n2. 修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：\n\n```yaml\nreplicaCount: 1\n\nimage:\n  repository: xxx/txclientx\n  tag: 5.24.11203.10\n  pullPolicy: IfNotPresent\n\nservice:\n  enabled: false\n\ndaemonset:\n  enabled: true\n  containers:\n    - name: txclient\n      image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"\n      ports:\n        - containerPort: 80  # 你程序暴露的端口，可以根据实际情况调整\n\nresources: {}\n```\n3. 修改模板文件： 在 templates/daemonset.yaml 中，替换其中的变量为模板形式：\n\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"    \n        env:\n        - name: KhGuid\n          value: \"xxxxxxx\"\n        - name: TxClient_DatabusUrl\n          value: \"https://xxx.com\"\n\n```\n4. 安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：\n\n```bash\nhelm install txclient /helm/txclient\n```\n这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：\n![lens](./images/helm/lens-helm.png)\n可以看到在两个node里面都有一个pod运行起来了。\n![lens](./images/helm/lens-pod.png)\n\n# 实用技巧与最佳实践\n1. 使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。\n\n   - 传入外部配置文件：\n\n    ```bash\n    helm install my-release ./my-chart -f custom-values.yaml\n    ```\n    - 使用 --set 传递单个值：\n    ```bash\n    helm install my-release ./my-chart --set image.tag=v1.2.3\n    ```\n   这种方式对于修改特定的单个配置项非常有用。\n2. Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。\n\n3. 多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。\n\n   如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。\n\n    ```bash\n    helm install my-release ./my-chart -f values-prod.yaml\n    helm install my-release ./my-chart -f values-dev.yaml\n    ```\n\n4. 自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。\n\n5. 调试和测试\n   - 调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。\n\n    ```bash\n    helm template my-release ./my-chart -f values.yaml\n    ```\n    这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。\n\n   - 测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。\n\n    ```bash\n    helm test my-release\n    ```\n\n# 结语\nHelm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。","source":"_posts/k8s-helm.md","raw":"---\ntitle: Kubernetes 分享：如何使用 Helm 优化 Kubernetes 应用部署\ndate: 2024-12-11 14:22:16\ntags:\n---\n\n在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。\n\n今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。\n\n# 什么是 Helm 和 Helm Chart？\n![architecture](./images/helm/helm3-arch.png)\n1. Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。\n\n2. Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。\n\n# 为什么要使用 Helm Chart？\n在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：\n\n- 简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。\n- 模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。\n- 版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。\n- 共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。\n\n# Helm Chart 结构\n一个典型的 Helm Chart 包含以下几个关键部分：\n![helm](./images/helm/new-helm.png)\n\n1. Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。\n2. values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。\n3. templates/目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。\n4. charts/目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。\n5. README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。\n\n# 创建一个简单的 Helm Chart\n假设我们要创建一个监控程序部署 Helm Chart，并且采用[DaemonSet](/2024/08/01/daemonset/)方式部署，步骤如下：\n\n1. 创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：\n\n```bash\nhelm create txclient\n```\n这将生成一个包含上述结构的基本 Chart。\n\n2. 修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：\n\n```yaml\nreplicaCount: 1\n\nimage:\n  repository: xxx/txclientx\n  tag: 5.24.11203.10\n  pullPolicy: IfNotPresent\n\nservice:\n  enabled: false\n\ndaemonset:\n  enabled: true\n  containers:\n    - name: txclient\n      image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"\n      ports:\n        - containerPort: 80  # 你程序暴露的端口，可以根据实际情况调整\n\nresources: {}\n```\n3. 修改模板文件： 在 templates/daemonset.yaml 中，替换其中的变量为模板形式：\n\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: txclientx\n  namespace: monitor\nspec:\n  selector:\n    matchLabels:\n      name: txclientx\n  template:\n    metadata:\n      labels:\n        name: txclientx\n    spec:\n      containers:\n      - name: txclientx\n        image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"    \n        env:\n        - name: KhGuid\n          value: \"xxxxxxx\"\n        - name: TxClient_DatabusUrl\n          value: \"https://xxx.com\"\n\n```\n4. 安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：\n\n```bash\nhelm install txclient /helm/txclient\n```\n这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：\n![lens](./images/helm/lens-helm.png)\n可以看到在两个node里面都有一个pod运行起来了。\n![lens](./images/helm/lens-pod.png)\n\n# 实用技巧与最佳实践\n1. 使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。\n\n   - 传入外部配置文件：\n\n    ```bash\n    helm install my-release ./my-chart -f custom-values.yaml\n    ```\n    - 使用 --set 传递单个值：\n    ```bash\n    helm install my-release ./my-chart --set image.tag=v1.2.3\n    ```\n   这种方式对于修改特定的单个配置项非常有用。\n2. Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。\n\n3. 多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。\n\n   如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。\n\n    ```bash\n    helm install my-release ./my-chart -f values-prod.yaml\n    helm install my-release ./my-chart -f values-dev.yaml\n    ```\n\n4. 自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。\n\n5. 调试和测试\n   - 调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。\n\n    ```bash\n    helm template my-release ./my-chart -f values.yaml\n    ```\n    这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。\n\n   - 测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。\n\n    ```bash\n    helm test my-release\n    ```\n\n# 结语\nHelm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。","slug":"k8s-helm","published":1,"updated":"2024-12-12T06:30:51.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawh000rrkp17774asv9","content":"<p>在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。</p>\n<p>今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。</p>\n<h1 id=\"什么是-Helm-和-Helm-Chart？\"><a href=\"#什么是-Helm-和-Helm-Chart？\" class=\"headerlink\" title=\"什么是 Helm 和 Helm Chart？\"></a>什么是 Helm 和 Helm Chart？</h1><p><img src=\"/blog/./images/helm/helm3-arch.png\" alt=\"architecture\"></p>\n<ol>\n<li><p>Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。</p>\n</li>\n<li><p>Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。</p>\n</li>\n</ol>\n<h1 id=\"为什么要使用-Helm-Chart？\"><a href=\"#为什么要使用-Helm-Chart？\" class=\"headerlink\" title=\"为什么要使用 Helm Chart？\"></a>为什么要使用 Helm Chart？</h1><p>在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：</p>\n<ul>\n<li>简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。</li>\n<li>模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。</li>\n<li>版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。</li>\n<li>共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。</li>\n</ul>\n<h1 id=\"Helm-Chart-结构\"><a href=\"#Helm-Chart-结构\" class=\"headerlink\" title=\"Helm Chart 结构\"></a>Helm Chart 结构</h1><p>一个典型的 Helm Chart 包含以下几个关键部分：<br><img src=\"/blog/./images/helm/new-helm.png\" alt=\"helm\"></p>\n<ol>\n<li>Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。</li>\n<li>values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。</li>\n<li>templates&#x2F;目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。</li>\n<li>charts&#x2F;目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。</li>\n<li>README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。</li>\n</ol>\n<h1 id=\"创建一个简单的-Helm-Chart\"><a href=\"#创建一个简单的-Helm-Chart\" class=\"headerlink\" title=\"创建一个简单的 Helm Chart\"></a>创建一个简单的 Helm Chart</h1><p>假设我们要创建一个监控程序部署 Helm Chart，并且采用<a href=\"/2024/08/01/daemonset/\">DaemonSet</a>方式部署，步骤如下：</p>\n<ol>\n<li>创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm create txclient</span><br></pre></td></tr></table></figure>\n<p>这将生成一个包含上述结构的基本 Chart。</p>\n<ol start=\"2\">\n<li>修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">replicaCount:</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">image:</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span> <span class=\"string\">xxx/txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">tag:</span> <span class=\"number\">5.24</span><span class=\"number\">.11203</span><span class=\"number\">.10</span></span><br><span class=\"line\">  <span class=\"attr\">pullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">service:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">daemonset:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclient</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 你程序暴露的端口，可以根据实际情况调整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">resources:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>修改模板文件： 在 templates&#x2F;daemonset.yaml 中，替换其中的变量为模板形式：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span>    </span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxxxxxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxClient_DatabusUrl</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://xxx.com&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install txclient /helm/txclient</span><br></pre></td></tr></table></figure>\n<p>这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：<br><img src=\"/blog/./images/helm/lens-helm.png\" alt=\"lens\"><br>可以看到在两个node里面都有一个pod运行起来了。<br><img src=\"/blog/./images/helm/lens-pod.png\" alt=\"lens\"></p>\n<h1 id=\"实用技巧与最佳实践\"><a href=\"#实用技巧与最佳实践\" class=\"headerlink\" title=\"实用技巧与最佳实践\"></a>实用技巧与最佳实践</h1><ol>\n<li><p>使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。</p>\n<ul>\n<li>传入外部配置文件：</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f custom-values.yaml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 –set 传递单个值： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart --<span class=\"built_in\">set</span> image.tag=v1.2.3</span><br></pre></td></tr></table></figure>\n这种方式对于修改特定的单个配置项非常有用。</li>\n</ul>\n</li>\n<li><p>Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。</p>\n</li>\n<li><p>多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。</p>\n<p>如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f values-prod.yaml</span><br><span class=\"line\">helm install my-release ./my-chart -f values-dev.yaml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。</p>\n</li>\n<li><p>调试和测试</p>\n<ul>\n<li>调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm template my-release ./my-chart -f values.yaml</span><br></pre></td></tr></table></figure>\n<p> 这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。</p>\n<ul>\n<li>测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm <span class=\"built_in\">test</span> my-release</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Helm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 Kubernetes 的生态中，Helm 是一个非常重要的工具，它作为 Kubernetes 的包管理器，简化了复杂应用的部署和管理过程。而 Helm Chart 是 Helm 中的核心概念，它将应用的部署定义成一种可复用的模板，能帮助我们快速地在 Kubernetes 上安装、升级和管理应用。</p>\n<p>今天，我们将深入探讨 Helm Chart 的概念、使用方式以及一些实用的实践技巧，帮助你更高效地管理 Kubernetes 应用。</p>\n<h1 id=\"什么是-Helm-和-Helm-Chart？\"><a href=\"#什么是-Helm-和-Helm-Chart？\" class=\"headerlink\" title=\"什么是 Helm 和 Helm Chart？\"></a>什么是 Helm 和 Helm Chart？</h1><p><img src=\"/blog/./images/helm/helm3-arch.png\" alt=\"architecture\"></p>\n<ol>\n<li><p>Helm：Helm 是 Kubernetes 的包管理工具，类似于 Linux 上的 APT 或 YUM。它允许你定义、安装和管理 Kubernetes 应用程序的各种资源。Helm 通过 Chart 来实现这一功能。</p>\n</li>\n<li><p>Helm Chart：Helm Chart 是一种标准化的应用定义格式，包含了 Kubernetes 对象的所有资源定义，如 Deployment、Service、ConfigMap 等。Chart 本质上是一个压缩包，里面存放着 Kubernetes 应用的 YAML 配置文件和模板，使用 Helm 进行管理。</p>\n</li>\n</ol>\n<h1 id=\"为什么要使用-Helm-Chart？\"><a href=\"#为什么要使用-Helm-Chart？\" class=\"headerlink\" title=\"为什么要使用 Helm Chart？\"></a>为什么要使用 Helm Chart？</h1><p>在没有 Helm 之前，Kubernetes 部署通常涉及手动编写和管理多个 YAML 文件，而这些文件常常会有大量的重复和冗余。使用 Helm Chart 有以下几个优势：</p>\n<ul>\n<li>简化应用部署：通过 Helm Chart，用户只需要一个简单的命令就能将应用快速部署到 Kubernetes 集群中。</li>\n<li>模板化配置：Chart 使用模板引擎，允许你在不同环境中配置不同的值（如数据库的用户名、密码等），避免手动修改多个配置文件。</li>\n<li>版本管理：Helm 支持对应用的版本控制，可以轻松回滚到之前的版本。</li>\n<li>共享与重用：通过 Helm 仓库，开发者可以共享自己创建的 Helm Chart，其他人可以直接使用。</li>\n</ul>\n<h1 id=\"Helm-Chart-结构\"><a href=\"#Helm-Chart-结构\" class=\"headerlink\" title=\"Helm Chart 结构\"></a>Helm Chart 结构</h1><p>一个典型的 Helm Chart 包含以下几个关键部分：<br><img src=\"/blog/./images/helm/new-helm.png\" alt=\"helm\"></p>\n<ol>\n<li>Chart.yaml：这个文件包含了 Chart 的基本信息，例如名称、版本、描述等。</li>\n<li>values.yaml：这是 Helm Chart 中用于存放默认值的文件，用户可以在部署时覆盖其中的配置项。</li>\n<li>templates&#x2F;目录：存放模板文件，在这些文件中，我们可以使用 Go 模板语法进行变量替换和条件判断，最终生成 Kubernetes 的资源文件。</li>\n<li>charts&#x2F;目录：存放依赖的子 Chart，Helm 支持多 Chart 之间的依赖关系。</li>\n<li>README.md：存放 Chart 的使用文档，提供如何使用 Chart 的指南。</li>\n</ol>\n<h1 id=\"创建一个简单的-Helm-Chart\"><a href=\"#创建一个简单的-Helm-Chart\" class=\"headerlink\" title=\"创建一个简单的 Helm Chart\"></a>创建一个简单的 Helm Chart</h1><p>假设我们要创建一个监控程序部署 Helm Chart，并且采用<a href=\"/2024/08/01/daemonset/\">DaemonSet</a>方式部署，步骤如下：</p>\n<ol>\n<li>创建 Chart： 使用 Helm 的命令行工具创建一个新的 Chart：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm create txclient</span><br></pre></td></tr></table></figure>\n<p>这将生成一个包含上述结构的基本 Chart。</p>\n<ol start=\"2\">\n<li>修改 values.yaml： 在 values.yaml 中，可以配置容器的镜像、端口等：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">replicaCount:</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">image:</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span> <span class=\"string\">xxx/txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">tag:</span> <span class=\"number\">5.24</span><span class=\"number\">.11203</span><span class=\"number\">.10</span></span><br><span class=\"line\">  <span class=\"attr\">pullPolicy:</span> <span class=\"string\">IfNotPresent</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">service:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">daemonset:</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">containers:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclient</span></span><br><span class=\"line\">      <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span>  <span class=\"comment\"># 你程序暴露的端口，可以根据实际情况调整</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">resources:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>修改模板文件： 在 templates&#x2F;daemonset.yaml 中，替换其中的变量为模板形式：</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">monitor</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">txclientx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">&quot;<span class=\"template-variable\">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class=\"template-variable\">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span>    </span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">KhGuid</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;xxxxxxx&quot;</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">TxClient_DatabusUrl</span></span><br><span class=\"line\">          <span class=\"attr\">value:</span> <span class=\"string\">&quot;https://xxx.com&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>安装 Chart： 在创建好 Helm Chart 后，可以通过 Helm 安装应用：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install txclient /helm/txclient</span><br></pre></td></tr></table></figure>\n<p>这会根据模板创建一个 txclient 部署。安装完成之后我们可以用openlens查看一下部署情况：<br><img src=\"/blog/./images/helm/lens-helm.png\" alt=\"lens\"><br>可以看到在两个node里面都有一个pod运行起来了。<br><img src=\"/blog/./images/helm/lens-pod.png\" alt=\"lens\"></p>\n<h1 id=\"实用技巧与最佳实践\"><a href=\"#实用技巧与最佳实践\" class=\"headerlink\" title=\"实用技巧与最佳实践\"></a>实用技巧与最佳实践</h1><ol>\n<li><p>使用 values.yaml 管理配置： 对于复杂的应用，values.yaml 可以帮助你管理不同环境的配置。可以在安装时传递自定义配置文件，支持不同环境下的灵活部署。</p>\n<ul>\n<li>传入外部配置文件：</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f custom-values.yaml</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 –set 传递单个值： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart --<span class=\"built_in\">set</span> image.tag=v1.2.3</span><br></pre></td></tr></table></figure>\n这种方式对于修改特定的单个配置项非常有用。</li>\n</ul>\n</li>\n<li><p>Chart 版本管理： Helm 允许你为 Chart 打标签并管理版本，确保每次发布的应用都有明确的版本标记，方便回滚。</p>\n</li>\n<li><p>多环境部署： 在 Helm Chart 中使用不同的命名空间和环境变量，可以轻松实现多个环境（如开发、测试、生产）的部署。</p>\n<p>如果你有多个环境（比如开发、生产等），可以为每个环境创建不同的 values.yaml 文件。然后使用 -f 来指定不同环境的配置。</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm install my-release ./my-chart -f values-prod.yaml</span><br><span class=\"line\">helm install my-release ./my-chart -f values-dev.yaml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义 Helm Chart： 你可以将常见的 Kubernetes 应用封装成 Helm Chart，方便团队内部共享和管理。</p>\n</li>\n<li><p>调试和测试</p>\n<ul>\n<li>调试 Chart：在安装或升级 Helm Chart 前，使用 helm template 可以渲染出最终的 Kubernetes 资源清单。这对于调试和验证 Helm Chart 是否按预期工作非常有帮助。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm template my-release ./my-chart -f values.yaml</span><br></pre></td></tr></table></figure>\n<p> 这样可以查看 Helm 渲染后的所有资源清单，而不会真正部署到 Kubernetes 集群中。</p>\n<ul>\n<li>测试 Chart：Helm 也提供了 Chart 的单元测试功能，使用 helm test 来运行测试。如果你在 Chart 中定义了测试（如 Pod，Job 等），可以通过这个命令来运行这些测试。</li>\n</ul>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm <span class=\"built_in\">test</span> my-release</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Helm 和 Helm Chart 作为 Kubernetes 中的强大工具，极大地简化了应用的部署、管理和维护过程。掌握 Helm 的使用，能有效提高开发效率，减少重复工作，并确保部署的一致性。无论是个人开发者还是团队协作，Helm 都是 Kubernetes 环境下不可或缺的利器。</p>\n"},{"title":"深入解读 MFA 和 TOTP 的实现原理与应用","date":"2024-11-20T06:56:26.000Z","_content":"# 前言\n前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。\n所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。\n![web](/images/mfa/web.png)\n终于不用掏手机了。。。\n\n提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。\n![github](/images/mfa/github.png)\n\n\n现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。\n\n----\n\n# 什么是 MFA 和 TOTP？\n## MFA（多因素认证）\n多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：\n\n1. 知识因素：用户知道的内容，如密码或 PIN。\n2. 拥有因素：用户拥有的内容，如手机、硬件令牌。\n3. 生物因素：用户本身的特性，如指纹、面部识别。\n通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。\n\n## TOTP（基于时间的一次性密码）\nTOTP 是一种动态生成的密码，基于：\n\n- 共享密钥：系统和用户共享的一个随机密钥。\n- 时间步长：通常为 30 秒，密码每 30 秒更新一次。\nTOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。\n\n# TOTP 的工作原理\n标准流程\n1. 共享密钥的生成与分发：\n\n    - 系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。\n    - 用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。\n2. 时间步计算：\n\n    - 当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。\n3. HMAC 运算：\n\n    - 使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。\n4. 动态截取：\n\n    - 从哈希值中动态截取 4 字节数据，确保结果随机性。\n5. 生成动态密码：\n\n    - 将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。\n6. 验证：\n\n    - 系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。\n\n# TOTP密钥的保护\n根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：\n1. 减少密钥泄露的风险\n    - 单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。\n    - 防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。\n\n2. 补救措施\n由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：\n\n    + 备用验证方法：\n        - 提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。\n        - 提供其他备选验证方式（如短信验证、电子邮件验证）。\n    + 重新绑定机制：\n        - 用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。\n        - 一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。\n\n\n# TOTP 的实现原理\n以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。\n\n1. Base32 解码\nTOTP 密钥通常使用 Base32 编码，需先解码为原始字节。\n\n```csharp\nstatic byte[] Base32Decode(string base32)\n{\n    // 示例解码实现\n    const string base32Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n    base32 = base32.TrimEnd('=').ToUpper();\n    List<byte> bytes = new List<byte>();\n\n    int buffer = 0, bitsLeft = 0;\n    foreach (char c in base32)\n    {\n        if (!base32Chars.Contains(c))\n            throw new FormatException(\"Invalid Base32 character.\");\n        buffer = (buffer << 5) | base32Chars.IndexOf(c);\n        bitsLeft += 5;\n\n        if (bitsLeft >= 8)\n        {\n            bytes.Add((byte)(buffer >> (bitsLeft - 8)));\n            bitsLeft -= 8;\n        }\n    }\n\n    return bytes.ToArray();\n}\n```\n2. 获取计数器值\n计数器值通过当前时间计算得出，单位为 30 秒。\n\n```csharp\nlong GetCounter()\n{\n    return DateTimeOffset.UtcNow.ToUnixTimeSeconds() / 30;\n}\n\nbyte[] GetCounterBytes(long counter)\n{\n    byte[] bytes = BitConverter.GetBytes(counter);\n    if (BitConverter.IsLittleEndian)\n        Array.Reverse(bytes); // 转换为大端序\n    return bytes;\n}\n```\n3. HMAC 计算与动态截取\n使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。\n\n```csharp\nstring GenerateTOTP(string secretKey, int passwordLength = 6)\n{\n    byte[] keyBytes = Base32Decode(secretKey);\n    long counter = GetCounter();\n    byte[] counterBytes = GetCounterBytes(counter);\n\n    using var hmac = new HMACSHA1(keyBytes);\n    byte[] hash = hmac.ComputeHash(counterBytes);\n\n    // 动态截取\n    int offset = hash[^1] & 0x0F;\n    int binaryCode = ((hash[offset] & 0x7F) << 24) |\n                     ((hash[offset + 1] & 0xFF) << 16) |\n                     ((hash[offset + 2] & 0xFF) << 8) |\n                     (hash[offset + 3] & 0xFF);\n\n    int otp = binaryCode % (int)Math.Pow(10, passwordLength);\n    return otp.ToString(new string('0', passwordLength)); // 补齐前导零\n}\n```\n4. 示例完整调用\n以下代码生成一个 6 位动态密码。\n\n```csharp\nstring secretKey = \"xxxxxxxxxxx\"; // Base32 编码的密钥\nstring totp = GenerateTOTP(secretKey);\nConsole.WriteLine($\"当前 TOTP 动态密码为: {totp}\");\n```\n![示例完整调用](/images/mfa/run.png)\n# TOTP 的实际应用\n常见场景\n- 账户登录保护：结合密码一起验证，提高安全性。\n- 交易确认：确保关键操作的合法性。\n- 设备绑定：保护设备认证过程。\n\n主流实现工具\n- 手机应用：Google Authenticator、Microsoft Authenticator。\n- 服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。\n\n# TOTP 的优缺点\n优点\n1. 安全性高：密码定期更新，短时间内有效。\n2. 易用性好：无需额外硬件，使用手机即可。\n3. 实现简单：基于开源算法和规范，易于集成。\n\n缺点\n1. 时间同步要求：客户端与服务器需时间一致。\n2. 丢失风险：若用户丢失密钥或设备，可能导致无法验证。\n\n# 总结\nTOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！\n在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？\n\n欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊","source":"_posts/mfa.md","raw":"---\ntitle: 深入解读 MFA 和 TOTP 的实现原理与应用\ndate: 2024-11-20 14:56:26\ntags:\n---\n# 前言\n前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。\n所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。\n![web](/images/mfa/web.png)\n终于不用掏手机了。。。\n\n提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。\n![github](/images/mfa/github.png)\n\n\n现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。\n\n----\n\n# 什么是 MFA 和 TOTP？\n## MFA（多因素认证）\n多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：\n\n1. 知识因素：用户知道的内容，如密码或 PIN。\n2. 拥有因素：用户拥有的内容，如手机、硬件令牌。\n3. 生物因素：用户本身的特性，如指纹、面部识别。\n通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。\n\n## TOTP（基于时间的一次性密码）\nTOTP 是一种动态生成的密码，基于：\n\n- 共享密钥：系统和用户共享的一个随机密钥。\n- 时间步长：通常为 30 秒，密码每 30 秒更新一次。\nTOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。\n\n# TOTP 的工作原理\n标准流程\n1. 共享密钥的生成与分发：\n\n    - 系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。\n    - 用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。\n2. 时间步计算：\n\n    - 当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。\n3. HMAC 运算：\n\n    - 使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。\n4. 动态截取：\n\n    - 从哈希值中动态截取 4 字节数据，确保结果随机性。\n5. 生成动态密码：\n\n    - 将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。\n6. 验证：\n\n    - 系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。\n\n# TOTP密钥的保护\n根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：\n1. 减少密钥泄露的风险\n    - 单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。\n    - 防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。\n\n2. 补救措施\n由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：\n\n    + 备用验证方法：\n        - 提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。\n        - 提供其他备选验证方式（如短信验证、电子邮件验证）。\n    + 重新绑定机制：\n        - 用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。\n        - 一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。\n\n\n# TOTP 的实现原理\n以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。\n\n1. Base32 解码\nTOTP 密钥通常使用 Base32 编码，需先解码为原始字节。\n\n```csharp\nstatic byte[] Base32Decode(string base32)\n{\n    // 示例解码实现\n    const string base32Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n    base32 = base32.TrimEnd('=').ToUpper();\n    List<byte> bytes = new List<byte>();\n\n    int buffer = 0, bitsLeft = 0;\n    foreach (char c in base32)\n    {\n        if (!base32Chars.Contains(c))\n            throw new FormatException(\"Invalid Base32 character.\");\n        buffer = (buffer << 5) | base32Chars.IndexOf(c);\n        bitsLeft += 5;\n\n        if (bitsLeft >= 8)\n        {\n            bytes.Add((byte)(buffer >> (bitsLeft - 8)));\n            bitsLeft -= 8;\n        }\n    }\n\n    return bytes.ToArray();\n}\n```\n2. 获取计数器值\n计数器值通过当前时间计算得出，单位为 30 秒。\n\n```csharp\nlong GetCounter()\n{\n    return DateTimeOffset.UtcNow.ToUnixTimeSeconds() / 30;\n}\n\nbyte[] GetCounterBytes(long counter)\n{\n    byte[] bytes = BitConverter.GetBytes(counter);\n    if (BitConverter.IsLittleEndian)\n        Array.Reverse(bytes); // 转换为大端序\n    return bytes;\n}\n```\n3. HMAC 计算与动态截取\n使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。\n\n```csharp\nstring GenerateTOTP(string secretKey, int passwordLength = 6)\n{\n    byte[] keyBytes = Base32Decode(secretKey);\n    long counter = GetCounter();\n    byte[] counterBytes = GetCounterBytes(counter);\n\n    using var hmac = new HMACSHA1(keyBytes);\n    byte[] hash = hmac.ComputeHash(counterBytes);\n\n    // 动态截取\n    int offset = hash[^1] & 0x0F;\n    int binaryCode = ((hash[offset] & 0x7F) << 24) |\n                     ((hash[offset + 1] & 0xFF) << 16) |\n                     ((hash[offset + 2] & 0xFF) << 8) |\n                     (hash[offset + 3] & 0xFF);\n\n    int otp = binaryCode % (int)Math.Pow(10, passwordLength);\n    return otp.ToString(new string('0', passwordLength)); // 补齐前导零\n}\n```\n4. 示例完整调用\n以下代码生成一个 6 位动态密码。\n\n```csharp\nstring secretKey = \"xxxxxxxxxxx\"; // Base32 编码的密钥\nstring totp = GenerateTOTP(secretKey);\nConsole.WriteLine($\"当前 TOTP 动态密码为: {totp}\");\n```\n![示例完整调用](/images/mfa/run.png)\n# TOTP 的实际应用\n常见场景\n- 账户登录保护：结合密码一起验证，提高安全性。\n- 交易确认：确保关键操作的合法性。\n- 设备绑定：保护设备认证过程。\n\n主流实现工具\n- 手机应用：Google Authenticator、Microsoft Authenticator。\n- 服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。\n\n# TOTP 的优缺点\n优点\n1. 安全性高：密码定期更新，短时间内有效。\n2. 易用性好：无需额外硬件，使用手机即可。\n3. 实现简单：基于开源算法和规范，易于集成。\n\n缺点\n1. 时间同步要求：客户端与服务器需时间一致。\n2. 丢失风险：若用户丢失密钥或设备，可能导致无法验证。\n\n# 总结\nTOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！\n在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？\n\n欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊","slug":"mfa","published":1,"updated":"2024-11-21T06:23:11.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawi000trkp135mdcjcf","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。<br>所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。<br><img src=\"/blog/images/mfa/web.png\" alt=\"web\"><br>终于不用掏手机了。。。</p>\n<p>提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。<br><img src=\"/blog/images/mfa/github.png\" alt=\"github\"></p>\n<p>现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。</p>\n<hr>\n<h1 id=\"什么是-MFA-和-TOTP？\"><a href=\"#什么是-MFA-和-TOTP？\" class=\"headerlink\" title=\"什么是 MFA 和 TOTP？\"></a>什么是 MFA 和 TOTP？</h1><h2 id=\"MFA（多因素认证）\"><a href=\"#MFA（多因素认证）\" class=\"headerlink\" title=\"MFA（多因素认证）\"></a>MFA（多因素认证）</h2><p>多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：</p>\n<ol>\n<li>知识因素：用户知道的内容，如密码或 PIN。</li>\n<li>拥有因素：用户拥有的内容，如手机、硬件令牌。</li>\n<li>生物因素：用户本身的特性，如指纹、面部识别。<br>通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。</li>\n</ol>\n<h2 id=\"TOTP（基于时间的一次性密码）\"><a href=\"#TOTP（基于时间的一次性密码）\" class=\"headerlink\" title=\"TOTP（基于时间的一次性密码）\"></a>TOTP（基于时间的一次性密码）</h2><p>TOTP 是一种动态生成的密码，基于：</p>\n<ul>\n<li>共享密钥：系统和用户共享的一个随机密钥。</li>\n<li>时间步长：通常为 30 秒，密码每 30 秒更新一次。<br>TOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。</li>\n</ul>\n<h1 id=\"TOTP-的工作原理\"><a href=\"#TOTP-的工作原理\" class=\"headerlink\" title=\"TOTP 的工作原理\"></a>TOTP 的工作原理</h1><p>标准流程</p>\n<ol>\n<li><p>共享密钥的生成与分发：</p>\n<ul>\n<li>系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。</li>\n<li>用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。</li>\n</ul>\n</li>\n<li><p>时间步计算：</p>\n<ul>\n<li>当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。</li>\n</ul>\n</li>\n<li><p>HMAC 运算：</p>\n<ul>\n<li>使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。</li>\n</ul>\n</li>\n<li><p>动态截取：</p>\n<ul>\n<li>从哈希值中动态截取 4 字节数据，确保结果随机性。</li>\n</ul>\n</li>\n<li><p>生成动态密码：</p>\n<ul>\n<li>将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。</li>\n</ul>\n</li>\n<li><p>验证：</p>\n<ul>\n<li>系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP密钥的保护\"><a href=\"#TOTP密钥的保护\" class=\"headerlink\" title=\"TOTP密钥的保护\"></a>TOTP密钥的保护</h1><p>根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：</p>\n<ol>\n<li><p>减少密钥泄露的风险</p>\n<ul>\n<li>单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。</li>\n<li>防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。</li>\n</ul>\n</li>\n<li><p>补救措施<br>由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：</p>\n<ul>\n<li>备用验证方法：<ul>\n<li>提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。</li>\n<li>提供其他备选验证方式（如短信验证、电子邮件验证）。</li>\n</ul>\n</li>\n<li>重新绑定机制：<ul>\n<li>用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。</li>\n<li>一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP-的实现原理\"><a href=\"#TOTP-的实现原理\" class=\"headerlink\" title=\"TOTP 的实现原理\"></a>TOTP 的实现原理</h1><p>以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。</p>\n<ol>\n<li>Base32 解码<br>TOTP 密钥通常使用 Base32 编码，需先解码为原始字节。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">byte</span>[] <span class=\"title\">Base32Decode</span>(<span class=\"params\"><span class=\"built_in\">string</span> base32</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例解码实现</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> base32Chars = <span class=\"string\">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;</span><br><span class=\"line\">    base32 = base32.TrimEnd(<span class=\"string\">&#x27;=&#x27;</span>).ToUpper();</span><br><span class=\"line\">    List&lt;<span class=\"built_in\">byte</span>&gt; bytes = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">byte</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> buffer = <span class=\"number\">0</span>, bitsLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> base32)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!base32Chars.Contains(c))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">&quot;Invalid Base32 character.&quot;</span>);</span><br><span class=\"line\">        buffer = (buffer &lt;&lt; <span class=\"number\">5</span>) | base32Chars.IndexOf(c);</span><br><span class=\"line\">        bitsLeft += <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitsLeft &gt;= <span class=\"number\">8</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bytes.Add((<span class=\"built_in\">byte</span>)(buffer &gt;&gt; (bitsLeft - <span class=\"number\">8</span>)));</span><br><span class=\"line\">            bitsLeft -= <span class=\"number\">8</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes.ToArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>获取计数器值<br>计数器值通过当前时间计算得出，单位为 30 秒。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">long</span> <span class=\"title\">GetCounter</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DateTimeOffset.UtcNow.ToUnixTimeSeconds() / <span class=\"number\">30</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">byte</span>[] <span class=\"title\">GetCounterBytes</span>(<span class=\"params\"><span class=\"built_in\">long</span> counter</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] bytes = BitConverter.GetBytes(counter);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BitConverter.IsLittleEndian)</span><br><span class=\"line\">        Array.Reverse(bytes); <span class=\"comment\">// 转换为大端序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>HMAC 计算与动态截取<br>使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">GenerateTOTP</span>(<span class=\"params\"><span class=\"built_in\">string</span> secretKey, <span class=\"built_in\">int</span> passwordLength = <span class=\"number\">6</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] keyBytes = Base32Decode(secretKey);</span><br><span class=\"line\">    <span class=\"built_in\">long</span> counter = GetCounter();</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] counterBytes = GetCounterBytes(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> hmac = <span class=\"keyword\">new</span> HMACSHA1(keyBytes);</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] hash = hmac.ComputeHash(counterBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动态截取</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> offset = hash[^<span class=\"number\">1</span>] &amp; <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> binaryCode = ((hash[offset] &amp; <span class=\"number\">0x7F</span>) &lt;&lt; <span class=\"number\">24</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span>) |</span><br><span class=\"line\">                     (hash[offset + <span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> otp = binaryCode % (<span class=\"built_in\">int</span>)Math.Pow(<span class=\"number\">10</span>, passwordLength);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otp.ToString(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">&#x27;0&#x27;</span>, passwordLength)); <span class=\"comment\">// 补齐前导零</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>示例完整调用<br>以下代码生成一个 6 位动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> secretKey = <span class=\"string\">&quot;xxxxxxxxxxx&quot;</span>; <span class=\"comment\">// Base32 编码的密钥</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> totp = GenerateTOTP(secretKey);</span><br><span class=\"line\">Console.WriteLine(<span class=\"string\">$&quot;当前 TOTP 动态密码为: <span class=\"subst\">&#123;totp&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/mfa/run.png\" alt=\"示例完整调用\"></p>\n<h1 id=\"TOTP-的实际应用\"><a href=\"#TOTP-的实际应用\" class=\"headerlink\" title=\"TOTP 的实际应用\"></a>TOTP 的实际应用</h1><p>常见场景</p>\n<ul>\n<li>账户登录保护：结合密码一起验证，提高安全性。</li>\n<li>交易确认：确保关键操作的合法性。</li>\n<li>设备绑定：保护设备认证过程。</li>\n</ul>\n<p>主流实现工具</p>\n<ul>\n<li>手机应用：Google Authenticator、Microsoft Authenticator。</li>\n<li>服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。</li>\n</ul>\n<h1 id=\"TOTP-的优缺点\"><a href=\"#TOTP-的优缺点\" class=\"headerlink\" title=\"TOTP 的优缺点\"></a>TOTP 的优缺点</h1><p>优点</p>\n<ol>\n<li>安全性高：密码定期更新，短时间内有效。</li>\n<li>易用性好：无需额外硬件，使用手机即可。</li>\n<li>实现简单：基于开源算法和规范，易于集成。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>时间同步要求：客户端与服务器需时间一致。</li>\n<li>丢失风险：若用户丢失密钥或设备，可能导致无法验证。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！<br>在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？</p>\n<p>欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间发现自己的aliyun账号存在异常登录，吓的我赶紧改了密码开启了MFA多因素认证。同时，我把github等一干支持MFA的应用都开启了MFA。但是这也给我造成了困扰。每次登录都要拿出手机看看手机上的安全码，感觉有点麻烦。<br>所以我尝试自己用TOTP来实现一个PC版的MFA，不再依赖手机。<br><img src=\"/blog/images/mfa/web.png\" alt=\"web\"><br>终于不用掏手机了。。。</p>\n<p>提到各种概念，部分老铁可能有些陌生。但是下面github的界面想必大家都比较熟悉，没错，这就是我们今天要聊的东西。<br><img src=\"/blog/images/mfa/github.png\" alt=\"github\"></p>\n<p>现代数字化时代，密码泄露事件频发，传统的单一密码保护方式已无法满足安全需求。多因素认证（MFA, Multi-Factor Authentication）因其能够显著增强账户安全性，成为越来越多系统的必备安全功能。其中，基于时间的一次性密码（TOTP, Time-Based One-Time Password）是 MFA 的重要实现方式之一。本文将深入解读 TOTP 的原理，并展示其具体实现。</p>\n<hr>\n<h1 id=\"什么是-MFA-和-TOTP？\"><a href=\"#什么是-MFA-和-TOTP？\" class=\"headerlink\" title=\"什么是 MFA 和 TOTP？\"></a>什么是 MFA 和 TOTP？</h1><h2 id=\"MFA（多因素认证）\"><a href=\"#MFA（多因素认证）\" class=\"headerlink\" title=\"MFA（多因素认证）\"></a>MFA（多因素认证）</h2><p>多因素认证是一种验证用户身份的方法，它需要用户提供两个或更多独立的身份验证因素，常见的三种验证因素为：</p>\n<ol>\n<li>知识因素：用户知道的内容，如密码或 PIN。</li>\n<li>拥有因素：用户拥有的内容，如手机、硬件令牌。</li>\n<li>生物因素：用户本身的特性，如指纹、面部识别。<br>通过组合不同的验证因素，MFA 能够显著降低因密码泄露带来的风险。</li>\n</ol>\n<h2 id=\"TOTP（基于时间的一次性密码）\"><a href=\"#TOTP（基于时间的一次性密码）\" class=\"headerlink\" title=\"TOTP（基于时间的一次性密码）\"></a>TOTP（基于时间的一次性密码）</h2><p>TOTP 是一种动态生成的密码，基于：</p>\n<ul>\n<li>共享密钥：系统和用户共享的一个随机密钥。</li>\n<li>时间步长：通常为 30 秒，密码每 30 秒更新一次。<br>TOTP 密码不可预测且短时间内失效，非常适合作为 MFA 的第二验证因素。</li>\n</ul>\n<h1 id=\"TOTP-的工作原理\"><a href=\"#TOTP-的工作原理\" class=\"headerlink\" title=\"TOTP 的工作原理\"></a>TOTP 的工作原理</h1><p>标准流程</p>\n<ol>\n<li><p>共享密钥的生成与分发：</p>\n<ul>\n<li>系统生成一个随机的密钥（通常使用 Base32 编码），通过二维码等方式分发给用户。</li>\n<li>用户将密钥输入到支持 TOTP 的认证应用（如 Google Authenticator）。</li>\n</ul>\n</li>\n<li><p>时间步计算：</p>\n<ul>\n<li>当前时间戳（以秒为单位）除以步长（如 30 秒），得到当前的计数器值。</li>\n</ul>\n</li>\n<li><p>HMAC 运算：</p>\n<ul>\n<li>使用共享密钥和计数器值，通过 HMAC-SHA1 算法生成哈希值。</li>\n</ul>\n</li>\n<li><p>动态截取：</p>\n<ul>\n<li>从哈希值中动态截取 4 字节数据，确保结果随机性。</li>\n</ul>\n</li>\n<li><p>生成动态密码：</p>\n<ul>\n<li>将截取的数据取模（通常为 10^6），得到一个 6 位数字密码。</li>\n</ul>\n</li>\n<li><p>验证：</p>\n<ul>\n<li>系统与用户计算出的 TOTP 密码进行比较，若匹配，则验证通过。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP密钥的保护\"><a href=\"#TOTP密钥的保护\" class=\"headerlink\" title=\"TOTP密钥的保护\"></a>TOTP密钥的保护</h1><p>根据上面TOTP的工作原理我们知道，TOTP里面系统和用户共享一个密钥，一旦密钥泄露，就会导致用户账户的安全风险。针对这个问题，一般可以采取以下措施来降低风险：</p>\n<ol>\n<li><p>减少密钥泄露的风险</p>\n<ul>\n<li>单次展示原则：用户完成绑定后，密钥不再显示，这样即使有人在之后访问用户账户，也无法通过查看页面或接口窃取密钥。</li>\n<li>防止截屏泄露：用户可以在绑定时生成密钥的二维码，但绑定完成后，页面不再提供密钥或二维码，减少因截屏或日志记录造成的泄露风险。</li>\n</ul>\n</li>\n<li><p>补救措施<br>由于密钥只展示一次，丢失密钥的用户可能会面临绑定无法使用的问题。为此，网站通常会提供以下补救机制：</p>\n<ul>\n<li>备用验证方法：<ul>\n<li>提供备用的一次性恢复码（Recovery Codes），通常是几个固定的静态代码，用户可以在 TOTP 无法使用时输入。</li>\n<li>提供其他备选验证方式（如短信验证、电子邮件验证）。</li>\n</ul>\n</li>\n<li>重新绑定机制：<ul>\n<li>用户可以通过验证其他身份信息（如身份证、手机号等）重新绑定 TOTP 密钥。</li>\n<li>一些高安全性网站会要求用户提交更详细的验证信息（如人脸识别）来重置密钥。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"TOTP-的实现原理\"><a href=\"#TOTP-的实现原理\" class=\"headerlink\" title=\"TOTP 的实现原理\"></a>TOTP 的实现原理</h1><p>以下是用 C# 实现 TOTP 的核心代码，展示从 Base32 解码到动态密码生成的完整流程。</p>\n<ol>\n<li>Base32 解码<br>TOTP 密钥通常使用 Base32 编码，需先解码为原始字节。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"built_in\">byte</span>[] <span class=\"title\">Base32Decode</span>(<span class=\"params\"><span class=\"built_in\">string</span> base32</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例解码实现</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> base32Chars = <span class=\"string\">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;</span><br><span class=\"line\">    base32 = base32.TrimEnd(<span class=\"string\">&#x27;=&#x27;</span>).ToUpper();</span><br><span class=\"line\">    List&lt;<span class=\"built_in\">byte</span>&gt; bytes = <span class=\"keyword\">new</span> List&lt;<span class=\"built_in\">byte</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> buffer = <span class=\"number\">0</span>, bitsLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> (<span class=\"built_in\">char</span> c <span class=\"keyword\">in</span> base32)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!base32Chars.Contains(c))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FormatException(<span class=\"string\">&quot;Invalid Base32 character.&quot;</span>);</span><br><span class=\"line\">        buffer = (buffer &lt;&lt; <span class=\"number\">5</span>) | base32Chars.IndexOf(c);</span><br><span class=\"line\">        bitsLeft += <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bitsLeft &gt;= <span class=\"number\">8</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bytes.Add((<span class=\"built_in\">byte</span>)(buffer &gt;&gt; (bitsLeft - <span class=\"number\">8</span>)));</span><br><span class=\"line\">            bitsLeft -= <span class=\"number\">8</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes.ToArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>获取计数器值<br>计数器值通过当前时间计算得出，单位为 30 秒。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">long</span> <span class=\"title\">GetCounter</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DateTimeOffset.UtcNow.ToUnixTimeSeconds() / <span class=\"number\">30</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">byte</span>[] <span class=\"title\">GetCounterBytes</span>(<span class=\"params\"><span class=\"built_in\">long</span> counter</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] bytes = BitConverter.GetBytes(counter);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (BitConverter.IsLittleEndian)</span><br><span class=\"line\">        Array.Reverse(bytes); <span class=\"comment\">// 转换为大端序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bytes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>HMAC 计算与动态截取<br>使用 HMAC-SHA1 算法生成哈希值，并截取动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">GenerateTOTP</span>(<span class=\"params\"><span class=\"built_in\">string</span> secretKey, <span class=\"built_in\">int</span> passwordLength = <span class=\"number\">6</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] keyBytes = Base32Decode(secretKey);</span><br><span class=\"line\">    <span class=\"built_in\">long</span> counter = GetCounter();</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] counterBytes = GetCounterBytes(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> hmac = <span class=\"keyword\">new</span> HMACSHA1(keyBytes);</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] hash = hmac.ComputeHash(counterBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 动态截取</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> offset = hash[^<span class=\"number\">1</span>] &amp; <span class=\"number\">0x0F</span>;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> binaryCode = ((hash[offset] &amp; <span class=\"number\">0x7F</span>) &lt;&lt; <span class=\"number\">24</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">1</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span>) |</span><br><span class=\"line\">                     ((hash[offset + <span class=\"number\">2</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span>) |</span><br><span class=\"line\">                     (hash[offset + <span class=\"number\">3</span>] &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> otp = binaryCode % (<span class=\"built_in\">int</span>)Math.Pow(<span class=\"number\">10</span>, passwordLength);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> otp.ToString(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">&#x27;0&#x27;</span>, passwordLength)); <span class=\"comment\">// 补齐前导零</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>示例完整调用<br>以下代码生成一个 6 位动态密码。</li>\n</ol>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> secretKey = <span class=\"string\">&quot;xxxxxxxxxxx&quot;</span>; <span class=\"comment\">// Base32 编码的密钥</span></span><br><span class=\"line\"><span class=\"built_in\">string</span> totp = GenerateTOTP(secretKey);</span><br><span class=\"line\">Console.WriteLine(<span class=\"string\">$&quot;当前 TOTP 动态密码为: <span class=\"subst\">&#123;totp&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/mfa/run.png\" alt=\"示例完整调用\"></p>\n<h1 id=\"TOTP-的实际应用\"><a href=\"#TOTP-的实际应用\" class=\"headerlink\" title=\"TOTP 的实际应用\"></a>TOTP 的实际应用</h1><p>常见场景</p>\n<ul>\n<li>账户登录保护：结合密码一起验证，提高安全性。</li>\n<li>交易确认：确保关键操作的合法性。</li>\n<li>设备绑定：保护设备认证过程。</li>\n</ul>\n<p>主流实现工具</p>\n<ul>\n<li>手机应用：Google Authenticator、Microsoft Authenticator。</li>\n<li>服务器支持：多语言库（如 Python 的 pyotp、Java 的 OtpAuth）。</li>\n</ul>\n<h1 id=\"TOTP-的优缺点\"><a href=\"#TOTP-的优缺点\" class=\"headerlink\" title=\"TOTP 的优缺点\"></a>TOTP 的优缺点</h1><p>优点</p>\n<ol>\n<li>安全性高：密码定期更新，短时间内有效。</li>\n<li>易用性好：无需额外硬件，使用手机即可。</li>\n<li>实现简单：基于开源算法和规范，易于集成。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>时间同步要求：客户端与服务器需时间一致。</li>\n<li>丢失风险：若用户丢失密钥或设备，可能导致无法验证。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TOTP 是多因素认证中的关键技术，通过动态密码提高安全性，广泛应用于各类系统。理解其原理并掌握实现技术，可以帮助开发者更好地保障用户账户安全。希望本文的讲解与示例能为您搭建 TOTP 功能提供帮助！<br>在下一步的实践中，你是否准备好为你的应用添加 MFA 支持？或者尝试将 TOTP 整合到你的项目中？</p>\n<p>欢迎分享你的实现和经验，如果需要更具体的内容，欢迎随时讨论！ 😊</p>\n"},{"title":"程序日志设计与存储：实践与注意事项(一)","date":"2024-12-18T08:34:05.000Z","_content":"# 引言\n程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。\n\n本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。\n\n----\n\n# 什么样的程序日志是优秀的？\n之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。\n\n![自信](./images/log/confident.png)\n结果我实际看到的是这样的场景是下面这样的\n\n![日志](./images/log/bad.png)\n\n怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。\n\n这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。\n\n\n在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。\n\n__不好的程序日志往往存在以下几个问题：__\n\n2.1. 缺乏结构，信息混乱\n在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：\n\n```\nError at line 34\nServer is down\nUser failed to login\n```\n这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。\n\n2.2. 信息过于简单，缺少上下文\n日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：\n\n```\nERROR: Login failed\n```\n没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。\n\n![我是谁](./images/log/whoami.jpg)\n\n2.3. 日志内容冗余，冗长无效\n有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：\n\n```\nINFO: Request started\nINFO: Request body: { \"username\": \"johndoe\", \"password\": \"123456\" }\nINFO: Headers: { \"Authorization\": \"Bearer token123\" }\nINFO: Response status: 200\nINFO: Response body: { \"message\": \"success\" }\n```\n虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。\n\n2.4. 没有日志级别，信息无法筛选\n如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：\n\n```\nA critical error occurred while processing the request.\n```\n如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。\n\n\n优秀的程序日志应该具备以下几个特征：\n\n## 1. 结构化日志\n结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。\n\n__优秀的日志示例（JSON 格式）：__\n\n```json\n复制代码\n{\n  \"timestamp\": \"2024-12-18T14:05:23.123Z\",\n  \"level\": \"INFO\",\n  \"message\": \"User login successful\",\n  \"user_id\": 12345,\n  \"ip_address\": \"192.168.1.1\",\n  \"request_id\": \"xyz123\",\n  \"duration_ms\": 150\n}\n```\n__为什么结构化日志优秀？__\n\n+ 可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。\n+ 与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。\n\n## 2. 日志级别\n日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：\n\n+ DEBUG：调试信息，帮助开发者了解程序运行的细节。\n+ INFO：常规信息，表示程序的正常运行过程。\n+ WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。\n+ ERROR：错误信息，表示程序出现了异常，需要处理。\n+ FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。\n\n__为什么使用日志级别？__\n\n+ 便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。\n+ 优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。\n\n## 3. 上下文信息\n日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。\n\n就像\n\n__优秀的日志应包含的上下文信息：__\n\n+ 请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。\n+ 用户信息：如用户 ID 或用户名，能够帮助分析用户行为。\n+ 机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。\n+ 异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。\n\n## 4. 日志可读性\n虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。\n\n# 设计日志的过程中应避免的问题\n在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：\n\n## 1. 日志信息过于冗长\n许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。\n\n__避免措施：__\n\n确保每条日志都包含足够的信息，但不要重复记录无关信息。\n对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。\n使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。\n## 2. 日志格式不统一\n日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。\n\n__避免措施：__\n\n采用统一的日志格式，尽量使用结构化日志（如 JSON）。\n定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。\n对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。\n\n## 3. 忽略日志的性能影响\n日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I/O 阻塞、磁盘空间耗尽或系统性能下降。\n\n__避免措施：__\n\n对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。\n使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。\n设定日志的生命周期，定期清理过时的日志，避免日志文件过大。\n\n## 4. 缺乏追踪和关联能力\n在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。\n\n__避免措施：__\n\n在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。\n在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。\n\n## 5. 没有有效的日志存储与管理方案\n当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。\n\n__避免措施：__\n\n使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。\n配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。\n考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。\n\n# 总结\n一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。\n\n通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。\n\n由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。","source":"_posts/log.md","raw":"---\ntitle: 程序日志设计与存储：实践与注意事项(一)\ndate: 2024-12-18 16:34:05\ntags:\n---\n# 引言\n程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。\n\n本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。\n\n----\n\n# 什么样的程序日志是优秀的？\n之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。\n\n![自信](./images/log/confident.png)\n结果我实际看到的是这样的场景是下面这样的\n\n![日志](./images/log/bad.png)\n\n怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。\n\n这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。\n\n\n在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。\n\n__不好的程序日志往往存在以下几个问题：__\n\n2.1. 缺乏结构，信息混乱\n在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：\n\n```\nError at line 34\nServer is down\nUser failed to login\n```\n这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。\n\n2.2. 信息过于简单，缺少上下文\n日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：\n\n```\nERROR: Login failed\n```\n没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。\n\n![我是谁](./images/log/whoami.jpg)\n\n2.3. 日志内容冗余，冗长无效\n有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：\n\n```\nINFO: Request started\nINFO: Request body: { \"username\": \"johndoe\", \"password\": \"123456\" }\nINFO: Headers: { \"Authorization\": \"Bearer token123\" }\nINFO: Response status: 200\nINFO: Response body: { \"message\": \"success\" }\n```\n虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。\n\n2.4. 没有日志级别，信息无法筛选\n如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：\n\n```\nA critical error occurred while processing the request.\n```\n如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。\n\n\n优秀的程序日志应该具备以下几个特征：\n\n## 1. 结构化日志\n结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。\n\n__优秀的日志示例（JSON 格式）：__\n\n```json\n复制代码\n{\n  \"timestamp\": \"2024-12-18T14:05:23.123Z\",\n  \"level\": \"INFO\",\n  \"message\": \"User login successful\",\n  \"user_id\": 12345,\n  \"ip_address\": \"192.168.1.1\",\n  \"request_id\": \"xyz123\",\n  \"duration_ms\": 150\n}\n```\n__为什么结构化日志优秀？__\n\n+ 可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。\n+ 与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。\n\n## 2. 日志级别\n日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：\n\n+ DEBUG：调试信息，帮助开发者了解程序运行的细节。\n+ INFO：常规信息，表示程序的正常运行过程。\n+ WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。\n+ ERROR：错误信息，表示程序出现了异常，需要处理。\n+ FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。\n\n__为什么使用日志级别？__\n\n+ 便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。\n+ 优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。\n\n## 3. 上下文信息\n日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。\n\n就像\n\n__优秀的日志应包含的上下文信息：__\n\n+ 请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。\n+ 用户信息：如用户 ID 或用户名，能够帮助分析用户行为。\n+ 机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。\n+ 异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。\n\n## 4. 日志可读性\n虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。\n\n# 设计日志的过程中应避免的问题\n在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：\n\n## 1. 日志信息过于冗长\n许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。\n\n__避免措施：__\n\n确保每条日志都包含足够的信息，但不要重复记录无关信息。\n对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。\n使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。\n## 2. 日志格式不统一\n日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。\n\n__避免措施：__\n\n采用统一的日志格式，尽量使用结构化日志（如 JSON）。\n定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。\n对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。\n\n## 3. 忽略日志的性能影响\n日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I/O 阻塞、磁盘空间耗尽或系统性能下降。\n\n__避免措施：__\n\n对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。\n使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。\n设定日志的生命周期，定期清理过时的日志，避免日志文件过大。\n\n## 4. 缺乏追踪和关联能力\n在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。\n\n__避免措施：__\n\n在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。\n在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。\n\n## 5. 没有有效的日志存储与管理方案\n当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。\n\n__避免措施：__\n\n使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。\n配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。\n考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。\n\n# 总结\n一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。\n\n通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。\n\n由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。","slug":"log","published":1,"updated":"2024-12-26T08:06:26.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawi000vrkp14nxq0str","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。</p>\n<p>本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。</p>\n<hr>\n<h1 id=\"什么样的程序日志是优秀的？\"><a href=\"#什么样的程序日志是优秀的？\" class=\"headerlink\" title=\"什么样的程序日志是优秀的？\"></a>什么样的程序日志是优秀的？</h1><p>之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。</p>\n<p><img src=\"/blog/./images/log/confident.png\" alt=\"自信\"><br>结果我实际看到的是这样的场景是下面这样的</p>\n<p><img src=\"/blog/./images/log/bad.png\" alt=\"日志\"></p>\n<p>怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。</p>\n<p>这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。</p>\n<p>在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。</p>\n<p><strong>不好的程序日志往往存在以下几个问题：</strong></p>\n<p>2.1. 缺乏结构，信息混乱<br>在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error at line 34</span><br><span class=\"line\">Server is down</span><br><span class=\"line\">User failed to login</span><br></pre></td></tr></table></figure>\n<p>这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。</p>\n<p>2.2. 信息过于简单，缺少上下文<br>日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: Login failed</span><br></pre></td></tr></table></figure>\n<p>没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。</p>\n<p><img src=\"/blog/./images/log/whoami.jpg\" alt=\"我是谁\"></p>\n<p>2.3. 日志内容冗余，冗长无效<br>有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Request started</span><br><span class=\"line\">INFO: Request body: &#123; &quot;username&quot;: &quot;johndoe&quot;, &quot;password&quot;: &quot;123456&quot; &#125;</span><br><span class=\"line\">INFO: Headers: &#123; &quot;Authorization&quot;: &quot;Bearer token123&quot; &#125;</span><br><span class=\"line\">INFO: Response status: 200</span><br><span class=\"line\">INFO: Response body: &#123; &quot;message&quot;: &quot;success&quot; &#125;</span><br></pre></td></tr></table></figure>\n<p>虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。</p>\n<p>2.4. 没有日志级别，信息无法筛选<br>如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A critical error occurred while processing the request.</span><br></pre></td></tr></table></figure>\n<p>如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。</p>\n<p>优秀的程序日志应该具备以下几个特征：</p>\n<h2 id=\"1-结构化日志\"><a href=\"#1-结构化日志\" class=\"headerlink\" title=\"1. 结构化日志\"></a>1. 结构化日志</h2><p>结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。</p>\n<p><strong>优秀的日志示例（JSON 格式）：</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复制代码</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2024-12-18T14:05:23.123Z&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;INFO&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;User login successful&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;user_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">12345</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;ip_address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;192.168.1.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;request_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xyz123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;duration_ms&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">150</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>为什么结构化日志优秀？</strong></p>\n<ul>\n<li>可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。</li>\n<li>与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。</li>\n</ul>\n<h2 id=\"2-日志级别\"><a href=\"#2-日志级别\" class=\"headerlink\" title=\"2. 日志级别\"></a>2. 日志级别</h2><p>日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：</p>\n<ul>\n<li>DEBUG：调试信息，帮助开发者了解程序运行的细节。</li>\n<li>INFO：常规信息，表示程序的正常运行过程。</li>\n<li>WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。</li>\n<li>ERROR：错误信息，表示程序出现了异常，需要处理。</li>\n<li>FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。</li>\n</ul>\n<p><strong>为什么使用日志级别？</strong></p>\n<ul>\n<li>便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。</li>\n<li>优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。</li>\n</ul>\n<h2 id=\"3-上下文信息\"><a href=\"#3-上下文信息\" class=\"headerlink\" title=\"3. 上下文信息\"></a>3. 上下文信息</h2><p>日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。</p>\n<p>就像</p>\n<p><strong>优秀的日志应包含的上下文信息：</strong></p>\n<ul>\n<li>请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。</li>\n<li>用户信息：如用户 ID 或用户名，能够帮助分析用户行为。</li>\n<li>机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。</li>\n<li>异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。</li>\n</ul>\n<h2 id=\"4-日志可读性\"><a href=\"#4-日志可读性\" class=\"headerlink\" title=\"4. 日志可读性\"></a>4. 日志可读性</h2><p>虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。</p>\n<h1 id=\"设计日志的过程中应避免的问题\"><a href=\"#设计日志的过程中应避免的问题\" class=\"headerlink\" title=\"设计日志的过程中应避免的问题\"></a>设计日志的过程中应避免的问题</h1><p>在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：</p>\n<h2 id=\"1-日志信息过于冗长\"><a href=\"#1-日志信息过于冗长\" class=\"headerlink\" title=\"1. 日志信息过于冗长\"></a>1. 日志信息过于冗长</h2><p>许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。</p>\n<p><strong>避免措施：</strong></p>\n<p>确保每条日志都包含足够的信息，但不要重复记录无关信息。<br>对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。<br>使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。</p>\n<h2 id=\"2-日志格式不统一\"><a href=\"#2-日志格式不统一\" class=\"headerlink\" title=\"2. 日志格式不统一\"></a>2. 日志格式不统一</h2><p>日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。</p>\n<p><strong>避免措施：</strong></p>\n<p>采用统一的日志格式，尽量使用结构化日志（如 JSON）。<br>定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。<br>对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。</p>\n<h2 id=\"3-忽略日志的性能影响\"><a href=\"#3-忽略日志的性能影响\" class=\"headerlink\" title=\"3. 忽略日志的性能影响\"></a>3. 忽略日志的性能影响</h2><p>日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I&#x2F;O 阻塞、磁盘空间耗尽或系统性能下降。</p>\n<p><strong>避免措施：</strong></p>\n<p>对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。<br>使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。<br>设定日志的生命周期，定期清理过时的日志，避免日志文件过大。</p>\n<h2 id=\"4-缺乏追踪和关联能力\"><a href=\"#4-缺乏追踪和关联能力\" class=\"headerlink\" title=\"4. 缺乏追踪和关联能力\"></a>4. 缺乏追踪和关联能力</h2><p>在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。</p>\n<p><strong>避免措施：</strong></p>\n<p>在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。<br>在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。</p>\n<h2 id=\"5-没有有效的日志存储与管理方案\"><a href=\"#5-没有有效的日志存储与管理方案\" class=\"headerlink\" title=\"5. 没有有效的日志存储与管理方案\"></a>5. 没有有效的日志存储与管理方案</h2><p>当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。</p>\n<p><strong>避免措施：</strong></p>\n<p>使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。<br>配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。<br>考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。</p>\n<p>通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。</p>\n<p>由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>程序日志是开发和运维过程中最常用的工具之一。日志不仅是调试和排查故障的关键依据，也是监控系统健康、分析系统性能和提升安全性的有效手段。一个好的日志系统能显著提高问题定位的效率，帮助开发人员快速识别和解决问题。然而，日志系统如果设计不当，不仅会让开发者陷入信息的海洋，还可能对系统性能产生负面影响。</p>\n<p>本文将深入探讨如何设计一个优秀的程序日志系统，讨论优秀日志的特征，并指出在设计日志时应该避免的一些常见问题。</p>\n<hr>\n<h1 id=\"什么样的程序日志是优秀的？\"><a href=\"#什么样的程序日志是优秀的？\" class=\"headerlink\" title=\"什么样的程序日志是优秀的？\"></a>什么样的程序日志是优秀的？</h1><p>之所以想写这篇文章，源于前几天被其他部门的同事拉去看个问题。我问：有日志么？ 他回复：链路日志应有尽有。</p>\n<p><img src=\"/blog/./images/log/confident.png\" alt=\"自信\"><br>结果我实际看到的是这样的场景是下面这样的</p>\n<p><img src=\"/blog/./images/log/bad.png\" alt=\"日志\"></p>\n<p>怎么说呢？你说他没有日志吧，他有。你说他有日志，但是日志内容很糟糕，跟没有没啥区别。</p>\n<p>这让我很疑惑，为什么会出现这种情况呢？ 我开始思考，这是因为没有设计好日志系统么？ 于是我开始思考日志系统。</p>\n<p>在谈什么样的日志是优秀的日志之前，首先我们来分析一下上面的日志存在什么问题？或者说什么样的日志是糟糕的日志。</p>\n<p><strong>不好的程序日志往往存在以下几个问题：</strong></p>\n<p>2.1. 缺乏结构，信息混乱<br>在没有规范的日志设计中，日志通常是以纯文本的形式输出，甚至不同的开发者使用不同的格式记录信息，导致日志内容混乱且难以解析。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error at line 34</span><br><span class=\"line\">Server is down</span><br><span class=\"line\">User failed to login</span><br></pre></td></tr></table></figure>\n<p>这种日志不仅无法清晰表达出问题发生的时间、上下文和严重性，而且在海量日志中也不容易进行搜索和过滤。</p>\n<p>2.2. 信息过于简单，缺少上下文<br>日志如果只记录了简单的信息，往往无法帮助开发者快速定位问题。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: Login failed</span><br></pre></td></tr></table></figure>\n<p>没有包含关键信息，如失败的用户名、请求的IP地址、错误的具体原因等，导致开发者在查看日志时无法准确还原发生的具体场景，增加了调试的难度。</p>\n<p><img src=\"/blog/./images/log/whoami.jpg\" alt=\"我是谁\"></p>\n<p>2.3. 日志内容冗余，冗长无效<br>有些日志记录过于冗长，包含大量不必要的信息。例如，记录每个 HTTP 请求的请求头、请求体等详细信息，可能会导致日志文件膨胀，查找有用信息的难度增加。举例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO: Request started</span><br><span class=\"line\">INFO: Request body: &#123; &quot;username&quot;: &quot;johndoe&quot;, &quot;password&quot;: &quot;123456&quot; &#125;</span><br><span class=\"line\">INFO: Headers: &#123; &quot;Authorization&quot;: &quot;Bearer token123&quot; &#125;</span><br><span class=\"line\">INFO: Response status: 200</span><br><span class=\"line\">INFO: Response body: &#123; &quot;message&quot;: &quot;success&quot; &#125;</span><br></pre></td></tr></table></figure>\n<p>虽然这些信息看似完整，但在某些情况下，过度记录请求和响应的细节反而会使日志分析变得更加困难。开发者更关心的是请求的结果（如成功或失败）和关键的错误信息，而不是每个请求的具体细节。</p>\n<p>2.4. 没有日志级别，信息无法筛选<br>如果程序中没有使用日志级别（如 INFO、DEBUG、ERROR），日志信息就很容易变得杂乱无章。开发者在调试时很难快速找到关键信息。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A critical error occurred while processing the request.</span><br></pre></td></tr></table></figure>\n<p>如果日志中没有明确的级别，那么开发者就无法快速区分出哪些日志是正常的信息，哪些日志是需要关注的错误或警告信息。</p>\n<p>优秀的程序日志应该具备以下几个特征：</p>\n<h2 id=\"1-结构化日志\"><a href=\"#1-结构化日志\" class=\"headerlink\" title=\"1. 结构化日志\"></a>1. 结构化日志</h2><p>结构化日志是指日志内容被组织成易于解析的格式，如 JSON 或其他键值对格式。这种格式便于机器处理和分析，且能够与其他系统（如 Elasticsearch、Kibana）无缝对接。</p>\n<p><strong>优秀的日志示例（JSON 格式）：</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复制代码</span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2024-12-18T14:05:23.123Z&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;level&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;INFO&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;User login successful&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;user_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">12345</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;ip_address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;192.168.1.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;request_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;xyz123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;duration_ms&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">150</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>为什么结构化日志优秀？</strong></p>\n<ul>\n<li>可搜索和分析：结构化的格式使得日志内容更易于被查询、过滤和分析。例如，我们可以根据 level 来筛选错误日志，根据 user_id 查看某个用户的所有操作日志。</li>\n<li>与日志系统兼容：结构化日志特别适用于与日志聚合和分析工具（如 Elasticsearch、Splunk、Kibana）集成。这些工具可以高效地解析和展示日志数据，提供更强大的查询和可视化功能。</li>\n</ul>\n<h2 id=\"2-日志级别\"><a href=\"#2-日志级别\" class=\"headerlink\" title=\"2. 日志级别\"></a>2. 日志级别</h2><p>日志级别是日志信息的重要分类，有助于按重要性和紧急程度区分日志。常见的日志级别有：</p>\n<ul>\n<li>DEBUG：调试信息，帮助开发者了解程序运行的细节。</li>\n<li>INFO：常规信息，表示程序的正常运行过程。</li>\n<li>WARN：警告信息，表示系统出现了潜在问题，但不影响程序的正常运行。</li>\n<li>ERROR：错误信息，表示程序出现了异常，需要处理。</li>\n<li>FATAL：致命错误，表示程序无法继续运行，通常需要立即修复。</li>\n</ul>\n<p><strong>为什么使用日志级别？</strong></p>\n<ul>\n<li>便于筛选和定位问题：不同的日志级别让我们能够快速定位问题所在。例如，在生产环境中，通常只会关注 ERROR 和 WARN 级别的日志，而在开发环境中则可以查看 DEBUG 级别的日志进行详细调试。</li>\n<li>优化性能：合理的日志级别能够避免不必要的日志输出，减少日志的生成和存储开销，尤其是在高并发的生产环境中。</li>\n</ul>\n<h2 id=\"3-上下文信息\"><a href=\"#3-上下文信息\" class=\"headerlink\" title=\"3. 上下文信息\"></a>3. 上下文信息</h2><p>日志应该包含足够的上下文信息，以便在出现问题时能够迅速定位和分析。例如，可以包含请求 ID、用户 ID、IP 地址、会话信息等。这样，即使日志是分散的，也能将它们联系起来，追溯问题的根源。</p>\n<p>就像</p>\n<p><strong>优秀的日志应包含的上下文信息：</strong></p>\n<ul>\n<li>请求 ID：帮助将一个请求的所有相关日志关联起来，特别是在微服务架构中，跟踪一个请求跨多个服务的执行。</li>\n<li>用户信息：如用户 ID 或用户名，能够帮助分析用户行为。</li>\n<li>机器或服务信息：如服务器的主机名或容器 ID，可以帮助确定问题是否与某个具体的节点或服务相关。</li>\n<li>异常堆栈跟踪：对于错误日志，堆栈信息能帮助开发者快速定位错误发生的地方。</li>\n</ul>\n<h2 id=\"4-日志可读性\"><a href=\"#4-日志可读性\" class=\"headerlink\" title=\"4. 日志可读性\"></a>4. 日志可读性</h2><p>虽然日志是为机器设计的，但它们也应该具有良好的可读性，尤其是在调试和分析时。尽管结构化日志能够被自动解析，但如果能够增加一些清晰的说明性文字，或者确保日志中的信息清晰易懂，开发者将能够更高效地进行排查。</p>\n<h1 id=\"设计日志的过程中应避免的问题\"><a href=\"#设计日志的过程中应避免的问题\" class=\"headerlink\" title=\"设计日志的过程中应避免的问题\"></a>设计日志的过程中应避免的问题</h1><p>在设计日志时，很多常见的问题如果没有处理好，可能导致日志系统的不完善甚至是负担。以下是设计日志时需要避免的一些常见问题：</p>\n<h2 id=\"1-日志信息过于冗长\"><a href=\"#1-日志信息过于冗长\" class=\"headerlink\" title=\"1. 日志信息过于冗长\"></a>1. 日志信息过于冗长</h2><p>许多开发者在记录日志时，往往倾向于记录过多的信息，导致日志过于冗长且不易处理。过多的日志信息不仅会占用磁盘空间，还可能导致日志查询的效率大幅降低。</p>\n<p><strong>避免措施：</strong></p>\n<p>确保每条日志都包含足够的信息，但不要重复记录无关信息。<br>对于 DEBUG 级别的日志，可以选择性记录详细信息，避免在生产环境中输出过多的无关数据。<br>使用合适的日志级别来控制信息的详细程度，避免将低级别日志用于重要的生产环境。</p>\n<h2 id=\"2-日志格式不统一\"><a href=\"#2-日志格式不统一\" class=\"headerlink\" title=\"2. 日志格式不统一\"></a>2. 日志格式不统一</h2><p>日志格式不统一会导致后期日志分析困难，尤其是在多个团队协作或者使用不同的语言和框架时。不同格式的日志可能使得聚合工具（如 Elasticsearch）无法正确解析和展示数据。</p>\n<p><strong>避免措施：</strong></p>\n<p>采用统一的日志格式，尽量使用结构化日志（如 JSON）。<br>定义标准的日志模板和规范，确保所有团队成员都遵循相同的日志输出格式。<br>对于日志内容中的时间戳、级别、消息等字段，制定一致的命名和格式规则。</p>\n<h2 id=\"3-忽略日志的性能影响\"><a href=\"#3-忽略日志的性能影响\" class=\"headerlink\" title=\"3. 忽略日志的性能影响\"></a>3. 忽略日志的性能影响</h2><p>日志记录虽然有助于调试和监控，但不合理的日志策略可能会影响程序的性能，特别是在高并发的环境下。如果日志记录过于频繁或数据量过大，可能会导致 I&#x2F;O 阻塞、磁盘空间耗尽或系统性能下降。</p>\n<p><strong>避免措施：</strong></p>\n<p>对于高频调用的部分，避免过于详细的日志记录。可以使用延迟记录、批量日志等方式减少日志对性能的影响。<br>使用异步日志记录机制，确保日志的输出不会阻塞主业务流程。<br>设定日志的生命周期，定期清理过时的日志，避免日志文件过大。</p>\n<h2 id=\"4-缺乏追踪和关联能力\"><a href=\"#4-缺乏追踪和关联能力\" class=\"headerlink\" title=\"4. 缺乏追踪和关联能力\"></a>4. 缺乏追踪和关联能力</h2><p>在分布式系统中，单独的日志往往无法提供足够的信息来追踪请求的全生命周期。因此，如果没有适当的追踪机制（如 trace_id），很难在多个服务之间建立关联，尤其是在出现故障时。</p>\n<p><strong>避免措施：</strong></p>\n<p>在每条日志中添加请求 ID、用户 ID 或 trace_id 等关键信息。<br>在微服务架构中，确保日志能够跨服务传播，并与分布式追踪系统（如 Jaeger）结合使用。</p>\n<h2 id=\"5-没有有效的日志存储与管理方案\"><a href=\"#5-没有有效的日志存储与管理方案\" class=\"headerlink\" title=\"5. 没有有效的日志存储与管理方案\"></a>5. 没有有效的日志存储与管理方案</h2><p>当日志量变得非常庞大时，存储和管理日志的方式也显得尤为重要。没有合适的存储方案，可能会导致日志丢失或查询困难。</p>\n<p><strong>避免措施：</strong></p>\n<p>使用集中式日志系统（如 Elasticsearch + Kibana）存储和分析日志，确保日志数据的可靠性和可查询性。<br>配置日志的生命周期管理（如定期归档和删除旧日志）以节省存储空间。<br>考虑使用日志聚合工具（如 Logstash、Filebeat）来收集和转发日志。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>一个优秀的程序日志系统不仅仅是记录信息，它是一个强大的工具，可以帮助开发者快速定位问题、提升系统的可维护性和可扩展性。设计日志时，我们应该注重日志的结构化、可读性、上下文信息以及日志级别的合理使用。同时，要避免日志冗长、格式不统一、性能问题、缺乏追踪能力等常见陷阱。</p>\n<p>通过合理设计日志系统，结合现代的日志存储和分析工具（如 Elasticsearch 和 Kibana），我们能够大大提升日志的可用性，从而提升系统的可靠性和开发效率。</p>\n<p>由于篇幅原因，我们将ES+Kibana+Jaeger的日志设计和存储放在下一篇文章中。</p>\n"},{"title":"AI驱动的自动化测试：探索MidScene.js的强大功能","date":"2025-02-27T06:10:28.000Z","_content":"随着AI快速发展，AI技术可以说已经渗透到了我们的生活和工作中。在开发领域，代码生成工具可以说是百花齐放，无处不在。而测试工具就寥寥无几了。\n\n在现代Web开发中，自动化测试已经成为提高开发效率和保证代码质量的重要手段。随着前端应用变得越来越复杂，传统的UI自动化测试方法面临着一些挑战，例如页面结构变化、动态内容加载等问题。为了解决这些问题，字节跳动推出了 MidScene.js ——一款AI驱动的UI自动化测试工具，旨在通过智能识别UI组件，帮助开发者更高效地进行自动化测试。它的目标是通过AI技术，自动识别和操作UI元素，从而进行自动化测试。与传统的基于选择器（如ID、class等）定位元素的自动化测试工具不同，MidScene.js通过机器视觉、图像识别和文本分析来识别和操作页面元素。\n\n在本文中，我们将深入探讨 MidScene.js 的工作原理、使用场景以及如何在项目中利用它进行UI自动化测试。\n![midscenejs](./images/midscenejs/bg.png)\n\n# MidScene.js的工作原理\nMidScene.js 的核心原理是通过AI来分析页面内容，识别UI组件，并模拟用户操作。它的工作流程可以分为以下几个步骤：\n\n![工作原理](./images/midscenejs/principle.png)\n\n1. 页面截图与UI元素分析\n- MidScene.js首先对页面进行截图或解析DOM，捕捉页面的视觉内容。\n- 然后，利用AI技术分析页面中的各种元素（按钮、输入框、图片等），并识别它们的功能和行为。\n2. 元素定位与事件触发\n- 识别到UI元素后，MidScene.js通过AI定位它们的位置和交互方式，不需要依赖传统的CSS选择器。\n- 一旦定位到目标元素，它会模拟用户操作，如点击、输入、滑动等，触发相应的事件。\n3. 状态验证与测试反馈\n- 在执行操作后，MidScene.js会检查页面的反馈，验证UI是否按照预期行为进行反应。\n- 如果出现异常或不符合预期的行为，MidScene.js会生成详细的测试报告。\n\n\n# MidScene.js到底怎么样？\n为了帮助大家更好地理解如何使用MidScene.js，以及MidScene.js到底效果怎么样。 下面我们通过一系列简单的场景，展示如何通过MidScene.js进行UI测试。同时我们把playwright和midscenejs的测试过程和结果进行对比。通过对比让大家更好地理解MidScene.js的强大功能。\n\n## 登录页面自动化测试\n登录可以说是web应用测试中的代表场景之一了。这里我实现了一个简单的测试场景，实现登录页面的自动化测试。\n![登录页面](./images/midscenejs/login.png)\n\n### playwright\nplaywright测试脚本如下\n```js\nimport { test, expect } from '@playwright/test';\n\ntest('用户可以成功登录', async ({ page }) => {\n  // 1. 访问登录页面\n  await page.goto('http://localhost:8000/login.html');\n  // 2. 输入用户名和密码\n  await page.fill('input[name=\"username\"]', 'admin');\n  await page.fill('input[name=\"password\"]', '1234');\n  // 3. 点击登录按钮\n  await page.click('input[type=\"submit\"]');\n  // 4. 断言是否跳转到首页或某个特定页面\n  await expect(page).toHaveURL(/.*list.*/);\n});\n```\n测试报告如下\n![playwright测试报告](./images/midscenejs/playwright-report.png)\n### MidScene.js\n这款 AI 工具最令人兴奋的一点是它能够使用<font color=\"#dd0000\">自然语言</font>。只需描述测试步骤要做什么，它就可以开始。\n\nMidScene.js测试脚本如下\n\n```js\nimport { AgentOverChromeBridge } from \"@midscene/web/bridge-mode\";\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\nconst sleep = (ms) => new Promise((r) => setTimeout(r, ms));\nPromise.resolve(\n  (async () => {\n    const agent = new AgentOverChromeBridge();\n\n    await agent.connectNewTabWithUrl(\"http://localhost:8000/login.html\");\n\n    await agent.ai('在“用户名”输入框里面输入“admin”');\n    await agent.ai('在“密码”输入框里面输入“1234”');\n    await agent.ai('点击“登录”按钮');\n    await sleep(3000);\n\n    await agent.aiAssert(\"跳转'键盘列表'页面”\");\n    await agent.destroy();\n  })()\n);\n```\n测试过程如下，这里我用的桥接模式进行测试的，方便大家看到整个过程。\n![测试过程](./images/midscenejs/midscene-login.gif)\n每次测试脚本执行完成之后midscene会生成一份测试报告\n![测试报告](./images/midscenejs/login-result.png)\n我们可以看到具体的测试结果\n![测试结果](./images/midscenejs/login-report.png)\n\n### 对比\n从这个场景中我们大致可以得出以下结论：\n1. 可写/读性：\n\n  - 👍 可书写算是一大亮点吧 ，大大降低了维护自动化脚本对前端的要求。可读性那必须是MidScene的强项了，基本上是所见即所得，完全不需要去找元素对应。\n\n  - 👎没有办法隐藏一些敏感信息（用户名和密码），需要在提示词中直接发送这些内容，而如果没有 Midscene.js，可以在单独的数据文件中隐藏它们。\n\n  - 👎阅读起来可能比较冗长。 比起代码来说，描述起来的文本可能会稍微长一些。\n\n\n2. 执行时间：\n\n  - 👎由于 Midscene.js 依赖第三方的AI 提供支持还需要屏幕截图，因此执行时间非常慢。AI 需要时间来规划和“思考”它需要做什么。报告和 JSON 输出清楚地显示了完成每项任务所需的时间。\n\n  - 👎在 Playwright 中，通过角色（role）定位元素是一种推荐的做法，并且能够自然地测试 Web 应用的无障碍性（a11y）。而 Midscene.js 使用的是截图方式，因此偏离了这种做法。\n\n  ![定位](./images/midscenejs/midscene-locate.png)\n\n  整个运行事件也基本上在我们的预期里面吧\n\n  - MidScene.js 的执行时间在 36 秒左右。\n  - Playwright 的执行时间在 5 秒左右。\n\n3. 可维护性：\n  - 👍如果重构我们上面的登录页面（ ID、标签），测试用例可能仍会正确执行所有的操作。但是如果是 Playwright 就需要做些维护工作了。\n  - 👎如果需要对测试脚本进行维护，调试过程将是反复试错。我们需要通过反复更改测试的提示词来进行。\n  - 👎Playwright 测试是采用 页面对象模式编写的，这有助于保持代码的可维护性和可扩展性。而在 Midscene.js 中，测试是直接写在测试文件中的，这正是 Midscene.js 设计的初衷。因此，虽然使用自然语言编写测试速度快且简单，但如果需要修改多个测试文件，将会变得非常麻烦。\n\n## 登录失败案例\n下面我们来看一个失败的测试案例，看看MidScene.js到底有多智能。\n\n更改上面登录的脚本，把密码改成错误的密码，看看测试结果如何。\n```js\nPromise.resolve(\n  (async () => {\n    const agent = new AgentOverChromeBridge();\n    await agent.connectNewTabWithUrl(\"http://localhost:8000/login.html\");\n    await agent.ai('在“用户名”输入框里面输入“admin”');\n    await agent.ai('在“密码”输入框里面输入“wrong password”');\n    await agent.ai('点击“登录”按钮');\n    await sleep(3000);\n\n    await agent.aiAssert(\"用户无法登录\");\n    await agent.destroy();\n  })()\n);\n```\n查看报告的结果可以很好的让我们知道它是如何做的断言, 断言也是根据语义结合具体的场景来判断的，非常的灵活！\n![失败案例](./images/midscenejs/fail.png)\n\n# 总结\n通过AI驱动的 MidScene.js，开发者可以轻松进行自动化UI测试，减少传统UI测试中的元素选择和维护负担。它能够适应动态变化的UI，智能识别和操作页面元素，极大地提升了自动化测试的效率和准确性。无论是回归测试，还是复杂UI交互的自动化，MidScene.js都能够为开发者提供强大的支持。\n\n## 优势：\n - 快速的初始和用例编写，易于使用，简单、快捷\n - 适应动态变化的UI\n - 可读性（自然语言）\n - 可能是一个很好的UI自动化测试工具\n\n## 劣势：\n - 执行时间较长\n - 缺乏使用变量的能力\n - 仅捕获当前窗口中可见的内容 \n - 需要一个框架来在提示中使用正确的语言，以提高操作和断言的准确性（否则可能需要反复调试，或者同一个测试用例偶发失败的问题）\n - 第三方AI需要读取浏览器截图，是否可能存在安全问题（第三方AI是否会存储截图？）\n\n希望这篇文章能帮助你更好地理解和使用MidScene.js，如果你有任何问题或建议，欢迎在评论区留言！感兴趣的老铁也可以访问[MidScene.js](https://midscenejs.com/)的官网了解更多信息，也可访问老夫的[GitHub](https://github.com/ItProHub/midscenejs)获取完整的示例代码","source":"_posts/midscenejs.md","raw":"---\ntitle: AI驱动的自动化测试：探索MidScene.js的强大功能\ndate: 2025-02-27 14:10:28\ntags:\n---\n随着AI快速发展，AI技术可以说已经渗透到了我们的生活和工作中。在开发领域，代码生成工具可以说是百花齐放，无处不在。而测试工具就寥寥无几了。\n\n在现代Web开发中，自动化测试已经成为提高开发效率和保证代码质量的重要手段。随着前端应用变得越来越复杂，传统的UI自动化测试方法面临着一些挑战，例如页面结构变化、动态内容加载等问题。为了解决这些问题，字节跳动推出了 MidScene.js ——一款AI驱动的UI自动化测试工具，旨在通过智能识别UI组件，帮助开发者更高效地进行自动化测试。它的目标是通过AI技术，自动识别和操作UI元素，从而进行自动化测试。与传统的基于选择器（如ID、class等）定位元素的自动化测试工具不同，MidScene.js通过机器视觉、图像识别和文本分析来识别和操作页面元素。\n\n在本文中，我们将深入探讨 MidScene.js 的工作原理、使用场景以及如何在项目中利用它进行UI自动化测试。\n![midscenejs](./images/midscenejs/bg.png)\n\n# MidScene.js的工作原理\nMidScene.js 的核心原理是通过AI来分析页面内容，识别UI组件，并模拟用户操作。它的工作流程可以分为以下几个步骤：\n\n![工作原理](./images/midscenejs/principle.png)\n\n1. 页面截图与UI元素分析\n- MidScene.js首先对页面进行截图或解析DOM，捕捉页面的视觉内容。\n- 然后，利用AI技术分析页面中的各种元素（按钮、输入框、图片等），并识别它们的功能和行为。\n2. 元素定位与事件触发\n- 识别到UI元素后，MidScene.js通过AI定位它们的位置和交互方式，不需要依赖传统的CSS选择器。\n- 一旦定位到目标元素，它会模拟用户操作，如点击、输入、滑动等，触发相应的事件。\n3. 状态验证与测试反馈\n- 在执行操作后，MidScene.js会检查页面的反馈，验证UI是否按照预期行为进行反应。\n- 如果出现异常或不符合预期的行为，MidScene.js会生成详细的测试报告。\n\n\n# MidScene.js到底怎么样？\n为了帮助大家更好地理解如何使用MidScene.js，以及MidScene.js到底效果怎么样。 下面我们通过一系列简单的场景，展示如何通过MidScene.js进行UI测试。同时我们把playwright和midscenejs的测试过程和结果进行对比。通过对比让大家更好地理解MidScene.js的强大功能。\n\n## 登录页面自动化测试\n登录可以说是web应用测试中的代表场景之一了。这里我实现了一个简单的测试场景，实现登录页面的自动化测试。\n![登录页面](./images/midscenejs/login.png)\n\n### playwright\nplaywright测试脚本如下\n```js\nimport { test, expect } from '@playwright/test';\n\ntest('用户可以成功登录', async ({ page }) => {\n  // 1. 访问登录页面\n  await page.goto('http://localhost:8000/login.html');\n  // 2. 输入用户名和密码\n  await page.fill('input[name=\"username\"]', 'admin');\n  await page.fill('input[name=\"password\"]', '1234');\n  // 3. 点击登录按钮\n  await page.click('input[type=\"submit\"]');\n  // 4. 断言是否跳转到首页或某个特定页面\n  await expect(page).toHaveURL(/.*list.*/);\n});\n```\n测试报告如下\n![playwright测试报告](./images/midscenejs/playwright-report.png)\n### MidScene.js\n这款 AI 工具最令人兴奋的一点是它能够使用<font color=\"#dd0000\">自然语言</font>。只需描述测试步骤要做什么，它就可以开始。\n\nMidScene.js测试脚本如下\n\n```js\nimport { AgentOverChromeBridge } from \"@midscene/web/bridge-mode\";\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\nconst sleep = (ms) => new Promise((r) => setTimeout(r, ms));\nPromise.resolve(\n  (async () => {\n    const agent = new AgentOverChromeBridge();\n\n    await agent.connectNewTabWithUrl(\"http://localhost:8000/login.html\");\n\n    await agent.ai('在“用户名”输入框里面输入“admin”');\n    await agent.ai('在“密码”输入框里面输入“1234”');\n    await agent.ai('点击“登录”按钮');\n    await sleep(3000);\n\n    await agent.aiAssert(\"跳转'键盘列表'页面”\");\n    await agent.destroy();\n  })()\n);\n```\n测试过程如下，这里我用的桥接模式进行测试的，方便大家看到整个过程。\n![测试过程](./images/midscenejs/midscene-login.gif)\n每次测试脚本执行完成之后midscene会生成一份测试报告\n![测试报告](./images/midscenejs/login-result.png)\n我们可以看到具体的测试结果\n![测试结果](./images/midscenejs/login-report.png)\n\n### 对比\n从这个场景中我们大致可以得出以下结论：\n1. 可写/读性：\n\n  - 👍 可书写算是一大亮点吧 ，大大降低了维护自动化脚本对前端的要求。可读性那必须是MidScene的强项了，基本上是所见即所得，完全不需要去找元素对应。\n\n  - 👎没有办法隐藏一些敏感信息（用户名和密码），需要在提示词中直接发送这些内容，而如果没有 Midscene.js，可以在单独的数据文件中隐藏它们。\n\n  - 👎阅读起来可能比较冗长。 比起代码来说，描述起来的文本可能会稍微长一些。\n\n\n2. 执行时间：\n\n  - 👎由于 Midscene.js 依赖第三方的AI 提供支持还需要屏幕截图，因此执行时间非常慢。AI 需要时间来规划和“思考”它需要做什么。报告和 JSON 输出清楚地显示了完成每项任务所需的时间。\n\n  - 👎在 Playwright 中，通过角色（role）定位元素是一种推荐的做法，并且能够自然地测试 Web 应用的无障碍性（a11y）。而 Midscene.js 使用的是截图方式，因此偏离了这种做法。\n\n  ![定位](./images/midscenejs/midscene-locate.png)\n\n  整个运行事件也基本上在我们的预期里面吧\n\n  - MidScene.js 的执行时间在 36 秒左右。\n  - Playwright 的执行时间在 5 秒左右。\n\n3. 可维护性：\n  - 👍如果重构我们上面的登录页面（ ID、标签），测试用例可能仍会正确执行所有的操作。但是如果是 Playwright 就需要做些维护工作了。\n  - 👎如果需要对测试脚本进行维护，调试过程将是反复试错。我们需要通过反复更改测试的提示词来进行。\n  - 👎Playwright 测试是采用 页面对象模式编写的，这有助于保持代码的可维护性和可扩展性。而在 Midscene.js 中，测试是直接写在测试文件中的，这正是 Midscene.js 设计的初衷。因此，虽然使用自然语言编写测试速度快且简单，但如果需要修改多个测试文件，将会变得非常麻烦。\n\n## 登录失败案例\n下面我们来看一个失败的测试案例，看看MidScene.js到底有多智能。\n\n更改上面登录的脚本，把密码改成错误的密码，看看测试结果如何。\n```js\nPromise.resolve(\n  (async () => {\n    const agent = new AgentOverChromeBridge();\n    await agent.connectNewTabWithUrl(\"http://localhost:8000/login.html\");\n    await agent.ai('在“用户名”输入框里面输入“admin”');\n    await agent.ai('在“密码”输入框里面输入“wrong password”');\n    await agent.ai('点击“登录”按钮');\n    await sleep(3000);\n\n    await agent.aiAssert(\"用户无法登录\");\n    await agent.destroy();\n  })()\n);\n```\n查看报告的结果可以很好的让我们知道它是如何做的断言, 断言也是根据语义结合具体的场景来判断的，非常的灵活！\n![失败案例](./images/midscenejs/fail.png)\n\n# 总结\n通过AI驱动的 MidScene.js，开发者可以轻松进行自动化UI测试，减少传统UI测试中的元素选择和维护负担。它能够适应动态变化的UI，智能识别和操作页面元素，极大地提升了自动化测试的效率和准确性。无论是回归测试，还是复杂UI交互的自动化，MidScene.js都能够为开发者提供强大的支持。\n\n## 优势：\n - 快速的初始和用例编写，易于使用，简单、快捷\n - 适应动态变化的UI\n - 可读性（自然语言）\n - 可能是一个很好的UI自动化测试工具\n\n## 劣势：\n - 执行时间较长\n - 缺乏使用变量的能力\n - 仅捕获当前窗口中可见的内容 \n - 需要一个框架来在提示中使用正确的语言，以提高操作和断言的准确性（否则可能需要反复调试，或者同一个测试用例偶发失败的问题）\n - 第三方AI需要读取浏览器截图，是否可能存在安全问题（第三方AI是否会存储截图？）\n\n希望这篇文章能帮助你更好地理解和使用MidScene.js，如果你有任何问题或建议，欢迎在评论区留言！感兴趣的老铁也可以访问[MidScene.js](https://midscenejs.com/)的官网了解更多信息，也可访问老夫的[GitHub](https://github.com/ItProHub/midscenejs)获取完整的示例代码","slug":"midscenejs","published":1,"updated":"2025-03-04T01:10:55.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawj000xrkp16puq6vvs","content":"<p>随着AI快速发展，AI技术可以说已经渗透到了我们的生活和工作中。在开发领域，代码生成工具可以说是百花齐放，无处不在。而测试工具就寥寥无几了。</p>\n<p>在现代Web开发中，自动化测试已经成为提高开发效率和保证代码质量的重要手段。随着前端应用变得越来越复杂，传统的UI自动化测试方法面临着一些挑战，例如页面结构变化、动态内容加载等问题。为了解决这些问题，字节跳动推出了 MidScene.js ——一款AI驱动的UI自动化测试工具，旨在通过智能识别UI组件，帮助开发者更高效地进行自动化测试。它的目标是通过AI技术，自动识别和操作UI元素，从而进行自动化测试。与传统的基于选择器（如ID、class等）定位元素的自动化测试工具不同，MidScene.js通过机器视觉、图像识别和文本分析来识别和操作页面元素。</p>\n<p>在本文中，我们将深入探讨 MidScene.js 的工作原理、使用场景以及如何在项目中利用它进行UI自动化测试。<br><img src=\"/blog/./images/midscenejs/bg.png\" alt=\"midscenejs\"></p>\n<h1 id=\"MidScene-js的工作原理\"><a href=\"#MidScene-js的工作原理\" class=\"headerlink\" title=\"MidScene.js的工作原理\"></a>MidScene.js的工作原理</h1><p>MidScene.js 的核心原理是通过AI来分析页面内容，识别UI组件，并模拟用户操作。它的工作流程可以分为以下几个步骤：</p>\n<p><img src=\"/blog/./images/midscenejs/principle.png\" alt=\"工作原理\"></p>\n<ol>\n<li>页面截图与UI元素分析</li>\n</ol>\n<ul>\n<li>MidScene.js首先对页面进行截图或解析DOM，捕捉页面的视觉内容。</li>\n<li>然后，利用AI技术分析页面中的各种元素（按钮、输入框、图片等），并识别它们的功能和行为。</li>\n</ul>\n<ol start=\"2\">\n<li>元素定位与事件触发</li>\n</ol>\n<ul>\n<li>识别到UI元素后，MidScene.js通过AI定位它们的位置和交互方式，不需要依赖传统的CSS选择器。</li>\n<li>一旦定位到目标元素，它会模拟用户操作，如点击、输入、滑动等，触发相应的事件。</li>\n</ul>\n<ol start=\"3\">\n<li>状态验证与测试反馈</li>\n</ol>\n<ul>\n<li>在执行操作后，MidScene.js会检查页面的反馈，验证UI是否按照预期行为进行反应。</li>\n<li>如果出现异常或不符合预期的行为，MidScene.js会生成详细的测试报告。</li>\n</ul>\n<h1 id=\"MidScene-js到底怎么样？\"><a href=\"#MidScene-js到底怎么样？\" class=\"headerlink\" title=\"MidScene.js到底怎么样？\"></a>MidScene.js到底怎么样？</h1><p>为了帮助大家更好地理解如何使用MidScene.js，以及MidScene.js到底效果怎么样。 下面我们通过一系列简单的场景，展示如何通过MidScene.js进行UI测试。同时我们把playwright和midscenejs的测试过程和结果进行对比。通过对比让大家更好地理解MidScene.js的强大功能。</p>\n<h2 id=\"登录页面自动化测试\"><a href=\"#登录页面自动化测试\" class=\"headerlink\" title=\"登录页面自动化测试\"></a>登录页面自动化测试</h2><p>登录可以说是web应用测试中的代表场景之一了。这里我实现了一个简单的测试场景，实现登录页面的自动化测试。<br><img src=\"/blog/./images/midscenejs/login.png\" alt=\"登录页面\"></p>\n<h3 id=\"playwright\"><a href=\"#playwright\" class=\"headerlink\" title=\"playwright\"></a>playwright</h3><p>playwright测试脚本如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; test, expect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@playwright/test&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;用户可以成功登录&#x27;</span>, <span class=\"keyword\">async</span> (&#123; page &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 访问登录页面</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">goto</span>(<span class=\"string\">&#x27;http://localhost:8000/login.html&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 输入用户名和密码</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;input[name=&quot;username&quot;]&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;input[name=&quot;password&quot;]&#x27;</span>, <span class=\"string\">&#x27;1234&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 3. 点击登录按钮</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">click</span>(<span class=\"string\">&#x27;input[type=&quot;submit&quot;]&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 4. 断言是否跳转到首页或某个特定页面</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">expect</span>(page).<span class=\"title function_\">toHaveURL</span>(<span class=\"regexp\">/.*list.*/</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>测试报告如下<br><img src=\"/blog/./images/midscenejs/playwright-report.png\" alt=\"playwright测试报告\"></p>\n<h3 id=\"MidScene-js\"><a href=\"#MidScene-js\" class=\"headerlink\" title=\"MidScene.js\"></a>MidScene.js</h3><p>这款 AI 工具最令人兴奋的一点是它能够使用<font color=\"#dd0000\">自然语言</font>。只需描述测试步骤要做什么，它就可以开始。</p>\n<p>MidScene.js测试脚本如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AgentOverChromeBridge</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@midscene/web/bridge-mode&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> dotenv <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dotenv&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">dotenv.<span class=\"title function_\">config</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">sleep</span> = (<span class=\"params\">ms</span>) =&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> <span class=\"built_in\">setTimeout</span>(r, ms));</span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(</span><br><span class=\"line\">  (<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> agent = <span class=\"keyword\">new</span> <span class=\"title class_\">AgentOverChromeBridge</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">connectNewTabWithUrl</span>(<span class=\"string\">&quot;http://localhost:8000/login.html&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“用户名”输入框里面输入“admin”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“密码”输入框里面输入“1234”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;点击“登录”按钮&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">sleep</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">aiAssert</span>(<span class=\"string\">&quot;跳转&#x27;键盘列表&#x27;页面”&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">destroy</span>();</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>测试过程如下，这里我用的桥接模式进行测试的，方便大家看到整个过程。<br><img src=\"/blog/./images/midscenejs/midscene-login.gif\" alt=\"测试过程\"><br>每次测试脚本执行完成之后midscene会生成一份测试报告<br><img src=\"/blog/./images/midscenejs/login-result.png\" alt=\"测试报告\"><br>我们可以看到具体的测试结果<br><img src=\"/blog/./images/midscenejs/login-report.png\" alt=\"测试结果\"></p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><p>从这个场景中我们大致可以得出以下结论：</p>\n<ol>\n<li>可写&#x2F;读性：</li>\n</ol>\n<ul>\n<li><p>👍 可书写算是一大亮点吧 ，大大降低了维护自动化脚本对前端的要求。可读性那必须是MidScene的强项了，基本上是所见即所得，完全不需要去找元素对应。</p>\n</li>\n<li><p>👎没有办法隐藏一些敏感信息（用户名和密码），需要在提示词中直接发送这些内容，而如果没有 Midscene.js，可以在单独的数据文件中隐藏它们。</p>\n</li>\n<li><p>👎阅读起来可能比较冗长。 比起代码来说，描述起来的文本可能会稍微长一些。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>执行时间：</li>\n</ol>\n<ul>\n<li><p>👎由于 Midscene.js 依赖第三方的AI 提供支持还需要屏幕截图，因此执行时间非常慢。AI 需要时间来规划和“思考”它需要做什么。报告和 JSON 输出清楚地显示了完成每项任务所需的时间。</p>\n</li>\n<li><p>👎在 Playwright 中，通过角色（role）定位元素是一种推荐的做法，并且能够自然地测试 Web 应用的无障碍性（a11y）。而 Midscene.js 使用的是截图方式，因此偏离了这种做法。</p>\n</li>\n</ul>\n<p>  <img src=\"/blog/./images/midscenejs/midscene-locate.png\" alt=\"定位\"></p>\n<p>  整个运行事件也基本上在我们的预期里面吧</p>\n<ul>\n<li>MidScene.js 的执行时间在 36 秒左右。</li>\n<li>Playwright 的执行时间在 5 秒左右。</li>\n</ul>\n<ol start=\"3\">\n<li>可维护性：</li>\n</ol>\n<ul>\n<li>👍如果重构我们上面的登录页面（ ID、标签），测试用例可能仍会正确执行所有的操作。但是如果是 Playwright 就需要做些维护工作了。</li>\n<li>👎如果需要对测试脚本进行维护，调试过程将是反复试错。我们需要通过反复更改测试的提示词来进行。</li>\n<li>👎Playwright 测试是采用 页面对象模式编写的，这有助于保持代码的可维护性和可扩展性。而在 Midscene.js 中，测试是直接写在测试文件中的，这正是 Midscene.js 设计的初衷。因此，虽然使用自然语言编写测试速度快且简单，但如果需要修改多个测试文件，将会变得非常麻烦。</li>\n</ul>\n<h2 id=\"登录失败案例\"><a href=\"#登录失败案例\" class=\"headerlink\" title=\"登录失败案例\"></a>登录失败案例</h2><p>下面我们来看一个失败的测试案例，看看MidScene.js到底有多智能。</p>\n<p>更改上面登录的脚本，把密码改成错误的密码，看看测试结果如何。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(</span><br><span class=\"line\">  (<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> agent = <span class=\"keyword\">new</span> <span class=\"title class_\">AgentOverChromeBridge</span>();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">connectNewTabWithUrl</span>(<span class=\"string\">&quot;http://localhost:8000/login.html&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“用户名”输入框里面输入“admin”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“密码”输入框里面输入“wrong password”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;点击“登录”按钮&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">sleep</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">aiAssert</span>(<span class=\"string\">&quot;用户无法登录&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">destroy</span>();</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>查看报告的结果可以很好的让我们知道它是如何做的断言, 断言也是根据语义结合具体的场景来判断的，非常的灵活！<br><img src=\"/blog/./images/midscenejs/fail.png\" alt=\"失败案例\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过AI驱动的 MidScene.js，开发者可以轻松进行自动化UI测试，减少传统UI测试中的元素选择和维护负担。它能够适应动态变化的UI，智能识别和操作页面元素，极大地提升了自动化测试的效率和准确性。无论是回归测试，还是复杂UI交互的自动化，MidScene.js都能够为开发者提供强大的支持。</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>快速的初始和用例编写，易于使用，简单、快捷</li>\n<li>适应动态变化的UI</li>\n<li>可读性（自然语言）</li>\n<li>可能是一个很好的UI自动化测试工具</li>\n</ul>\n<h2 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h2><ul>\n<li>执行时间较长</li>\n<li>缺乏使用变量的能力</li>\n<li>仅捕获当前窗口中可见的内容 </li>\n<li>需要一个框架来在提示中使用正确的语言，以提高操作和断言的准确性（否则可能需要反复调试，或者同一个测试用例偶发失败的问题）</li>\n<li>第三方AI需要读取浏览器截图，是否可能存在安全问题（第三方AI是否会存储截图？）</li>\n</ul>\n<p>希望这篇文章能帮助你更好地理解和使用MidScene.js，如果你有任何问题或建议，欢迎在评论区留言！感兴趣的老铁也可以访问<a href=\"https://midscenejs.com/\">MidScene.js</a>的官网了解更多信息，也可访问老夫的<a href=\"https://github.com/ItProHub/midscenejs\">GitHub</a>获取完整的示例代码</p>\n","site":{"data":{}},"excerpt":"","more":"<p>随着AI快速发展，AI技术可以说已经渗透到了我们的生活和工作中。在开发领域，代码生成工具可以说是百花齐放，无处不在。而测试工具就寥寥无几了。</p>\n<p>在现代Web开发中，自动化测试已经成为提高开发效率和保证代码质量的重要手段。随着前端应用变得越来越复杂，传统的UI自动化测试方法面临着一些挑战，例如页面结构变化、动态内容加载等问题。为了解决这些问题，字节跳动推出了 MidScene.js ——一款AI驱动的UI自动化测试工具，旨在通过智能识别UI组件，帮助开发者更高效地进行自动化测试。它的目标是通过AI技术，自动识别和操作UI元素，从而进行自动化测试。与传统的基于选择器（如ID、class等）定位元素的自动化测试工具不同，MidScene.js通过机器视觉、图像识别和文本分析来识别和操作页面元素。</p>\n<p>在本文中，我们将深入探讨 MidScene.js 的工作原理、使用场景以及如何在项目中利用它进行UI自动化测试。<br><img src=\"/blog/./images/midscenejs/bg.png\" alt=\"midscenejs\"></p>\n<h1 id=\"MidScene-js的工作原理\"><a href=\"#MidScene-js的工作原理\" class=\"headerlink\" title=\"MidScene.js的工作原理\"></a>MidScene.js的工作原理</h1><p>MidScene.js 的核心原理是通过AI来分析页面内容，识别UI组件，并模拟用户操作。它的工作流程可以分为以下几个步骤：</p>\n<p><img src=\"/blog/./images/midscenejs/principle.png\" alt=\"工作原理\"></p>\n<ol>\n<li>页面截图与UI元素分析</li>\n</ol>\n<ul>\n<li>MidScene.js首先对页面进行截图或解析DOM，捕捉页面的视觉内容。</li>\n<li>然后，利用AI技术分析页面中的各种元素（按钮、输入框、图片等），并识别它们的功能和行为。</li>\n</ul>\n<ol start=\"2\">\n<li>元素定位与事件触发</li>\n</ol>\n<ul>\n<li>识别到UI元素后，MidScene.js通过AI定位它们的位置和交互方式，不需要依赖传统的CSS选择器。</li>\n<li>一旦定位到目标元素，它会模拟用户操作，如点击、输入、滑动等，触发相应的事件。</li>\n</ul>\n<ol start=\"3\">\n<li>状态验证与测试反馈</li>\n</ol>\n<ul>\n<li>在执行操作后，MidScene.js会检查页面的反馈，验证UI是否按照预期行为进行反应。</li>\n<li>如果出现异常或不符合预期的行为，MidScene.js会生成详细的测试报告。</li>\n</ul>\n<h1 id=\"MidScene-js到底怎么样？\"><a href=\"#MidScene-js到底怎么样？\" class=\"headerlink\" title=\"MidScene.js到底怎么样？\"></a>MidScene.js到底怎么样？</h1><p>为了帮助大家更好地理解如何使用MidScene.js，以及MidScene.js到底效果怎么样。 下面我们通过一系列简单的场景，展示如何通过MidScene.js进行UI测试。同时我们把playwright和midscenejs的测试过程和结果进行对比。通过对比让大家更好地理解MidScene.js的强大功能。</p>\n<h2 id=\"登录页面自动化测试\"><a href=\"#登录页面自动化测试\" class=\"headerlink\" title=\"登录页面自动化测试\"></a>登录页面自动化测试</h2><p>登录可以说是web应用测试中的代表场景之一了。这里我实现了一个简单的测试场景，实现登录页面的自动化测试。<br><img src=\"/blog/./images/midscenejs/login.png\" alt=\"登录页面\"></p>\n<h3 id=\"playwright\"><a href=\"#playwright\" class=\"headerlink\" title=\"playwright\"></a>playwright</h3><p>playwright测试脚本如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; test, expect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@playwright/test&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"string\">&#x27;用户可以成功登录&#x27;</span>, <span class=\"keyword\">async</span> (&#123; page &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 访问登录页面</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">goto</span>(<span class=\"string\">&#x27;http://localhost:8000/login.html&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 输入用户名和密码</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;input[name=&quot;username&quot;]&#x27;</span>, <span class=\"string\">&#x27;admin&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;input[name=&quot;password&quot;]&#x27;</span>, <span class=\"string\">&#x27;1234&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 3. 点击登录按钮</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> page.<span class=\"title function_\">click</span>(<span class=\"string\">&#x27;input[type=&quot;submit&quot;]&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 4. 断言是否跳转到首页或某个特定页面</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">expect</span>(page).<span class=\"title function_\">toHaveURL</span>(<span class=\"regexp\">/.*list.*/</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>测试报告如下<br><img src=\"/blog/./images/midscenejs/playwright-report.png\" alt=\"playwright测试报告\"></p>\n<h3 id=\"MidScene-js\"><a href=\"#MidScene-js\" class=\"headerlink\" title=\"MidScene.js\"></a>MidScene.js</h3><p>这款 AI 工具最令人兴奋的一点是它能够使用<font color=\"#dd0000\">自然语言</font>。只需描述测试步骤要做什么，它就可以开始。</p>\n<p>MidScene.js测试脚本如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">AgentOverChromeBridge</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@midscene/web/bridge-mode&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> dotenv <span class=\"keyword\">from</span> <span class=\"string\">&#x27;dotenv&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">dotenv.<span class=\"title function_\">config</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">sleep</span> = (<span class=\"params\">ms</span>) =&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> <span class=\"built_in\">setTimeout</span>(r, ms));</span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(</span><br><span class=\"line\">  (<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> agent = <span class=\"keyword\">new</span> <span class=\"title class_\">AgentOverChromeBridge</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">connectNewTabWithUrl</span>(<span class=\"string\">&quot;http://localhost:8000/login.html&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“用户名”输入框里面输入“admin”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“密码”输入框里面输入“1234”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;点击“登录”按钮&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">sleep</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">aiAssert</span>(<span class=\"string\">&quot;跳转&#x27;键盘列表&#x27;页面”&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">destroy</span>();</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>测试过程如下，这里我用的桥接模式进行测试的，方便大家看到整个过程。<br><img src=\"/blog/./images/midscenejs/midscene-login.gif\" alt=\"测试过程\"><br>每次测试脚本执行完成之后midscene会生成一份测试报告<br><img src=\"/blog/./images/midscenejs/login-result.png\" alt=\"测试报告\"><br>我们可以看到具体的测试结果<br><img src=\"/blog/./images/midscenejs/login-report.png\" alt=\"测试结果\"></p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><p>从这个场景中我们大致可以得出以下结论：</p>\n<ol>\n<li>可写&#x2F;读性：</li>\n</ol>\n<ul>\n<li><p>👍 可书写算是一大亮点吧 ，大大降低了维护自动化脚本对前端的要求。可读性那必须是MidScene的强项了，基本上是所见即所得，完全不需要去找元素对应。</p>\n</li>\n<li><p>👎没有办法隐藏一些敏感信息（用户名和密码），需要在提示词中直接发送这些内容，而如果没有 Midscene.js，可以在单独的数据文件中隐藏它们。</p>\n</li>\n<li><p>👎阅读起来可能比较冗长。 比起代码来说，描述起来的文本可能会稍微长一些。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>执行时间：</li>\n</ol>\n<ul>\n<li><p>👎由于 Midscene.js 依赖第三方的AI 提供支持还需要屏幕截图，因此执行时间非常慢。AI 需要时间来规划和“思考”它需要做什么。报告和 JSON 输出清楚地显示了完成每项任务所需的时间。</p>\n</li>\n<li><p>👎在 Playwright 中，通过角色（role）定位元素是一种推荐的做法，并且能够自然地测试 Web 应用的无障碍性（a11y）。而 Midscene.js 使用的是截图方式，因此偏离了这种做法。</p>\n</li>\n</ul>\n<p>  <img src=\"/blog/./images/midscenejs/midscene-locate.png\" alt=\"定位\"></p>\n<p>  整个运行事件也基本上在我们的预期里面吧</p>\n<ul>\n<li>MidScene.js 的执行时间在 36 秒左右。</li>\n<li>Playwright 的执行时间在 5 秒左右。</li>\n</ul>\n<ol start=\"3\">\n<li>可维护性：</li>\n</ol>\n<ul>\n<li>👍如果重构我们上面的登录页面（ ID、标签），测试用例可能仍会正确执行所有的操作。但是如果是 Playwright 就需要做些维护工作了。</li>\n<li>👎如果需要对测试脚本进行维护，调试过程将是反复试错。我们需要通过反复更改测试的提示词来进行。</li>\n<li>👎Playwright 测试是采用 页面对象模式编写的，这有助于保持代码的可维护性和可扩展性。而在 Midscene.js 中，测试是直接写在测试文件中的，这正是 Midscene.js 设计的初衷。因此，虽然使用自然语言编写测试速度快且简单，但如果需要修改多个测试文件，将会变得非常麻烦。</li>\n</ul>\n<h2 id=\"登录失败案例\"><a href=\"#登录失败案例\" class=\"headerlink\" title=\"登录失败案例\"></a>登录失败案例</h2><p>下面我们来看一个失败的测试案例，看看MidScene.js到底有多智能。</p>\n<p>更改上面登录的脚本，把密码改成错误的密码，看看测试结果如何。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(</span><br><span class=\"line\">  (<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> agent = <span class=\"keyword\">new</span> <span class=\"title class_\">AgentOverChromeBridge</span>();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">connectNewTabWithUrl</span>(<span class=\"string\">&quot;http://localhost:8000/login.html&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“用户名”输入框里面输入“admin”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;在“密码”输入框里面输入“wrong password”&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">ai</span>(<span class=\"string\">&#x27;点击“登录”按钮&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">sleep</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">aiAssert</span>(<span class=\"string\">&quot;用户无法登录&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> agent.<span class=\"title function_\">destroy</span>();</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>查看报告的结果可以很好的让我们知道它是如何做的断言, 断言也是根据语义结合具体的场景来判断的，非常的灵活！<br><img src=\"/blog/./images/midscenejs/fail.png\" alt=\"失败案例\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过AI驱动的 MidScene.js，开发者可以轻松进行自动化UI测试，减少传统UI测试中的元素选择和维护负担。它能够适应动态变化的UI，智能识别和操作页面元素，极大地提升了自动化测试的效率和准确性。无论是回归测试，还是复杂UI交互的自动化，MidScene.js都能够为开发者提供强大的支持。</p>\n<h2 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h2><ul>\n<li>快速的初始和用例编写，易于使用，简单、快捷</li>\n<li>适应动态变化的UI</li>\n<li>可读性（自然语言）</li>\n<li>可能是一个很好的UI自动化测试工具</li>\n</ul>\n<h2 id=\"劣势：\"><a href=\"#劣势：\" class=\"headerlink\" title=\"劣势：\"></a>劣势：</h2><ul>\n<li>执行时间较长</li>\n<li>缺乏使用变量的能力</li>\n<li>仅捕获当前窗口中可见的内容 </li>\n<li>需要一个框架来在提示中使用正确的语言，以提高操作和断言的准确性（否则可能需要反复调试，或者同一个测试用例偶发失败的问题）</li>\n<li>第三方AI需要读取浏览器截图，是否可能存在安全问题（第三方AI是否会存储截图？）</li>\n</ul>\n<p>希望这篇文章能帮助你更好地理解和使用MidScene.js，如果你有任何问题或建议，欢迎在评论区留言！感兴趣的老铁也可以访问<a href=\"https://midscenejs.com/\">MidScene.js</a>的官网了解更多信息，也可访问老夫的<a href=\"https://github.com/ItProHub/midscenejs\">GitHub</a>获取完整的示例代码</p>\n"},{"title":"「AI」科普向 | OpenAI Operator：推动数字世界的新纪元","date":"2025-02-12T08:52:00.000Z","_content":"上个月，OpenAI宣布上线名为Operator的首款AI智能体，它能通过网页执行各种任务。个人认为它标志着AI技术向更高层次发展的重要一步。\n\n![OpenAI Operator](./images/openai-operator/operator.jpg)\n\n随着人工智能（AI）技术的不断进步，我们已经进入了一个充满变革的时代。特别是当 OpenAI 推出其新工具——Operator 时，AI 与数字世界的互动方式迎来了前所未有的变革。Operator 并不是简单的工具，它标志着 AI 不仅仅是一个内容生成器，而是成为了一个能够主动操作、自动化任务和“浏览”网络的智能代理。\n\n在本文中，我们将介绍 OpenAI Operator 的核心功能、它如何改变信息的获取方式，以及它可能引发的互联网商业模式变革。\n\n# 什么是 OpenAI Operator？\n**OpenAI Operator** 是一种全新的 AI 工具，它为用户提供了一个强大的数字代理，能够代替用户主动操作网页和应用程序，完成各种在线任务。与 ChatGPT 主要侧重于生成对话内容不同，Operator 使 AI 可以主动浏览网络、操作网站、预定服务等，基本上将传统的网络互动方式变得无缝化。\n\nOpenAI 展示了一个例子，你不再需要访问旅游网站如 TripAdvisor，自行搜索、筛选和预定旅游产品。现在，只需告诉 Operator，让它为你“find me a friendly campsite at Joshua Tree this weekend”，AI 就能自动完成这一切，几乎不需要用户的干预。\n\n![OpenAI Operator](./images/openai-operator/operator-demo.gif)\n\n这一功能的核心在于通过 AI 代理（Computer-Using Agent，CUA）实现高度的自动化和任务执行，使得用户不再直接与传统网站交互，而是通过 AI 来“控制”这些服务。\n\n![工作原理](./images/openai-operator/principle.png)\n\n很遗憾的是笔者还没有机会亲自体验过这个功能,只能通过OpenAI的发布会和官网了解到这个功能的基本情况。别问为啥，问就是没钱💰💰💰。目前Operator仅对美国的Pro用户开放。\n\n![价格](./images/openai-operator/price.png)\n\n# OpenAI Operator 的核心功能\n## 自动化网络操作\nOperator 的核心能力是自动化执行网络操作，它不仅能够访问网站，还能在网站内执行操作。举例来说，AI 可以直接为你完成机票预定、酒店查询，甚至购物购买任务。这一过程极大简化了用户体验，用户无需再通过多个网页和平台来获取所需信息，AI 自动完成所有中间步骤。\n\n## 无缝集成与跨平台兼容性\n不同于传统的互联网操作，Operator 具有跨平台的兼容性，它可以同时与多个应用程序和网站进行交互。无论是旅游网站、购物平台，还是社交媒体，AI 都能无缝对接，执行任务而不需要人工干预。\n\n## 解放用户与中间人\n通过 OpenAI Operator，传统的中介角色（如 Google、TripAdvisor、淘宝等平台）正面临着前所未有的挑战。这些平台通常依赖广告、佣金和中介收入来维持运营，但随着 AI 直接完成用户请求，这些收入模式将变得不再可持续。\n\n例如，过去你可能需要通过 Google 搜索找到 TripAdvisor，浏览旅游产品，再通过第三方网站完成预定。现在，AI 会自动为你完成这一切，无需依赖这些传统平台。这个变化预示着未来我们可能进入一个没有中介、直接由 AI 提供服务的世界。\n\n![价格](./images/openai-operator/future.jpg)\n\n## 未来的商业模式与开放数据层\n随着 Operator 的普及，传统的互联网公司将面临巨大的变革。越来越多的服务商将不再直接面对消费者，而是将他们的数据和服务卖给 AI 公司，或通过 API 接口让 AI 可以付费访问。正如某些评论所言，未来的互联网将更多地面向 AI，而不是最终用户。\n\n这种转变可能导致一些平台转向数据驱动模式，提供结构化数据而不是传统的内容展示。对于像 TripAdvisor、Yelp 这样的服务提供商来说，它们将不得不重新思考如何在这个新生态中生存下去，可能的方式是通过与 AI 的合作，直接向 AI 公司销售结构化数据。\n\n## 从“搜索”到“请求”\n以往，我们通过搜索引擎如 Google 寻找信息。现在，AI 能够主动“请求”信息并处理这些请求，完全改变了用户交互的方式。Operator 将逐步替代传统的搜索引擎和网站浏览，用户只需告诉 AI 他们的需求，AI 就能自动完成信息获取和任务执行。这种转变可能会加速互联网的“衰退”，特别是对于那些依赖广告和展示内容的传统网站。\n\n![衰落](./images/openai-operator/decline.jpg)\n\n# OpenAI Operator 的潜在应用场景\n## 智能个人助手\n随着 Operator 的发展，AI 不再仅仅是一个问答助手，它将成为一个全方位的个人助手，能够自动化处理日常任务、购物、工作安排等。例如，AI 可以根据你的需求自动预定旅行、购买商品，甚至向服务商发送请求。\n\n## 智能客户服务\nAI 可以集成到客户服务中，自动执行订单查询、退换货、技术支持等操作，减少人工干预，提高服务效率。Operator 让客户服务变得更加高效和个性化，用户无需再访问多个平台，AI 可以直接在后台操作系统和服务，提供即时响应。\n\n## 信息和数据自动化获取\nAI 能够快速从各种信息源（如新闻网站、研究数据库、产品评价平台）中自动提取并汇总信息。这对于需要高效获取行业数据或市场情报的用户尤为重要，AI 可以代替人工收集和筛选信息，从而节省大量时间和精力。\n\n# 互联网的未来：从开放到结构化\n如同一些行业观察者所预测的那样，随着 AI 技术的发展，互联网将不再是一个开放的、面向用户的内容平台，而会演变为一个服务于 AI 的结构化数据层。在这个新环境中，传统的互联网公司将不再直接面向用户，而是通过 API 向 AI 提供数据和服务，甚至可能要求用户通过身份认证和授权来获取服务。\n\n这意味着，我们很可能会进入一个没有“搜索”或“浏览”的新时代，所有信息获取和服务操作都通过 AI 完成，传统互联网平台的地位将逐步下降。\n\n# 总结\nOpenAI Operator 为 AI 赋予了前所未有的能力，能够主动操作数字世界中的各类系统和平台。这不仅重新定义了 AI 与数字世界的交互方式，也引发了对于互联网未来发展的深刻反思。随着 AI 的普及，传统互联网商业模式面临着巨大的挑战，开放网络的消亡可能是不可避免的趋势。\n\n尽管如此，OpenAI Operator 为我们带来了一个充满可能性的未来，AI 将变得更加智能、主动和个性化，彻底改变我们与数字世界互动的方式。\n\n","source":"_posts/openai-operator.md","raw":"---\ntitle: 「AI」科普向 | OpenAI Operator：推动数字世界的新纪元\ndate: 2025-02-12 16:52:00\ntags:\n---\n上个月，OpenAI宣布上线名为Operator的首款AI智能体，它能通过网页执行各种任务。个人认为它标志着AI技术向更高层次发展的重要一步。\n\n![OpenAI Operator](./images/openai-operator/operator.jpg)\n\n随着人工智能（AI）技术的不断进步，我们已经进入了一个充满变革的时代。特别是当 OpenAI 推出其新工具——Operator 时，AI 与数字世界的互动方式迎来了前所未有的变革。Operator 并不是简单的工具，它标志着 AI 不仅仅是一个内容生成器，而是成为了一个能够主动操作、自动化任务和“浏览”网络的智能代理。\n\n在本文中，我们将介绍 OpenAI Operator 的核心功能、它如何改变信息的获取方式，以及它可能引发的互联网商业模式变革。\n\n# 什么是 OpenAI Operator？\n**OpenAI Operator** 是一种全新的 AI 工具，它为用户提供了一个强大的数字代理，能够代替用户主动操作网页和应用程序，完成各种在线任务。与 ChatGPT 主要侧重于生成对话内容不同，Operator 使 AI 可以主动浏览网络、操作网站、预定服务等，基本上将传统的网络互动方式变得无缝化。\n\nOpenAI 展示了一个例子，你不再需要访问旅游网站如 TripAdvisor，自行搜索、筛选和预定旅游产品。现在，只需告诉 Operator，让它为你“find me a friendly campsite at Joshua Tree this weekend”，AI 就能自动完成这一切，几乎不需要用户的干预。\n\n![OpenAI Operator](./images/openai-operator/operator-demo.gif)\n\n这一功能的核心在于通过 AI 代理（Computer-Using Agent，CUA）实现高度的自动化和任务执行，使得用户不再直接与传统网站交互，而是通过 AI 来“控制”这些服务。\n\n![工作原理](./images/openai-operator/principle.png)\n\n很遗憾的是笔者还没有机会亲自体验过这个功能,只能通过OpenAI的发布会和官网了解到这个功能的基本情况。别问为啥，问就是没钱💰💰💰。目前Operator仅对美国的Pro用户开放。\n\n![价格](./images/openai-operator/price.png)\n\n# OpenAI Operator 的核心功能\n## 自动化网络操作\nOperator 的核心能力是自动化执行网络操作，它不仅能够访问网站，还能在网站内执行操作。举例来说，AI 可以直接为你完成机票预定、酒店查询，甚至购物购买任务。这一过程极大简化了用户体验，用户无需再通过多个网页和平台来获取所需信息，AI 自动完成所有中间步骤。\n\n## 无缝集成与跨平台兼容性\n不同于传统的互联网操作，Operator 具有跨平台的兼容性，它可以同时与多个应用程序和网站进行交互。无论是旅游网站、购物平台，还是社交媒体，AI 都能无缝对接，执行任务而不需要人工干预。\n\n## 解放用户与中间人\n通过 OpenAI Operator，传统的中介角色（如 Google、TripAdvisor、淘宝等平台）正面临着前所未有的挑战。这些平台通常依赖广告、佣金和中介收入来维持运营，但随着 AI 直接完成用户请求，这些收入模式将变得不再可持续。\n\n例如，过去你可能需要通过 Google 搜索找到 TripAdvisor，浏览旅游产品，再通过第三方网站完成预定。现在，AI 会自动为你完成这一切，无需依赖这些传统平台。这个变化预示着未来我们可能进入一个没有中介、直接由 AI 提供服务的世界。\n\n![价格](./images/openai-operator/future.jpg)\n\n## 未来的商业模式与开放数据层\n随着 Operator 的普及，传统的互联网公司将面临巨大的变革。越来越多的服务商将不再直接面对消费者，而是将他们的数据和服务卖给 AI 公司，或通过 API 接口让 AI 可以付费访问。正如某些评论所言，未来的互联网将更多地面向 AI，而不是最终用户。\n\n这种转变可能导致一些平台转向数据驱动模式，提供结构化数据而不是传统的内容展示。对于像 TripAdvisor、Yelp 这样的服务提供商来说，它们将不得不重新思考如何在这个新生态中生存下去，可能的方式是通过与 AI 的合作，直接向 AI 公司销售结构化数据。\n\n## 从“搜索”到“请求”\n以往，我们通过搜索引擎如 Google 寻找信息。现在，AI 能够主动“请求”信息并处理这些请求，完全改变了用户交互的方式。Operator 将逐步替代传统的搜索引擎和网站浏览，用户只需告诉 AI 他们的需求，AI 就能自动完成信息获取和任务执行。这种转变可能会加速互联网的“衰退”，特别是对于那些依赖广告和展示内容的传统网站。\n\n![衰落](./images/openai-operator/decline.jpg)\n\n# OpenAI Operator 的潜在应用场景\n## 智能个人助手\n随着 Operator 的发展，AI 不再仅仅是一个问答助手，它将成为一个全方位的个人助手，能够自动化处理日常任务、购物、工作安排等。例如，AI 可以根据你的需求自动预定旅行、购买商品，甚至向服务商发送请求。\n\n## 智能客户服务\nAI 可以集成到客户服务中，自动执行订单查询、退换货、技术支持等操作，减少人工干预，提高服务效率。Operator 让客户服务变得更加高效和个性化，用户无需再访问多个平台，AI 可以直接在后台操作系统和服务，提供即时响应。\n\n## 信息和数据自动化获取\nAI 能够快速从各种信息源（如新闻网站、研究数据库、产品评价平台）中自动提取并汇总信息。这对于需要高效获取行业数据或市场情报的用户尤为重要，AI 可以代替人工收集和筛选信息，从而节省大量时间和精力。\n\n# 互联网的未来：从开放到结构化\n如同一些行业观察者所预测的那样，随着 AI 技术的发展，互联网将不再是一个开放的、面向用户的内容平台，而会演变为一个服务于 AI 的结构化数据层。在这个新环境中，传统的互联网公司将不再直接面向用户，而是通过 API 向 AI 提供数据和服务，甚至可能要求用户通过身份认证和授权来获取服务。\n\n这意味着，我们很可能会进入一个没有“搜索”或“浏览”的新时代，所有信息获取和服务操作都通过 AI 完成，传统互联网平台的地位将逐步下降。\n\n# 总结\nOpenAI Operator 为 AI 赋予了前所未有的能力，能够主动操作数字世界中的各类系统和平台。这不仅重新定义了 AI 与数字世界的交互方式，也引发了对于互联网未来发展的深刻反思。随着 AI 的普及，传统互联网商业模式面临着巨大的挑战，开放网络的消亡可能是不可避免的趋势。\n\n尽管如此，OpenAI Operator 为我们带来了一个充满可能性的未来，AI 将变得更加智能、主动和个性化，彻底改变我们与数字世界互动的方式。\n\n","slug":"openai-operator","published":1,"updated":"2025-02-14T06:55:27.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawj000yrkp1dcnt58td","content":"<p>上个月，OpenAI宣布上线名为Operator的首款AI智能体，它能通过网页执行各种任务。个人认为它标志着AI技术向更高层次发展的重要一步。</p>\n<p><img src=\"/blog/./images/openai-operator/operator.jpg\" alt=\"OpenAI Operator\"></p>\n<p>随着人工智能（AI）技术的不断进步，我们已经进入了一个充满变革的时代。特别是当 OpenAI 推出其新工具——Operator 时，AI 与数字世界的互动方式迎来了前所未有的变革。Operator 并不是简单的工具，它标志着 AI 不仅仅是一个内容生成器，而是成为了一个能够主动操作、自动化任务和“浏览”网络的智能代理。</p>\n<p>在本文中，我们将介绍 OpenAI Operator 的核心功能、它如何改变信息的获取方式，以及它可能引发的互联网商业模式变革。</p>\n<h1 id=\"什么是-OpenAI-Operator？\"><a href=\"#什么是-OpenAI-Operator？\" class=\"headerlink\" title=\"什么是 OpenAI Operator？\"></a>什么是 OpenAI Operator？</h1><p><strong>OpenAI Operator</strong> 是一种全新的 AI 工具，它为用户提供了一个强大的数字代理，能够代替用户主动操作网页和应用程序，完成各种在线任务。与 ChatGPT 主要侧重于生成对话内容不同，Operator 使 AI 可以主动浏览网络、操作网站、预定服务等，基本上将传统的网络互动方式变得无缝化。</p>\n<p>OpenAI 展示了一个例子，你不再需要访问旅游网站如 TripAdvisor，自行搜索、筛选和预定旅游产品。现在，只需告诉 Operator，让它为你“find me a friendly campsite at Joshua Tree this weekend”，AI 就能自动完成这一切，几乎不需要用户的干预。</p>\n<p><img src=\"/blog/./images/openai-operator/operator-demo.gif\" alt=\"OpenAI Operator\"></p>\n<p>这一功能的核心在于通过 AI 代理（Computer-Using Agent，CUA）实现高度的自动化和任务执行，使得用户不再直接与传统网站交互，而是通过 AI 来“控制”这些服务。</p>\n<p><img src=\"/blog/./images/openai-operator/principle.png\" alt=\"工作原理\"></p>\n<p>很遗憾的是笔者还没有机会亲自体验过这个功能,只能通过OpenAI的发布会和官网了解到这个功能的基本情况。别问为啥，问就是没钱💰💰💰。目前Operator仅对美国的Pro用户开放。</p>\n<p><img src=\"/blog/./images/openai-operator/price.png\" alt=\"价格\"></p>\n<h1 id=\"OpenAI-Operator-的核心功能\"><a href=\"#OpenAI-Operator-的核心功能\" class=\"headerlink\" title=\"OpenAI Operator 的核心功能\"></a>OpenAI Operator 的核心功能</h1><h2 id=\"自动化网络操作\"><a href=\"#自动化网络操作\" class=\"headerlink\" title=\"自动化网络操作\"></a>自动化网络操作</h2><p>Operator 的核心能力是自动化执行网络操作，它不仅能够访问网站，还能在网站内执行操作。举例来说，AI 可以直接为你完成机票预定、酒店查询，甚至购物购买任务。这一过程极大简化了用户体验，用户无需再通过多个网页和平台来获取所需信息，AI 自动完成所有中间步骤。</p>\n<h2 id=\"无缝集成与跨平台兼容性\"><a href=\"#无缝集成与跨平台兼容性\" class=\"headerlink\" title=\"无缝集成与跨平台兼容性\"></a>无缝集成与跨平台兼容性</h2><p>不同于传统的互联网操作，Operator 具有跨平台的兼容性，它可以同时与多个应用程序和网站进行交互。无论是旅游网站、购物平台，还是社交媒体，AI 都能无缝对接，执行任务而不需要人工干预。</p>\n<h2 id=\"解放用户与中间人\"><a href=\"#解放用户与中间人\" class=\"headerlink\" title=\"解放用户与中间人\"></a>解放用户与中间人</h2><p>通过 OpenAI Operator，传统的中介角色（如 Google、TripAdvisor、淘宝等平台）正面临着前所未有的挑战。这些平台通常依赖广告、佣金和中介收入来维持运营，但随着 AI 直接完成用户请求，这些收入模式将变得不再可持续。</p>\n<p>例如，过去你可能需要通过 Google 搜索找到 TripAdvisor，浏览旅游产品，再通过第三方网站完成预定。现在，AI 会自动为你完成这一切，无需依赖这些传统平台。这个变化预示着未来我们可能进入一个没有中介、直接由 AI 提供服务的世界。</p>\n<p><img src=\"/blog/./images/openai-operator/future.jpg\" alt=\"价格\"></p>\n<h2 id=\"未来的商业模式与开放数据层\"><a href=\"#未来的商业模式与开放数据层\" class=\"headerlink\" title=\"未来的商业模式与开放数据层\"></a>未来的商业模式与开放数据层</h2><p>随着 Operator 的普及，传统的互联网公司将面临巨大的变革。越来越多的服务商将不再直接面对消费者，而是将他们的数据和服务卖给 AI 公司，或通过 API 接口让 AI 可以付费访问。正如某些评论所言，未来的互联网将更多地面向 AI，而不是最终用户。</p>\n<p>这种转变可能导致一些平台转向数据驱动模式，提供结构化数据而不是传统的内容展示。对于像 TripAdvisor、Yelp 这样的服务提供商来说，它们将不得不重新思考如何在这个新生态中生存下去，可能的方式是通过与 AI 的合作，直接向 AI 公司销售结构化数据。</p>\n<h2 id=\"从“搜索”到“请求”\"><a href=\"#从“搜索”到“请求”\" class=\"headerlink\" title=\"从“搜索”到“请求”\"></a>从“搜索”到“请求”</h2><p>以往，我们通过搜索引擎如 Google 寻找信息。现在，AI 能够主动“请求”信息并处理这些请求，完全改变了用户交互的方式。Operator 将逐步替代传统的搜索引擎和网站浏览，用户只需告诉 AI 他们的需求，AI 就能自动完成信息获取和任务执行。这种转变可能会加速互联网的“衰退”，特别是对于那些依赖广告和展示内容的传统网站。</p>\n<p><img src=\"/blog/./images/openai-operator/decline.jpg\" alt=\"衰落\"></p>\n<h1 id=\"OpenAI-Operator-的潜在应用场景\"><a href=\"#OpenAI-Operator-的潜在应用场景\" class=\"headerlink\" title=\"OpenAI Operator 的潜在应用场景\"></a>OpenAI Operator 的潜在应用场景</h1><h2 id=\"智能个人助手\"><a href=\"#智能个人助手\" class=\"headerlink\" title=\"智能个人助手\"></a>智能个人助手</h2><p>随着 Operator 的发展，AI 不再仅仅是一个问答助手，它将成为一个全方位的个人助手，能够自动化处理日常任务、购物、工作安排等。例如，AI 可以根据你的需求自动预定旅行、购买商品，甚至向服务商发送请求。</p>\n<h2 id=\"智能客户服务\"><a href=\"#智能客户服务\" class=\"headerlink\" title=\"智能客户服务\"></a>智能客户服务</h2><p>AI 可以集成到客户服务中，自动执行订单查询、退换货、技术支持等操作，减少人工干预，提高服务效率。Operator 让客户服务变得更加高效和个性化，用户无需再访问多个平台，AI 可以直接在后台操作系统和服务，提供即时响应。</p>\n<h2 id=\"信息和数据自动化获取\"><a href=\"#信息和数据自动化获取\" class=\"headerlink\" title=\"信息和数据自动化获取\"></a>信息和数据自动化获取</h2><p>AI 能够快速从各种信息源（如新闻网站、研究数据库、产品评价平台）中自动提取并汇总信息。这对于需要高效获取行业数据或市场情报的用户尤为重要，AI 可以代替人工收集和筛选信息，从而节省大量时间和精力。</p>\n<h1 id=\"互联网的未来：从开放到结构化\"><a href=\"#互联网的未来：从开放到结构化\" class=\"headerlink\" title=\"互联网的未来：从开放到结构化\"></a>互联网的未来：从开放到结构化</h1><p>如同一些行业观察者所预测的那样，随着 AI 技术的发展，互联网将不再是一个开放的、面向用户的内容平台，而会演变为一个服务于 AI 的结构化数据层。在这个新环境中，传统的互联网公司将不再直接面向用户，而是通过 API 向 AI 提供数据和服务，甚至可能要求用户通过身份认证和授权来获取服务。</p>\n<p>这意味着，我们很可能会进入一个没有“搜索”或“浏览”的新时代，所有信息获取和服务操作都通过 AI 完成，传统互联网平台的地位将逐步下降。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>OpenAI Operator 为 AI 赋予了前所未有的能力，能够主动操作数字世界中的各类系统和平台。这不仅重新定义了 AI 与数字世界的交互方式，也引发了对于互联网未来发展的深刻反思。随着 AI 的普及，传统互联网商业模式面临着巨大的挑战，开放网络的消亡可能是不可避免的趋势。</p>\n<p>尽管如此，OpenAI Operator 为我们带来了一个充满可能性的未来，AI 将变得更加智能、主动和个性化，彻底改变我们与数字世界互动的方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上个月，OpenAI宣布上线名为Operator的首款AI智能体，它能通过网页执行各种任务。个人认为它标志着AI技术向更高层次发展的重要一步。</p>\n<p><img src=\"/blog/./images/openai-operator/operator.jpg\" alt=\"OpenAI Operator\"></p>\n<p>随着人工智能（AI）技术的不断进步，我们已经进入了一个充满变革的时代。特别是当 OpenAI 推出其新工具——Operator 时，AI 与数字世界的互动方式迎来了前所未有的变革。Operator 并不是简单的工具，它标志着 AI 不仅仅是一个内容生成器，而是成为了一个能够主动操作、自动化任务和“浏览”网络的智能代理。</p>\n<p>在本文中，我们将介绍 OpenAI Operator 的核心功能、它如何改变信息的获取方式，以及它可能引发的互联网商业模式变革。</p>\n<h1 id=\"什么是-OpenAI-Operator？\"><a href=\"#什么是-OpenAI-Operator？\" class=\"headerlink\" title=\"什么是 OpenAI Operator？\"></a>什么是 OpenAI Operator？</h1><p><strong>OpenAI Operator</strong> 是一种全新的 AI 工具，它为用户提供了一个强大的数字代理，能够代替用户主动操作网页和应用程序，完成各种在线任务。与 ChatGPT 主要侧重于生成对话内容不同，Operator 使 AI 可以主动浏览网络、操作网站、预定服务等，基本上将传统的网络互动方式变得无缝化。</p>\n<p>OpenAI 展示了一个例子，你不再需要访问旅游网站如 TripAdvisor，自行搜索、筛选和预定旅游产品。现在，只需告诉 Operator，让它为你“find me a friendly campsite at Joshua Tree this weekend”，AI 就能自动完成这一切，几乎不需要用户的干预。</p>\n<p><img src=\"/blog/./images/openai-operator/operator-demo.gif\" alt=\"OpenAI Operator\"></p>\n<p>这一功能的核心在于通过 AI 代理（Computer-Using Agent，CUA）实现高度的自动化和任务执行，使得用户不再直接与传统网站交互，而是通过 AI 来“控制”这些服务。</p>\n<p><img src=\"/blog/./images/openai-operator/principle.png\" alt=\"工作原理\"></p>\n<p>很遗憾的是笔者还没有机会亲自体验过这个功能,只能通过OpenAI的发布会和官网了解到这个功能的基本情况。别问为啥，问就是没钱💰💰💰。目前Operator仅对美国的Pro用户开放。</p>\n<p><img src=\"/blog/./images/openai-operator/price.png\" alt=\"价格\"></p>\n<h1 id=\"OpenAI-Operator-的核心功能\"><a href=\"#OpenAI-Operator-的核心功能\" class=\"headerlink\" title=\"OpenAI Operator 的核心功能\"></a>OpenAI Operator 的核心功能</h1><h2 id=\"自动化网络操作\"><a href=\"#自动化网络操作\" class=\"headerlink\" title=\"自动化网络操作\"></a>自动化网络操作</h2><p>Operator 的核心能力是自动化执行网络操作，它不仅能够访问网站，还能在网站内执行操作。举例来说，AI 可以直接为你完成机票预定、酒店查询，甚至购物购买任务。这一过程极大简化了用户体验，用户无需再通过多个网页和平台来获取所需信息，AI 自动完成所有中间步骤。</p>\n<h2 id=\"无缝集成与跨平台兼容性\"><a href=\"#无缝集成与跨平台兼容性\" class=\"headerlink\" title=\"无缝集成与跨平台兼容性\"></a>无缝集成与跨平台兼容性</h2><p>不同于传统的互联网操作，Operator 具有跨平台的兼容性，它可以同时与多个应用程序和网站进行交互。无论是旅游网站、购物平台，还是社交媒体，AI 都能无缝对接，执行任务而不需要人工干预。</p>\n<h2 id=\"解放用户与中间人\"><a href=\"#解放用户与中间人\" class=\"headerlink\" title=\"解放用户与中间人\"></a>解放用户与中间人</h2><p>通过 OpenAI Operator，传统的中介角色（如 Google、TripAdvisor、淘宝等平台）正面临着前所未有的挑战。这些平台通常依赖广告、佣金和中介收入来维持运营，但随着 AI 直接完成用户请求，这些收入模式将变得不再可持续。</p>\n<p>例如，过去你可能需要通过 Google 搜索找到 TripAdvisor，浏览旅游产品，再通过第三方网站完成预定。现在，AI 会自动为你完成这一切，无需依赖这些传统平台。这个变化预示着未来我们可能进入一个没有中介、直接由 AI 提供服务的世界。</p>\n<p><img src=\"/blog/./images/openai-operator/future.jpg\" alt=\"价格\"></p>\n<h2 id=\"未来的商业模式与开放数据层\"><a href=\"#未来的商业模式与开放数据层\" class=\"headerlink\" title=\"未来的商业模式与开放数据层\"></a>未来的商业模式与开放数据层</h2><p>随着 Operator 的普及，传统的互联网公司将面临巨大的变革。越来越多的服务商将不再直接面对消费者，而是将他们的数据和服务卖给 AI 公司，或通过 API 接口让 AI 可以付费访问。正如某些评论所言，未来的互联网将更多地面向 AI，而不是最终用户。</p>\n<p>这种转变可能导致一些平台转向数据驱动模式，提供结构化数据而不是传统的内容展示。对于像 TripAdvisor、Yelp 这样的服务提供商来说，它们将不得不重新思考如何在这个新生态中生存下去，可能的方式是通过与 AI 的合作，直接向 AI 公司销售结构化数据。</p>\n<h2 id=\"从“搜索”到“请求”\"><a href=\"#从“搜索”到“请求”\" class=\"headerlink\" title=\"从“搜索”到“请求”\"></a>从“搜索”到“请求”</h2><p>以往，我们通过搜索引擎如 Google 寻找信息。现在，AI 能够主动“请求”信息并处理这些请求，完全改变了用户交互的方式。Operator 将逐步替代传统的搜索引擎和网站浏览，用户只需告诉 AI 他们的需求，AI 就能自动完成信息获取和任务执行。这种转变可能会加速互联网的“衰退”，特别是对于那些依赖广告和展示内容的传统网站。</p>\n<p><img src=\"/blog/./images/openai-operator/decline.jpg\" alt=\"衰落\"></p>\n<h1 id=\"OpenAI-Operator-的潜在应用场景\"><a href=\"#OpenAI-Operator-的潜在应用场景\" class=\"headerlink\" title=\"OpenAI Operator 的潜在应用场景\"></a>OpenAI Operator 的潜在应用场景</h1><h2 id=\"智能个人助手\"><a href=\"#智能个人助手\" class=\"headerlink\" title=\"智能个人助手\"></a>智能个人助手</h2><p>随着 Operator 的发展，AI 不再仅仅是一个问答助手，它将成为一个全方位的个人助手，能够自动化处理日常任务、购物、工作安排等。例如，AI 可以根据你的需求自动预定旅行、购买商品，甚至向服务商发送请求。</p>\n<h2 id=\"智能客户服务\"><a href=\"#智能客户服务\" class=\"headerlink\" title=\"智能客户服务\"></a>智能客户服务</h2><p>AI 可以集成到客户服务中，自动执行订单查询、退换货、技术支持等操作，减少人工干预，提高服务效率。Operator 让客户服务变得更加高效和个性化，用户无需再访问多个平台，AI 可以直接在后台操作系统和服务，提供即时响应。</p>\n<h2 id=\"信息和数据自动化获取\"><a href=\"#信息和数据自动化获取\" class=\"headerlink\" title=\"信息和数据自动化获取\"></a>信息和数据自动化获取</h2><p>AI 能够快速从各种信息源（如新闻网站、研究数据库、产品评价平台）中自动提取并汇总信息。这对于需要高效获取行业数据或市场情报的用户尤为重要，AI 可以代替人工收集和筛选信息，从而节省大量时间和精力。</p>\n<h1 id=\"互联网的未来：从开放到结构化\"><a href=\"#互联网的未来：从开放到结构化\" class=\"headerlink\" title=\"互联网的未来：从开放到结构化\"></a>互联网的未来：从开放到结构化</h1><p>如同一些行业观察者所预测的那样，随着 AI 技术的发展，互联网将不再是一个开放的、面向用户的内容平台，而会演变为一个服务于 AI 的结构化数据层。在这个新环境中，传统的互联网公司将不再直接面向用户，而是通过 API 向 AI 提供数据和服务，甚至可能要求用户通过身份认证和授权来获取服务。</p>\n<p>这意味着，我们很可能会进入一个没有“搜索”或“浏览”的新时代，所有信息获取和服务操作都通过 AI 完成，传统互联网平台的地位将逐步下降。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>OpenAI Operator 为 AI 赋予了前所未有的能力，能够主动操作数字世界中的各类系统和平台。这不仅重新定义了 AI 与数字世界的交互方式，也引发了对于互联网未来发展的深刻反思。随着 AI 的普及，传统互联网商业模式面临着巨大的挑战，开放网络的消亡可能是不可避免的趋势。</p>\n<p>尽管如此，OpenAI Operator 为我们带来了一个充满可能性的未来，AI 将变得更加智能、主动和个性化，彻底改变我们与数字世界互动的方式。</p>\n"},{"title":"组织发展致命杀手：内耗","date":"2024-03-28T09:49:50.000Z","_content":"\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/organization-internal-loss.md","raw":"---\ntitle: 组织发展致命杀手：内耗\ndate: 2024-03-28 17:49:50\ntags: 组织 内耗\n---\n\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"organization-internal-loss","published":1,"updated":"2024-04-26T03:06:35.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawk0010rkp1alf8adf8","content":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/blog/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/blog/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/blog/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/blog/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"并发不是并行！","date":"2025-01-07T08:05:45.000Z","_content":"\n\n在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。\n\n本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。\n\n# 什么是并发（Concurrency）？\n并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。\n\n## 并发的特点：\n\n- 任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。\n- 资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。\n- 通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。\n\n## 并发的例子：\n想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。\n\n```C#\nclass ConcurrencyExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并发示例：\");\n\n        // 创建两个任务，并行执行\n        var task1 = Task.Run(() => DoWork(\"任务 1\"));\n        var task2 = Task.Run(() => DoWork(\"任务 2\"));\n\n        // 等待任务完成\n        Task.WhenAll(task1, task2).Wait();\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(string taskName)\n    {\n        Console.WriteLine($\"{taskName} 开始\");\n\n        // 模拟I/O密集型操作，如网络请求或文件读写\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"{taskName} 正在处理: {i + 1}\");\n            Thread.Sleep(1000);  // 模拟I/O操作\n        }\n\n        Console.WriteLine($\"{taskName} 完成\");\n    }\n}\n```\n\n![并发示例](./images/parallelism/concurrency-result.png)\n\n# 什么是并行（Parallelism）？\n并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。\n\n## 并行的特点：\n- 任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。\n- 需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。\n- 任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。\n\n## 并行的例子：\n以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。\n\n```C#\nclass ParallelismExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并行示例：\");\n\n        // 使用 Parallel.For 并行执行多个任务\n        Parallel.For(0, 5, i => {\n            DoWork(i);\n        });\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(int taskId)\n    {\n        Console.WriteLine($\"任务 {taskId} 开始\");\n\n        // 模拟计算密集型操作\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"任务 {taskId} 正在处理: {i + 1}\");\n        }\n\n        Console.WriteLine($\"任务 {taskId} 完成\");\n    }\n}\n```\n![并发示例](./images/parallelism/parallelism-result.png)\n\n# 并发和并行的区别\n尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：\n\n__并发__\n![并发](./images/parallelism/concurrency-vs-parallelism-1.png)\n__并行__\n![并行](./images/parallelism/concurrency-vs-parallelism-2.png)\n\n\n\n|特性|\t并发（Concurrency）|\t并行（Parallelism）|\n|--|--|--|\n|定义|\t多个任务在同一时间段内交替执行，可能并不同时发生|\t多个任务在同一时刻同时执行|\n|任务执行 |\t任务交替执行，可能共享资源|\t任务同时执行，通常有多个处理单元|\n|资源需求|\t单核或多核都可以实现|\t需要多核或多个计算单元支持|\n|适用场景|\tI/O密集型任务，如文件读取、网络请求等|\t计算密集型任务，如图像处理、科学计算等|\n|实现方式|\t通过时间分片调度任务|\t通过多核或多计算节点同时执行多个任务|\n\n\n# 并发与并行的结合应用\n在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。\n\n例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。\n\n![并发与并行结合](./images/parallelism/concurrency-vs-parallelism-3.png)\n\n# 在编程中的并发与并行\n在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：\n\n## 并发编程：\n- 线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。\n- 事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。\n- 协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。\n\n## 并行编程：\n- 多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。\n- 分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。\n\n# 并发与并行的实际应用\n## 并发应用：\n- Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I/O密集型的场景下，能够有效提高吞吐量。\n- 聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。\n\n## 并行应用：\n- 科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。\n- 大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。\n\n# 总结\n- 并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I/O密集型应用。\n- 并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。\n- 在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。\n\n无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。\n\n----\n\n欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。","source":"_posts/parallelism.md","raw":"---\ntitle: 并发不是并行！\ndate: 2025-01-07 16:05:45\ntags:\n---\n\n\n在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。\n\n本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。\n\n# 什么是并发（Concurrency）？\n并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。\n\n## 并发的特点：\n\n- 任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。\n- 资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。\n- 通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。\n\n## 并发的例子：\n想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。\n\n```C#\nclass ConcurrencyExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并发示例：\");\n\n        // 创建两个任务，并行执行\n        var task1 = Task.Run(() => DoWork(\"任务 1\"));\n        var task2 = Task.Run(() => DoWork(\"任务 2\"));\n\n        // 等待任务完成\n        Task.WhenAll(task1, task2).Wait();\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(string taskName)\n    {\n        Console.WriteLine($\"{taskName} 开始\");\n\n        // 模拟I/O密集型操作，如网络请求或文件读写\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"{taskName} 正在处理: {i + 1}\");\n            Thread.Sleep(1000);  // 模拟I/O操作\n        }\n\n        Console.WriteLine($\"{taskName} 完成\");\n    }\n}\n```\n\n![并发示例](./images/parallelism/concurrency-result.png)\n\n# 什么是并行（Parallelism）？\n并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。\n\n## 并行的特点：\n- 任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。\n- 需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。\n- 任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。\n\n## 并行的例子：\n以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。\n\n```C#\nclass ParallelismExample\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"并行示例：\");\n\n        // 使用 Parallel.For 并行执行多个任务\n        Parallel.For(0, 5, i => {\n            DoWork(i);\n        });\n\n        Console.WriteLine(\"所有任务完成\");\n    }\n\n    static void DoWork(int taskId)\n    {\n        Console.WriteLine($\"任务 {taskId} 开始\");\n\n        // 模拟计算密集型操作\n        for( int i = 0; i < 5; i++ ) {\n            Console.WriteLine($\"任务 {taskId} 正在处理: {i + 1}\");\n        }\n\n        Console.WriteLine($\"任务 {taskId} 完成\");\n    }\n}\n```\n![并发示例](./images/parallelism/parallelism-result.png)\n\n# 并发和并行的区别\n尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：\n\n__并发__\n![并发](./images/parallelism/concurrency-vs-parallelism-1.png)\n__并行__\n![并行](./images/parallelism/concurrency-vs-parallelism-2.png)\n\n\n\n|特性|\t并发（Concurrency）|\t并行（Parallelism）|\n|--|--|--|\n|定义|\t多个任务在同一时间段内交替执行，可能并不同时发生|\t多个任务在同一时刻同时执行|\n|任务执行 |\t任务交替执行，可能共享资源|\t任务同时执行，通常有多个处理单元|\n|资源需求|\t单核或多核都可以实现|\t需要多核或多个计算单元支持|\n|适用场景|\tI/O密集型任务，如文件读取、网络请求等|\t计算密集型任务，如图像处理、科学计算等|\n|实现方式|\t通过时间分片调度任务|\t通过多核或多计算节点同时执行多个任务|\n\n\n# 并发与并行的结合应用\n在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。\n\n例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。\n\n![并发与并行结合](./images/parallelism/concurrency-vs-parallelism-3.png)\n\n# 在编程中的并发与并行\n在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：\n\n## 并发编程：\n- 线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。\n- 事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。\n- 协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。\n\n## 并行编程：\n- 多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。\n- 分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。\n\n# 并发与并行的实际应用\n## 并发应用：\n- Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I/O密集型的场景下，能够有效提高吞吐量。\n- 聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。\n\n## 并行应用：\n- 科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。\n- 大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。\n\n# 总结\n- 并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I/O密集型应用。\n- 并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。\n- 在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。\n\n无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。\n\n----\n\n欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。","slug":"parallelism","published":1,"updated":"2025-01-08T06:21:07.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawk0011rkp13k6e1kf0","content":"<p>在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。</p>\n<p>本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。</p>\n<h1 id=\"什么是并发（Concurrency）？\"><a href=\"#什么是并发（Concurrency）？\" class=\"headerlink\" title=\"什么是并发（Concurrency）？\"></a>什么是并发（Concurrency）？</h1><p>并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。</p>\n<h2 id=\"并发的特点：\"><a href=\"#并发的特点：\" class=\"headerlink\" title=\"并发的特点：\"></a>并发的特点：</h2><ul>\n<li>任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。</li>\n<li>资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。</li>\n<li>通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。</li>\n</ul>\n<h2 id=\"并发的例子：\"><a href=\"#并发的例子：\" class=\"headerlink\" title=\"并发的例子：\"></a>并发的例子：</h2><p>想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrencyExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并发示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建两个任务，并行执行</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> task1 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 1&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">var</span> task2 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待任务完成</span></span><br><span class=\"line\">        Task.WhenAll(task1, task2).Wait();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">string</span> taskName</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟I/O密集型操作，如网络请求或文件读写</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">            Thread.Sleep(<span class=\"number\">1000</span>);  <span class=\"comment\">// 模拟I/O操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/parallelism/concurrency-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"什么是并行（Parallelism）？\"><a href=\"#什么是并行（Parallelism）？\" class=\"headerlink\" title=\"什么是并行（Parallelism）？\"></a>什么是并行（Parallelism）？</h1><p>并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。</p>\n<h2 id=\"并行的特点：\"><a href=\"#并行的特点：\" class=\"headerlink\" title=\"并行的特点：\"></a>并行的特点：</h2><ul>\n<li>任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。</li>\n<li>需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。</li>\n<li>任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。</li>\n</ul>\n<h2 id=\"并行的例子：\"><a href=\"#并行的例子：\" class=\"headerlink\" title=\"并行的例子：\"></a>并行的例子：</h2><p>以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ParallelismExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并行示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 Parallel.For 并行执行多个任务</span></span><br><span class=\"line\">        Parallel.For(<span class=\"number\">0</span>, <span class=\"number\">5</span>, i =&gt; &#123;</span><br><span class=\"line\">            DoWork(i);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">int</span> taskId</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟计算密集型操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/parallelism/parallelism-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"并发和并行的区别\"><a href=\"#并发和并行的区别\" class=\"headerlink\" title=\"并发和并行的区别\"></a>并发和并行的区别</h1><p>尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：</p>\n<p><strong>并发</strong><br><img src=\"/blog/./images/parallelism/concurrency-vs-parallelism-1.png\" alt=\"并发\"><br><strong>并行</strong><br><img src=\"/blog/./images/parallelism/concurrency-vs-parallelism-2.png\" alt=\"并行\"></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>并发（Concurrency）</th>\n<th>并行（Parallelism）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义</td>\n<td>多个任务在同一时间段内交替执行，可能并不同时发生</td>\n<td>多个任务在同一时刻同时执行</td>\n</tr>\n<tr>\n<td>任务执行</td>\n<td>任务交替执行，可能共享资源</td>\n<td>任务同时执行，通常有多个处理单元</td>\n</tr>\n<tr>\n<td>资源需求</td>\n<td>单核或多核都可以实现</td>\n<td>需要多核或多个计算单元支持</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>I&#x2F;O密集型任务，如文件读取、网络请求等</td>\n<td>计算密集型任务，如图像处理、科学计算等</td>\n</tr>\n<tr>\n<td>实现方式</td>\n<td>通过时间分片调度任务</td>\n<td>通过多核或多计算节点同时执行多个任务</td>\n</tr>\n</tbody></table>\n<h1 id=\"并发与并行的结合应用\"><a href=\"#并发与并行的结合应用\" class=\"headerlink\" title=\"并发与并行的结合应用\"></a>并发与并行的结合应用</h1><p>在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。</p>\n<p>例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。</p>\n<p><img src=\"/blog/./images/parallelism/concurrency-vs-parallelism-3.png\" alt=\"并发与并行结合\"></p>\n<h1 id=\"在编程中的并发与并行\"><a href=\"#在编程中的并发与并行\" class=\"headerlink\" title=\"在编程中的并发与并行\"></a>在编程中的并发与并行</h1><p>在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：</p>\n<h2 id=\"并发编程：\"><a href=\"#并发编程：\" class=\"headerlink\" title=\"并发编程：\"></a>并发编程：</h2><ul>\n<li>线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。</li>\n<li>事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。</li>\n<li>协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。</li>\n</ul>\n<h2 id=\"并行编程：\"><a href=\"#并行编程：\" class=\"headerlink\" title=\"并行编程：\"></a>并行编程：</h2><ul>\n<li>多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。</li>\n<li>分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。</li>\n</ul>\n<h1 id=\"并发与并行的实际应用\"><a href=\"#并发与并行的实际应用\" class=\"headerlink\" title=\"并发与并行的实际应用\"></a>并发与并行的实际应用</h1><h2 id=\"并发应用：\"><a href=\"#并发应用：\" class=\"headerlink\" title=\"并发应用：\"></a>并发应用：</h2><ul>\n<li>Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I&#x2F;O密集型的场景下，能够有效提高吞吐量。</li>\n<li>聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。</li>\n</ul>\n<h2 id=\"并行应用：\"><a href=\"#并行应用：\" class=\"headerlink\" title=\"并行应用：\"></a>并行应用：</h2><ul>\n<li>科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。</li>\n<li>大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I&#x2F;O密集型应用。</li>\n<li>并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。</li>\n<li>在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。</li>\n</ul>\n<p>无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。</p>\n<hr>\n<p>欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在现代计算机科学中，我们经常听到“并发”和“并行”这两个术语。虽然它们在某些场景中可能显得相似，但本质上有很大的区别。理解这两个概念不仅有助于我们深入掌握计算机的工作原理，也能帮助我们在实际开发中作出更好的设计决策。</p>\n<p>本文将深入探讨并发和并行的定义、区别以及它们在实际应用中的不同场景。</p>\n<h1 id=\"什么是并发（Concurrency）？\"><a href=\"#什么是并发（Concurrency）？\" class=\"headerlink\" title=\"什么是并发（Concurrency）？\"></a>什么是并发（Concurrency）？</h1><p>并发是指在同一时间段内处理多个任务的能力。并发并不要求任务必须同时进行，而是任务能够在某个时间段内交替执行，系统能够有效地管理多个任务，让它们看起来像是并行执行。</p>\n<h2 id=\"并发的特点：\"><a href=\"#并发的特点：\" class=\"headerlink\" title=\"并发的特点：\"></a>并发的特点：</h2><ul>\n<li>任务交替执行：在并发的系统中，多个任务可能会交替执行，但并不一定是同时发生的。</li>\n<li>资源共享：并发任务通常共享有限的计算资源，任务之间的执行顺序不一定是固定的。</li>\n<li>通常发生在单核处理器上：在单核处理器上，通过时间分片的方式来切换任务，使得每个任务在一定的时间片内得到执行，从而给人一种任务同时进行的感觉。</li>\n</ul>\n<h2 id=\"并发的例子：\"><a href=\"#并发的例子：\" class=\"headerlink\" title=\"并发的例子：\"></a>并发的例子：</h2><p>想象一下你正在使用一个多任务的操作系统，你可能在写文档、回复邮件、浏览网页以及播放音乐。操作系统会将CPU时间分配给这些任务，每个任务在不同的时间片段内执行，看起来它们在同时进行，实际上它们是交替进行的。这就是并发。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrencyExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并发示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建两个任务，并行执行</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> task1 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 1&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">var</span> task2 = Task.Run(() =&gt; DoWork(<span class=\"string\">&quot;任务 2&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待任务完成</span></span><br><span class=\"line\">        Task.WhenAll(task1, task2).Wait();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">string</span> taskName</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟I/O密集型操作，如网络请求或文件读写</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">            Thread.Sleep(<span class=\"number\">1000</span>);  <span class=\"comment\">// 模拟I/O操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;<span class=\"subst\">&#123;taskName&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/parallelism/concurrency-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"什么是并行（Parallelism）？\"><a href=\"#什么是并行（Parallelism）？\" class=\"headerlink\" title=\"什么是并行（Parallelism）？\"></a>什么是并行（Parallelism）？</h1><p>并行是指多个任务在同一时刻并行执行。为了实现并行，通常需要多核处理器或者多个处理单元。这些任务被分配到不同的处理器核心上，能够真正的在同一时刻同时运行。</p>\n<h2 id=\"并行的特点：\"><a href=\"#并行的特点：\" class=\"headerlink\" title=\"并行的特点：\"></a>并行的特点：</h2><ul>\n<li>任务同时执行：多个任务在同一时刻并行进行，不存在时间片的切换。</li>\n<li>需要多个处理单元：并行执行通常要求计算资源（如多个CPU核心、多个计算机节点等）支持。</li>\n<li>任务独立性：任务之间通常是相互独立的，能够并行执行而不会互相干扰。</li>\n</ul>\n<h2 id=\"并行的例子：\"><a href=\"#并行的例子：\" class=\"headerlink\" title=\"并行的例子：\"></a>并行的例子：</h2><p>以图像处理为例，假设你有一张大图片需要进行处理（例如滤镜、色彩调整等）。如果你的计算机有多个处理器核心，你可以将这张图片分成多个小块，每个核心同时处理不同的图像块，最终合并结果。这样，整个图像处理过程就实现了并行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ParallelismExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;并行示例：&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 使用 Parallel.For 并行执行多个任务</span></span><br><span class=\"line\">        Parallel.For(<span class=\"number\">0</span>, <span class=\"number\">5</span>, i =&gt; &#123;</span><br><span class=\"line\">            DoWork(i);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;所有任务完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">DoWork</span>(<span class=\"params\"><span class=\"built_in\">int</span> taskId</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 开始&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟计算密集型操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ ) &#123;</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 正在处理: <span class=\"subst\">&#123;i + <span class=\"number\">1</span>&#125;</span>&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;任务 <span class=\"subst\">&#123;taskId&#125;</span> 完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/parallelism/parallelism-result.png\" alt=\"并发示例\"></p>\n<h1 id=\"并发和并行的区别\"><a href=\"#并发和并行的区别\" class=\"headerlink\" title=\"并发和并行的区别\"></a>并发和并行的区别</h1><p>尽管并发和并行都涉及多个任务的执行，但它们的实现方式和应用场景有很大的区别。可以通过下面两张图来对比并发和并行的区别：</p>\n<p><strong>并发</strong><br><img src=\"/blog/./images/parallelism/concurrency-vs-parallelism-1.png\" alt=\"并发\"><br><strong>并行</strong><br><img src=\"/blog/./images/parallelism/concurrency-vs-parallelism-2.png\" alt=\"并行\"></p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>并发（Concurrency）</th>\n<th>并行（Parallelism）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>定义</td>\n<td>多个任务在同一时间段内交替执行，可能并不同时发生</td>\n<td>多个任务在同一时刻同时执行</td>\n</tr>\n<tr>\n<td>任务执行</td>\n<td>任务交替执行，可能共享资源</td>\n<td>任务同时执行，通常有多个处理单元</td>\n</tr>\n<tr>\n<td>资源需求</td>\n<td>单核或多核都可以实现</td>\n<td>需要多核或多个计算单元支持</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>I&#x2F;O密集型任务，如文件读取、网络请求等</td>\n<td>计算密集型任务，如图像处理、科学计算等</td>\n</tr>\n<tr>\n<td>实现方式</td>\n<td>通过时间分片调度任务</td>\n<td>通过多核或多计算节点同时执行多个任务</td>\n</tr>\n</tbody></table>\n<h1 id=\"并发与并行的结合应用\"><a href=\"#并发与并行的结合应用\" class=\"headerlink\" title=\"并发与并行的结合应用\"></a>并发与并行的结合应用</h1><p>在现代计算机系统中，并发和并行往往是结合使用的。操作系统可以通过并发来管理多个任务的调度，而硬件资源则可以通过并行来加速任务的执行。</p>\n<p>例如，在现代的Web服务器中，可能会有多个用户请求同时到达，操作系统通过并发管理多个请求的处理。对于每个请求，服务器可能会在多个处理器核心上并行执行数据处理任务，以加速响应速度。</p>\n<p><img src=\"/blog/./images/parallelism/concurrency-vs-parallelism-3.png\" alt=\"并发与并行结合\"></p>\n<h1 id=\"在编程中的并发与并行\"><a href=\"#在编程中的并发与并行\" class=\"headerlink\" title=\"在编程中的并发与并行\"></a>在编程中的并发与并行</h1><p>在编程中，处理并发和并行常常依赖于不同的技术和框架。下面列举几种常见的实现方式：</p>\n<h2 id=\"并发编程：\"><a href=\"#并发编程：\" class=\"headerlink\" title=\"并发编程：\"></a>并发编程：</h2><ul>\n<li>线程（Thread）：操作系统通过多线程实现并发，多个线程可以并发执行任务。</li>\n<li>事件驱动（Event-driven）：例如Node.js就是通过单线程事件循环的方式处理并发请求，不需要多个线程即可实现高效的并发。</li>\n<li>协程（Coroutine）：协程是一种比线程更轻量级的并发模型，多个协程可以在单线程中交替执行。</li>\n</ul>\n<h2 id=\"并行编程：\"><a href=\"#并行编程：\" class=\"headerlink\" title=\"并行编程：\"></a>并行编程：</h2><ul>\n<li>多线程：在多核系统中，程序可以使用多个线程来并行执行计算任务。</li>\n<li>分布式计算：如MapReduce、Spark等，通过多个计算节点来处理大规模的数据集，实现并行计算。</li>\n</ul>\n<h1 id=\"并发与并行的实际应用\"><a href=\"#并发与并行的实际应用\" class=\"headerlink\" title=\"并发与并行的实际应用\"></a>并发与并行的实际应用</h1><h2 id=\"并发应用：\"><a href=\"#并发应用：\" class=\"headerlink\" title=\"并发应用：\"></a>并发应用：</h2><ul>\n<li>Web服务器：例如Nginx和Node.js都利用并发来处理大量的并发请求，尤其是在I&#x2F;O密集型的场景下，能够有效提高吞吐量。</li>\n<li>聊天应用：比如即时通讯软件，每个用户的消息处理都是并发的，操作系统会根据空闲的CPU资源调度不同的消息处理线程。</li>\n</ul>\n<h2 id=\"并行应用：\"><a href=\"#并行应用：\" class=\"headerlink\" title=\"并行应用：\"></a>并行应用：</h2><ul>\n<li>科学计算：如天气预测、物理模拟等计算密集型任务可以通过并行计算加速处理过程。</li>\n<li>大数据分析：通过分布式计算框架如Hadoop、Spark等进行数据处理，能够在多个节点上并行处理海量数据。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>并发是处理多个任务的能力，任务交替进行，不一定在同一时刻执行，适用于I&#x2F;O密集型应用。</li>\n<li>并行是同时处理多个任务的能力，任务在同一时刻执行，适用于计算密集型应用。</li>\n<li>在实际开发中，理解并发与并行的区别有助于我们选择合适的工具和技术，设计出更高效、可扩展的系统。</li>\n</ul>\n<p>无论是在操作系统设计、Web开发还是高性能计算领域，并发和并行都起着至关重要的作用。希望本文能够帮助大家清晰地理解这两个概念，并能够在实际开发中灵活应用。</p>\n<hr>\n<p>欢迎在评论区分享您的见解和经验，讨论如何在实际项目中有效利用并发和并行。</p>\n"},{"title":"代理服务解析：正向代理、反向代理和透明代理","date":"2024-06-20T02:06:56.000Z","_content":"\n在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。\n\n然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。\n\n# 什么是代理服务器？\n代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。\n\n# 正向代理\n## 定义\n正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。\n\n## 工作原理\n![正向代理](/images/proxy/forward-proxy.png)\n1. 客户端向代理服务器发送请求。\n2. 代理服务器向目标服务器转发请求。\n3. 目标服务器响应代理服务器。\n4. 代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。\n2. 缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。\n3. 匿名性：隐藏客户端的真实IP地址，保护隐私。\n\n## 示例代码\n```\n# 简单的正向代理示例（Python）\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport requests\n\nclass Proxy(BaseHTTPRequestHandler):\n    def do_GET(self):\n        url = self.path[1:]\n        response = requests.get(url)\n        self.send_response(response.status_code)\n        self.send_header('Content-type', response.headers['Content-Type'])\n        self.end_headers()\n        self.wfile.write(response.content)\n\nif __name__ == \"__main__\":\n    server = HTTPServer(('localhost', 8080), Proxy)\n    print(\"Starting proxy server on port 8080\")\n    server.serve_forever()\n\n```\n\n# 反向代理\n## 定义\n反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。\n\n尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。\n反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。\n\n## 反向代理和正向代理的相似之处\n正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。\n正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。\n正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。\n也可以使用相同的软件来配置正向和反向代理。\n\n例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。\n\n## 工作原理\n![反向代理](/images/proxy/reverse-proxy.png)\n1. 客户端向反向代理服务器发送请求。\n2. 反向代理服务器向内部服务器转发请求。\n3. 内部服务器响应反向代理服务器。\n4. 反向代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。\n2. 安全性：隐藏内部服务器的IP地址，增加安全性。\n3. SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。\n\n## 示例\n```\n# Nginx 反向代理配置示例\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend_server;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n\n# 透明代理\n## 定义\n透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。\n\n透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。\n\n透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。\n\n## 工作原理\n![反向代理](/images/proxy/transparent-proxy.png)\n1. 客户端向目标服务器发送请求。\n2. 透明代理截获并转发请求。\n3. 目标服务器响应请求。\n4. 透明代理截获并转发响应。\n\n## 应用场景\n1. 监控和过滤：用于网络监控、过滤和记录网络流量。\n2. 缓存：透明代理缓存常用内容，提高访问速度。\n3. 访问控制：控制对特定网站或服务的访问。\n\n## 示例代码\n```shell\n# 使用iptables设置透明代理\n# 假设代理服务器IP为192.168.1.1，目标端口为8080\niptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080\niptables -t nat -A POSTROUTING -j MASQUERADE\n```\n\n# 总结\n代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。","source":"_posts/proxy.md","raw":"---\ntitle: 代理服务解析：正向代理、反向代理和透明代理\ndate: 2024-06-20 10:06:56\ntags:\n---\n\n在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。\n\n然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。\n\n# 什么是代理服务器？\n代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。\n\n# 正向代理\n## 定义\n正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。\n\n## 工作原理\n![正向代理](/images/proxy/forward-proxy.png)\n1. 客户端向代理服务器发送请求。\n2. 代理服务器向目标服务器转发请求。\n3. 目标服务器响应代理服务器。\n4. 代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。\n2. 缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。\n3. 匿名性：隐藏客户端的真实IP地址，保护隐私。\n\n## 示例代码\n```\n# 简单的正向代理示例（Python）\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport requests\n\nclass Proxy(BaseHTTPRequestHandler):\n    def do_GET(self):\n        url = self.path[1:]\n        response = requests.get(url)\n        self.send_response(response.status_code)\n        self.send_header('Content-type', response.headers['Content-Type'])\n        self.end_headers()\n        self.wfile.write(response.content)\n\nif __name__ == \"__main__\":\n    server = HTTPServer(('localhost', 8080), Proxy)\n    print(\"Starting proxy server on port 8080\")\n    server.serve_forever()\n\n```\n\n# 反向代理\n## 定义\n反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。\n\n尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。\n反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。\n\n## 反向代理和正向代理的相似之处\n正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。\n正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。\n正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。\n也可以使用相同的软件来配置正向和反向代理。\n\n例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。\n\n## 工作原理\n![反向代理](/images/proxy/reverse-proxy.png)\n1. 客户端向反向代理服务器发送请求。\n2. 反向代理服务器向内部服务器转发请求。\n3. 内部服务器响应反向代理服务器。\n4. 反向代理服务器将响应返回给客户端。\n\n## 应用场景\n1. 负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。\n2. 安全性：隐藏内部服务器的IP地址，增加安全性。\n3. SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。\n\n## 示例\n```\n# Nginx 反向代理配置示例\nserver {\n    listen 80;\n    server_name example.com;\n\n    location / {\n        proxy_pass http://backend_server;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n\n# 透明代理\n## 定义\n透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。\n\n透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。\n\n透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。\n\n## 工作原理\n![反向代理](/images/proxy/transparent-proxy.png)\n1. 客户端向目标服务器发送请求。\n2. 透明代理截获并转发请求。\n3. 目标服务器响应请求。\n4. 透明代理截获并转发响应。\n\n## 应用场景\n1. 监控和过滤：用于网络监控、过滤和记录网络流量。\n2. 缓存：透明代理缓存常用内容，提高访问速度。\n3. 访问控制：控制对特定网站或服务的访问。\n\n## 示例代码\n```shell\n# 使用iptables设置透明代理\n# 假设代理服务器IP为192.168.1.1，目标端口为8080\niptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080\niptables -t nat -A POSTROUTING -j MASQUERADE\n```\n\n# 总结\n代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。","slug":"proxy","published":1,"updated":"2024-06-21T01:04:32.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawk0013rkp192hz8r7l","content":"<p>在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。</p>\n<p>然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。</p>\n<h1 id=\"什么是代理服务器？\"><a href=\"#什么是代理服务器？\" class=\"headerlink\" title=\"什么是代理服务器？\"></a>什么是代理服务器？</h1><p>代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。</p>\n<h1 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/blog/images/proxy/forward-proxy.png\" alt=\"正向代理\"></p>\n<ol>\n<li>客户端向代理服务器发送请求。</li>\n<li>代理服务器向目标服务器转发请求。</li>\n<li>目标服务器响应代理服务器。</li>\n<li>代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。</li>\n<li>缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。</li>\n<li>匿名性：隐藏客户端的真实IP地址，保护隐私。</li>\n</ol>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 简单的正向代理示例（Python）</span><br><span class=\"line\">from http.server import BaseHTTPRequestHandler, HTTPServer</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy(BaseHTTPRequestHandler):</span><br><span class=\"line\">    def do_GET(self):</span><br><span class=\"line\">        url = self.path[1:]</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\">        self.send_response(response.status_code)</span><br><span class=\"line\">        self.send_header(&#x27;Content-type&#x27;, response.headers[&#x27;Content-Type&#x27;])</span><br><span class=\"line\">        self.end_headers()</span><br><span class=\"line\">        self.wfile.write(response.content)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    server = HTTPServer((&#x27;localhost&#x27;, 8080), Proxy)</span><br><span class=\"line\">    print(&quot;Starting proxy server on port 8080&quot;)</span><br><span class=\"line\">    server.serve_forever()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。</p>\n<p>尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。<br>反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。</p>\n<h2 id=\"反向代理和正向代理的相似之处\"><a href=\"#反向代理和正向代理的相似之处\" class=\"headerlink\" title=\"反向代理和正向代理的相似之处\"></a>反向代理和正向代理的相似之处</h2><p>正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。<br>正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。<br>正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。<br>也可以使用相同的软件来配置正向和反向代理。</p>\n<p>例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。</p>\n<h2 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/blog/images/proxy/reverse-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向反向代理服务器发送请求。</li>\n<li>反向代理服务器向内部服务器转发请求。</li>\n<li>内部服务器响应反向代理服务器。</li>\n<li>反向代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。</li>\n<li>安全性：隐藏内部服务器的IP地址，增加安全性。</li>\n<li>SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Nginx 反向代理配置示例</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://backend_server;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。</p>\n<p>透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。</p>\n<p>透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。</p>\n<h2 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/blog/images/proxy/transparent-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向目标服务器发送请求。</li>\n<li>透明代理截获并转发请求。</li>\n<li>目标服务器响应请求。</li>\n<li>透明代理截获并转发响应。</li>\n</ol>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>监控和过滤：用于网络监控、过滤和记录网络流量。</li>\n<li>缓存：透明代理缓存常用内容，提高访问速度。</li>\n<li>访问控制：控制对特定网站或服务的访问。</li>\n</ol>\n<h2 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用iptables设置透明代理</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">假设代理服务器IP为192.168.1.1，目标端口为8080</span></span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在现代互联网架构中，代理服务器的使用无处不在。从浏览网页到复杂的企业网络架构，代理服务器在其中扮演了重要角色。许多企业使用代理服务器来路由和保护网络之间的流量。</p>\n<p>然而，人们常常混淆代理服务器与反向代理服务器的区别。在这篇文章中，我们将剖析这几个个概念，并解释管理员如何使用反向代理服务器来轻松实现访问管理控制。本文将深入探讨三种常见的代理类型：正向代理、反向代理和透明代理，并结合实际应用场景进行讲解。</p>\n<h1 id=\"什么是代理服务器？\"><a href=\"#什么是代理服务器？\" class=\"headerlink\" title=\"什么是代理服务器？\"></a>什么是代理服务器？</h1><p>代理服务器（Proxy Server）是一个充当客户端和目标服务器之间中介的服务器。它接收客户端的请求，将其转发到目标服务器，并将响应返回给客户端。这种中介作用可以用于各种目的，包括缓存、匿名性、安全性等。</p>\n<h1 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>正向代理（Forward Proxy）是客户端用来访问其他服务器的代理。客户端向代理服务器发送请求，代理服务器再将请求转发到目标服务器，并将响应返回给客户端。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/blog/images/proxy/forward-proxy.png\" alt=\"正向代理\"></p>\n<ol>\n<li>客户端向代理服务器发送请求。</li>\n<li>代理服务器向目标服务器转发请求。</li>\n<li>目标服务器响应代理服务器。</li>\n<li>代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>访问控制：企业内部网络通过正向代理控制员工访问外部网络的权限。</li>\n<li>缓存：代理服务器缓存常用的网页，减少带宽消耗和加快访问速度。</li>\n<li>匿名性：隐藏客户端的真实IP地址，保护隐私。</li>\n</ol>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 简单的正向代理示例（Python）</span><br><span class=\"line\">from http.server import BaseHTTPRequestHandler, HTTPServer</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">class Proxy(BaseHTTPRequestHandler):</span><br><span class=\"line\">    def do_GET(self):</span><br><span class=\"line\">        url = self.path[1:]</span><br><span class=\"line\">        response = requests.get(url)</span><br><span class=\"line\">        self.send_response(response.status_code)</span><br><span class=\"line\">        self.send_header(&#x27;Content-type&#x27;, response.headers[&#x27;Content-Type&#x27;])</span><br><span class=\"line\">        self.end_headers()</span><br><span class=\"line\">        self.wfile.write(response.content)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    server = HTTPServer((&#x27;localhost&#x27;, 8080), Proxy)</span><br><span class=\"line\">    print(&quot;Starting proxy server on port 8080&quot;)</span><br><span class=\"line\">    server.serve_forever()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>反向代理（Reverse Proxy）是服务器端用来接收客户端请求的代理。客户端的请求首先到达反向代理服务器，再由反向代理服务器将请求转发到内部服务器。</p>\n<p>尽管正向代理和反向代理具有相似的名称，但其目的、实现方式以及在企业架构中扮演的角色却有很大不同。<br>反向代理和正向代理之间的主要区别在于，正向代理使专用网络上隔离的计算机能够连接到公共互联网，而反向代理使互联网上的计算机能够访问专用子网。</p>\n<h2 id=\"反向代理和正向代理的相似之处\"><a href=\"#反向代理和正向代理的相似之处\" class=\"headerlink\" title=\"反向代理和正向代理的相似之处\"></a>反向代理和正向代理的相似之处</h2><p>正向代理和反向代理之间最大的相似之处在于，它们都保护连接到私有网络的设备免受来自互联网和其他外部网络的威胁。<br>正向和反向代理都可以限制通过它们的文件类型和大小，并不允许未经身份验证的用户通过它们发送请求。<br>正向和反向代理都可以执行端口和协议切换，这可以进一步掩盖用于访问隐藏在其背后的资源的访问模式。<br>也可以使用相同的软件来配置正向和反向代理。</p>\n<p>例如，Nginx和Apache Web 服务器在企业架构中都常用作反向代理。这两款软件也可以配置为充当正向代理。</p>\n<h2 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/blog/images/proxy/reverse-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向反向代理服务器发送请求。</li>\n<li>反向代理服务器向内部服务器转发请求。</li>\n<li>内部服务器响应反向代理服务器。</li>\n<li>反向代理服务器将响应返回给客户端。</li>\n</ol>\n<h2 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>负载均衡：将请求分发到多台服务器，减轻单台服务器的压力。</li>\n<li>安全性：隐藏内部服务器的IP地址，增加安全性。</li>\n<li>SSL终止：反向代理服务器处理SSL加密，减轻内部服务器的负担。</li>\n</ol>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Nginx 反向代理配置示例</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://backend_server;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h1><h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>透明代理（Transparent Proxy）是客户端和服务器端都不知道其存在的代理。透明代理在网络层或传输层捕获并转发数据包，而不改变数据包的源地址和目标地址。</p>\n<p>透明代理也称为强制代理、内联代理或拦截代理。与常规代理相反，透明代理不需要对现有设置进行任何更改。它在浏览互联网时在用户不知情的情况下实施。</p>\n<p>透明代理不会操纵请求或更改您的IP。它执行重定向并可用于身份验证。透明代理充当由ISP实现的缓存代理。用户不知道，因为用户看不到处理请求的方式有任何不同。</p>\n<h2 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/blog/images/proxy/transparent-proxy.png\" alt=\"反向代理\"></p>\n<ol>\n<li>客户端向目标服务器发送请求。</li>\n<li>透明代理截获并转发请求。</li>\n<li>目标服务器响应请求。</li>\n<li>透明代理截获并转发响应。</li>\n</ol>\n<h2 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ol>\n<li>监控和过滤：用于网络监控、过滤和记录网络流量。</li>\n<li>缓存：透明代理缓存常用内容，提高访问速度。</li>\n<li>访问控制：控制对特定网站或服务的访问。</li>\n</ol>\n<h2 id=\"示例代码-1\"><a href=\"#示例代码-1\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">使用iptables设置透明代理</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">假设代理服务器IP为192.168.1.1，目标端口为8080</span></span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.1:8080</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>代理服务器在现代网络架构中具有重要作用。正向代理主要用于客户端访问控制和匿名性，反向代理用于服务器端的负载均衡和安全性，而透明代理则在监控和过滤方面有独特的应用。理解并合理使用这三种代理，可以显著提升网络的性能、安全性和管理效率。</p>\n"},{"title":"QUIC:被寄予厚望的下一代互联网传输协议","date":"2024-08-16T08:45:11.000Z","_content":"HTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。\n\n为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP/2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP/3的底层协议。\n\n本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能\n\n\n# 为什么选择QUIC？\n\n传统的HTTP/2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：\n\n1. 连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。\n![三次握手](/images/http/TCP-connection-1.png)<center>(图片来源网络)</center>\n\n2. 队头阻塞（Head-of-Line Blocking）：虽然HTTP/2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。\n\n    >HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。\n\n![队头阻塞](/images/quic/head_of_line_blocking.png)<center>(图片来源网络)</center>\n\nQUIC通过以下方式解决了这些问题：\n\n1. 更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。\n2. 内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。\n3. 多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。\n4. 更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。\n\n# QUIC协议的核心特性\n\n1. UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。\n \n    > 你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。\n\n2. 多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。\n\n3. 连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。\n\n4. 内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。\n\n5. 拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。\n\n# 与TCP的对比\n|特性|\tTCP |\tQUIC |\n|--|--|--|\n|传输层|\t基于TCP|\t基于UDP|\n|多路复用|\t受限于TCP的队头阻塞|\t无队头阻塞的多路复用|\n|加密|\t可选（如TLS）|\t内置TLS 1.3|\n|握手时间|\t至少需要一个RTT|\t最低0-RTT|\n|连接迁移|\t不支持 |\t支持|\n|实时性|\t表现较差，适合可靠传输|\t表现优秀，适合低延迟传输|\n\n# QUIC建立连接\n在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。\n![handshake](/images/quic/handshake.png)\n\n## 简单流程图总结：\n\n1. ClientHello -> 客户端发起握手请求，包含支持的加密算法和其他参数。\n2. ServerHello -> 服务器回应，选择加密算法，并发送证书。\n3. Certificate -> 服务器发送证书并验证身份。\n4. Finished -> 双方确认加密密钥和握手完成。\n5. 开始加密通信 -> 使用QUIC加密数据流开始实际数据传输。\n\n## 为什么需要多次消息交换：\n\n+ 身份验证：客户端需要验证服务器身份，防止中间人攻击。\n+ 密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。\n+ 加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。\n\nQUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。\n\n# 测试连接迁移\n上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。\n\n为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：\n```\nserver {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    listen 443 quic reuseport;\n    listen [::]:443 quic reuseport;\n\n    http2 on;\n    server_name itprohub.site www.itprohub.site;\n\n    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;\n    ssl_certificate_key /etc/ssh/itprohub.site.key;\n\n    # 配置 QUIC 相关的 HTTP/3 选项\n    #add_header Alt-Svc 'h3=\":443\"; ma=86400';  # HTTP/3 ALPN\n\n    ssl_protocols TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    ssl_ciphers \"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256\";  # 适用于 TLS 1.3 的推荐套件\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。\n```\nsudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap\n```\n最后我们用wireshark 分析抓包文件\n\nTCP如下：\n![TCP](/images/quic/tcp.png)\n\nQUIC如下：\n![QUIC](/images/quic/quic.png)\n\n对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。\n\nQUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。\n\n具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。\n\n# QUIC协议的应用场景\n\n1. 视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。\n\n2. 实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。\n\n3. 移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。\n\n4. Web浏览：HTTP/3已经逐步取代HTTP/2成为新的Web传输标准。QUIC作为HTTP/3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。\n\n# QUIC的挑战\n\n尽管QUIC有许多优势，但它也面临一些挑战：\n\n1. UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。\n\n2. 兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。\n\n3. 复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。\n\n\n# 总结\n\n随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP/3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。\n\nQUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。\n\n----\n\n这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！","source":"_posts/quic.md","raw":"---\ntitle: QUIC:被寄予厚望的下一代互联网传输协议\ndate: 2024-08-16 16:45:11\ntags:\n---\nHTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。\n\n为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP/2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP/3的底层协议。\n\n本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能\n\n\n# 为什么选择QUIC？\n\n传统的HTTP/2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：\n\n1. 连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。\n![三次握手](/images/http/TCP-connection-1.png)<center>(图片来源网络)</center>\n\n2. 队头阻塞（Head-of-Line Blocking）：虽然HTTP/2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。\n\n    >HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。\n\n![队头阻塞](/images/quic/head_of_line_blocking.png)<center>(图片来源网络)</center>\n\nQUIC通过以下方式解决了这些问题：\n\n1. 更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。\n2. 内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。\n3. 多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。\n4. 更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。\n\n# QUIC协议的核心特性\n\n1. UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。\n \n    > 你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。\n\n2. 多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。\n\n3. 连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。\n\n4. 内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。\n\n5. 拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。\n\n# 与TCP的对比\n|特性|\tTCP |\tQUIC |\n|--|--|--|\n|传输层|\t基于TCP|\t基于UDP|\n|多路复用|\t受限于TCP的队头阻塞|\t无队头阻塞的多路复用|\n|加密|\t可选（如TLS）|\t内置TLS 1.3|\n|握手时间|\t至少需要一个RTT|\t最低0-RTT|\n|连接迁移|\t不支持 |\t支持|\n|实时性|\t表现较差，适合可靠传输|\t表现优秀，适合低延迟传输|\n\n# QUIC建立连接\n在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。\n![handshake](/images/quic/handshake.png)\n\n## 简单流程图总结：\n\n1. ClientHello -> 客户端发起握手请求，包含支持的加密算法和其他参数。\n2. ServerHello -> 服务器回应，选择加密算法，并发送证书。\n3. Certificate -> 服务器发送证书并验证身份。\n4. Finished -> 双方确认加密密钥和握手完成。\n5. 开始加密通信 -> 使用QUIC加密数据流开始实际数据传输。\n\n## 为什么需要多次消息交换：\n\n+ 身份验证：客户端需要验证服务器身份，防止中间人攻击。\n+ 密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。\n+ 加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。\n\nQUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。\n\n# 测试连接迁移\n上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。\n\n为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：\n```\nserver {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    listen 443 quic reuseport;\n    listen [::]:443 quic reuseport;\n\n    http2 on;\n    server_name itprohub.site www.itprohub.site;\n\n    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;\n    ssl_certificate_key /etc/ssh/itprohub.site.key;\n\n    # 配置 QUIC 相关的 HTTP/3 选项\n    #add_header Alt-Svc 'h3=\":443\"; ma=86400';  # HTTP/3 ALPN\n\n    ssl_protocols TLSv1.3;\n    ssl_prefer_server_ciphers on;\n    ssl_ciphers \"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256\";  # 适用于 TLS 1.3 的推荐套件\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。\n```\nsudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap\n```\n最后我们用wireshark 分析抓包文件\n\nTCP如下：\n![TCP](/images/quic/tcp.png)\n\nQUIC如下：\n![QUIC](/images/quic/quic.png)\n\n对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。\n\nQUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。\n\n具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。\n\n# QUIC协议的应用场景\n\n1. 视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。\n\n2. 实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。\n\n3. 移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。\n\n4. Web浏览：HTTP/3已经逐步取代HTTP/2成为新的Web传输标准。QUIC作为HTTP/3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。\n\n# QUIC的挑战\n\n尽管QUIC有许多优势，但它也面临一些挑战：\n\n1. UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。\n\n2. 兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。\n\n3. 复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。\n\n\n# 总结\n\n随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP/3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。\n\nQUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。\n\n----\n\n这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！","slug":"quic","published":1,"updated":"2024-08-23T02:21:47.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawl0014rkp1cuxk9xuk","content":"<p>HTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。</p>\n<p>为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP&#x2F;2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP&#x2F;3的底层协议。</p>\n<p>本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能</p>\n<h1 id=\"为什么选择QUIC？\"><a href=\"#为什么选择QUIC？\" class=\"headerlink\" title=\"为什么选择QUIC？\"></a>为什么选择QUIC？</h1><p>传统的HTTP&#x2F;2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：</p>\n<ol>\n<li><p>连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。<br><img src=\"/blog/images/http/TCP-connection-1.png\" alt=\"三次握手\"><center>(图片来源网络)</center></p>\n</li>\n<li><p>队头阻塞（Head-of-Line Blocking）：虽然HTTP&#x2F;2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。</p>\n<blockquote>\n<p>HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/blog/images/quic/head_of_line_blocking.png\" alt=\"队头阻塞\"><center>(图片来源网络)</center></p>\n<p>QUIC通过以下方式解决了这些问题：</p>\n<ol>\n<li>更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。</li>\n<li>内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。</li>\n<li>多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。</li>\n<li>更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。</li>\n</ol>\n<h1 id=\"QUIC协议的核心特性\"><a href=\"#QUIC协议的核心特性\" class=\"headerlink\" title=\"QUIC协议的核心特性\"></a>QUIC协议的核心特性</h1><ol>\n<li><p>UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。</p>\n<blockquote>\n<p>你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。</p>\n</blockquote>\n</li>\n<li><p>多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。</p>\n</li>\n<li><p>连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。</p>\n</li>\n<li><p>内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。</p>\n</li>\n<li><p>拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。</p>\n</li>\n</ol>\n<h1 id=\"与TCP的对比\"><a href=\"#与TCP的对比\" class=\"headerlink\" title=\"与TCP的对比\"></a>与TCP的对比</h1><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TCP</th>\n<th>QUIC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输层</td>\n<td>基于TCP</td>\n<td>基于UDP</td>\n</tr>\n<tr>\n<td>多路复用</td>\n<td>受限于TCP的队头阻塞</td>\n<td>无队头阻塞的多路复用</td>\n</tr>\n<tr>\n<td>加密</td>\n<td>可选（如TLS）</td>\n<td>内置TLS 1.3</td>\n</tr>\n<tr>\n<td>握手时间</td>\n<td>至少需要一个RTT</td>\n<td>最低0-RTT</td>\n</tr>\n<tr>\n<td>连接迁移</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>实时性</td>\n<td>表现较差，适合可靠传输</td>\n<td>表现优秀，适合低延迟传输</td>\n</tr>\n</tbody></table>\n<h1 id=\"QUIC建立连接\"><a href=\"#QUIC建立连接\" class=\"headerlink\" title=\"QUIC建立连接\"></a>QUIC建立连接</h1><p>在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。<br><img src=\"/blog/images/quic/handshake.png\" alt=\"handshake\"></p>\n<h2 id=\"简单流程图总结：\"><a href=\"#简单流程图总结：\" class=\"headerlink\" title=\"简单流程图总结：\"></a>简单流程图总结：</h2><ol>\n<li>ClientHello -&gt; 客户端发起握手请求，包含支持的加密算法和其他参数。</li>\n<li>ServerHello -&gt; 服务器回应，选择加密算法，并发送证书。</li>\n<li>Certificate -&gt; 服务器发送证书并验证身份。</li>\n<li>Finished -&gt; 双方确认加密密钥和握手完成。</li>\n<li>开始加密通信 -&gt; 使用QUIC加密数据流开始实际数据传输。</li>\n</ol>\n<h2 id=\"为什么需要多次消息交换：\"><a href=\"#为什么需要多次消息交换：\" class=\"headerlink\" title=\"为什么需要多次消息交换：\"></a>为什么需要多次消息交换：</h2><ul>\n<li>身份验证：客户端需要验证服务器身份，防止中间人攻击。</li>\n<li>密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。</li>\n<li>加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。</li>\n</ul>\n<p>QUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。</p>\n<h1 id=\"测试连接迁移\"><a href=\"#测试连接迁移\" class=\"headerlink\" title=\"测试连接迁移\"></a>测试连接迁移</h1><p>上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。</p>\n<p>为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    listen [::]:443 ssl;</span><br><span class=\"line\">    listen 443 quic reuseport;</span><br><span class=\"line\">    listen [::]:443 quic reuseport;</span><br><span class=\"line\"></span><br><span class=\"line\">    http2 on;</span><br><span class=\"line\">    server_name itprohub.site www.itprohub.site;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;</span><br><span class=\"line\">    ssl_certificate_key /etc/ssh/itprohub.site.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 配置 QUIC 相关的 HTTP/3 选项</span><br><span class=\"line\">    #add_header Alt-Svc &#x27;h3=&quot;:443&quot;; ma=86400&#x27;;  # HTTP/3 ALPN</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1.3;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    ssl_ciphers &quot;TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256&quot;;  # 适用于 TLS 1.3 的推荐套件</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_timeout 10m;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap</span><br></pre></td></tr></table></figure>\n<p>最后我们用wireshark 分析抓包文件</p>\n<p>TCP如下：<br><img src=\"/blog/images/quic/tcp.png\" alt=\"TCP\"></p>\n<p>QUIC如下：<br><img src=\"/blog/images/quic/quic.png\" alt=\"QUIC\"></p>\n<p>对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。</p>\n<p>QUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。</p>\n<p>具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。</p>\n<h1 id=\"QUIC协议的应用场景\"><a href=\"#QUIC协议的应用场景\" class=\"headerlink\" title=\"QUIC协议的应用场景\"></a>QUIC协议的应用场景</h1><ol>\n<li><p>视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。</p>\n</li>\n<li><p>实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。</p>\n</li>\n<li><p>移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。</p>\n</li>\n<li><p>Web浏览：HTTP&#x2F;3已经逐步取代HTTP&#x2F;2成为新的Web传输标准。QUIC作为HTTP&#x2F;3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。</p>\n</li>\n</ol>\n<h1 id=\"QUIC的挑战\"><a href=\"#QUIC的挑战\" class=\"headerlink\" title=\"QUIC的挑战\"></a>QUIC的挑战</h1><p>尽管QUIC有许多优势，但它也面临一些挑战：</p>\n<ol>\n<li><p>UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。</p>\n</li>\n<li><p>兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。</p>\n</li>\n<li><p>复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP&#x2F;3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。</p>\n<p>QUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。</p>\n<hr>\n<p>这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP协议是一种应用协议，它通常运行在TCP之上。但是TCP协议存在一些限制，导致Web应用程序响应速度较慢。</p>\n<p>为了克服 TCP 的缺点，Google开发了一种改变游戏规则的传输协议 QUIC。QUIC（Quick UDP Internet Connections）是一种传输层网络协议，最早由Google在2012年提出，旨在改善HTTP&#x2F;2的性能，特别是在高延迟和不稳定网络条件下。QUIC的主要目标是通过基于UDP的传输来减少连接建立时间、提高传输效率，并改善整体网络性能。随着QUIC的逐渐成熟，IETF（互联网工程任务组）标准化了QUIC，并且它现在成为HTTP&#x2F;3的底层协议。</p>\n<p>本文我们将开始了解 QUIC 将如何取代 TCP。我们将首先介绍 TCP 和 UDP 的一些基本网络概念。然后我们将了解 QUIC 是什么以及它是如何工作的。我们将探讨为什么 QUIC 比 TCP 具有更高的性能</p>\n<h1 id=\"为什么选择QUIC？\"><a href=\"#为什么选择QUIC？\" class=\"headerlink\" title=\"为什么选择QUIC？\"></a>为什么选择QUIC？</h1><p>传统的HTTP&#x2F;2虽然引入了多路复用，但它仍然依赖于TCP（传输控制协议）。TCP在设计时主要考虑可靠性，而不是速度。这导致了几个问题，特别是在移动设备或高延迟网络中：</p>\n<ol>\n<li><p>连接建立慢：TCP的握手过程需要三次往返，特别是在TLS（传输层安全）上使用时，可能还需要额外的握手。<br><img src=\"/blog/images/http/TCP-connection-1.png\" alt=\"三次握手\"><center>(图片来源网络)</center></p>\n</li>\n<li><p>队头阻塞（Head-of-Line Blocking）：虽然HTTP&#x2F;2在应用层引入了多路复用，但底层TCP流仍然是串行的，任何丢包都会导致所有流的传输被阻塞。</p>\n<blockquote>\n<p>HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</p>\n</blockquote>\n</li>\n</ol>\n<p><img src=\"/blog/images/quic/head_of_line_blocking.png\" alt=\"队头阻塞\"><center>(图片来源网络)</center></p>\n<p>QUIC通过以下方式解决了这些问题：</p>\n<ol>\n<li>更快的连接建立：QUIC将握手时间减少到一次往返（0-RTT），在某些情况下甚至可以做到无往返（0-RTT Resumption）。</li>\n<li>内置加密：QUIC协议本身内置了TLS 1.3加密，减少了TLS握手带来的延迟。</li>\n<li>多路复用无队头阻塞：QUIC使用独立的传输流，丢包只会影响特定的流，不会阻塞其他流的数据传输。</li>\n<li>更好的移动性支持：QUIC支持连接迁移，这意味着在切换网络（如从Wi-Fi切换到4G）时，连接可以保持不变，无需重新建立。</li>\n</ol>\n<h1 id=\"QUIC协议的核心特性\"><a href=\"#QUIC协议的核心特性\" class=\"headerlink\" title=\"QUIC协议的核心特性\"></a>QUIC协议的核心特性</h1><ol>\n<li><p>UDP传输：QUIC基于UDP协议，而不是传统的TCP。这使得它能够实现更快的握手过程，并在高延迟网络环境下表现更好。</p>\n<blockquote>\n<p>你可能想知道“由于 QUIC 在 UDP 上工作，数据包会丢失吗？”。答案是不会。QUIC 在 UDP 堆栈之上增加了可靠性。它实现了数据包重传，以防它没有收到必要的数据包。例如：- 如果服务器没有从客户端收到数据包 5，协议将检测到它，服务器将要求客户端重新发送相同的数据包。</p>\n</blockquote>\n</li>\n<li><p>多路复用：QUIC允许多个数据流在一个连接中传输，这意味着即使某个数据流出现丢包，其他流也不会受到影响，减少了队头阻塞问题。</p>\n</li>\n<li><p>连接迁移：QUIC协议允许连接在不同的IP地址和端口之间迁移。这对于移动设备非常有用，例如在Wi-Fi和4G网络之间切换时，连接不会中断。</p>\n</li>\n<li><p>内置加密：QUIC协议默认集成了TLS 1.3，确保数据传输的安全性，同时减少了加密握手所需的时间。</p>\n</li>\n<li><p>拥塞控制：QUIC引入了先进的拥塞控制机制，通过实时调整传输速率来优化网络性能，特别是在网络状况不佳的情况下。</p>\n</li>\n</ol>\n<h1 id=\"与TCP的对比\"><a href=\"#与TCP的对比\" class=\"headerlink\" title=\"与TCP的对比\"></a>与TCP的对比</h1><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>TCP</th>\n<th>QUIC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输层</td>\n<td>基于TCP</td>\n<td>基于UDP</td>\n</tr>\n<tr>\n<td>多路复用</td>\n<td>受限于TCP的队头阻塞</td>\n<td>无队头阻塞的多路复用</td>\n</tr>\n<tr>\n<td>加密</td>\n<td>可选（如TLS）</td>\n<td>内置TLS 1.3</td>\n</tr>\n<tr>\n<td>握手时间</td>\n<td>至少需要一个RTT</td>\n<td>最低0-RTT</td>\n</tr>\n<tr>\n<td>连接迁移</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>实时性</td>\n<td>表现较差，适合可靠传输</td>\n<td>表现优秀，适合低延迟传输</td>\n</tr>\n</tbody></table>\n<h1 id=\"QUIC建立连接\"><a href=\"#QUIC建立连接\" class=\"headerlink\" title=\"QUIC建立连接\"></a>QUIC建立连接</h1><p>在QUIC协议的握手过程中，特别是使用TLS 1.3时，客户端和服务器之间需要多次交换消息来完成连接的建立和加密密钥的协商。<br><img src=\"/blog/images/quic/handshake.png\" alt=\"handshake\"></p>\n<h2 id=\"简单流程图总结：\"><a href=\"#简单流程图总结：\" class=\"headerlink\" title=\"简单流程图总结：\"></a>简单流程图总结：</h2><ol>\n<li>ClientHello -&gt; 客户端发起握手请求，包含支持的加密算法和其他参数。</li>\n<li>ServerHello -&gt; 服务器回应，选择加密算法，并发送证书。</li>\n<li>Certificate -&gt; 服务器发送证书并验证身份。</li>\n<li>Finished -&gt; 双方确认加密密钥和握手完成。</li>\n<li>开始加密通信 -&gt; 使用QUIC加密数据流开始实际数据传输。</li>\n</ol>\n<h2 id=\"为什么需要多次消息交换：\"><a href=\"#为什么需要多次消息交换：\" class=\"headerlink\" title=\"为什么需要多次消息交换：\"></a>为什么需要多次消息交换：</h2><ul>\n<li>身份验证：客户端需要验证服务器身份，防止中间人攻击。</li>\n<li>密钥协商：客户端和服务器需要共同生成会话密钥，用于加密后续的通信。</li>\n<li>加密通道建立：完成握手后，双方通信将完全通过加密通道进行，确保数据安全。</li>\n</ul>\n<p>QUIC利用TLS 1.3的握手过程来保证安全性，并结合了QUIC的低延迟特性，使得连接建立和数据传输更加快速。如果看到多个握手消息，这是因为握手的各个阶段涉及到多个消息的交换和验证。</p>\n<h1 id=\"测试连接迁移\"><a href=\"#测试连接迁移\" class=\"headerlink\" title=\"测试连接迁移\"></a>测试连接迁移</h1><p>上面说到QUIC支持连接迁移，这里我们撸一个简单的例子看看效果。</p>\n<p>为了方便看到具体的效果，这里我们撸了一个站点先后分别使用TCP和UDP。nginx配置如下所示（TCP的配置注释QUIC相关配置即可）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    listen [::]:443 ssl;</span><br><span class=\"line\">    listen 443 quic reuseport;</span><br><span class=\"line\">    listen [::]:443 quic reuseport;</span><br><span class=\"line\"></span><br><span class=\"line\">    http2 on;</span><br><span class=\"line\">    server_name itprohub.site www.itprohub.site;</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_certificate /etc/ssh/itprohub.site_bundle.crt;</span><br><span class=\"line\">    ssl_certificate_key /etc/ssh/itprohub.site.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 配置 QUIC 相关的 HTTP/3 选项</span><br><span class=\"line\">    #add_header Alt-Svc &#x27;h3=&quot;:443&quot;; ma=86400&#x27;;  # HTTP/3 ALPN</span><br><span class=\"line\"></span><br><span class=\"line\">    ssl_protocols TLSv1.3;</span><br><span class=\"line\">    ssl_prefer_server_ciphers on;</span><br><span class=\"line\">    ssl_ciphers &quot;TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256&quot;;  # 适用于 TLS 1.3 的推荐套件</span><br><span class=\"line\">    ssl_session_cache shared:SSL:10m;</span><br><span class=\"line\">    ssl_session_timeout 10m;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后用手机访问该站点，过程中我们切换手机网络，并在服务端进行抓包。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo tcpdump -i eth0 udp port 443 -w quic_capture.pcap</span><br></pre></td></tr></table></figure>\n<p>最后我们用wireshark 分析抓包文件</p>\n<p>TCP如下：<br><img src=\"/blog/images/quic/tcp.png\" alt=\"TCP\"></p>\n<p>QUIC如下：<br><img src=\"/blog/images/quic/quic.png\" alt=\"QUIC\"></p>\n<p>对比两次的结果，我们会发现TCP切换网络之后ip立即发生的变化，并且重新进行握手。而QUIC没有立即变化ip，同时没有重新握手的过程。</p>\n<p>QUIC 协议设计的一个关键点就是支持连接迁移，即使客户端的 IP 地址发生变化，QUIC 也会尽量保持同一个连接不中断。因此，当你切换网络时，QUIC 可能会继续使用旧的连接来发送数据包，而不会立即使用新的 IP 地址，这就是为什么 Wireshark 可能不会立即显示 IP 变化。</p>\n<p>具体来说，QUIC 会尝试通过网络路径发现（Path Validation）来验证新的网络路径是否可用，这个过程可能需要一些时间。在切换网络后的短时间内，QUIC 可能仍会通过旧的路径发送数据，直到确认新路径可用。这就解释了为什么你在 Wireshark 中看到 QUIC 的 IP 地址没有变化，而 TCP 切换网络后立即更新了 IP 地址。</p>\n<h1 id=\"QUIC协议的应用场景\"><a href=\"#QUIC协议的应用场景\" class=\"headerlink\" title=\"QUIC协议的应用场景\"></a>QUIC协议的应用场景</h1><ol>\n<li><p>视频流媒体：在视频流媒体应用中，低延迟和稳定性是至关重要的。QUIC的多路复用和更快的连接建立时间使得它成为理想的选择，尤其是在不稳定的网络环境下。</p>\n</li>\n<li><p>实时通讯：在VoIP或视频会议等实时通讯应用中，QUIC的低延迟和快速恢复能力显著改善了用户体验。</p>\n</li>\n<li><p>移动应用：对于频繁切换网络环境的移动应用（如Wi-Fi到4G切换），QUIC的连接迁移能力确保了连接的连续性，减少了重新连接的开销。</p>\n</li>\n<li><p>Web浏览：HTTP&#x2F;3已经逐步取代HTTP&#x2F;2成为新的Web传输标准。QUIC作为HTTP&#x2F;3的底层协议，改善了页面加载速度，特别是在复杂网页内容的加载过程中。</p>\n</li>\n</ol>\n<h1 id=\"QUIC的挑战\"><a href=\"#QUIC的挑战\" class=\"headerlink\" title=\"QUIC的挑战\"></a>QUIC的挑战</h1><p>尽管QUIC有许多优势，但它也面临一些挑战：</p>\n<ol>\n<li><p>UDP阻塞：由于QUIC基于UDP，一些网络设备（如防火墙和NAT）可能会阻止或限制UDP流量，影响QUIC的性能。</p>\n</li>\n<li><p>兼容性问题：尽管QUIC越来越受欢迎，但并不是所有设备和应用程序都支持它。因此，过渡到QUIC需要兼顾兼容性问题。</p>\n</li>\n<li><p>复杂性增加：由于QUIC集成了加密和多路复用等功能，相比TCP，它的实现更为复杂，可能导致维护成本的增加。</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>随着互联网对实时性和效率的需求不断增长，QUIC将扮演越来越重要的角色。HTTP&#x2F;3的普及将推动QUIC的广泛应用，尤其是在Web浏览和实时应用中。此外，随着5G网络的发展，QUIC的低延迟和高效率将进一步展示其优势。</p>\n<p>QUIC作为一种新型的传输协议，通过改进连接建立、减少延迟、支持多路复用和连接迁移，解决了TCP的许多固有问题。虽然QUIC仍然面临一些挑战，但随着标准化和应用的推进，它将成为未来互联网的重要组成部分。开发者可以开始探索并应用QUIC协议，以提升应用程序的网络性能和用户体验。</p>\n<hr>\n<p>这篇博客旨在帮助你理解和应用QUIC协议。如果你有任何关于QUIC的疑问或经验分享，欢迎在评论区讨论！</p>\n"},{"title":"深入理解 RabbitMQ 中的基础概念","date":"2024-07-09T08:28:36.000Z","_content":"\nRabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。\n\n# 标准 RabbitMQ 消息流\n1. 生产者向交易所发布一条消息。\n2. 交换机收到消息并且负责消息的路由。\n3. 必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。\n4. 消息一直留在队列中，直到被消费者处理。\n5. 消费者处理该消息。\n![mq-flow](/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg)\n\n# 1. 核心概念\n## 1.1 broker\n简单来说 Broker 就是消息队列服务器实体。\n\n我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：\n\n+ 磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失\n+ 内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。\n## 1.2 Channel\nChannel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。\n\nChannel 信道是生产者/消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。\n\n在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务\n\n### 为什么使用 Channel 而不是直接使用 TCP 连接？\n1. 性能：\n   - 创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。\n   - TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。\n   - Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。\n\n2. 独立性：\n   - 每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。\n   - 这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。\n\n3. 资源复用：\n   - 通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。\n   - 使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。\n\n下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。\n![一个channel对应一个connection](/images/rabbitmq-basic/channel1.png)\n```CSharp\nvar factory = new ConnectionFactory() {\n    HostName = \"127.0.0.1\"\n};\nstring clientProvidedName = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})-Subscriber\";\n\n// 创建一个 TCP 连接\nvar connection = factory.CreateConnection(clientProvidedName);\nstring consumerTag = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})\";\n\n// 在同一个连接上创建第一个 Channel\nvar channel1 = connection.CreateModel();\nvar queueName1 = \"TestMQ.Rabbit.WeChat\";\n\nvar consumer1 = new EventingBasicConsumer(channel1);\nconsumer1.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel1.BasicConsume(queue: queueName1, autoAck: true, consumerTag, consumer: consumer1);\n\n// 在同一个连接上创建第二个 Channel\nvar channel2 = connection.CreateModel();\nvar queueName2 = \"TestMQ.Rabbit.Email\";\n\nvar consumer2 = new EventingBasicConsumer(channel2);\nconsumer2.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel2.BasicConsume(queue: queueName2, autoAck: true, consumerTag, consumer: consumer2);\n```\n![一个channel对应一个connection](/images/rabbitmq-basic/channel2.png)\n\n## 1.3 Exchange\nExchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：\n\n+ Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。\n+ Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。\n+ Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。\n+ Headers Exchange：根据消息头属性来路由消息，而不是路由键。\n## 1.4 Queue\nQueue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。\n\n## 1.5 Vhost（Virtual Host）\nvhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。\n\n\n### 作用和好处\n1. 资源隔离：\n   - 独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。\n   - 安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。\n2.多租户支持：\n   - 隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。\n3. 环境隔离：\n   - 开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。\n4. 简化管理：\n   - 组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。\n\n\n上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange\n![默认交换机](/images/rabbitmq-basic/default-exchange.png)\n\n## 1.6 Routing Key\nRouting Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。\n\n### Exchange 类型与 RoutingKey、BindingKey 的关系\n不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：\n\n1. Direct Exchange：\n   - 交换机将消息路由到 RoutingKey 精确匹配的队列。\n   - 例如，RoutingKey 为 \"orange\" 的消息只会路由到绑定了 BindingKey 为 \"orange\" 的队列。\n    ![direct exchange](/images/rabbitmq-basic/direct-exchange.svg)\n2. Topic Exchange：\n   - 交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。\n   - RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。\n   - 例如，RoutingKey 为 \"user.update.info\" 的消息可以匹配 BindingKey 为 \"user.*.info\" 或 \"user.#\"。\n![direct exchange](/images/rabbitmq-basic/topic-exchange.svg)\n3. Fanout Exchange：\n   - 交换机将消息广播到所有绑定的队列，忽略 RoutingKey。\n   - 在这种情况下，BindingKey 不被使用。\n![direct exchange](/images/rabbitmq-basic/fanout-exchange.svg)\n下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。\n   ![fanout](/images/rabbitmq-basic/vro2s-b2mub.gif)\n4. Headers Exchange：\n   - 交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。\n   - BindingKey 在这种交换机类型中不被使用。\n![direct exchange](/images/rabbitmq-basic/rabbitmq-headers-exchange.svg)\n\n由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。\n\n\n# 3. 使用场景\n虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧\n\n## 3.1 负载均衡\n在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。\n\n## 3.2 异步处理\n将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。\n\n## 3.3 日志系统\n使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。\n\n# 4. 结论\nRabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。\n\n\n参考文档\n[RabbitMq经典队列](https://www.rabbitmq.com/docs/classic-queues)\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","source":"_posts/rabbitmq-basic.md","raw":"---\ntitle: 深入理解 RabbitMQ 中的基础概念\ndate: 2024-07-09 16:28:36\ntags:\n---\n\nRabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。\n\n# 标准 RabbitMQ 消息流\n1. 生产者向交易所发布一条消息。\n2. 交换机收到消息并且负责消息的路由。\n3. 必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。\n4. 消息一直留在队列中，直到被消费者处理。\n5. 消费者处理该消息。\n![mq-flow](/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg)\n\n# 1. 核心概念\n## 1.1 broker\n简单来说 Broker 就是消息队列服务器实体。\n\n我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：\n\n+ 磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失\n+ 内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。\n## 1.2 Channel\nChannel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。\n\nChannel 信道是生产者/消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。\n\n在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务\n\n### 为什么使用 Channel 而不是直接使用 TCP 连接？\n1. 性能：\n   - 创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。\n   - TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。\n   - Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。\n\n2. 独立性：\n   - 每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。\n   - 这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。\n\n3. 资源复用：\n   - 通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。\n   - 使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。\n\n下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。\n![一个channel对应一个connection](/images/rabbitmq-basic/channel1.png)\n```CSharp\nvar factory = new ConnectionFactory() {\n    HostName = \"127.0.0.1\"\n};\nstring clientProvidedName = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})-Subscriber\";\n\n// 创建一个 TCP 连接\nvar connection = factory.CreateConnection(clientProvidedName);\nstring consumerTag = $\"{EnvUtils.GetAppName()}({EnvUtils.GetHostName()})\";\n\n// 在同一个连接上创建第一个 Channel\nvar channel1 = connection.CreateModel();\nvar queueName1 = \"TestMQ.Rabbit.WeChat\";\n\nvar consumer1 = new EventingBasicConsumer(channel1);\nconsumer1.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel1.BasicConsume(queue: queueName1, autoAck: true, consumerTag, consumer: consumer1);\n\n// 在同一个连接上创建第二个 Channel\nvar channel2 = connection.CreateModel();\nvar queueName2 = \"TestMQ.Rabbit.Email\";\n\nvar consumer2 = new EventingBasicConsumer(channel2);\nconsumer2.Received += (model, ea) => {\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n};\nchannel2.BasicConsume(queue: queueName2, autoAck: true, consumerTag, consumer: consumer2);\n```\n![一个channel对应一个connection](/images/rabbitmq-basic/channel2.png)\n\n## 1.3 Exchange\nExchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：\n\n+ Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。\n+ Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。\n+ Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。\n+ Headers Exchange：根据消息头属性来路由消息，而不是路由键。\n## 1.4 Queue\nQueue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。\n\n## 1.5 Vhost（Virtual Host）\nvhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。\n\n\n### 作用和好处\n1. 资源隔离：\n   - 独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。\n   - 安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。\n2.多租户支持：\n   - 隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。\n3. 环境隔离：\n   - 开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。\n4. 简化管理：\n   - 组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。\n\n\n上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange\n![默认交换机](/images/rabbitmq-basic/default-exchange.png)\n\n## 1.6 Routing Key\nRouting Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。\n\n### Exchange 类型与 RoutingKey、BindingKey 的关系\n不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：\n\n1. Direct Exchange：\n   - 交换机将消息路由到 RoutingKey 精确匹配的队列。\n   - 例如，RoutingKey 为 \"orange\" 的消息只会路由到绑定了 BindingKey 为 \"orange\" 的队列。\n    ![direct exchange](/images/rabbitmq-basic/direct-exchange.svg)\n2. Topic Exchange：\n   - 交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。\n   - RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。\n   - 例如，RoutingKey 为 \"user.update.info\" 的消息可以匹配 BindingKey 为 \"user.*.info\" 或 \"user.#\"。\n![direct exchange](/images/rabbitmq-basic/topic-exchange.svg)\n3. Fanout Exchange：\n   - 交换机将消息广播到所有绑定的队列，忽略 RoutingKey。\n   - 在这种情况下，BindingKey 不被使用。\n![direct exchange](/images/rabbitmq-basic/fanout-exchange.svg)\n下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。\n   ![fanout](/images/rabbitmq-basic/vro2s-b2mub.gif)\n4. Headers Exchange：\n   - 交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。\n   - BindingKey 在这种交换机类型中不被使用。\n![direct exchange](/images/rabbitmq-basic/rabbitmq-headers-exchange.svg)\n\n由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。\n\n\n# 3. 使用场景\n虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧\n\n## 3.1 负载均衡\n在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。\n\n## 3.2 异步处理\n将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。\n\n## 3.3 日志系统\n使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。\n\n# 4. 结论\nRabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。\n\n\n参考文档\n[RabbitMq经典队列](https://www.rabbitmq.com/docs/classic-queues)\n\n\n希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！","slug":"rabbitmq-basic","published":1,"updated":"2024-07-10T12:42:57.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawl0015rkp1c81h5kjb","content":"<p>RabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。</p>\n<h1 id=\"标准-RabbitMQ-消息流\"><a href=\"#标准-RabbitMQ-消息流\" class=\"headerlink\" title=\"标准 RabbitMQ 消息流\"></a>标准 RabbitMQ 消息流</h1><ol>\n<li>生产者向交易所发布一条消息。</li>\n<li>交换机收到消息并且负责消息的路由。</li>\n<li>必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。</li>\n<li>消息一直留在队列中，直到被消费者处理。</li>\n<li>消费者处理该消息。<br><img src=\"/blog/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg\" alt=\"mq-flow\"></li>\n</ol>\n<h1 id=\"1-核心概念\"><a href=\"#1-核心概念\" class=\"headerlink\" title=\"1. 核心概念\"></a>1. 核心概念</h1><h2 id=\"1-1-broker\"><a href=\"#1-1-broker\" class=\"headerlink\" title=\"1.1 broker\"></a>1.1 broker</h2><p>简单来说 Broker 就是消息队列服务器实体。</p>\n<p>我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：</p>\n<ul>\n<li>磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失</li>\n<li>内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。</li>\n</ul>\n<h2 id=\"1-2-Channel\"><a href=\"#1-2-Channel\" class=\"headerlink\" title=\"1.2 Channel\"></a>1.2 Channel</h2><p>Channel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。</p>\n<p>Channel 信道是生产者&#x2F;消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。</p>\n<p>在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务</p>\n<h3 id=\"为什么使用-Channel-而不是直接使用-TCP-连接？\"><a href=\"#为什么使用-Channel-而不是直接使用-TCP-连接？\" class=\"headerlink\" title=\"为什么使用 Channel 而不是直接使用 TCP 连接？\"></a>为什么使用 Channel 而不是直接使用 TCP 连接？</h3><ol>\n<li><p>性能：</p>\n<ul>\n<li>创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。</li>\n<li>TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。</li>\n<li>Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。</li>\n</ul>\n</li>\n<li><p>独立性：</p>\n<ul>\n<li>每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。</li>\n<li>这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。</li>\n</ul>\n</li>\n<li><p>资源复用：</p>\n<ul>\n<li>通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。</li>\n<li>使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。</li>\n</ul>\n</li>\n</ol>\n<p>下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。<br><img src=\"/blog/images/rabbitmq-basic/channel1.png\" alt=\"一个channel对应一个connection\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123;</span><br><span class=\"line\">    HostName = <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> clientProvidedName = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)-Subscriber&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = factory.CreateConnection(clientProvidedName);</span><br><span class=\"line\"><span class=\"built_in\">string</span> consumerTag = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第一个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel1 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName1 = <span class=\"string\">&quot;TestMQ.Rabbit.WeChat&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer1 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel1);</span><br><span class=\"line\">consumer1.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel1.BasicConsume(queue: queueName1, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第二个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel2 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName2 = <span class=\"string\">&quot;TestMQ.Rabbit.Email&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer2 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel2);</span><br><span class=\"line\">consumer2.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel2.BasicConsume(queue: queueName2, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/rabbitmq-basic/channel2.png\" alt=\"一个channel对应一个connection\"></p>\n<h2 id=\"1-3-Exchange\"><a href=\"#1-3-Exchange\" class=\"headerlink\" title=\"1.3 Exchange\"></a>1.3 Exchange</h2><p>Exchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：</p>\n<ul>\n<li>Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。</li>\n<li>Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。</li>\n<li>Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。</li>\n<li>Headers Exchange：根据消息头属性来路由消息，而不是路由键。</li>\n</ul>\n<h2 id=\"1-4-Queue\"><a href=\"#1-4-Queue\" class=\"headerlink\" title=\"1.4 Queue\"></a>1.4 Queue</h2><p>Queue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。</p>\n<h2 id=\"1-5-Vhost（Virtual-Host）\"><a href=\"#1-5-Vhost（Virtual-Host）\" class=\"headerlink\" title=\"1.5 Vhost（Virtual Host）\"></a>1.5 Vhost（Virtual Host）</h2><p>vhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。</p>\n<h3 id=\"作用和好处\"><a href=\"#作用和好处\" class=\"headerlink\" title=\"作用和好处\"></a>作用和好处</h3><ol>\n<li>资源隔离：<ul>\n<li>独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。</li>\n<li>安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。<br>2.多租户支持：</li>\n<li>隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。</li>\n</ul>\n</li>\n<li>环境隔离：<ul>\n<li>开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。</li>\n</ul>\n</li>\n<li>简化管理：<ul>\n<li>组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。</li>\n</ul>\n</li>\n</ol>\n<p>上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange<br><img src=\"/blog/images/rabbitmq-basic/default-exchange.png\" alt=\"默认交换机\"></p>\n<h2 id=\"1-6-Routing-Key\"><a href=\"#1-6-Routing-Key\" class=\"headerlink\" title=\"1.6 Routing Key\"></a>1.6 Routing Key</h2><p>Routing Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。</p>\n<h3 id=\"Exchange-类型与-RoutingKey、BindingKey-的关系\"><a href=\"#Exchange-类型与-RoutingKey、BindingKey-的关系\" class=\"headerlink\" title=\"Exchange 类型与 RoutingKey、BindingKey 的关系\"></a>Exchange 类型与 RoutingKey、BindingKey 的关系</h3><p>不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：</p>\n<ol>\n<li>Direct Exchange：<ul>\n<li>交换机将消息路由到 RoutingKey 精确匹配的队列。</li>\n<li>例如，RoutingKey 为 “orange” 的消息只会路由到绑定了 BindingKey 为 “orange” 的队列。<br> <img src=\"/blog/images/rabbitmq-basic/direct-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Topic Exchange：<ul>\n<li>交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。</li>\n<li>RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。</li>\n<li>例如，RoutingKey 为 “user.update.info” 的消息可以匹配 BindingKey 为 “user.*.info” 或 “user.#”。<br><img src=\"/blog/images/rabbitmq-basic/topic-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Fanout Exchange：<ul>\n<li>交换机将消息广播到所有绑定的队列，忽略 RoutingKey。</li>\n<li>在这种情况下，BindingKey 不被使用。<br><img src=\"/blog/images/rabbitmq-basic/fanout-exchange.svg\" alt=\"direct exchange\"><br>下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。<br><img src=\"/blog/images/rabbitmq-basic/vro2s-b2mub.gif\" alt=\"fanout\"></li>\n</ul>\n</li>\n<li>Headers Exchange：<ul>\n<li>交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。</li>\n<li>BindingKey 在这种交换机类型中不被使用。<br><img src=\"/blog/images/rabbitmq-basic/rabbitmq-headers-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n</ol>\n<p>由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。</p>\n<h1 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h1><p>虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧</p>\n<h2 id=\"3-1-负载均衡\"><a href=\"#3-1-负载均衡\" class=\"headerlink\" title=\"3.1 负载均衡\"></a>3.1 负载均衡</h2><p>在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。</p>\n<h2 id=\"3-2-异步处理\"><a href=\"#3-2-异步处理\" class=\"headerlink\" title=\"3.2 异步处理\"></a>3.2 异步处理</h2><p>将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。</p>\n<h2 id=\"3-3-日志系统\"><a href=\"#3-3-日志系统\" class=\"headerlink\" title=\"3.3 日志系统\"></a>3.3 日志系统</h2><p>使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4. 结论\"></a>4. 结论</h1><p>RabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/classic-queues\">RabbitMq经典队列</a></p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>RabbitMQ 是一个广泛使用的消息代理，它使得不同系统和服务之间可以进行可靠的消息传递。理解 RabbitMQ 的核心概念是高效使用它的关键。本文将深入探讨 RabbitMQ 的 Channel、Exchange、Queue、Vhost、Route 等概念，并通过实际开发示例展示如何在项目中应用这些概念。</p>\n<h1 id=\"标准-RabbitMQ-消息流\"><a href=\"#标准-RabbitMQ-消息流\" class=\"headerlink\" title=\"标准 RabbitMQ 消息流\"></a>标准 RabbitMQ 消息流</h1><ol>\n<li>生产者向交易所发布一条消息。</li>\n<li>交换机收到消息并且负责消息的路由。</li>\n<li>必须在队列和交换机之间建立绑定。在本例中，我们绑定了来自交换机的两个不同队列。交换机将消息路由到队列中。</li>\n<li>消息一直留在队列中，直到被消费者处理。</li>\n<li>消费者处理该消息。<br><img src=\"/blog/images/rabbitmq-basic/exchanges-bidings-routing-keys.svg\" alt=\"mq-flow\"></li>\n</ol>\n<h1 id=\"1-核心概念\"><a href=\"#1-核心概念\" class=\"headerlink\" title=\"1. 核心概念\"></a>1. 核心概念</h1><h2 id=\"1-1-broker\"><a href=\"#1-1-broker\" class=\"headerlink\" title=\"1.1 broker\"></a>1.1 broker</h2><p>简单来说 Broker 就是消息队列服务器实体。</p>\n<p>我们把部署 RabbitMQ 的机器称为节点，也就是 Broker。Broker 有 2 种类型节点：</p>\n<ul>\n<li>磁盘节点：磁盘节点的 Broker 把元数据存储在磁盘中，磁盘节点的 Broker 在重启后元数据可以通过读取磁盘进行重建，保证了元数据不丢失</li>\n<li>内存节点：内存节点的 Broker 把元数据存储在内存中，内存节点的 Broker 可以获得更高的性能，但在重启后元数据就都丢了。</li>\n</ul>\n<h2 id=\"1-2-Channel\"><a href=\"#1-2-Channel\" class=\"headerlink\" title=\"1.2 Channel\"></a>1.2 Channel</h2><p>Channel 是 RabbitMQ 中的一个虚拟连接，是建立在实际的 TCP 连接之上的。通过 Channel，可以减少 TCP 连接的创建和销毁带来的开销，提升消息传输的效率。每个 Channel 可以有自己的设置和属性，与其他 Channel 相互独立。</p>\n<p>Channel 信道是生产者&#x2F;消费者与 RabbitMQ 通信的渠道，生产者 publish 或者消费者消费一个队列都是需要通过信道来通信的。也就是 RabbitMQ 在一个 TCP 上面建立成百上千的信道来达到多个线程处理。</p>\n<p>在客户端的每个连接里，可建立多个 Channel，每个 Channel 代表一个会话任务</p>\n<h3 id=\"为什么使用-Channel-而不是直接使用-TCP-连接？\"><a href=\"#为什么使用-Channel-而不是直接使用-TCP-连接？\" class=\"headerlink\" title=\"为什么使用 Channel 而不是直接使用 TCP 连接？\"></a>为什么使用 Channel 而不是直接使用 TCP 连接？</h3><ol>\n<li><p>性能：</p>\n<ul>\n<li>创建和销毁 TCP 连接是昂贵的操作，而创建和销毁 Channel 是相对轻量级的。</li>\n<li>TCP 连接的建立涉及三次握手，而销毁涉及四次挥手，这些操作在高频率连接情况下会带来显著的开销。</li>\n<li>Channel 的创建和销毁不需要这种复杂的握手过程，因此可以快速地进行资源管理。</li>\n</ul>\n</li>\n<li><p>独立性：</p>\n<ul>\n<li>每个 Channel 都是独立的，可以有自己的设置和属性。比如，每个 Channel 可以绑定到不同的队列和交换机，有不同的 QoS（Quality of Service）设置等。</li>\n<li>这种独立性允许在一个 TCP 连接上同时进行多种不同的消息处理任务，而不相互干扰。</li>\n</ul>\n</li>\n<li><p>资源复用：</p>\n<ul>\n<li>通过复用 TCP 连接，可以减少系统的资源消耗，特别是在高并发的场景下。</li>\n<li>使用 Channel 复用 TCP 连接还可以提高传输效率，减少网络带宽的占用。</li>\n</ul>\n</li>\n</ol>\n<p>下面我们通过一个简单的例子看一下。这里我们创建了两个队列，每个队列一个消费者。默认情况下，我们会看到2个Channel和2个Connection。然后我们稍微改一下代码，让两个消费者绑定在一个Connection上。<br><img src=\"/blog/images/rabbitmq-basic/channel1.png\" alt=\"一个channel对应一个connection\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123;</span><br><span class=\"line\">    HostName = <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> clientProvidedName = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)-Subscriber&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> connection = factory.CreateConnection(clientProvidedName);</span><br><span class=\"line\"><span class=\"built_in\">string</span> consumerTag = <span class=\"string\">$&quot;<span class=\"subst\">&#123;EnvUtils.GetAppName()&#125;</span>(<span class=\"subst\">&#123;EnvUtils.GetHostName()&#125;</span>)&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第一个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel1 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName1 = <span class=\"string\">&quot;TestMQ.Rabbit.WeChat&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer1 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel1);</span><br><span class=\"line\">consumer1.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel1.BasicConsume(queue: queueName1, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在同一个连接上创建第二个 Channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> channel2 = connection.CreateModel();</span><br><span class=\"line\"><span class=\"keyword\">var</span> queueName2 = <span class=\"string\">&quot;TestMQ.Rabbit.Email&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> consumer2 = <span class=\"keyword\">new</span> EventingBasicConsumer(channel2);</span><br><span class=\"line\">consumer2.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">channel2.BasicConsume(queue: queueName2, autoAck: <span class=\"literal\">true</span>, consumerTag, consumer: consumer2);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/rabbitmq-basic/channel2.png\" alt=\"一个channel对应一个connection\"></p>\n<h2 id=\"1-3-Exchange\"><a href=\"#1-3-Exchange\" class=\"headerlink\" title=\"1.3 Exchange\"></a>1.3 Exchange</h2><p>Exchange 是 RabbitMQ 中接收消息并根据绑定规则将其路由到一个或多个 Queue 的组件。默认的 Exchange 类型有：</p>\n<ul>\n<li>Direct Exchange：根据消息的路由键（routing key）精确匹配绑定键将消息发送到对应的 Queue。</li>\n<li>Topic Exchange：根据消息的路由键模式（如 logs.*）匹配绑定键，将消息发送到对应的 Queue。</li>\n<li>Fanout Exchange：将接收到的消息广播到所有绑定的 Queue，不考虑路由键。</li>\n<li>Headers Exchange：根据消息头属性来路由消息，而不是路由键。</li>\n</ul>\n<h2 id=\"1-4-Queue\"><a href=\"#1-4-Queue\" class=\"headerlink\" title=\"1.4 Queue\"></a>1.4 Queue</h2><p>Queue 是 RabbitMQ 中存储消息的地方，消费者从 Queue 中接收消息。Queue 可以绑定到一个或多个 Exchange，并根据绑定规则接收消息。Queue 具有 FIFO（First In, First Out）特性，确保消息按顺序处理。</p>\n<h2 id=\"1-5-Vhost（Virtual-Host）\"><a href=\"#1-5-Vhost（Virtual-Host）\" class=\"headerlink\" title=\"1.5 Vhost（Virtual Host）\"></a>1.5 Vhost（Virtual Host）</h2><p>vhost(虚拟主机)是一种逻辑隔离机制，用于将消息队列和相关资源隔离开来。虚拟主机允许您在单个RabbitMQ服务器上创建多个独立的消息队列环境，每个环境都有自己的队列、交换机、绑定和权限设置。</p>\n<h3 id=\"作用和好处\"><a href=\"#作用和好处\" class=\"headerlink\" title=\"作用和好处\"></a>作用和好处</h3><ol>\n<li>资源隔离：<ul>\n<li>独立的命名空间：每个 vhost 都有自己独立的命名空间，这意味着在一个 vhost 中创建的队列、交换机和绑定不会与其他 vhost 中的资源冲突。</li>\n<li>安全性和权限管理：通过 vhost，可以为不同的用户分配不同的权限，从而确保不同应用程序或服务之间的数据安全。例如，应用 A 和应用 B 可以使用相同的资源名称（如队列名）而不会产生冲突，因为它们在不同的 vhost 中。<br>2.多租户支持：</li>\n<li>隔离不同应用或服务：在多租户环境中，可以为每个租户（tenant）创建一个 vhost，从而将不同租户的消息和资源完全隔离开来。这对于 SaaS 应用程序尤为重要，可以确保不同客户之间的数据不互相干扰。</li>\n</ul>\n</li>\n<li>环境隔离：<ul>\n<li>开发、测试和生产环境：可以使用不同的 vhost 来隔离开发、测试和生产环境。这样可以确保在开发和测试过程中不会对生产环境中的消息和队列产生影响。</li>\n</ul>\n</li>\n<li>简化管理：<ul>\n<li>组织和管理资源：通过 vhost，可以更好地组织和管理 RabbitMQ 资源。在管理界面中，可以清晰地看到每个 vhost 中的资源使用情况，从而简化了运维和管理工作。</li>\n</ul>\n</li>\n</ol>\n<p>上面我们说到默认的4中Exchange类型。当我们手动创建vhost的时候就会发现，mq也自动帮我们给vhost创建了对应的4种类型总共7个Exchange<br><img src=\"/blog/images/rabbitmq-basic/default-exchange.png\" alt=\"默认交换机\"></p>\n<h2 id=\"1-6-Routing-Key\"><a href=\"#1-6-Routing-Key\" class=\"headerlink\" title=\"1.6 Routing Key\"></a>1.6 Routing Key</h2><p>Routing Key 是生产者发送消息时指定的路由信息，Exchange 根据 Routing Key 将消息路由到相应的 Queue。不同类型的 Exchange 使用 Routing Key 的方式不同。</p>\n<h3 id=\"Exchange-类型与-RoutingKey、BindingKey-的关系\"><a href=\"#Exchange-类型与-RoutingKey、BindingKey-的关系\" class=\"headerlink\" title=\"Exchange 类型与 RoutingKey、BindingKey 的关系\"></a>Exchange 类型与 RoutingKey、BindingKey 的关系</h3><p>不同类型的交换机处理 RoutingKey 和 BindingKey 的方式不同：</p>\n<ol>\n<li>Direct Exchange：<ul>\n<li>交换机将消息路由到 RoutingKey 精确匹配的队列。</li>\n<li>例如，RoutingKey 为 “orange” 的消息只会路由到绑定了 BindingKey 为 “orange” 的队列。<br> <img src=\"/blog/images/rabbitmq-basic/direct-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Topic Exchange：<ul>\n<li>交换机根据 RoutingKey 和 BindingKey 的模式匹配规则路由消息。</li>\n<li>RoutingKey 是由点分隔的字符串，BindingKey 可以包含特殊字符 *（匹配一个单词）和 #（匹配零个或多个单词）。</li>\n<li>例如，RoutingKey 为 “user.update.info” 的消息可以匹配 BindingKey 为 “user.*.info” 或 “user.#”。<br><img src=\"/blog/images/rabbitmq-basic/topic-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n<li>Fanout Exchange：<ul>\n<li>交换机将消息广播到所有绑定的队列，忽略 RoutingKey。</li>\n<li>在这种情况下，BindingKey 不被使用。<br><img src=\"/blog/images/rabbitmq-basic/fanout-exchange.svg\" alt=\"direct exchange\"><br>下面我写了一个简单的fanout交换机的demo​，我们可以看到，往交换机发送一条消息，4个队列都收到了消息。<br><img src=\"/blog/images/rabbitmq-basic/vro2s-b2mub.gif\" alt=\"fanout\"></li>\n</ul>\n</li>\n<li>Headers Exchange：<ul>\n<li>交换机根据消息头属性（Headers）而不是 RoutingKey 进行路由。</li>\n<li>BindingKey 在这种交换机类型中不被使用。<br><img src=\"/blog/images/rabbitmq-basic/rabbitmq-headers-exchange.svg\" alt=\"direct exchange\"></li>\n</ul>\n</li>\n</ol>\n<p>由 Exchange、Queue、RoutingKey 三个才能决定一个从 Exchange 到 Queue的 唯一的线路。</p>\n<h1 id=\"3-使用场景\"><a href=\"#3-使用场景\" class=\"headerlink\" title=\"3. 使用场景\"></a>3. 使用场景</h1><p>虽然这篇文章将的是mq里面的概念，但是我们还是简单带过一下mq的使用场景吧</p>\n<h2 id=\"3-1-负载均衡\"><a href=\"#3-1-负载均衡\" class=\"headerlink\" title=\"3.1 负载均衡\"></a>3.1 负载均衡</h2><p>在微服务架构中，可以使用 RabbitMQ 进行负载均衡，将任务分发给多个消费者，提升系统的处理能力。</p>\n<h2 id=\"3-2-异步处理\"><a href=\"#3-2-异步处理\" class=\"headerlink\" title=\"3.2 异步处理\"></a>3.2 异步处理</h2><p>将需要异步处理的任务放入 RabbitMQ 队列，可以使系统更具响应性，减少请求处理时间。</p>\n<h2 id=\"3-3-日志系统\"><a href=\"#3-3-日志系统\" class=\"headerlink\" title=\"3.3 日志系统\"></a>3.3 日志系统</h2><p>使用 Fanout Exchange，将日志消息广播到多个日志处理服务，实现分布式日志收集和分析。</p>\n<h1 id=\"4-结论\"><a href=\"#4-结论\" class=\"headerlink\" title=\"4. 结论\"></a>4. 结论</h1><p>RabbitMQ 通过 Channel、Exchange、Queue、Vhost、Routing Key 等机制，实现了高效、可靠的消息传递。在实际开发中，合理使用这些概念和机制，可以显著提升系统的性能和可靠性。希望本文的介绍和示例代码能帮助你更好地理解和使用 RabbitMQ。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/classic-queues\">RabbitMq经典队列</a></p>\n<p>希望这篇文章能帮助你理解学习Docker。如果你有任何问题或建议，欢迎留言讨论！</p>\n"},{"title":"Redis成长记 - Redis的陷阱（一）","date":"2024-04-18T07:09:28.000Z","_content":"相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/redis-interview-1.md","raw":"---\ntitle: Redis成长记 - Redis的陷阱（一）\ndate: 2024-04-18 15:09:28\ntags: redis 面试 求职\n---\n相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"redis-interview-1","published":1,"updated":"2024-04-26T03:31:26.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawl0017rkp1cjjm6q5s","content":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/blog/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/blog/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/blog/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/blog/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/blog/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/blog/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"RabbitMQ之三种队列之间的区别及如何选型","date":"2024-07-11T02:36:12.000Z","_content":"\nRabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。\n\n# 经典队列（Classic Queues）\n## 简介：\n经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。\n\n## 特点：\n\n+ 存储机制：消息存储在磁盘或内存中，支持持久化。\n+ 消息传递：一旦消息被消费者确认，消息会从队列中删除。\n+ 性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。\n+ 高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。\n## 适用场景：\n\n适合大多数常规消息传递场景，如任务调度、事件通知等。\n当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。\n\n# 仲裁队列（Quorum Queues）\n## 简介：\n仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。\n\n## 特点：\n\n- 存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。\n- 高可用性：天然支持高可用性，通过多节点复制实现数据冗余。\n- 数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。\n- 性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。\n\n## 适用场景：\n\n- 适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。\n- 在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。\n\n## 注意事项\n1. 仲裁队列只能声明为持久的\n仲裁队列只能被声明为持久的，否则会引发以下错误消息：\n：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效\n\nQuorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。\n\n2. 仲裁队列的消息默认就是持久化的\n对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。\n\n下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。\n![重启前](/images/rabbitmq-quarum/quarum1.png)\n然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。\n![重启后](/images/rabbitmq-quarum/quarum2.png)\n\n## 仲裁队列 VS 经典队列\n\n### 数据一致性\n仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。\n\n### 数据可靠性\n仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。\n\n# 流式队列（Stream Queues）\n流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。\n\n## 特点：\n+ 存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。\n+ 高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。\n+ 数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。\n+ 订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。\n\n## 什么是消息回放和重复消费？\n消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。\n\n重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。\n\n```CSharp\npublic void InitStreamMQ()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n    // 声明流式队列\n    var args = new Dictionary<string, object> { { \"x-queue-type\", \"stream\" } };\n    channel.QueueDeclare(queue: \"stream_queue\", durable: true, exclusive: false, autoDelete: false, arguments: args);\n    channel.QueueBind(queue: \"stream_queue\", exchange: \"amq.direct\", routingKey: \"stream_queue\");\n}\n\n\n[ActionTitle(Name = \"订阅队列\")]\n[Route(\"subscribe\")]\npublic void SubscribeQuorumMessage()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", VirtualHost = \"/\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n\n    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);\n    // 设置消费者，从指定的偏移量消费消息\n    var consumer = new EventingBasicConsumer(channel);\n    consumer.Received += (model, ea) => {\n        var body = ea.Body.ToArray();\n        var message = Encoding.UTF8.GetString(body);\n        Console.WriteLine(\" [x] Received {0}\", message);\n    };\n\n    /**\n     * x-stream-offset的可选值有以下几种：\n        first: 从日志队列中第一个可消费的消息开始消费\n        last: 消费消息日志中最后一个消息\n        next: 相当于不指定offset，消费不到消息。\n        Offset: 一个数字型的偏移量\n        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)\n     */\n    var args = new Dictionary<string, object> { { \"x-stream-offset\", 2 } };\n    channel.BasicConsume(queue: \"stream_queue\", autoAck: false, arguments: args, consumer: consumer);\n}\n\n```\n这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.\n![offset](/images/rabbitmq-quarum/stream_offset.png)\n\n## 流式队列的工作原理\n流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。\n\n## 适用场景：\n\n+ 适用于实时数据分析、日志处理、实时监控等场景。\n+ 在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。\n\n## PS\n1. Auto-Ack 必须为 false\n在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。\n![aoto ack](/images/rabbitmq-quarum/stream_error2.png)\n\n2. 必须设置prefetchCount\n流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用\n![prefetchCount](/images/rabbitmq-quarum/stream_error1.png)\n\n3. durable必须设置为true\n与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。\n\n\n# 选型建议\n在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：\n\n1. 经典队列：\n   - 适合大多数常规的消息传递需求。\n   - 需要较高的性能和可靠性，但不需要特别高的数据一致性要求。\n2. 仲裁队列：\n   - 适用于对数据一致性和高可用性要求较高的场景。\n   - 需要确保消息不丢失且能够在多节点间保持数据一致性。\n3. 流式队列：\n   - 适合处理大规模实时数据流和高吞吐量的场景。\n   - 需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。\n\n# 总结\n通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。\n\n参考文档\n[Quorum Queues](https://www.rabbitmq.com/docs/quorum-queues)","source":"_posts/rabbitmq-quorum.md","raw":"---\ntitle: RabbitMQ之三种队列之间的区别及如何选型\ndate: 2024-07-11 10:36:12\ntags:\n---\n\nRabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。\n\n# 经典队列（Classic Queues）\n## 简介：\n经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。\n\n## 特点：\n\n+ 存储机制：消息存储在磁盘或内存中，支持持久化。\n+ 消息传递：一旦消息被消费者确认，消息会从队列中删除。\n+ 性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。\n+ 高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。\n## 适用场景：\n\n适合大多数常规消息传递场景，如任务调度、事件通知等。\n当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。\n\n# 仲裁队列（Quorum Queues）\n## 简介：\n仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。\n\n## 特点：\n\n- 存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。\n- 高可用性：天然支持高可用性，通过多节点复制实现数据冗余。\n- 数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。\n- 性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。\n\n## 适用场景：\n\n- 适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。\n- 在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。\n\n## 注意事项\n1. 仲裁队列只能声明为持久的\n仲裁队列只能被声明为持久的，否则会引发以下错误消息：\n：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效\n\nQuorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。\n\n2. 仲裁队列的消息默认就是持久化的\n对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。\n\n下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。\n![重启前](/images/rabbitmq-quarum/quarum1.png)\n然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。\n![重启后](/images/rabbitmq-quarum/quarum2.png)\n\n## 仲裁队列 VS 经典队列\n\n### 数据一致性\n仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。\n\n### 数据可靠性\n仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。\n\n# 流式队列（Stream Queues）\n流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。\n\n## 特点：\n+ 存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。\n+ 高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。\n+ 数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。\n+ 订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。\n\n## 什么是消息回放和重复消费？\n消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。\n\n重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。\n\n```CSharp\npublic void InitStreamMQ()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n    // 声明流式队列\n    var args = new Dictionary<string, object> { { \"x-queue-type\", \"stream\" } };\n    channel.QueueDeclare(queue: \"stream_queue\", durable: true, exclusive: false, autoDelete: false, arguments: args);\n    channel.QueueBind(queue: \"stream_queue\", exchange: \"amq.direct\", routingKey: \"stream_queue\");\n}\n\n\n[ActionTitle(Name = \"订阅队列\")]\n[Route(\"subscribe\")]\npublic void SubscribeQuorumMessage()\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\", VirtualHost = \"/\", UserName = \"user\", Password = \"myrabbit\" };\n\n    var connection = factory.CreateConnection();\n    var channel = connection.CreateModel();\n\n    channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);\n    // 设置消费者，从指定的偏移量消费消息\n    var consumer = new EventingBasicConsumer(channel);\n    consumer.Received += (model, ea) => {\n        var body = ea.Body.ToArray();\n        var message = Encoding.UTF8.GetString(body);\n        Console.WriteLine(\" [x] Received {0}\", message);\n    };\n\n    /**\n     * x-stream-offset的可选值有以下几种：\n        first: 从日志队列中第一个可消费的消息开始消费\n        last: 消费消息日志中最后一个消息\n        next: 相当于不指定offset，消费不到消息。\n        Offset: 一个数字型的偏移量\n        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)\n     */\n    var args = new Dictionary<string, object> { { \"x-stream-offset\", 2 } };\n    channel.BasicConsume(queue: \"stream_queue\", autoAck: false, arguments: args, consumer: consumer);\n}\n\n```\n这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.\n![offset](/images/rabbitmq-quarum/stream_offset.png)\n\n## 流式队列的工作原理\n流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。\n\n## 适用场景：\n\n+ 适用于实时数据分析、日志处理、实时监控等场景。\n+ 在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。\n\n## PS\n1. Auto-Ack 必须为 false\n在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。\n![aoto ack](/images/rabbitmq-quarum/stream_error2.png)\n\n2. 必须设置prefetchCount\n流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用\n![prefetchCount](/images/rabbitmq-quarum/stream_error1.png)\n\n3. durable必须设置为true\n与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。\n\n\n# 选型建议\n在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：\n\n1. 经典队列：\n   - 适合大多数常规的消息传递需求。\n   - 需要较高的性能和可靠性，但不需要特别高的数据一致性要求。\n2. 仲裁队列：\n   - 适用于对数据一致性和高可用性要求较高的场景。\n   - 需要确保消息不丢失且能够在多节点间保持数据一致性。\n3. 流式队列：\n   - 适合处理大规模实时数据流和高吞吐量的场景。\n   - 需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。\n\n# 总结\n通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。\n\n参考文档\n[Quorum Queues](https://www.rabbitmq.com/docs/quorum-queues)","slug":"rabbitmq-quorum","published":1,"updated":"2024-07-13T07:55:05.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawl0018rkp1h23b1945","content":"<p>RabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。</p>\n<h1 id=\"经典队列（Classic-Queues）\"><a href=\"#经典队列（Classic-Queues）\" class=\"headerlink\" title=\"经典队列（Classic Queues）\"></a>经典队列（Classic Queues）</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在磁盘或内存中，支持持久化。</li>\n<li>消息传递：一旦消息被消费者确认，消息会从队列中删除。</li>\n<li>性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。</li>\n<li>高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。</li>\n</ul>\n<h2 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><p>适合大多数常规消息传递场景，如任务调度、事件通知等。<br>当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。</p>\n<h1 id=\"仲裁队列（Quorum-Queues）\"><a href=\"#仲裁队列（Quorum-Queues）\" class=\"headerlink\" title=\"仲裁队列（Quorum Queues）\"></a>仲裁队列（Quorum Queues）</h1><h2 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。</p>\n<h2 id=\"特点：-1\"><a href=\"#特点：-1\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。</li>\n<li>高可用性：天然支持高可用性，通过多节点复制实现数据冗余。</li>\n<li>数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。</li>\n<li>性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。</li>\n</ul>\n<h2 id=\"适用场景：-1\"><a href=\"#适用场景：-1\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。</li>\n<li>在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>仲裁队列只能声明为持久的<br>仲裁队列只能被声明为持久的，否则会引发以下错误消息：<br>：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效</li>\n</ol>\n<p>Quorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。</p>\n<ol start=\"2\">\n<li>仲裁队列的消息默认就是持久化的<br>对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。</li>\n</ol>\n<p>下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。<br><img src=\"/blog/images/rabbitmq-quarum/quarum1.png\" alt=\"重启前\"><br>然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。<br><img src=\"/blog/images/rabbitmq-quarum/quarum2.png\" alt=\"重启后\"></p>\n<h2 id=\"仲裁队列-VS-经典队列\"><a href=\"#仲裁队列-VS-经典队列\" class=\"headerlink\" title=\"仲裁队列 VS 经典队列\"></a>仲裁队列 VS 经典队列</h2><h3 id=\"数据一致性\"><a href=\"#数据一致性\" class=\"headerlink\" title=\"数据一致性\"></a>数据一致性</h3><p>仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。</p>\n<h3 id=\"数据可靠性\"><a href=\"#数据可靠性\" class=\"headerlink\" title=\"数据可靠性\"></a>数据可靠性</h3><p>仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。</p>\n<h1 id=\"流式队列（Stream-Queues）\"><a href=\"#流式队列（Stream-Queues）\" class=\"headerlink\" title=\"流式队列（Stream Queues）\"></a>流式队列（Stream Queues）</h1><p>流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。</p>\n<h2 id=\"特点：-2\"><a href=\"#特点：-2\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。</li>\n<li>高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。</li>\n<li>数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。</li>\n<li>订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。</li>\n</ul>\n<h2 id=\"什么是消息回放和重复消费？\"><a href=\"#什么是消息回放和重复消费？\" class=\"headerlink\" title=\"什么是消息回放和重复消费？\"></a>什么是消息回放和重复消费？</h2><p>消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。</p>\n<p>重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InitStreamMQ</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\">    <span class=\"comment\">// 声明流式队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-queue-type&quot;</span>, <span class=\"string\">&quot;stream&quot;</span> &#125; &#125;;</span><br><span class=\"line\">    channel.QueueDeclare(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, durable: <span class=\"literal\">true</span>, exclusive: <span class=\"literal\">false</span>, autoDelete: <span class=\"literal\">false</span>, arguments: args);</span><br><span class=\"line\">    channel.QueueBind(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, exchange: <span class=\"string\">&quot;amq.direct&quot;</span>, routingKey: <span class=\"string\">&quot;stream_queue&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;订阅队列&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;subscribe&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SubscribeQuorumMessage</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, VirtualHost = <span class=\"string\">&quot;/&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.BasicQos(prefetchSize: <span class=\"number\">0</span>, prefetchCount: <span class=\"number\">1</span>, <span class=\"keyword\">global</span>: <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置消费者，从指定的偏移量消费消息</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">    consumer.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * x-stream-offset的可选值有以下几种：</span></span><br><span class=\"line\"><span class=\"comment\">        first: 从日志队列中第一个可消费的消息开始消费</span></span><br><span class=\"line\"><span class=\"comment\">        last: 消费消息日志中最后一个消息</span></span><br><span class=\"line\"><span class=\"comment\">        next: 相当于不指定offset，消费不到消息。</span></span><br><span class=\"line\"><span class=\"comment\">        Offset: 一个数字型的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-stream-offset&quot;</span>, <span class=\"number\">2</span> &#125; &#125;;</span><br><span class=\"line\">    channel.BasicConsume(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, arguments: args, consumer: consumer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.<br><img src=\"/blog/images/rabbitmq-quarum/stream_offset.png\" alt=\"offset\"></p>\n<h2 id=\"流式队列的工作原理\"><a href=\"#流式队列的工作原理\" class=\"headerlink\" title=\"流式队列的工作原理\"></a>流式队列的工作原理</h2><p>流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。</p>\n<h2 id=\"适用场景：-2\"><a href=\"#适用场景：-2\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于实时数据分析、日志处理、实时监控等场景。</li>\n<li>在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。</li>\n</ul>\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><ol>\n<li><p>Auto-Ack 必须为 false<br>在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。<br><img src=\"/blog/images/rabbitmq-quarum/stream_error2.png\" alt=\"aoto ack\"></p>\n</li>\n<li><p>必须设置prefetchCount<br>流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用<br><img src=\"/blog/images/rabbitmq-quarum/stream_error1.png\" alt=\"prefetchCount\"></p>\n</li>\n<li><p>durable必须设置为true<br>与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。</p>\n</li>\n</ol>\n<h1 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h1><p>在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：</p>\n<ol>\n<li>经典队列：<ul>\n<li>适合大多数常规的消息传递需求。</li>\n<li>需要较高的性能和可靠性，但不需要特别高的数据一致性要求。</li>\n</ul>\n</li>\n<li>仲裁队列：<ul>\n<li>适用于对数据一致性和高可用性要求较高的场景。</li>\n<li>需要确保消息不丢失且能够在多节点间保持数据一致性。</li>\n</ul>\n</li>\n<li>流式队列：<ul>\n<li>适合处理大规模实时数据流和高吞吐量的场景。</li>\n<li>需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/quorum-queues\">Quorum Queues</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>RabbitMQ 是一个强大的消息队列系统，它提供了多种队列类型以满足不同的使用需求。本文将探讨三种主要队列类型：经典队列、仲裁队列和流式队列，并讨论它们的区别和选型建议。</p>\n<h1 id=\"经典队列（Classic-Queues）\"><a href=\"#经典队列（Classic-Queues）\" class=\"headerlink\" title=\"经典队列（Classic Queues）\"></a>经典队列（Classic Queues）</h1><h2 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>经典队列是 RabbitMQ 中最早期也是最常用的一种队列类型。它们具有良好的性能和稳定性，适合大多数常规的消息传递场景。</p>\n<h2 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在磁盘或内存中，支持持久化。</li>\n<li>消息传递：一旦消息被消费者确认，消息会从队列中删除。</li>\n<li>性能：性能相对较高，但在高并发和大消息量场景下，可能会遇到瓶颈。</li>\n<li>高可用性：支持镜像队列，实现高可用性。镜像队列中的消息会复制到多个节点，以防单节点故障。</li>\n</ul>\n<h2 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><p>适合大多数常规消息传递场景，如任务调度、事件通知等。<br>当需要消息的持久化存储和高可靠性时，经典队列是一个很好的选择。</p>\n<h1 id=\"仲裁队列（Quorum-Queues）\"><a href=\"#仲裁队列（Quorum-Queues）\" class=\"headerlink\" title=\"仲裁队列（Quorum Queues）\"></a>仲裁队列（Quorum Queues）</h1><h2 id=\"简介：-1\"><a href=\"#简介：-1\" class=\"headerlink\" title=\"简介：\"></a>简介：</h2><p>仲裁队列是一种基于 Raft 协议实现的新型队列，专为提高数据一致性和可靠性而设计。</p>\n<h2 id=\"特点：-1\"><a href=\"#特点：-1\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息存储在多个节点上，采用 Raft 协议确保数据一致性。</li>\n<li>高可用性：天然支持高可用性，通过多节点复制实现数据冗余。</li>\n<li>数据一致性：仲裁队列确保每条消息在多个副本之间的一致性，避免单点故障导致的数据丢失。</li>\n<li>性能：由于需要确保数据一致性，性能可能比经典队列略低，适合对数据一致性要求较高的场景。</li>\n</ul>\n<h2 id=\"适用场景：-1\"><a href=\"#适用场景：-1\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于对数据一致性和高可用性要求较高的场景，如金融交易、订单处理等关键业务系统。</li>\n<li>在需要确保消息不丢失且需要高可用性的情况下，仲裁队列是一个理想选择。</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>仲裁队列只能声明为持久的<br>仲裁队列只能被声明为持久的，否则会引发以下错误消息：<br>：server_initiated_close，406，“PRECONDITION_FAILED - 队列‘my-quorum-queue’的属性‘non-durable’无效</li>\n</ol>\n<p>Quorum 队列具有一些特殊功能和限制。它们不能是非持久的，因为 Raft 日志始终写入磁盘，因此它们永远不能被声明为瞬态的。从 3.8.2 开始，它们也不支持消息 TTL 和消息优先级 2。</p>\n<ol start=\"2\">\n<li>仲裁队列的消息默认就是持久化的<br>对mq熟悉的老铁应该知道，队列的持久化和消息的持久化是分开的。一般情况下如果不对消息声明为持久化的，服务重启之后消息就会丢失。但是仲裁队列默认消息就是持久化的。</li>\n</ol>\n<p>下面我手撸了一个简单的demo，同时给经典队列和仲裁队列各发送一条消息。<br><img src=\"/blog/images/rabbitmq-quarum/quarum1.png\" alt=\"重启前\"><br>然后我们重启服务，发现经典队列的消息已经丢失了，但是仲裁队列的消息还在队列中。<br><img src=\"/blog/images/rabbitmq-quarum/quarum2.png\" alt=\"重启后\"></p>\n<h2 id=\"仲裁队列-VS-经典队列\"><a href=\"#仲裁队列-VS-经典队列\" class=\"headerlink\" title=\"仲裁队列 VS 经典队列\"></a>仲裁队列 VS 经典队列</h2><h3 id=\"数据一致性\"><a href=\"#数据一致性\" class=\"headerlink\" title=\"数据一致性\"></a>数据一致性</h3><p>仲裁队列使用 Raft 共识算法来确保数据的一致性。即使在单节点情况下，仲裁队列也会严格遵循日志记录和确认机制，确保消息的顺序和一致性。而经典队列在单节点情况下可能会因节点故障导致数据丢失或不一致。</p>\n<h3 id=\"数据可靠性\"><a href=\"#数据可靠性\" class=\"headerlink\" title=\"数据可靠性\"></a>数据可靠性</h3><p>仲裁队列会将每条消息记录到持久存储中，确保即使在系统崩溃后，消息也不会丢失。经典队列虽然也支持消息持久化，但其可靠性依赖于消息写入磁盘的速度和节点的稳定性。</p>\n<h1 id=\"流式队列（Stream-Queues）\"><a href=\"#流式队列（Stream-Queues）\" class=\"headerlink\" title=\"流式队列（Stream Queues）\"></a>流式队列（Stream Queues）</h1><p>流式队列是一种新型队列，专为处理大规模数据流和高吞吐量场景设计。</p>\n<h2 id=\"特点：-2\"><a href=\"#特点：-2\" class=\"headerlink\" title=\"特点：\"></a>特点：</h2><ul>\n<li>存储机制：消息以流的形式存储，可以实现消息的回放和重复消费。</li>\n<li>高吞吐量：设计上优化了高吞吐量和低延迟，适合处理大规模实时数据流。</li>\n<li>数据持久性：消息可以持久化存储，支持长时间的消息保留和回溯。</li>\n<li>订阅机制：支持多种订阅模式，允许多个消费者按需订阅消息流。</li>\n</ul>\n<h2 id=\"什么是消息回放和重复消费？\"><a href=\"#什么是消息回放和重复消费？\" class=\"headerlink\" title=\"什么是消息回放和重复消费？\"></a>什么是消息回放和重复消费？</h2><p>消息回放：允许消费者在任何时间点重新读取过去的消息。这对于需要重现历史事件或进行审计的应用程序特别有用。</p>\n<p>重复消费：消费者可以多次消费同一条消息，这在调试和处理异常时尤为重要。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">InitStreamMQ</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\">    <span class=\"comment\">// 声明流式队列</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-queue-type&quot;</span>, <span class=\"string\">&quot;stream&quot;</span> &#125; &#125;;</span><br><span class=\"line\">    channel.QueueDeclare(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, durable: <span class=\"literal\">true</span>, exclusive: <span class=\"literal\">false</span>, autoDelete: <span class=\"literal\">false</span>, arguments: args);</span><br><span class=\"line\">    channel.QueueBind(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, exchange: <span class=\"string\">&quot;amq.direct&quot;</span>, routingKey: <span class=\"string\">&quot;stream_queue&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;订阅队列&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;subscribe&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SubscribeQuorumMessage</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> factory = <span class=\"keyword\">new</span> ConnectionFactory() &#123; HostName = <span class=\"string\">&quot;localhost&quot;</span>, VirtualHost = <span class=\"string\">&quot;/&quot;</span>, UserName = <span class=\"string\">&quot;user&quot;</span>, Password = <span class=\"string\">&quot;myrabbit&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> connection = factory.CreateConnection();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> channel = connection.CreateModel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.BasicQos(prefetchSize: <span class=\"number\">0</span>, prefetchCount: <span class=\"number\">1</span>, <span class=\"keyword\">global</span>: <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置消费者，从指定的偏移量消费消息</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">    consumer.Received += (model, ea) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * x-stream-offset的可选值有以下几种：</span></span><br><span class=\"line\"><span class=\"comment\">        first: 从日志队列中第一个可消费的消息开始消费</span></span><br><span class=\"line\"><span class=\"comment\">        last: 消费消息日志中最后一个消息</span></span><br><span class=\"line\"><span class=\"comment\">        next: 相当于不指定offset，消费不到消息。</span></span><br><span class=\"line\"><span class=\"comment\">        Offset: 一个数字型的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">        Timestamp:一个代表时间的Data类型变量，表示从这个时间点开始消费。例如 一个小时前 Date timestamp = new Date(System.currentTimeMillis() - 60 * 60 * 1_000)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; &#123; &#123; <span class=\"string\">&quot;x-stream-offset&quot;</span>, <span class=\"number\">2</span> &#125; &#125;;</span><br><span class=\"line\">    channel.BasicConsume(queue: <span class=\"string\">&quot;stream_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, arguments: args, consumer: consumer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我们往流式队列里面发送了10条消息但是每次消费的时候都从第3条消息(offset为2)开始消费.<br><img src=\"/blog/images/rabbitmq-quarum/stream_offset.png\" alt=\"offset\"></p>\n<h2 id=\"流式队列的工作原理\"><a href=\"#流式队列的工作原理\" class=\"headerlink\" title=\"流式队列的工作原理\"></a>流式队列的工作原理</h2><p>流式队列的工作方式类似于日志系统（如 Apache Kafka）。消息按照顺序追加到队列的末尾，并保存在磁盘上。每个消息都有一个唯一的偏移量（offset），消费者可以通过指定偏移量来读取特定的消息或重新消费消息。</p>\n<h2 id=\"适用场景：-2\"><a href=\"#适用场景：-2\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h2><ul>\n<li>适用于实时数据分析、日志处理、实时监控等场景。</li>\n<li>在需要处理大规模数据流和高吞吐量的场景下，流式队列是一个合适的选择。</li>\n</ul>\n<h2 id=\"PS\"><a href=\"#PS\" class=\"headerlink\" title=\"PS\"></a>PS</h2><ol>\n<li><p>Auto-Ack 必须为 false<br>在流式队列中，为了确保消息的可靠性和能够实现消息回放，自动确认（autoAck）必须设置为 false。自动确认会导致消息一旦被消费即刻从队列中移除，失去消息的持久性和回放功能。<br><img src=\"/blog/images/rabbitmq-quarum/stream_error2.png\" alt=\"aoto ack\"></p>\n</li>\n<li><p>必须设置prefetchCount<br>流式队列（Stream Queue）在 RabbitMQ 中主要设计用于高吞吐量和低延迟的消息传输。设置 prefetchCount（每次发送给消费者的消息数量）是为了优化流式队列的性能和资源使用<br><img src=\"/blog/images/rabbitmq-quarum/stream_error1.png\" alt=\"prefetchCount\"></p>\n</li>\n<li><p>durable必须设置为true<br>与Quorum队列类似， Stream队列的durable参数必须声明为true，exclusive参数必须声明为false。这其中，x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。</p>\n</li>\n</ol>\n<h1 id=\"选型建议\"><a href=\"#选型建议\" class=\"headerlink\" title=\"选型建议\"></a>选型建议</h1><p>在选择 RabbitMQ 队列类型时，需要根据具体的业务需求和场景来决定。以下是一些选型建议：</p>\n<ol>\n<li>经典队列：<ul>\n<li>适合大多数常规的消息传递需求。</li>\n<li>需要较高的性能和可靠性，但不需要特别高的数据一致性要求。</li>\n</ul>\n</li>\n<li>仲裁队列：<ul>\n<li>适用于对数据一致性和高可用性要求较高的场景。</li>\n<li>需要确保消息不丢失且能够在多节点间保持数据一致性。</li>\n</ul>\n</li>\n<li>流式队列：<ul>\n<li>适合处理大规模实时数据流和高吞吐量的场景。</li>\n<li>需要消息的回放和重复消费功能，适用于实时数据分析和日志处理等场景。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过了解经典队列、仲裁队列和流式队列的特点和应用场景，能够更好地选择适合自己业务需求的队列类型。在实际应用中，可以根据具体的业务需求和性能要求，灵活地选择和配置 RabbitMQ 队列，以实现最佳的消息传递效果。</p>\n<p>参考文档<br><a href=\"https://www.rabbitmq.com/docs/quorum-queues\">Quorum Queues</a></p>\n"},{"title":"Rspack：一个新一代的 JavaScript 打包工具","date":"2024-11-29T07:50:26.000Z","_content":"\n在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。\n\n在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。\n\n![background](./images/rspack/bg.png)\n\n# 什么是 Rspack？\nRspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。\n\nRspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。\n\n# Rspack 的核心特点\n1. 更快的构建速度\nRspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。\n\n2. 基于 Rust 的高性能编译\nRspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。\n\n3. 高效的代码拆分\nRspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。\n\n4. 灵活的配置\n与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。\n\n说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。\nRspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。\nRspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。\n\n# 示例：使用 Rspack 构建一个简单的项目\n既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。\n这里我们直接采用官方Vue2的示例进行测试[参考示例](https://github.com/rspack-contrib/rspack-examples)。\n\nrspack.config.js\n```\nconst rspack = require('@rspack/core');\nconst { VueLoaderPlugin } = require('vue-loader');\n\n/** @type {import('@rspack/cli').Configuration} */\nconst config = {\n  context: __dirname,\n  entry: {\n    main: './src/main.js',\n  },\n  experiments: {\n    css: true,\n  },\n  devServer: {\n    historyApiFallback: true,\n  },\n  devtool: false,\n  plugins: [\n    new VueLoaderPlugin(),\n    new rspack.HtmlRspackPlugin({\n      template: './index.html',\n    }),\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        use: [\n          {\n            loader: 'vue-loader',\n            options: {\n              experimentalInlineMatchResource: true,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        loader: 'less-loader',\n        type: 'css',\n      },\n      {\n        test: /\\.svg$/,\n        type: 'asset/resource',\n      },\n    ],\n  },\n};\nmodule.exports = config;\n```\nwebpack.config.js\n```\nconst {VueLoaderPlugin} = require(\"vue-loader\");\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst config = {\n    context: __dirname,\n    entry: {\n        main: './src/main.js',\n    },\n    experiments: {\n        css: true,\n    },\n    devServer: {\n        historyApiFallback: true,\n    },\n    devtool: false,\n    plugins: [\n        new VueLoaderPlugin(),\n        new HtmlWebpackPlugin({ template: './index.html' }),\n    ],\n    module: {\n        rules: [\n            {\n                test: /\\.vue$/,\n                use: [\n                    {\n                        loader: 'vue-loader',\n                        options: {\n                            experimentalInlineMatchResource: true,\n                        },\n                    },\n                ],\n            },\n            {\n                test: /\\.less$/,\n                loader: 'less-loader',\n                type: 'css',\n            },\n            {\n                test: /\\.svg$/,\n                type: 'asset/resource',\n            },\n        ],\n    },\n};\nmodule.exports = config;\n```\n在wsl里面，分别执行以下命令进行构建：\n```\ntime npx rspack --config rspack.config.js --mode production\n```\n最后我们简单对比一下时间：\n![时间对比](./images/rspack/result1.png)\n\n# Rspack 的优点：对比 Webpack\n1. 构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。\n\n2. 内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。\n\n3. 智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。\n\n4. 灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。\n\n    >由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。\n\n    ![工具栈](./images/rspack/tools.png)\n\n# 结语\nRspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。\n\n如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。\n\n这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。\n\n","source":"_posts/rspack.md","raw":"---\ntitle: Rspack：一个新一代的 JavaScript 打包工具\ndate: 2024-11-29 15:50:26\ntags:\n---\n\n在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。\n\n在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。\n\n![background](./images/rspack/bg.png)\n\n# 什么是 Rspack？\nRspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。\n\nRspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。\n\n# Rspack 的核心特点\n1. 更快的构建速度\nRspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。\n\n2. 基于 Rust 的高性能编译\nRspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。\n\n3. 高效的代码拆分\nRspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。\n\n4. 灵活的配置\n与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。\n\n说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。\nRspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。\nRspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。\n\n# 示例：使用 Rspack 构建一个简单的项目\n既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。\n这里我们直接采用官方Vue2的示例进行测试[参考示例](https://github.com/rspack-contrib/rspack-examples)。\n\nrspack.config.js\n```\nconst rspack = require('@rspack/core');\nconst { VueLoaderPlugin } = require('vue-loader');\n\n/** @type {import('@rspack/cli').Configuration} */\nconst config = {\n  context: __dirname,\n  entry: {\n    main: './src/main.js',\n  },\n  experiments: {\n    css: true,\n  },\n  devServer: {\n    historyApiFallback: true,\n  },\n  devtool: false,\n  plugins: [\n    new VueLoaderPlugin(),\n    new rspack.HtmlRspackPlugin({\n      template: './index.html',\n    }),\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        use: [\n          {\n            loader: 'vue-loader',\n            options: {\n              experimentalInlineMatchResource: true,\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        loader: 'less-loader',\n        type: 'css',\n      },\n      {\n        test: /\\.svg$/,\n        type: 'asset/resource',\n      },\n    ],\n  },\n};\nmodule.exports = config;\n```\nwebpack.config.js\n```\nconst {VueLoaderPlugin} = require(\"vue-loader\");\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst config = {\n    context: __dirname,\n    entry: {\n        main: './src/main.js',\n    },\n    experiments: {\n        css: true,\n    },\n    devServer: {\n        historyApiFallback: true,\n    },\n    devtool: false,\n    plugins: [\n        new VueLoaderPlugin(),\n        new HtmlWebpackPlugin({ template: './index.html' }),\n    ],\n    module: {\n        rules: [\n            {\n                test: /\\.vue$/,\n                use: [\n                    {\n                        loader: 'vue-loader',\n                        options: {\n                            experimentalInlineMatchResource: true,\n                        },\n                    },\n                ],\n            },\n            {\n                test: /\\.less$/,\n                loader: 'less-loader',\n                type: 'css',\n            },\n            {\n                test: /\\.svg$/,\n                type: 'asset/resource',\n            },\n        ],\n    },\n};\nmodule.exports = config;\n```\n在wsl里面，分别执行以下命令进行构建：\n```\ntime npx rspack --config rspack.config.js --mode production\n```\n最后我们简单对比一下时间：\n![时间对比](./images/rspack/result1.png)\n\n# Rspack 的优点：对比 Webpack\n1. 构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。\n\n2. 内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。\n\n3. 智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。\n\n4. 灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。\n\n    >由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。\n\n    ![工具栈](./images/rspack/tools.png)\n\n# 结语\nRspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。\n\n如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。\n\n这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。\n\n","slug":"rspack","published":1,"updated":"2024-11-29T08:33:25.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawm001arkp1cslq1wqo","content":"<p>在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。</p>\n<p>在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。</p>\n<p><img src=\"/blog/./images/rspack/bg.png\" alt=\"background\"></p>\n<h1 id=\"什么是-Rspack？\"><a href=\"#什么是-Rspack？\" class=\"headerlink\" title=\"什么是 Rspack？\"></a>什么是 Rspack？</h1><p>Rspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。</p>\n<p>Rspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。</p>\n<h1 id=\"Rspack-的核心特点\"><a href=\"#Rspack-的核心特点\" class=\"headerlink\" title=\"Rspack 的核心特点\"></a>Rspack 的核心特点</h1><ol>\n<li><p>更快的构建速度<br>Rspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。</p>\n</li>\n<li><p>基于 Rust 的高性能编译<br>Rspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。</p>\n</li>\n<li><p>高效的代码拆分<br>Rspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。</p>\n</li>\n<li><p>灵活的配置<br>与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。</p>\n</li>\n</ol>\n<p>说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。<br>Rspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。<br>Rspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。</p>\n<h1 id=\"示例：使用-Rspack-构建一个简单的项目\"><a href=\"#示例：使用-Rspack-构建一个简单的项目\" class=\"headerlink\" title=\"示例：使用 Rspack 构建一个简单的项目\"></a>示例：使用 Rspack 构建一个简单的项目</h1><p>既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。<br>这里我们直接采用官方Vue2的示例进行测试<a href=\"https://github.com/rspack-contrib/rspack-examples\">参考示例</a>。</p>\n<p>rspack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const rspack = require(&#x27;@rspack/core&#x27;);</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/** @type &#123;import(&#x27;@rspack/cli&#x27;).Configuration&#125; */</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">  context: __dirname,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  experiments: &#123;</span><br><span class=\"line\">    css: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    historyApiFallback: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: false,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new VueLoaderPlugin(),</span><br><span class=\"line\">    new rspack.HtmlRspackPlugin(&#123;</span><br><span class=\"line\">      template: &#x27;./index.html&#x27;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              experimentalInlineMatchResource: true,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.less$/,</span><br><span class=\"line\">        loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">        type: &#x27;css&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.svg$/,</span><br><span class=\"line\">        type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;VueLoaderPlugin&#125; = require(&quot;vue-loader&quot;);</span><br><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">    context: __dirname,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    experiments: &#123;</span><br><span class=\"line\">        css: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        historyApiFallback: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: false,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        new VueLoaderPlugin(),</span><br><span class=\"line\">        new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27; &#125;),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.vue$/,</span><br><span class=\"line\">                use: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">                        options: &#123;</span><br><span class=\"line\">                            experimentalInlineMatchResource: true,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                ],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.less$/,</span><br><span class=\"line\">                loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">                type: &#x27;css&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.svg$/,</span><br><span class=\"line\">                type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>在wsl里面，分别执行以下命令进行构建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time npx rspack --config rspack.config.js --mode production</span><br></pre></td></tr></table></figure>\n<p>最后我们简单对比一下时间：<br><img src=\"/blog/./images/rspack/result1.png\" alt=\"时间对比\"></p>\n<h1 id=\"Rspack-的优点：对比-Webpack\"><a href=\"#Rspack-的优点：对比-Webpack\" class=\"headerlink\" title=\"Rspack 的优点：对比 Webpack\"></a>Rspack 的优点：对比 Webpack</h1><ol>\n<li><p>构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。</p>\n</li>\n<li><p>内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。</p>\n</li>\n<li><p>智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。</p>\n</li>\n<li><p>灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。</p>\n<blockquote>\n<p>由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。</p>\n</blockquote>\n<p> <img src=\"/blog/./images/rspack/tools.png\" alt=\"工具栈\"></p>\n</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Rspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。</p>\n<p>如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。</p>\n<p>这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前端开发中，构建工具的选择一直是开发效率和性能优化的关键因素之一。Webpack 一直是前端开发中最流行的构建工具之一，但随着项目越来越复杂和构建时间的增加，开发者们开始寻找性能更强、更轻量的替代品。Rspack 就是应运而生的这样一款工具，它不仅继承了 Webpack 的思想，还通过一系列创新的优化大大提升了构建速度。</p>\n<p>在这篇博客中，我们将介绍 Rspack，并通过一些实际示例来展示它相对于传统构建工具的优势。</p>\n<p><img src=\"/blog/./images/rspack/bg.png\" alt=\"background\"></p>\n<h1 id=\"什么是-Rspack？\"><a href=\"#什么是-Rspack？\" class=\"headerlink\" title=\"什么是 Rspack？\"></a>什么是 Rspack？</h1><p>Rspack 是一个由 ByteDance 推出的高性能构建工具。它旨在通过使用更先进的技术栈和优化算法，解决 Webpack 在大型项目中的构建性能瓶颈。Rspack 的设计目标是实现“秒级构建”，使开发者能够专注于代码而非等待构建过程。</p>\n<p>Rspack 与 Webpack 相似，但其更强大的性能和优化策略，使得它在大型前端应用的构建中尤为适用。Rspack 目前对 ES 模块、TypeScript、React 等前端技术有很好的支持。</p>\n<h1 id=\"Rspack-的核心特点\"><a href=\"#Rspack-的核心特点\" class=\"headerlink\" title=\"Rspack 的核心特点\"></a>Rspack 的核心特点</h1><ol>\n<li><p>更快的构建速度<br>Rspack 最突出的特点就是其极致的构建速度。相比 Webpack，Rspack 在内存缓存、模块解析、代码拆分等多个方面做了优化，使得它在构建速度上有了显著的提升。</p>\n</li>\n<li><p>基于 Rust 的高性能编译<br>Rspack 使用 Rust 语言编写了其核心模块，因此在计算密集型的任务（例如文件打包和模块解析）上，比 JavaScript 实现要快得多。Rust 本身的高性能特性使得 Rspack 在构建过程中能够更高效地处理大量的模块和复杂的依赖关系。</p>\n</li>\n<li><p>高效的代码拆分<br>Rspack 支持比 Webpack 更细粒度的代码拆分策略，可以智能地拆分代码块，避免不必要的冗余代码加载，提高页面的加载速度。</p>\n</li>\n<li><p>灵活的配置<br>与 Webpack 相似，Rspack 提供了灵活的配置选项，但是其配置方式更简洁，降低了学习曲线。你可以通过类似 Webpack 的配置方式进行设置，同时它也支持一些新的功能和优化选项。</p>\n</li>\n</ol>\n<p>说Rspack快，但是，它的最大优势还不是快，而是 Webpack 的无缝替换。你基本上不需要改动配置，直接把配置文件webpack.config.js改名为rspack.config.js即可。<br>Rspack 不仅兼容 Webpack 的语法，还兼容插件。根据官方文档，下载量最高的50个 Webpack 插件，大部分可以直接使用。<br>Rspack 团队为了保证兼容性，向 Webpack 官方仓库做了100多次提交。甚至 Webpack 的主要维护者之一的 Alexander Akait 亲自动手，让很多插件可以在 Rspack 正常运行。</p>\n<h1 id=\"示例：使用-Rspack-构建一个简单的项目\"><a href=\"#示例：使用-Rspack-构建一个简单的项目\" class=\"headerlink\" title=\"示例：使用 Rspack 构建一个简单的项目\"></a>示例：使用 Rspack 构建一个简单的项目</h1><p>既然说Rspack快，那到底有多快呢？让我们简单写个例子来验证一下。<br>这里我们直接采用官方Vue2的示例进行测试<a href=\"https://github.com/rspack-contrib/rspack-examples\">参考示例</a>。</p>\n<p>rspack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const rspack = require(&#x27;@rspack/core&#x27;);</span><br><span class=\"line\">const &#123; VueLoaderPlugin &#125; = require(&#x27;vue-loader&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/** @type &#123;import(&#x27;@rspack/cli&#x27;).Configuration&#125; */</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">  context: __dirname,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  experiments: &#123;</span><br><span class=\"line\">    css: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    historyApiFallback: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: false,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new VueLoaderPlugin(),</span><br><span class=\"line\">    new rspack.HtmlRspackPlugin(&#123;</span><br><span class=\"line\">      template: &#x27;./index.html&#x27;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              experimentalInlineMatchResource: true,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.less$/,</span><br><span class=\"line\">        loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">        type: &#x27;css&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.svg$/,</span><br><span class=\"line\">        type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;VueLoaderPlugin&#125; = require(&quot;vue-loader&quot;);</span><br><span class=\"line\">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">    context: __dirname,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        main: &#x27;./src/main.js&#x27;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    experiments: &#123;</span><br><span class=\"line\">        css: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devServer: &#123;</span><br><span class=\"line\">        historyApiFallback: true,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: false,</span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        new VueLoaderPlugin(),</span><br><span class=\"line\">        new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27; &#125;),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.vue$/,</span><br><span class=\"line\">                use: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        loader: &#x27;vue-loader&#x27;,</span><br><span class=\"line\">                        options: &#123;</span><br><span class=\"line\">                            experimentalInlineMatchResource: true,</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                ],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.less$/,</span><br><span class=\"line\">                loader: &#x27;less-loader&#x27;,</span><br><span class=\"line\">                type: &#x27;css&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.svg$/,</span><br><span class=\"line\">                type: &#x27;asset/resource&#x27;,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p>在wsl里面，分别执行以下命令进行构建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">time npx rspack --config rspack.config.js --mode production</span><br></pre></td></tr></table></figure>\n<p>最后我们简单对比一下时间：<br><img src=\"/blog/./images/rspack/result1.png\" alt=\"时间对比\"></p>\n<h1 id=\"Rspack-的优点：对比-Webpack\"><a href=\"#Rspack-的优点：对比-Webpack\" class=\"headerlink\" title=\"Rspack 的优点：对比 Webpack\"></a>Rspack 的优点：对比 Webpack</h1><ol>\n<li><p>构建速度快： Rspack 的最大优势之一是其极速构建能力。与 Webpack 相比，Rspack 在大型项目中的构建速度明显更快，特别是在首次构建和增量构建时，Rspack 能够快速完成任务，极大地提高开发效率。</p>\n</li>\n<li><p>内存优化： Rspack 在内存使用方面做了大量优化，通过高效的内存管理和模块缓存机制，减少了构建过程中的内存消耗。这使得它在面对大型项目时更加稳定，避免了 Webpack 常见的内存溢出问题。</p>\n</li>\n<li><p>智能的代码拆分和优化： Rspack 在代码拆分上比 Webpack 更加智能。它可以根据应用的需求，灵活地拆分代码，从而避免了冗余代码的加载，优化了应用的加载速度。</p>\n</li>\n<li><p>灵活的配置和易用性： 虽然 Rspack 功能强大，但它的配置更加简洁，开发者可以快速上手。相比 Webpack，Rspack 提供了更多开箱即用的优化策略，降低了配置的复杂度。</p>\n<blockquote>\n<p>由于全盘继承 Webpack，Rspack 也同时继承了前者的体验问题：配置麻烦，上手不算容易。开发团队为了解决这个问题，在 Rspack 的基础上，封装了一系列更简单易用的衍生工具。</p>\n</blockquote>\n<p> <img src=\"/blog/./images/rspack/tools.png\" alt=\"工具栈\"></p>\n</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Rspack 是一款极具潜力的构建工具，特别适合那些对构建速度和性能有较高要求的前端开发者。它不仅在构建速度上超越了 Webpack，还通过采用 Rust 和其他先进的技术，优化了内存使用和模块处理。对于正在寻找替代 Webpack 的开发者，Rspack 是一个值得尝试的选择。</p>\n<p>如果你正在为一个大型项目寻求更高效的构建工具，不妨考虑将 Rspack 作为你的下一代构建工具，享受秒级构建的效率提升，提升开发体验。</p>\n<p>这篇博客介绍了 Rspack 的基本特点、配置方法和性能优势，通过实际的代码示例让读者更加直观地了解其使用过程和性能优越性。如果你想根据实际项目的需求进行优化，Rspack 提供了很多灵活的配置选项，帮助你在构建速度和代码质量之间找到最佳平衡点。</p>\n"},{"title":"从零开始搭建自己的相似图片搜索引擎","date":"2024-05-30T08:02:51.000Z","_content":"\n之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。\n功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。\n\n本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n![流程](/images/image-search/process.png)\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。\n从WB获取图片，保存到本地，那么我们第一步就算是完成了。\n\n  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。\n\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n# 嵌入\n这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。\n\n我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B/32 变体。\n详细的文档可以参考[《clip》](https://github.com/openai/CLIP)\n```python\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\n\n# 创建或获取一个集合\ncollection_name = 'image_vectors'\n\n# 遍历图片文件夹中的所有图片\nfor image_name in os.listdir(source_folder):\n    image_path = os.path.join(source_folder, image_name)\n    \n    # 确保文件是图片\n    if os.path.isfile(image_path) and image_name.lower().endswith(('png', 'jpg', 'jpeg', 'bmp', 'gif')):\n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 搜索相似结果\n        point = rest.PointStruct(\n            id=point_id,\n            vector=image_features,\n            payload={'file_name': image_name}\n        )\n        \n        # 将向量存储到Qdrant\n\n        # TODO 移动图片到目标文件夹        \n```\n做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。\n![图片](/images/image-search/qdrant.png)\n\n# 前端页面\n既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。\n所以我们的主要实现步骤有一下几个：\n1. 上传图片；\n2. 计算图片向量；\n3. 搜索相似图片；\n4. 返回相似图片；\n\n为了快速兑现功能，这里我也直接用python实现了一个简单的demo\n```python\napp = Flask(__name__)\nUPLOAD_FOLDER = 'uploads'\nCLIPPED_FOLDER = 'image_scraper/images/clipped'\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\ncollection_name = 'image_vectors'\n\n# 检查集合是否存在，如果不存在则创建\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return \"No file part\", 400\n    file = request.files['file']\n    if file.filename == '':\n        return \"No selected file\", 400\n    if file and allowed_file(file.filename):\n        \n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 在Qdrant中搜索相似图片\n        search_result = qdrant_client.search(\n            collection_name=collection_name,\n            query_vector=image_features,\n            limit=5  # 设置返回的结果数量\n        )\n\n        # 获取相似图片的文件名\n        similar_images = [hit.payload['file_name'] for hit in search_result]\n        \n        return render_template('result.html', images=similar_images)\n    return \"File not allowed\", 400\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n```\n\n\n最终的结果，大功告成！\n![图片](/images/image-search/search.gif)\n\n# 总结\n通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。\n\n这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。\n\n希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/similar-image-search.md","raw":"---\ntitle: 从零开始搭建自己的相似图片搜索引擎\ndate: 2024-05-30 16:02:51\ntags:\n---\n\n之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。\n功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。\n\n本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n![流程](/images/image-search/process.png)\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。\n从WB获取图片，保存到本地，那么我们第一步就算是完成了。\n\n  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。\n\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n# 嵌入\n这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。\n\n我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B/32 变体。\n详细的文档可以参考[《clip》](https://github.com/openai/CLIP)\n```python\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\n\n# 创建或获取一个集合\ncollection_name = 'image_vectors'\n\n# 遍历图片文件夹中的所有图片\nfor image_name in os.listdir(source_folder):\n    image_path = os.path.join(source_folder, image_name)\n    \n    # 确保文件是图片\n    if os.path.isfile(image_path) and image_name.lower().endswith(('png', 'jpg', 'jpeg', 'bmp', 'gif')):\n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 搜索相似结果\n        point = rest.PointStruct(\n            id=point_id,\n            vector=image_features,\n            payload={'file_name': image_name}\n        )\n        \n        # 将向量存储到Qdrant\n\n        # TODO 移动图片到目标文件夹        \n```\n做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。\n![图片](/images/image-search/qdrant.png)\n\n# 前端页面\n既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。\n所以我们的主要实现步骤有一下几个：\n1. 上传图片；\n2. 计算图片向量；\n3. 搜索相似图片；\n4. 返回相似图片；\n\n为了快速兑现功能，这里我也直接用python实现了一个简单的demo\n```python\napp = Flask(__name__)\nUPLOAD_FOLDER = 'uploads'\nCLIPPED_FOLDER = 'image_scraper/images/clipped'\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n\n# 初始化OpenCLIP模型\nmodel = open_clip.create_model('ViT-B-32', pretrained='openai')\npreprocess = open_clip.image_transform(model.visual.image_size, is_train=False)\n\n# 初始化Qdrant客户端\nqdrant_client = QdrantClient(host='localhost', port=6333)\ncollection_name = 'image_vectors'\n\n# 检查集合是否存在，如果不存在则创建\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return \"No file part\", 400\n    file = request.files['file']\n    if file.filename == '':\n        return \"No selected file\", 400\n    if file and allowed_file(file.filename):\n        \n        # 加载图片并进行预处理\n\n        # 获取图片向量\n\n        # 在Qdrant中搜索相似图片\n        search_result = qdrant_client.search(\n            collection_name=collection_name,\n            query_vector=image_features,\n            limit=5  # 设置返回的结果数量\n        )\n\n        # 获取相似图片的文件名\n        similar_images = [hit.payload['file_name'] for hit in search_result]\n        \n        return render_template('result.html', images=similar_images)\n    return \"File not allowed\", 400\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n```\n\n\n最终的结果，大功告成！\n![图片](/images/image-search/search.gif)\n\n# 总结\n通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。\n\n这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。\n\n希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"similar-image-search","published":1,"updated":"2024-06-07T15:31:38.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawm001brkp182s99gvg","content":"<p>之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。<br>功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。</p>\n<p>本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；<br><img src=\"/blog/images/image-search/process.png\" alt=\"流程\"></li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。<br>从WB获取图片，保存到本地，那么我们第一步就算是完成了。</p>\n<p>  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。</p>\n<p>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/blog/images/image-search/images.png\" alt=\"图片\"></p>\n<h1 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h1><p>这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。</p>\n<p>我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B&#x2F;32 变体。<br>详细的文档可以参考<a href=\"https://github.com/openai/CLIP\">《clip》</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建或获取一个集合</span></span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历图片文件夹中的所有图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> image_name <span class=\"keyword\">in</span> os.listdir(source_folder):</span><br><span class=\"line\">    image_path = os.path.join(source_folder, image_name)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 确保文件是图片</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.isfile(image_path) <span class=\"keyword\">and</span> image_name.lower().endswith((<span class=\"string\">&#x27;png&#x27;</span>, <span class=\"string\">&#x27;jpg&#x27;</span>, <span class=\"string\">&#x27;jpeg&#x27;</span>, <span class=\"string\">&#x27;bmp&#x27;</span>, <span class=\"string\">&#x27;gif&#x27;</span>)):</span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 搜索相似结果</span></span><br><span class=\"line\">        point = rest.PointStruct(</span><br><span class=\"line\">            <span class=\"built_in\">id</span>=point_id,</span><br><span class=\"line\">            vector=image_features,</span><br><span class=\"line\">            payload=&#123;<span class=\"string\">&#x27;file_name&#x27;</span>: image_name&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将向量存储到Qdrant</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># TODO 移动图片到目标文件夹        </span></span><br></pre></td></tr></table></figure>\n<p>做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。<br><img src=\"/blog/images/image-search/qdrant.png\" alt=\"图片\"></p>\n<h1 id=\"前端页面\"><a href=\"#前端页面\" class=\"headerlink\" title=\"前端页面\"></a>前端页面</h1><p>既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。<br>所以我们的主要实现步骤有一下几个：</p>\n<ol>\n<li>上传图片；</li>\n<li>计算图片向量；</li>\n<li>搜索相似图片；</li>\n<li>返回相似图片；</li>\n</ol>\n<p>为了快速兑现功能，这里我也直接用python实现了一个简单的demo</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">UPLOAD_FOLDER = <span class=\"string\">&#x27;uploads&#x27;</span></span><br><span class=\"line\">CLIPPED_FOLDER = <span class=\"string\">&#x27;image_scraper/images/clipped&#x27;</span></span><br><span class=\"line\">os.makedirs(UPLOAD_FOLDER, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查集合是否存在，如果不存在则创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;index.html&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/upload&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_file</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;file&#x27;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.files:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No file part&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    file = request.files[<span class=\"string\">&#x27;file&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.filename == <span class=\"string\">&#x27;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No selected file&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> file <span class=\"keyword\">and</span> allowed_file(file.filename):</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 在Qdrant中搜索相似图片</span></span><br><span class=\"line\">        search_result = qdrant_client.search(</span><br><span class=\"line\">            collection_name=collection_name,</span><br><span class=\"line\">            query_vector=image_features,</span><br><span class=\"line\">            limit=<span class=\"number\">5</span>  <span class=\"comment\"># 设置返回的结果数量</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取相似图片的文件名</span></span><br><span class=\"line\">        similar_images = [hit.payload[<span class=\"string\">&#x27;file_name&#x27;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;result.html&#x27;</span>, images=similar_images)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;File not allowed&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>最终的结果，大功告成！<br><img src=\"/blog/images/image-search/search.gif\" alt=\"图片\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。</p>\n<p>这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。</p>\n<p>希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前在HN上看到了一个简单的应用程序，作者从网上抓取了一堆图片并使用嵌入，然后制作了一个简单的“查看类似图片”的应用程序。<br>功能看起来很简单，但是感觉挺有意思的。所以我决定实践一下，通过实践来了解程序是如何运作的。</p>\n<p>本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；<br><img src=\"/blog/images/image-search/process.png\" alt=\"流程\"></li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。这一步我直接用了scrapy的框架来实现。<br>从WB获取图片，保存到本地，那么我们第一步就算是完成了。</p>\n<p>  请注意，WB可能有反爬虫措施，且抓取用户数据需要遵守相关法律法规和网站的服务条款。脚本仅用于学习和个人使用，抓取公共信息。</p>\n<p>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/blog/images/image-search/images.png\" alt=\"图片\"></p>\n<h1 id=\"嵌入\"><a href=\"#嵌入\" class=\"headerlink\" title=\"嵌入\"></a>嵌入</h1><p>这一步可以说是核心步骤了，我们需要将爬取的图片计算向量，保存到向量数据库（qdrant）里面。</p>\n<p>我们将使用 OpenAI 的 CLIP 模型，该模型可以将图像和文本转换为相同空间的向量表示。这里我们使用的是 ViT-B&#x2F;32 变体。<br>详细的文档可以参考<a href=\"https://github.com/openai/CLIP\">《clip》</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建或获取一个集合</span></span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历图片文件夹中的所有图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> image_name <span class=\"keyword\">in</span> os.listdir(source_folder):</span><br><span class=\"line\">    image_path = os.path.join(source_folder, image_name)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 确保文件是图片</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> os.path.isfile(image_path) <span class=\"keyword\">and</span> image_name.lower().endswith((<span class=\"string\">&#x27;png&#x27;</span>, <span class=\"string\">&#x27;jpg&#x27;</span>, <span class=\"string\">&#x27;jpeg&#x27;</span>, <span class=\"string\">&#x27;bmp&#x27;</span>, <span class=\"string\">&#x27;gif&#x27;</span>)):</span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 搜索相似结果</span></span><br><span class=\"line\">        point = rest.PointStruct(</span><br><span class=\"line\">            <span class=\"built_in\">id</span>=point_id,</span><br><span class=\"line\">            vector=image_features,</span><br><span class=\"line\">            payload=&#123;<span class=\"string\">&#x27;file_name&#x27;</span>: image_name&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 将向量存储到Qdrant</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># TODO 移动图片到目标文件夹        </span></span><br></pre></td></tr></table></figure>\n<p>做完上面这些，基本上我们的准备工作就完成了。我们有了一个图片库，然后为所有的图片计算了向量并且保存到了向量数据库里面。<br><img src=\"/blog/images/image-search/qdrant.png\" alt=\"图片\"></p>\n<h1 id=\"前端页面\"><a href=\"#前端页面\" class=\"headerlink\" title=\"前端页面\"></a>前端页面</h1><p>既然说是图片搜索，那么我们就一定需要图片上传的页面。同时根据用户上传的图片再去我们的图片库里面搜索出相似的图片返回给前端。<br>所以我们的主要实现步骤有一下几个：</p>\n<ol>\n<li>上传图片；</li>\n<li>计算图片向量；</li>\n<li>搜索相似图片；</li>\n<li>返回相似图片；</li>\n</ol>\n<p>为了快速兑现功能，这里我也直接用python实现了一个简单的demo</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">UPLOAD_FOLDER = <span class=\"string\">&#x27;uploads&#x27;</span></span><br><span class=\"line\">CLIPPED_FOLDER = <span class=\"string\">&#x27;image_scraper/images/clipped&#x27;</span></span><br><span class=\"line\">os.makedirs(UPLOAD_FOLDER, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化OpenCLIP模型</span></span><br><span class=\"line\">model = open_clip.create_model(<span class=\"string\">&#x27;ViT-B-32&#x27;</span>, pretrained=<span class=\"string\">&#x27;openai&#x27;</span>)</span><br><span class=\"line\">preprocess = open_clip.image_transform(model.visual.image_size, is_train=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化Qdrant客户端</span></span><br><span class=\"line\">qdrant_client = QdrantClient(host=<span class=\"string\">&#x27;localhost&#x27;</span>, port=<span class=\"number\">6333</span>)</span><br><span class=\"line\">collection_name = <span class=\"string\">&#x27;image_vectors&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查集合是否存在，如果不存在则创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;index.html&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/upload&#x27;</span>, methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upload_file</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;file&#x27;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> request.files:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No file part&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    file = request.files[<span class=\"string\">&#x27;file&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.filename == <span class=\"string\">&#x27;&#x27;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;No selected file&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> file <span class=\"keyword\">and</span> allowed_file(file.filename):</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 加载图片并进行预处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取图片向量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 在Qdrant中搜索相似图片</span></span><br><span class=\"line\">        search_result = qdrant_client.search(</span><br><span class=\"line\">            collection_name=collection_name,</span><br><span class=\"line\">            query_vector=image_features,</span><br><span class=\"line\">            limit=<span class=\"number\">5</span>  <span class=\"comment\"># 设置返回的结果数量</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 获取相似图片的文件名</span></span><br><span class=\"line\">        similar_images = [hit.payload[<span class=\"string\">&#x27;file_name&#x27;</span>] <span class=\"keyword\">for</span> hit <span class=\"keyword\">in</span> search_result]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> render_template(<span class=\"string\">&#x27;result.html&#x27;</span>, images=similar_images)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;File not allowed&quot;</span>, <span class=\"number\">400</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>最终的结果，大功告成！<br><img src=\"/blog/images/image-search/search.gif\" alt=\"图片\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述步骤，我们成功搭建了一个简单的相似图片搜索引擎。这个引擎利用了 OpenAI 的 CLIP 模型来生成图像向量嵌入，并使用 qdrant 来构建高效的向量搜索索引。最后，通过 Flask 搭建了一个 Web 服务接口，使得用户可以上传图片并查找相似图片。</p>\n<p>这个项目仅仅是一个开始，你可以根据实际需求进一步优化和扩展。例如，添加更多图片、优化查询速度、增加文本查询功能等。</p>\n<p>希望这篇博客能帮助你更好地理解如何从零开始搭建一个相似图片搜索引擎。如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"解读大型语言模型（LLM）API：了解流式输出的工作原理","date":"2024-11-08T02:09:20.000Z","_content":"\n最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。\n\n![gpt](./images/stream-output/gpt-1.gif)\n\n在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。\n\n----\n\n# 什么是流式输出？\n流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。\n\n传统的API 通常会一次性返回所有数据，然后客户端一次性接收。\n![normal](./images/stream-output/regular-http-communication.png)\n\n流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。\n![stream](./images/stream-output/sse-communication.png)\n\n流式输出通常用于以下几种场景：\n\n- 实时数据更新，例如股票行情、社交媒体的实时消息流。\n- 大数据处理，例如长时间查询或计算的结果逐步传输。\n- 节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。\n\n## 流式 API 的优势\n流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：\n\n+ 实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。\n+ 渐进式加载：减少等待时间，提升交互性。\n+ 流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。\n\n# 流式输出的实现方式\n在具体实现流式输出时，常用的技术包括：\n\n+ HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。\n\n+ Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。\n\n+ WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。\n\n<font color=\"#dd0000\">本文主要讲解SSE的实现。</font>\n\n# SSE数据格式\nServer-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。\n\n![sse](./images/stream-output/sse.gif)\n\n1. SSE 格式的基本结构\nSSE 使用 Content-Type: text/event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：\n\n- data：表示事件的主要数据内容，数据可以是单行或多行。\n- id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。\n- event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。\n- retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。\n2. SSE 数据格式示例\n在每条事件中，字段通过换行分隔，格式如下：\n\n```plaintext\nevent: custom-event\nid: 1\nretry: 5000\ndata: {\"message\": \"Hello, World!\"}\n```\n\n- event：自定义事件名为 custom-event。\n- id：该事件的唯一标识符为 1。\n- retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。\n- data：该事件的主要数据部分为 JSON 字符串 {\"message\": \"Hello, World!\"}。\n每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。\n\n3. 多行数据\ndata 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：\n\n```plaintext\ndata: {\"message\": \"Part 1 of the message\"}\n\ndata: {\"message\": \"Part 2 of the message\"}\n\ndata: {\"message\": \"Part 3 of the message\"}\n```\n\n在客户端收到时，这两行会被拼接成一条数据。\n\n# 示例：使用SSE实现流式输出\n\n 1. 后端实现\n后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：\n```C#\n[HttpPost, HttpGet]\n[ActionTitle(Name = \"聊天\")]\n[Route(\"chat\")]\npublic async Task Completions([FromBody] ChatDto chatDto)\n{\n    Response.ContentType = \"text/event-stream\";\n\n    await foreach( var message in GetStreamingResponseAsync(chatDto.Input) ) {\n        var data = $\"data: {message}\\n\\n\";\n        Console.Write(data);\n        var bytes = Encoding.UTF8.GetBytes(data);\n        await Response.Body.WriteAsync(bytes);\n        await Response.Body.FlushAsync();\n        await Task.Delay(100);\n    }\n}\n\npublic static async IAsyncEnumerable<string> GetStreamingResponseAsync(string userInput)\n{\n    // 随机获取一个配置\n    GptConfig gptConfig = new GptConfig() { \n        ApiKey = \"your-api-key\",\n        Version = \"2023-03-15-preview\"\n    };\n\n    HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, $\"URL_ADDRESS\");\n    request.Headers.Add(\"api-key\", gptConfig.ApiKey);\n\n    var requestBody = new {\n        messages = new[]\n        {\n            new { role = \"user\", content = userInput }\n        },       \n        stream = true\n    };\n\n    var jsonRequestBody = JsonSerializer.Serialize(requestBody);\n    request.Content = new StringContent(jsonRequestBody, Encoding.UTF8, \"application/json\");\n\n    using HttpClient httpClient = new HttpClient();\n\n    using( var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) {\n        response.EnsureSuccessStatusCode();\n        var responseStream = await response.Content.ReadAsStreamAsync();\n\n        using( var reader = new StreamReader(responseStream) ) {\n            while( !reader.EndOfStream ) {\n                var line = await reader.ReadLineAsync();\n                if( !string.IsNullOrWhiteSpace(line) && line.StartsWith(\"data:\") ) {\n                    var jsonData = line.Substring(5).Trim();\n                    if( jsonData == \"[DONE]\" )\n                        break;\n\n                    var data = JsonSerializer.Deserialize<JsonElement>(jsonData);\n\n                    // 检查是否包含 content 字段，避免报错\n                    if( data.TryGetProperty(\"choices\", out var choices) &&\n                        choices[0].TryGetProperty(\"delta\", out var delta) &&\n                        delta.TryGetProperty(\"content\", out var content) ) {\n                        yield return content.GetString();\n                    }\n                }\n            }\n        }\n    }\n\n}\n```\n\n 2. 前端实现\n在前端，我们可以使用 vue3来实现。以下是一个简单的示例：\n```javascript\nchat() {\n    fetch(`/v20/openai/chat`, {\n      method: 'POST',\n      body: JSON.stringify({ input: this.input }),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then((res) => {\n      const reader = res.body.getReader();\n\n      this.handleReadStream(reader)\n    }).finally(() => {\n      this.input = ''\n    })\n\n},\n// 流式对话\nhandleReadStream(stream) {\n  stream.read().then(({ done, value }) => {\n    if (done) {\n      return\n    }\n    const data = new TextDecoder().decode(value)\n    if (!data) {\n      return\n    }\n\n    this.message += data.replaceAll('data: ', '')\n    // 强制 Vue 渲染更新\n    this.$nextTick(() => {\n      console.log(\"Stream updated\");\n    });\n    // 递归处理流\n    this.handleReadStream(stream)\n  })\n},\n```\n 3. 实现效果\n![chat](./images/stream-output/result.gif)\n\n需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。\n![gzip](./images/stream-output/gzip.png)\n```\ndevServer: {\n    port: 9588,\n    compress: false,\n    allowedHosts: \"all\",\n    proxy: {\n      'v20': { target: 'http://localhost:2222', changeOrigin: true },\n    }\n  }\n```\n\n# 结论\n流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。","source":"_posts/stream-output.md","raw":"---\ntitle: 解读大型语言模型（LLM）API：了解流式输出的工作原理\ndate: 2024-11-08 10:09:20\ntags:\n---\n\n最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。\n\n![gpt](./images/stream-output/gpt-1.gif)\n\n在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。\n\n----\n\n# 什么是流式输出？\n流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。\n\n传统的API 通常会一次性返回所有数据，然后客户端一次性接收。\n![normal](./images/stream-output/regular-http-communication.png)\n\n流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。\n![stream](./images/stream-output/sse-communication.png)\n\n流式输出通常用于以下几种场景：\n\n- 实时数据更新，例如股票行情、社交媒体的实时消息流。\n- 大数据处理，例如长时间查询或计算的结果逐步传输。\n- 节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。\n\n## 流式 API 的优势\n流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：\n\n+ 实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。\n+ 渐进式加载：减少等待时间，提升交互性。\n+ 流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。\n\n# 流式输出的实现方式\n在具体实现流式输出时，常用的技术包括：\n\n+ HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。\n\n+ Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。\n\n+ WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。\n\n<font color=\"#dd0000\">本文主要讲解SSE的实现。</font>\n\n# SSE数据格式\nServer-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。\n\n![sse](./images/stream-output/sse.gif)\n\n1. SSE 格式的基本结构\nSSE 使用 Content-Type: text/event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：\n\n- data：表示事件的主要数据内容，数据可以是单行或多行。\n- id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。\n- event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。\n- retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。\n2. SSE 数据格式示例\n在每条事件中，字段通过换行分隔，格式如下：\n\n```plaintext\nevent: custom-event\nid: 1\nretry: 5000\ndata: {\"message\": \"Hello, World!\"}\n```\n\n- event：自定义事件名为 custom-event。\n- id：该事件的唯一标识符为 1。\n- retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。\n- data：该事件的主要数据部分为 JSON 字符串 {\"message\": \"Hello, World!\"}。\n每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。\n\n3. 多行数据\ndata 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：\n\n```plaintext\ndata: {\"message\": \"Part 1 of the message\"}\n\ndata: {\"message\": \"Part 2 of the message\"}\n\ndata: {\"message\": \"Part 3 of the message\"}\n```\n\n在客户端收到时，这两行会被拼接成一条数据。\n\n# 示例：使用SSE实现流式输出\n\n 1. 后端实现\n后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：\n```C#\n[HttpPost, HttpGet]\n[ActionTitle(Name = \"聊天\")]\n[Route(\"chat\")]\npublic async Task Completions([FromBody] ChatDto chatDto)\n{\n    Response.ContentType = \"text/event-stream\";\n\n    await foreach( var message in GetStreamingResponseAsync(chatDto.Input) ) {\n        var data = $\"data: {message}\\n\\n\";\n        Console.Write(data);\n        var bytes = Encoding.UTF8.GetBytes(data);\n        await Response.Body.WriteAsync(bytes);\n        await Response.Body.FlushAsync();\n        await Task.Delay(100);\n    }\n}\n\npublic static async IAsyncEnumerable<string> GetStreamingResponseAsync(string userInput)\n{\n    // 随机获取一个配置\n    GptConfig gptConfig = new GptConfig() { \n        ApiKey = \"your-api-key\",\n        Version = \"2023-03-15-preview\"\n    };\n\n    HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, $\"URL_ADDRESS\");\n    request.Headers.Add(\"api-key\", gptConfig.ApiKey);\n\n    var requestBody = new {\n        messages = new[]\n        {\n            new { role = \"user\", content = userInput }\n        },       \n        stream = true\n    };\n\n    var jsonRequestBody = JsonSerializer.Serialize(requestBody);\n    request.Content = new StringContent(jsonRequestBody, Encoding.UTF8, \"application/json\");\n\n    using HttpClient httpClient = new HttpClient();\n\n    using( var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) {\n        response.EnsureSuccessStatusCode();\n        var responseStream = await response.Content.ReadAsStreamAsync();\n\n        using( var reader = new StreamReader(responseStream) ) {\n            while( !reader.EndOfStream ) {\n                var line = await reader.ReadLineAsync();\n                if( !string.IsNullOrWhiteSpace(line) && line.StartsWith(\"data:\") ) {\n                    var jsonData = line.Substring(5).Trim();\n                    if( jsonData == \"[DONE]\" )\n                        break;\n\n                    var data = JsonSerializer.Deserialize<JsonElement>(jsonData);\n\n                    // 检查是否包含 content 字段，避免报错\n                    if( data.TryGetProperty(\"choices\", out var choices) &&\n                        choices[0].TryGetProperty(\"delta\", out var delta) &&\n                        delta.TryGetProperty(\"content\", out var content) ) {\n                        yield return content.GetString();\n                    }\n                }\n            }\n        }\n    }\n\n}\n```\n\n 2. 前端实现\n在前端，我们可以使用 vue3来实现。以下是一个简单的示例：\n```javascript\nchat() {\n    fetch(`/v20/openai/chat`, {\n      method: 'POST',\n      body: JSON.stringify({ input: this.input }),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then((res) => {\n      const reader = res.body.getReader();\n\n      this.handleReadStream(reader)\n    }).finally(() => {\n      this.input = ''\n    })\n\n},\n// 流式对话\nhandleReadStream(stream) {\n  stream.read().then(({ done, value }) => {\n    if (done) {\n      return\n    }\n    const data = new TextDecoder().decode(value)\n    if (!data) {\n      return\n    }\n\n    this.message += data.replaceAll('data: ', '')\n    // 强制 Vue 渲染更新\n    this.$nextTick(() => {\n      console.log(\"Stream updated\");\n    });\n    // 递归处理流\n    this.handleReadStream(stream)\n  })\n},\n```\n 3. 实现效果\n![chat](./images/stream-output/result.gif)\n\n需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。\n![gzip](./images/stream-output/gzip.png)\n```\ndevServer: {\n    port: 9588,\n    compress: false,\n    allowedHosts: \"all\",\n    proxy: {\n      'v20': { target: 'http://localhost:2222', changeOrigin: true },\n    }\n  }\n```\n\n# 结论\n流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。","slug":"stream-output","published":1,"updated":"2024-11-13T09:40:17.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawm001crkp1bojd3v6y","content":"<p>最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。</p>\n<p><img src=\"/blog/./images/stream-output/gpt-1.gif\" alt=\"gpt\"></p>\n<p>在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。</p>\n<hr>\n<h1 id=\"什么是流式输出？\"><a href=\"#什么是流式输出？\" class=\"headerlink\" title=\"什么是流式输出？\"></a>什么是流式输出？</h1><p>流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。</p>\n<p>传统的API 通常会一次性返回所有数据，然后客户端一次性接收。<br><img src=\"/blog/./images/stream-output/regular-http-communication.png\" alt=\"normal\"></p>\n<p>流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。<br><img src=\"/blog/./images/stream-output/sse-communication.png\" alt=\"stream\"></p>\n<p>流式输出通常用于以下几种场景：</p>\n<ul>\n<li>实时数据更新，例如股票行情、社交媒体的实时消息流。</li>\n<li>大数据处理，例如长时间查询或计算的结果逐步传输。</li>\n<li>节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。</li>\n</ul>\n<h2 id=\"流式-API-的优势\"><a href=\"#流式-API-的优势\" class=\"headerlink\" title=\"流式 API 的优势\"></a>流式 API 的优势</h2><p>流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：</p>\n<ul>\n<li>实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。</li>\n<li>渐进式加载：减少等待时间，提升交互性。</li>\n<li>流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。</li>\n</ul>\n<h1 id=\"流式输出的实现方式\"><a href=\"#流式输出的实现方式\" class=\"headerlink\" title=\"流式输出的实现方式\"></a>流式输出的实现方式</h1><p>在具体实现流式输出时，常用的技术包括：</p>\n<ul>\n<li><p>HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。</p>\n</li>\n<li><p>Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。</p>\n</li>\n<li><p>WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。</p>\n</li>\n</ul>\n<p><font color=\"#dd0000\">本文主要讲解SSE的实现。</font></p>\n<h1 id=\"SSE数据格式\"><a href=\"#SSE数据格式\" class=\"headerlink\" title=\"SSE数据格式\"></a>SSE数据格式</h1><p>Server-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。</p>\n<p><img src=\"/blog/./images/stream-output/sse.gif\" alt=\"sse\"></p>\n<ol>\n<li>SSE 格式的基本结构<br>SSE 使用 Content-Type: text&#x2F;event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：</li>\n</ol>\n<ul>\n<li>data：表示事件的主要数据内容，数据可以是单行或多行。</li>\n<li>id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。</li>\n<li>event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。</li>\n<li>retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。</li>\n</ul>\n<ol start=\"2\">\n<li>SSE 数据格式示例<br>在每条事件中，字段通过换行分隔，格式如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event: custom-event</span><br><span class=\"line\">id: 1</span><br><span class=\"line\">retry: 5000</span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Hello, World!&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>event：自定义事件名为 custom-event。</li>\n<li>id：该事件的唯一标识符为 1。</li>\n<li>retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。</li>\n<li>data：该事件的主要数据部分为 JSON 字符串 {“message”: “Hello, World!”}。<br>每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。</li>\n</ul>\n<ol start=\"3\">\n<li>多行数据<br>data 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 1 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 2 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 3 of the message&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在客户端收到时，这两行会被拼接成一条数据。</p>\n<h1 id=\"示例：使用SSE实现流式输出\"><a href=\"#示例：使用SSE实现流式输出\" class=\"headerlink\" title=\"示例：使用SSE实现流式输出\"></a>示例：使用SSE实现流式输出</h1><ol>\n<li><p>后端实现<br>后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpPost, HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;聊天&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;chat&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Completions</span>(<span class=\"params\">[FromBody] ChatDto chatDto</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.ContentType = <span class=\"string\">&quot;text/event-stream&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">foreach</span>( <span class=\"function\"><span class=\"keyword\">var</span> message <span class=\"keyword\">in</span> <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\">chatDto.Input</span>) )</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = <span class=\"string\">$&quot;data: <span class=\"subst\">&#123;message&#125;</span>\\n\\n&quot;</span>;</span><br><span class=\"line\">        Console.Write(data);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bytes = Encoding.UTF8.GetBytes(data);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.WriteAsync(bytes);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.FlushAsync();</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> IAsyncEnumerable&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\"><span class=\"built_in\">string</span> userInput</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机获取一个配置</span></span><br><span class=\"line\">    GptConfig gptConfig = <span class=\"keyword\">new</span> GptConfig() &#123; </span><br><span class=\"line\">        ApiKey = <span class=\"string\">&quot;your-api-key&quot;</span>,</span><br><span class=\"line\">        Version = <span class=\"string\">&quot;2023-03-15-preview&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpRequestMessage request = <span class=\"keyword\">new</span> HttpRequestMessage(HttpMethod.Post, <span class=\"string\">$&quot;URL_ADDRESS&quot;</span>);</span><br><span class=\"line\">    request.Headers.Add(<span class=\"string\">&quot;api-key&quot;</span>, gptConfig.ApiKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> requestBody = <span class=\"keyword\">new</span> &#123;</span><br><span class=\"line\">        messages = <span class=\"keyword\">new</span>[]</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> &#123; role = <span class=\"string\">&quot;user&quot;</span>, content = userInput &#125;</span><br><span class=\"line\">        &#125;,       </span><br><span class=\"line\">        stream = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonRequestBody = JsonSerializer.Serialize(requestBody);</span><br><span class=\"line\">    request.Content = <span class=\"keyword\">new</span> StringContent(jsonRequestBody, Encoding.UTF8, <span class=\"string\">&quot;application/json&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> HttpClient httpClient = <span class=\"keyword\">new</span> HttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> response = <span class=\"keyword\">await</span> httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) &#123;</span><br><span class=\"line\">        response.EnsureSuccessStatusCode();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> responseStream = <span class=\"keyword\">await</span> response.Content.ReadAsStreamAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> StreamReader(responseStream) ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( !reader.EndOfStream ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> line = <span class=\"keyword\">await</span> reader.ReadLineAsync();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( !<span class=\"built_in\">string</span>.IsNullOrWhiteSpace(line) &amp;&amp; line.StartsWith(<span class=\"string\">&quot;data:&quot;</span>) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> jsonData = line.Substring(<span class=\"number\">5</span>).Trim();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( jsonData == <span class=\"string\">&quot;[DONE]&quot;</span> )</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> data = JsonSerializer.Deserialize&lt;JsonElement&gt;(jsonData);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 检查是否包含 content 字段，避免报错</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( data.TryGetProperty(<span class=\"string\">&quot;choices&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> choices) &amp;&amp;</span><br><span class=\"line\">                        choices[<span class=\"number\">0</span>].TryGetProperty(<span class=\"string\">&quot;delta&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> delta) &amp;&amp;</span><br><span class=\"line\">                        delta.TryGetProperty(<span class=\"string\">&quot;content&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> content) ) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> content.GetString();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前端实现<br>在前端，我们可以使用 vue3来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">chat</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"string\">`/v20/openai/chat`</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(&#123; <span class=\"attr\">input</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> &#125;),</span><br><span class=\"line\">      <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reader = res.<span class=\"property\">body</span>.<span class=\"title function_\">getReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(reader)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"comment\">// 流式对话</span></span><br><span class=\"line\"><span class=\"title function_\">handleReadStream</span>(<span class=\"params\">stream</span>) &#123;</span><br><span class=\"line\">  stream.<span class=\"title function_\">read</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">&#123; done, value &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">new</span> <span class=\"title class_\">TextDecoder</span>().<span class=\"title function_\">decode</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> += data.<span class=\"title function_\">replaceAll</span>(<span class=\"string\">&#x27;data: &#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 强制 Vue 渲染更新</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Stream updated&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 递归处理流</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(stream)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p>实现效果<br><img src=\"/blog/./images/stream-output/result.gif\" alt=\"chat\"></p>\n</li>\n</ol>\n<p>需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。<br><img src=\"/blog/./images/stream-output/gzip.png\" alt=\"gzip\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    port: 9588,</span><br><span class=\"line\">    compress: false,</span><br><span class=\"line\">    allowedHosts: &quot;all&quot;,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &#x27;v20&#x27;: &#123; target: &#x27;http://localhost:2222&#x27;, changeOrigin: true &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近几年GPT在全球大火，相信大家在日常生活、工作中都在使用。细心的老铁们可能已经注意到，市面上的GPT在回复我们的问题的时候基本上都是采用类似对话的方式。数据在生成后立即被发送给用户，而不是等待所有数据都生成完毕后再一次性发送。</p>\n<p><img src=\"/blog/./images/stream-output/gpt-1.gif\" alt=\"gpt\"></p>\n<p>在本文中，我们将探讨主流的大型语言模型（LLM）提供商如何实现其流式输出的 HTTP API。我们将深入研究流式输出的工作原理，探讨其优势，并提供示例代码以帮助您理解如何在实际应用中使用流式输出。</p>\n<hr>\n<h1 id=\"什么是流式输出？\"><a href=\"#什么是流式输出？\" class=\"headerlink\" title=\"什么是流式输出？\"></a>什么是流式输出？</h1><p>流式输出（Streaming Output）是一种使后端将数据分块、逐步发送到前端的技术。通过这种方法，前端应用能够即时接收和渲染数据，不必等到整个响应体生成完毕后再处理。</p>\n<p>传统的API 通常会一次性返回所有数据，然后客户端一次性接收。<br><img src=\"/blog/./images/stream-output/regular-http-communication.png\" alt=\"normal\"></p>\n<p>流式输出则允许服务器在生成数据的同时将其发送给客户端，从而实现实时更新。<br><img src=\"/blog/./images/stream-output/sse-communication.png\" alt=\"stream\"></p>\n<p>流式输出通常用于以下几种场景：</p>\n<ul>\n<li>实时数据更新，例如股票行情、社交媒体的实时消息流。</li>\n<li>大数据处理，例如长时间查询或计算的结果逐步传输。</li>\n<li>节省带宽，在网络环境不佳的情况下减少一次性传输大量数据的压力。</li>\n</ul>\n<h2 id=\"流式-API-的优势\"><a href=\"#流式-API-的优势\" class=\"headerlink\" title=\"流式 API 的优势\"></a>流式 API 的优势</h2><p>流式 API 提供了即时响应的体验，允许用户在内容生成过程中即时查看部分结果。相比等待整个响应完成，流式输出极大提高了用户体验。适用于多种场景，例如：</p>\n<ul>\n<li>实时内容生成：用户在等待生成大段文本时，可以即时查看部分内容。</li>\n<li>渐进式加载：减少等待时间，提升交互性。</li>\n<li>流式处理：流式 API 让开发者能够边生成边处理数据，尤其适用于实时应用。</li>\n</ul>\n<h1 id=\"流式输出的实现方式\"><a href=\"#流式输出的实现方式\" class=\"headerlink\" title=\"流式输出的实现方式\"></a>流式输出的实现方式</h1><p>在具体实现流式输出时，常用的技术包括：</p>\n<ul>\n<li><p>HTTP 分块传输（Chunked Transfer Encoding）：HTTP 协议支持将数据以分块的方式传输，每个数据块都会携带长度信息。后端可以在响应完成之前，逐步地发送多个数据块给前端。</p>\n</li>\n<li><p>Server-Sent Events (SSE)：SSE 是一种在服务器向客户端推送事件的技术，适合实时性要求高但传输频率不高的场景。</p>\n</li>\n<li><p>WebSocket：WebSocket 是一个全双工协议，允许服务器和客户端相互通信，适合高频率的实时数据传输。</p>\n</li>\n</ul>\n<p><font color=\"#dd0000\">本文主要讲解SSE的实现。</font></p>\n<h1 id=\"SSE数据格式\"><a href=\"#SSE数据格式\" class=\"headerlink\" title=\"SSE数据格式\"></a>SSE数据格式</h1><p>Server-Sent Events（SSE）返回的数据格式是由一系列文本流组成，每行包含一个键值对，表示一个数据事件。每条事件消息由事件名称、数据内容等字段组成，并且这些字段具有特定的格式和规则。</p>\n<p><img src=\"/blog/./images/stream-output/sse.gif\" alt=\"sse\"></p>\n<ol>\n<li>SSE 格式的基本结构<br>SSE 使用 Content-Type: text&#x2F;event-stream，将数据以纯文本的方式分块传输到客户端，每次传输一个事件，数据传输结束时不需要关闭连接。每个事件消息有几个常用字段：</li>\n</ol>\n<ul>\n<li>data：表示事件的主要数据内容，数据可以是单行或多行。</li>\n<li>id：事件的唯一标识符（可选）。客户端会自动记录最近一次接收到的 id，以便在重新连接时从该事件之后恢复。</li>\n<li>event：事件的类型，默认为 message。客户端可以通过 addEventListener 监听不同类型的事件。</li>\n<li>retry：重试时间（以毫秒为单位），用于在连接中断时自动重连。</li>\n</ul>\n<ol start=\"2\">\n<li>SSE 数据格式示例<br>在每条事件中，字段通过换行分隔，格式如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event: custom-event</span><br><span class=\"line\">id: 1</span><br><span class=\"line\">retry: 5000</span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Hello, World!&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>event：自定义事件名为 custom-event。</li>\n<li>id：该事件的唯一标识符为 1。</li>\n<li>retry：指示客户端在连接断开后每隔 5000 毫秒（5 秒）重新尝试连接。</li>\n<li>data：该事件的主要数据部分为 JSON 字符串 {“message”: “Hello, World!”}。<br>每条事件结束后，必须包含两个换行符。若需要传输多条事件，可按此格式依次添加。</li>\n</ul>\n<ol start=\"3\">\n<li>多行数据<br>data 字段支持多行。对于多行内容，在每行前都需要加 data: 前缀, 并且以两个换行符(\\n\\n)结尾，SSE 会自动将其拼接为单个字符串传递到客户端。例如：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 1 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 2 of the message&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data: &#123;&quot;message&quot;: &quot;Part 3 of the message&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在客户端收到时，这两行会被拼接成一条数据。</p>\n<h1 id=\"示例：使用SSE实现流式输出\"><a href=\"#示例：使用SSE实现流式输出\" class=\"headerlink\" title=\"示例：使用SSE实现流式输出\"></a>示例：使用SSE实现流式输出</h1><ol>\n<li><p>后端实现<br>后端需要实现一个 HTTP 接口，该接口返回一个流式响应。在 C# 中，可以使用 ASP.NET Core 来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpPost, HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;聊天&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;chat&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Completions</span>(<span class=\"params\">[FromBody] ChatDto chatDto</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.ContentType = <span class=\"string\">&quot;text/event-stream&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">foreach</span>( <span class=\"function\"><span class=\"keyword\">var</span> message <span class=\"keyword\">in</span> <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\">chatDto.Input</span>) )</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = <span class=\"string\">$&quot;data: <span class=\"subst\">&#123;message&#125;</span>\\n\\n&quot;</span>;</span><br><span class=\"line\">        Console.Write(data);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bytes = Encoding.UTF8.GetBytes(data);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.WriteAsync(bytes);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Response.Body.FlushAsync();</span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> IAsyncEnumerable&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">GetStreamingResponseAsync</span>(<span class=\"params\"><span class=\"built_in\">string</span> userInput</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机获取一个配置</span></span><br><span class=\"line\">    GptConfig gptConfig = <span class=\"keyword\">new</span> GptConfig() &#123; </span><br><span class=\"line\">        ApiKey = <span class=\"string\">&quot;your-api-key&quot;</span>,</span><br><span class=\"line\">        Version = <span class=\"string\">&quot;2023-03-15-preview&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpRequestMessage request = <span class=\"keyword\">new</span> HttpRequestMessage(HttpMethod.Post, <span class=\"string\">$&quot;URL_ADDRESS&quot;</span>);</span><br><span class=\"line\">    request.Headers.Add(<span class=\"string\">&quot;api-key&quot;</span>, gptConfig.ApiKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> requestBody = <span class=\"keyword\">new</span> &#123;</span><br><span class=\"line\">        messages = <span class=\"keyword\">new</span>[]</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> &#123; role = <span class=\"string\">&quot;user&quot;</span>, content = userInput &#125;</span><br><span class=\"line\">        &#125;,       </span><br><span class=\"line\">        stream = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonRequestBody = JsonSerializer.Serialize(requestBody);</span><br><span class=\"line\">    request.Content = <span class=\"keyword\">new</span> StringContent(jsonRequestBody, Encoding.UTF8, <span class=\"string\">&quot;application/json&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> HttpClient httpClient = <span class=\"keyword\">new</span> HttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> response = <span class=\"keyword\">await</span> httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) ) &#123;</span><br><span class=\"line\">        response.EnsureSuccessStatusCode();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> responseStream = <span class=\"keyword\">await</span> response.Content.ReadAsStreamAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span>( <span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> StreamReader(responseStream) ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>( !reader.EndOfStream ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> line = <span class=\"keyword\">await</span> reader.ReadLineAsync();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>( !<span class=\"built_in\">string</span>.IsNullOrWhiteSpace(line) &amp;&amp; line.StartsWith(<span class=\"string\">&quot;data:&quot;</span>) ) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> jsonData = line.Substring(<span class=\"number\">5</span>).Trim();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( jsonData == <span class=\"string\">&quot;[DONE]&quot;</span> )</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> data = JsonSerializer.Deserialize&lt;JsonElement&gt;(jsonData);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 检查是否包含 content 字段，避免报错</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>( data.TryGetProperty(<span class=\"string\">&quot;choices&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> choices) &amp;&amp;</span><br><span class=\"line\">                        choices[<span class=\"number\">0</span>].TryGetProperty(<span class=\"string\">&quot;delta&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> delta) &amp;&amp;</span><br><span class=\"line\">                        delta.TryGetProperty(<span class=\"string\">&quot;content&quot;</span>, <span class=\"keyword\">out</span> <span class=\"keyword\">var</span> content) ) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">yield</span> <span class=\"keyword\">return</span> content.GetString();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前端实现<br>在前端，我们可以使用 vue3来实现。以下是一个简单的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">chat</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"string\">`/v20/openai/chat`</span>, &#123;</span><br><span class=\"line\">      <span class=\"attr\">method</span>: <span class=\"string\">&#x27;POST&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(&#123; <span class=\"attr\">input</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> &#125;),</span><br><span class=\"line\">      <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reader = res.<span class=\"property\">body</span>.<span class=\"title function_\">getReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(reader)</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">input</span> = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"><span class=\"comment\">// 流式对话</span></span><br><span class=\"line\"><span class=\"title function_\">handleReadStream</span>(<span class=\"params\">stream</span>) &#123;</span><br><span class=\"line\">  stream.<span class=\"title function_\">read</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">&#123; done, value &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (done) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">new</span> <span class=\"title class_\">TextDecoder</span>().<span class=\"title function_\">decode</span>(value)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">message</span> += data.<span class=\"title function_\">replaceAll</span>(<span class=\"string\">&#x27;data: &#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 强制 Vue 渲染更新</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.$nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Stream updated&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 递归处理流</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">handleReadStream</span>(stream)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li><p>实现效果<br><img src=\"/blog/./images/stream-output/result.gif\" alt=\"chat\"></p>\n</li>\n</ol>\n<p>需要注意的是，vue3项目在本地开发代理api接口的时候似乎默认启用了gzip压缩，导致前端无法正常解析SSE的数据格式。可以在vue.config.js中配置关闭gzip压缩。<br><img src=\"/blog/./images/stream-output/gzip.png\" alt=\"gzip\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devServer: &#123;</span><br><span class=\"line\">    port: 9588,</span><br><span class=\"line\">    compress: false,</span><br><span class=\"line\">    allowedHosts: &quot;all&quot;,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &#x27;v20&#x27;: &#123; target: &#x27;http://localhost:2222&#x27;, changeOrigin: true &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>流式输出是一种强大的工具，能够显著改善数据传输体验，特别适用于实时和大数据场景。合理选择适合的流式输出技术并处理好前后端的数据解析和错误恢复，可以显著提升应用的交互性和性能。</p>\n"},{"title":"深入探讨 TCP 粘包现象：问题、原因与解决方案","date":"2024-08-28T07:04:04.000Z","_content":"在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。\n\n# 什么是 TCP 粘包？\n\nTCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。\n\n举个简单的例子，假设客户端连续发送两条消息 \"Hello\" 和 \"World\"，由于粘包现象，接收端可能会一次性接收到 \"HelloWorld\"，而不是分开接收到 \"Hello\" 和 \"World\" 两条消息。\n\n# TCP 粘包的成因\n\n要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：\n\n1. TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。\n\n2. Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。\n\n3. 接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。\n\n# 如何解决 TCP 粘包问题\n\n粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：\n\n1. 定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。\n\n2. 分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。\n\n3. 消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。\n\n## HTTP有粘包问题么？\n众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？\n\nHTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：\n\n### 消息的明确边界\n\n+ Content-Length 头部\n    > HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。\n\n+ Chunked Transfer-Encoding\n    > 对于无法提前确定内容长度的情况，HTTP/1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。    \n\n\n# 示例代码\n\n下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法\n## 发送方粘包\n\n服务端代码\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[1024];\n        int bytesRead = stream.Read(buffer, 0, buffer.Length);\n        string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n\n        Console.WriteLine(\"Received Data:\\r\\n \" + receivedData);\n    }\n    listener.Stop();\n\n    Console.ReadLine();\n}\n```\n客户端代码\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string[] messages = { \"Message 1\\r\\n\", \"Message 2\\r\\n\", \"Message 3\\r\\n\" };\n\n        foreach( var msg in messages ) {\n            byte[] data = Encoding.UTF8.GetBytes(msg);\n            stream.Write(data, 0, data.Length);\n        }\n\n        Console.WriteLine(\"Messages sent.\");\n    }\n\n    Console.ReadLine();\n}\n```\n运行效果如下\n![发送方粘包](/images/sticky-packet/sender-sticky.png)\n在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。\n\n### 解决方案：使用消息长度前缀\n客户端代码：\n```C#\n static void Main(string[] args)\n {\n     using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n     using( NetworkStream stream = client.GetStream() ) {\n         string[] messages = { \"Message 1\", \"Message 2\", \"Message 3\" };\n\n         foreach( var msg in messages ) {\n             byte[] messageData = Encoding.UTF8.GetBytes(msg);\n             byte[] lengthPrefix = BitConverter.GetBytes(messageData.Length);\n\n             // 发送长度前缀\n             stream.Write(lengthPrefix, 0, lengthPrefix.Length);\n             // 发送实际消息\n             stream.Write(messageData, 0, messageData.Length);\n         }\n\n         Console.ReadLine();\n     }\n }\n```\n运行效果如下：\n![解决发送方粘包](/images/sticky-packet/solve-sender-sticky.png)\n\n\n## 接收方粘包\n服务端代码:\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20]; // 小缓冲区，故意分多次接收\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            Console.WriteLine(\"Receive: \" + part );\n\n            if( bytesRead < buffer.Length )\n                break; // 假设消息的最后一部分已经接收完\n        }\n\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n客户端代码:\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string message = \"This is a longer message that may be split across multiple packets.\";\n        byte[] data = Encoding.UTF8.GetBytes(message);\n        stream.Write(data, 0, data.Length);\n\n        Console.WriteLine(\"Message sent.\");\n    }\n    Console.ReadLine();\n}\n```\n\n运行效果\n![接收方粘包](/images/sticky-packet/server-sticky.png)\n\n### 解决方案：实现一个消息缓冲机制\n\n接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server start... \");\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20];\n        StringBuilder completeMessage = new StringBuilder();\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            // 每次接收数据并追加到消息缓冲区\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            completeMessage.Append(part);\n\n            // 假设消息以特定结束符结束，判断完整消息的逻辑\n            if( completeMessage.ToString().Contains(\"...\") ) // 示例中的结束符\n            {\n                break;\n            }\n        }\n        Console.WriteLine(\"Complete Message: \" + completeMessage.ToString());\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n效果如下：\n![解决接收方粘包](/images/sticky-packet/solve-server-sticky.png)\n\n# 总结\n\nTCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。\n\n希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！","source":"_posts/sticky-packet.md","raw":"---\ntitle: 深入探讨 TCP 粘包现象：问题、原因与解决方案\ndate: 2024-08-28 15:04:04\ntags:\n---\n在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。\n\n# 什么是 TCP 粘包？\n\nTCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。\n\n举个简单的例子，假设客户端连续发送两条消息 \"Hello\" 和 \"World\"，由于粘包现象，接收端可能会一次性接收到 \"HelloWorld\"，而不是分开接收到 \"Hello\" 和 \"World\" 两条消息。\n\n# TCP 粘包的成因\n\n要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：\n\n1. TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。\n\n2. Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。\n\n3. 接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。\n\n# 如何解决 TCP 粘包问题\n\n粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：\n\n1. 定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。\n\n2. 分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。\n\n3. 消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。\n\n## HTTP有粘包问题么？\n众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？\n\nHTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：\n\n### 消息的明确边界\n\n+ Content-Length 头部\n    > HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。\n\n+ Chunked Transfer-Encoding\n    > 对于无法提前确定内容长度的情况，HTTP/1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。    \n\n\n# 示例代码\n\n下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法\n## 发送方粘包\n\n服务端代码\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[1024];\n        int bytesRead = stream.Read(buffer, 0, buffer.Length);\n        string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n\n        Console.WriteLine(\"Received Data:\\r\\n \" + receivedData);\n    }\n    listener.Stop();\n\n    Console.ReadLine();\n}\n```\n客户端代码\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string[] messages = { \"Message 1\\r\\n\", \"Message 2\\r\\n\", \"Message 3\\r\\n\" };\n\n        foreach( var msg in messages ) {\n            byte[] data = Encoding.UTF8.GetBytes(msg);\n            stream.Write(data, 0, data.Length);\n        }\n\n        Console.WriteLine(\"Messages sent.\");\n    }\n\n    Console.ReadLine();\n}\n```\n运行效果如下\n![发送方粘包](/images/sticky-packet/sender-sticky.png)\n在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。\n\n### 解决方案：使用消息长度前缀\n客户端代码：\n```C#\n static void Main(string[] args)\n {\n     using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n     using( NetworkStream stream = client.GetStream() ) {\n         string[] messages = { \"Message 1\", \"Message 2\", \"Message 3\" };\n\n         foreach( var msg in messages ) {\n             byte[] messageData = Encoding.UTF8.GetBytes(msg);\n             byte[] lengthPrefix = BitConverter.GetBytes(messageData.Length);\n\n             // 发送长度前缀\n             stream.Write(lengthPrefix, 0, lengthPrefix.Length);\n             // 发送实际消息\n             stream.Write(messageData, 0, messageData.Length);\n         }\n\n         Console.ReadLine();\n     }\n }\n```\n运行效果如下：\n![解决发送方粘包](/images/sticky-packet/solve-sender-sticky.png)\n\n\n## 接收方粘包\n服务端代码:\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server Start...\");\n\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20]; // 小缓冲区，故意分多次接收\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            Console.WriteLine(\"Receive: \" + part );\n\n            if( bytesRead < buffer.Length )\n                break; // 假设消息的最后一部分已经接收完\n        }\n\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n客户端代码:\n```C#\nstatic void Main(string[] args)\n{\n    using( TcpClient client = new TcpClient(\"127.0.0.1\", 8888) )\n    using( NetworkStream stream = client.GetStream() ) {\n        string message = \"This is a longer message that may be split across multiple packets.\";\n        byte[] data = Encoding.UTF8.GetBytes(message);\n        stream.Write(data, 0, data.Length);\n\n        Console.WriteLine(\"Message sent.\");\n    }\n    Console.ReadLine();\n}\n```\n\n运行效果\n![接收方粘包](/images/sticky-packet/server-sticky.png)\n\n### 解决方案：实现一个消息缓冲机制\n\n接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。\n```C#\nstatic void Main(string[] args)\n{\n    TcpListener listener = new TcpListener(IPAddress.Any, 8888);\n    listener.Start();\n    Console.WriteLine(\"Server start... \");\n    using( TcpClient client = listener.AcceptTcpClient() )\n    using( NetworkStream stream = client.GetStream() ) {\n        byte[] buffer = new byte[20];\n        StringBuilder completeMessage = new StringBuilder();\n\n        int bytesRead;\n        while( (bytesRead = stream.Read(buffer, 0, buffer.Length)) > 0 ) {\n            // 每次接收数据并追加到消息缓冲区\n            string part = Encoding.UTF8.GetString(buffer, 0, bytesRead);\n            completeMessage.Append(part);\n\n            // 假设消息以特定结束符结束，判断完整消息的逻辑\n            if( completeMessage.ToString().Contains(\"...\") ) // 示例中的结束符\n            {\n                break;\n            }\n        }\n        Console.WriteLine(\"Complete Message: \" + completeMessage.ToString());\n    }\n\n    listener.Stop();\n    Console.ReadLine();\n}\n```\n效果如下：\n![解决接收方粘包](/images/sticky-packet/solve-server-sticky.png)\n\n# 总结\n\nTCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。\n\n希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！","slug":"sticky-packet","published":1,"updated":"2024-08-30T06:30:41.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawn001erkp17yn6fbgl","content":"<p>在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。</p>\n<h1 id=\"什么是-TCP-粘包？\"><a href=\"#什么是-TCP-粘包？\" class=\"headerlink\" title=\"什么是 TCP 粘包？\"></a>什么是 TCP 粘包？</h1><p>TCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。</p>\n<p>举个简单的例子，假设客户端连续发送两条消息 “Hello” 和 “World”，由于粘包现象，接收端可能会一次性接收到 “HelloWorld”，而不是分开接收到 “Hello” 和 “World” 两条消息。</p>\n<h1 id=\"TCP-粘包的成因\"><a href=\"#TCP-粘包的成因\" class=\"headerlink\" title=\"TCP 粘包的成因\"></a>TCP 粘包的成因</h1><p>要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：</p>\n<ol>\n<li><p>TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。</p>\n</li>\n<li><p>Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。</p>\n</li>\n<li><p>接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。</p>\n</li>\n</ol>\n<h1 id=\"如何解决-TCP-粘包问题\"><a href=\"#如何解决-TCP-粘包问题\" class=\"headerlink\" title=\"如何解决 TCP 粘包问题\"></a>如何解决 TCP 粘包问题</h1><p>粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：</p>\n<ol>\n<li><p>定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。</p>\n</li>\n<li><p>分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。</p>\n</li>\n<li><p>消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。</p>\n</li>\n</ol>\n<h2 id=\"HTTP有粘包问题么？\"><a href=\"#HTTP有粘包问题么？\" class=\"headerlink\" title=\"HTTP有粘包问题么？\"></a>HTTP有粘包问题么？</h2><p>众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？</p>\n<p>HTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：</p>\n<h3 id=\"消息的明确边界\"><a href=\"#消息的明确边界\" class=\"headerlink\" title=\"消息的明确边界\"></a>消息的明确边界</h3><ul>\n<li><p>Content-Length 头部</p>\n<blockquote>\n<p>HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。</p>\n</blockquote>\n</li>\n<li><p>Chunked Transfer-Encoding</p>\n<blockquote>\n<p>对于无法提前确定内容长度的情况，HTTP&#x2F;1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法</p>\n<h2 id=\"发送方粘包\"><a href=\"#发送方粘包\" class=\"headerlink\" title=\"发送方粘包\"></a>发送方粘包</h2><p>服务端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> receivedData = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Received Data:\\r\\n &quot;</span> + receivedData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 2\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 3\\r\\n&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Messages sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下<br><img src=\"/blog/images/sticky-packet/sender-sticky.png\" alt=\"发送方粘包\"><br>在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。</p>\n<h3 id=\"解决方案：使用消息长度前缀\"><a href=\"#解决方案：使用消息长度前缀\" class=\"headerlink\" title=\"解决方案：使用消息长度前缀\"></a>解决方案：使用消息长度前缀</h3><p>客户端代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1&quot;</span>, <span class=\"string\">&quot;Message 2&quot;</span>, <span class=\"string\">&quot;Message 3&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] messageData = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] lengthPrefix = BitConverter.GetBytes(messageData.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 发送长度前缀</span></span><br><span class=\"line\">            stream.Write(lengthPrefix, <span class=\"number\">0</span>, lengthPrefix.Length);</span><br><span class=\"line\">            <span class=\"comment\">// 发送实际消息</span></span><br><span class=\"line\">            stream.Write(messageData, <span class=\"number\">0</span>, messageData.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.ReadLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下：<br><img src=\"/blog/images/sticky-packet/solve-sender-sticky.png\" alt=\"解决发送方粘包\"></p>\n<h2 id=\"接收方粘包\"><a href=\"#接收方粘包\" class=\"headerlink\" title=\"接收方粘包\"></a>接收方粘包</h2><p>服务端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>]; <span class=\"comment\">// 小缓冲区，故意分多次接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">&quot;Receive: &quot;</span> + part );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( bytesRead &lt; buffer.Length )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>; <span class=\"comment\">// 假设消息的最后一部分已经接收完</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> message = <span class=\"string\">&quot;This is a longer message that may be split across multiple packets.&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(message);</span><br><span class=\"line\">        stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Message sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行效果<br><img src=\"/blog/images/sticky-packet/server-sticky.png\" alt=\"接收方粘包\"></p>\n<h3 id=\"解决方案：实现一个消息缓冲机制\"><a href=\"#解决方案：实现一个消息缓冲机制\" class=\"headerlink\" title=\"解决方案：实现一个消息缓冲机制\"></a>解决方案：实现一个消息缓冲机制</h3><p>接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server start... &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>];</span><br><span class=\"line\">        StringBuilder completeMessage = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每次接收数据并追加到消息缓冲区</span></span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            completeMessage.Append(part);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 假设消息以特定结束符结束，判断完整消息的逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( completeMessage.ToString().Contains(<span class=\"string\">&quot;...&quot;</span>) ) <span class=\"comment\">// 示例中的结束符</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Complete Message: &quot;</span> + completeMessage.ToString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下：<br><img src=\"/blog/images/sticky-packet/solve-server-sticky.png\" alt=\"解决接收方粘包\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。</p>\n<p>希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在网络编程中，TCP 粘包是一个常见而又令人头疼的问题。对于刚接触网络编程的开发者来说，粘包问题可能会引发数据混乱，导致程序运行异常。因此，了解 TCP 粘包现象及其解决方法，对于开发稳定可靠的网络应用至关重要。本文将详细探讨什么是 TCP 粘包、它的成因，以及如何有效解决这一问题。</p>\n<h1 id=\"什么是-TCP-粘包？\"><a href=\"#什么是-TCP-粘包？\" class=\"headerlink\" title=\"什么是 TCP 粘包？\"></a>什么是 TCP 粘包？</h1><p>TCP 粘包指的是在 TCP 传输过程中，多个数据包被合并成一个数据包传输到接收端，使得接收端在读取数据时无法区分出单个数据包的边界。粘包现象一般会出现在 TCP 流式传输中，导致接收端解析数据时出现混淆。</p>\n<p>举个简单的例子，假设客户端连续发送两条消息 “Hello” 和 “World”，由于粘包现象，接收端可能会一次性接收到 “HelloWorld”，而不是分开接收到 “Hello” 和 “World” 两条消息。</p>\n<h1 id=\"TCP-粘包的成因\"><a href=\"#TCP-粘包的成因\" class=\"headerlink\" title=\"TCP 粘包的成因\"></a>TCP 粘包的成因</h1><p>要理解 TCP 粘包的成因，首先需要了解 TCP 的工作机制：</p>\n<ol>\n<li><p>TCP 是面向字节流的协议：TCP 不会关心数据包的边界，它只会将数据按字节流的形式进行传输。因此，应用层发送的多次消息可能会被 TCP 组合成一个数据包进行发送，也可能会被拆分成多个数据包。</p>\n</li>\n<li><p>Nagle 算法：Nagle 算法是为了减少小包发送的网络负载而设计的。它会将小数据包积累到一定大小后再进行发送，这样就有可能导致多个小包被合并为一个大包，从而产生粘包现象。</p>\n</li>\n<li><p>接收端缓存机制：当接收端从 TCP 缓冲区中读取数据时，TCP 并不知道数据包的边界，因此接收到的数据可能会包含多个已粘在一起的数据包。</p>\n</li>\n</ol>\n<h1 id=\"如何解决-TCP-粘包问题\"><a href=\"#如何解决-TCP-粘包问题\" class=\"headerlink\" title=\"如何解决 TCP 粘包问题\"></a>如何解决 TCP 粘包问题</h1><p>粘包问题通常需要通过应用层协议来解决。以下是几种常见的解决方案：</p>\n<ol>\n<li><p>定长消息：通过约定固定长度的数据包格式，接收端可以根据固定长度来切分消息。虽然实现简单，但这种方法在数据量不固定的情况下效率较低。</p>\n</li>\n<li><p>分隔符法：在每个消息的末尾添加一个特殊的分隔符，如换行符 \\n，接收端可以根据分隔符来判断消息的边界。这种方法灵活性较好，但分隔符的选择需避免与实际数据内容冲突。</p>\n</li>\n<li><p>消息头部加长度字段：在每个消息的头部添加一个长度字段，表示消息的总长度，接收端可以先读取长度字段，再根据该长度读取完整的消息。这种方法较为通用且适用于各种长度的消息。</p>\n</li>\n</ol>\n<h2 id=\"HTTP有粘包问题么？\"><a href=\"#HTTP有粘包问题么？\" class=\"headerlink\" title=\"HTTP有粘包问题么？\"></a>HTTP有粘包问题么？</h2><p>众所周知，HTTP也是基于TCP的。那么HTTP有粘包的问题么？</p>\n<p>HTTP虽然是基于TCP的，但它通过设计和协议规范解决了TCP粘包问题，确保了数据的正确传输和解析。以下是HTTP如何处理粘包问题的关键点：</p>\n<h3 id=\"消息的明确边界\"><a href=\"#消息的明确边界\" class=\"headerlink\" title=\"消息的明确边界\"></a>消息的明确边界</h3><ul>\n<li><p>Content-Length 头部</p>\n<blockquote>\n<p>HTTP请求和响应通常包含一个 Content-Length 头部，该头部明确指示了消息体的长度（以字节为单位）。接收方通过读取这个头部信息，知道需要读取多少字节的数据来获取完整的消息体。</p>\n</blockquote>\n</li>\n<li><p>Chunked Transfer-Encoding</p>\n<blockquote>\n<p>对于无法提前确定内容长度的情况，HTTP&#x2F;1.1引入了分块传输编码（Chunked Transfer-Encoding）。在这种模式下，消息体被分成多个块，每个块都有自己的长度标识，最后一个块的长度为0表示消息结束。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h1><p>下面我们写两个个简单的例子，分别说明发送方粘包和接收方粘包，以及两种粘包的解决方法</p>\n<h2 id=\"发送方粘包\"><a href=\"#发送方粘包\" class=\"headerlink\" title=\"发送方粘包\"></a>发送方粘包</h2><p>服务端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length);</span><br><span class=\"line\">        <span class=\"built_in\">string</span> receivedData = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Received Data:\\r\\n &quot;</span> + receivedData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 2\\r\\n&quot;</span>, <span class=\"string\">&quot;Message 3\\r\\n&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Messages sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下<br><img src=\"/blog/images/sticky-packet/sender-sticky.png\" alt=\"发送方粘包\"><br>在接收方，我们看到的消息是一个连接的字符串，如 Message 1Message 2Message 3。这是因为发送方连续发送了多个消息，TCP协议将这些消息粘包在一起，导致接收方在一次读取操作中读取到多个消息。</p>\n<h3 id=\"解决方案：使用消息长度前缀\"><a href=\"#解决方案：使用消息长度前缀\" class=\"headerlink\" title=\"解决方案：使用消息长度前缀\"></a>解决方案：使用消息长度前缀</h3><p>客户端代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span>[] messages = &#123; <span class=\"string\">&quot;Message 1&quot;</span>, <span class=\"string\">&quot;Message 2&quot;</span>, <span class=\"string\">&quot;Message 3&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span>( <span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> messages ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] messageData = Encoding.UTF8.GetBytes(msg);</span><br><span class=\"line\">            <span class=\"built_in\">byte</span>[] lengthPrefix = BitConverter.GetBytes(messageData.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 发送长度前缀</span></span><br><span class=\"line\">            stream.Write(lengthPrefix, <span class=\"number\">0</span>, lengthPrefix.Length);</span><br><span class=\"line\">            <span class=\"comment\">// 发送实际消息</span></span><br><span class=\"line\">            stream.Write(messageData, <span class=\"number\">0</span>, messageData.Length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.ReadLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行效果如下：<br><img src=\"/blog/images/sticky-packet/solve-sender-sticky.png\" alt=\"解决发送方粘包\"></p>\n<h2 id=\"接收方粘包\"><a href=\"#接收方粘包\" class=\"headerlink\" title=\"接收方粘包\"></a>接收方粘包</h2><p>服务端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server Start...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>]; <span class=\"comment\">// 小缓冲区，故意分多次接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            Console.WriteLine(<span class=\"string\">&quot;Receive: &quot;</span> + part );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( bytesRead &lt; buffer.Length )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>; <span class=\"comment\">// 假设消息的最后一部分已经接收完</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>客户端代码:</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = <span class=\"keyword\">new</span> TcpClient(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8888</span>) )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">string</span> message = <span class=\"string\">&quot;This is a longer message that may be split across multiple packets.&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] data = Encoding.UTF8.GetBytes(message);</span><br><span class=\"line\">        stream.Write(data, <span class=\"number\">0</span>, data.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Message sent.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行效果<br><img src=\"/blog/images/sticky-packet/server-sticky.png\" alt=\"接收方粘包\"></p>\n<h3 id=\"解决方案：实现一个消息缓冲机制\"><a href=\"#解决方案：实现一个消息缓冲机制\" class=\"headerlink\" title=\"解决方案：实现一个消息缓冲机制\"></a>解决方案：实现一个消息缓冲机制</h3><p>接收方需要实现一个缓冲机制，将每次接收到的数据存入缓冲区中，直到缓冲区中包含完整的消息为止。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    TcpListener listener = <span class=\"keyword\">new</span> TcpListener(IPAddress.Any, <span class=\"number\">8888</span>);</span><br><span class=\"line\">    listener.Start();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">&quot;Server start... &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( TcpClient client = listener.AcceptTcpClient() )</span><br><span class=\"line\">    <span class=\"keyword\">using</span>( NetworkStream stream = client.GetStream() ) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">byte</span>[<span class=\"number\">20</span>];</span><br><span class=\"line\">        StringBuilder completeMessage = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">int</span> bytesRead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (bytesRead = stream.Read(buffer, <span class=\"number\">0</span>, buffer.Length)) &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每次接收数据并追加到消息缓冲区</span></span><br><span class=\"line\">            <span class=\"built_in\">string</span> part = Encoding.UTF8.GetString(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            completeMessage.Append(part);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 假设消息以特定结束符结束，判断完整消息的逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>( completeMessage.ToString().Contains(<span class=\"string\">&quot;...&quot;</span>) ) <span class=\"comment\">// 示例中的结束符</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Complete Message: &quot;</span> + completeMessage.ToString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    listener.Stop();</span><br><span class=\"line\">    Console.ReadLine();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下：<br><img src=\"/blog/images/sticky-packet/solve-server-sticky.png\" alt=\"解决接收方粘包\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>TCP 粘包是 TCP 协议本身特性导致的常见问题之一，通常需要通过应用层的协议设计来解决。通过对数据包添加定长、分隔符或长度字段等方法，开发者可以有效避免粘包现象，从而保证数据的正确性与完整性。在实际开发中，合理设计应用层协议对于网络程序的稳定性至关重要。</p>\n<p>希望这篇博客能够帮助你更好地理解和解决 TCP 粘包问题。如果你有任何问题或建议，欢迎在评论区留言讨论！</p>\n"},{"title":"WebRTC入门：让浏览器之间的实时通信变得简单","date":"2024-12-16T09:23:31.000Z","_content":"\n# 什么是WebRTC？\nWebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。\n\nWebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。\n\n# WebRTC的三大核心技术\nWebRTC的功能依赖于三个主要的API：\n\n1. getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。\n\n2. RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。\n\n3. RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。\n\n# WebRTC如何工作？\nWebRTC的工作原理可以概括为以下几个步骤：\n\n![结构](./images/webrtc/architecture.png)\n\n1. 媒体设备访问：使用getUserMedia API获取音视频流。\n\n2. 建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。\n\n3. ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。\n\n4. 数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。\n\n# SDP是什么？\nSDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。\n\n在 WebRTC 中，SDP 主要用于两个目的：\n\n+ 描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。\n+ 建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。\n\n##  WebRTC 中的 SDP 交换流程\nWebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：\n\n### 创建 Offer 和 Answer\n- Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。\n- Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。\n\n## SDP 交换过程\n1. 发起方创建 SDP offer：\n- 发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。\n- 发起方将 offer 通过信令通道发送给接收方。\n\n2. 接收方收到 offer 后创建 SDP answer：\n- 接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。\n- 接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。\n\n3. 双方交换 ICE 候选：\n- 在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。\n\n\n# 使用WebRTC实现文件传输\n下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。\n![流程](./images/webrtc/process.png)\n\n1. 连接信令服务器\nWebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。\n\n```javascript\nthis.connection = new HubConnectionBuilder()\n    .withUrl('http://localhost:5217/signalr')  // .NET SignalR 服务的 URL\n    .build();\n\n// 开始连接\ntry {\nawait this.connection.start();\nthis.isConnected = true;\nthis.connectionId = this.connection.connectionId;\nElMessage.success('SignalR 连接成功！');\n// 获取所有连接的 ID\nthis.connection.invoke('GetAllConnections');\n// 初始化 WebRTC\nthis.setupWebRTC();\n} catch (err) {\nElMessage.error('SignalR 连接失败！');\n}\n```\n这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。\n![连接](./images/webrtc/connections.png)\n\n2. 初始化 WebRTC\n创建一个RTCPeerConnection实例\n\n```javascript\nasync setupWebRTC() {\n    this.rtcPeerConnection = new RTCPeerConnection();\n\n    // 收集 ICE 候选并发送给目标连接\n    this.rtcPeerConnection.onicecandidate = event => {\n    if (event.candidate) {\n        console.log('收集到 ICE 候选:', event.candidate);\n        this.sendIceCandidate(event.candidate);\n    }\n    };\n\n    // 监听连接状态变化\n    this.rtcPeerConnection.oniceconnectionstatechange = () => {\n    console.log('ICE 连接状态:', this.rtcPeerConnection.iceConnectionState);\n    if (this.rtcPeerConnection.iceConnectionState === 'failed') {\n        console.error('ICE 连接失败！');\n    }\n    };\n\n    this.rtcPeerConnection.onconnectionstatechange = () => {\n    console.log('WebRTC 连接状态:', this.rtcPeerConnection.connectionState);\n    if (this.rtcPeerConnection.connectionState === 'failed') {\n        console.error('WebRTC 连接失败！');\n    }\n    };\n\n    this.setupDataChannel()\n}\n```\n\n3. 发送信令并建立连接\n在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。\n\n```javascript\n// 发送 Offer 给目标客户端\nasync sendOffer() {\n    if (this.targetConnectionId) {\n    const offer = await this.rtcPeerConnection.createOffer();\n    await this.rtcPeerConnection.setLocalDescription(offer);\n    try {\n        console.log('发送 Offer:', offer);\n        await this.connection.invoke('SendOffer', offer, this.targetConnectionId);\n    } catch (err) {\n        console.error('发送 Offer 失败：', err);\n    }\n    }\n},\n\n// 目标客户端接收到的 Offer，创建 Answer\nasync receiveOffer(offer) {\n    console.log('收到 Offer:', offer);\n    await this.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n    const answer = await this.rtcPeerConnection.createAnswer();\n    console.log(\"创建 Answer 成功\");\n    await this.rtcPeerConnection.setLocalDescription(answer);\n    console.log(\"Local Description 设置成功\");\n    this.connection.invoke('SendAnswer', answer, this.targetConnectionId);\n},\n```\n4. 传输文件\n在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。\n\n```javascript\n// 选择文件\nhandleFileSelection(event) {\n    const file = event.target.files[0];\n    if (file) {\n    this.file = file;\n    console.log('已选择文件:', file.name);\n    }\n},\n\n// 发送文件\nsendFile() {\n    if (this.dataChannel && this.file) {\n    const chunkSize = 16384;  // 设置块大小为 16KB\n    const fileReader = new FileReader();\n\n    let offset = 0;\n\n    // 发送文件基本信息（如文件名和文件大小）\n    const fileInfo = {\n        name: this.file.name,\n        size: this.file.size,\n    };\n\n    this.dataChannel.send(JSON.stringify(fileInfo));  // 发送文件基本信息\n\n    const sendNextChunk = () => {\n        const fileSlice = this.file.slice(offset, offset + chunkSize);\n        fileReader.onload = () => {\n        this.dataChannel.send(fileReader.result);  // 发送文件块\n        offset += chunkSize;\n        if (offset < this.file.size) {\n            sendNextChunk();  // 继续发送下一个块\n        } else {\n            console.log('文件发送完毕');\n        }\n        };\n        fileReader.readAsArrayBuffer(fileSlice);  // 读取文件块为 ArrayBuffer\n    };\n\n    sendNextChunk();  // 开始发送文件块\n    } else {\n    console.error('数据通道不可用或未选择文件');\n    }\n},\n```\n\n打完收工，最后我们来看看实现的效果：\n![效果](./images/webrtc/result.gif)\n\n# WebRTC的实际应用\nWebRTC已被广泛应用于各种实时通信场景，包括：\n\n1. 视频会议：如Zoom、Google Meet等平台都使用了WebRTC。\n2. 在线教育：利用WebRTC实现师生之间的实时互动和交流。\n3. 文件传输：通过RTCDataChannel实现浏览器间的文件传输。\n4. 在线客服：实现企业与客户之间的实时视频或语音通信。\n\n# WebRTC的优势与挑战\n## 优势\n- 无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。\n- 低延迟：WebRTC专为实时通信设计，支持高效的数据传输。\n- 跨平台：支持各种操作系统和设备，具有良好的兼容性。\n## 挑战\n- NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN/TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。\n- 信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。\n- 浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。\n\n# 小结\nWebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。\n\n----\n\n本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。\n","source":"_posts/web-rtc.md","raw":"---\ntitle: WebRTC入门：让浏览器之间的实时通信变得简单\ndate: 2024-12-16 17:23:31\ntags:\n---\n\n# 什么是WebRTC？\nWebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。\n\nWebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。\n\n# WebRTC的三大核心技术\nWebRTC的功能依赖于三个主要的API：\n\n1. getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。\n\n2. RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。\n\n3. RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。\n\n# WebRTC如何工作？\nWebRTC的工作原理可以概括为以下几个步骤：\n\n![结构](./images/webrtc/architecture.png)\n\n1. 媒体设备访问：使用getUserMedia API获取音视频流。\n\n2. 建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。\n\n3. ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。\n\n4. 数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。\n\n# SDP是什么？\nSDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。\n\n在 WebRTC 中，SDP 主要用于两个目的：\n\n+ 描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。\n+ 建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。\n\n##  WebRTC 中的 SDP 交换流程\nWebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：\n\n### 创建 Offer 和 Answer\n- Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。\n- Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。\n\n## SDP 交换过程\n1. 发起方创建 SDP offer：\n- 发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。\n- 发起方将 offer 通过信令通道发送给接收方。\n\n2. 接收方收到 offer 后创建 SDP answer：\n- 接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。\n- 接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。\n\n3. 双方交换 ICE 候选：\n- 在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。\n\n\n# 使用WebRTC实现文件传输\n下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。\n![流程](./images/webrtc/process.png)\n\n1. 连接信令服务器\nWebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。\n\n```javascript\nthis.connection = new HubConnectionBuilder()\n    .withUrl('http://localhost:5217/signalr')  // .NET SignalR 服务的 URL\n    .build();\n\n// 开始连接\ntry {\nawait this.connection.start();\nthis.isConnected = true;\nthis.connectionId = this.connection.connectionId;\nElMessage.success('SignalR 连接成功！');\n// 获取所有连接的 ID\nthis.connection.invoke('GetAllConnections');\n// 初始化 WebRTC\nthis.setupWebRTC();\n} catch (err) {\nElMessage.error('SignalR 连接失败！');\n}\n```\n这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。\n![连接](./images/webrtc/connections.png)\n\n2. 初始化 WebRTC\n创建一个RTCPeerConnection实例\n\n```javascript\nasync setupWebRTC() {\n    this.rtcPeerConnection = new RTCPeerConnection();\n\n    // 收集 ICE 候选并发送给目标连接\n    this.rtcPeerConnection.onicecandidate = event => {\n    if (event.candidate) {\n        console.log('收集到 ICE 候选:', event.candidate);\n        this.sendIceCandidate(event.candidate);\n    }\n    };\n\n    // 监听连接状态变化\n    this.rtcPeerConnection.oniceconnectionstatechange = () => {\n    console.log('ICE 连接状态:', this.rtcPeerConnection.iceConnectionState);\n    if (this.rtcPeerConnection.iceConnectionState === 'failed') {\n        console.error('ICE 连接失败！');\n    }\n    };\n\n    this.rtcPeerConnection.onconnectionstatechange = () => {\n    console.log('WebRTC 连接状态:', this.rtcPeerConnection.connectionState);\n    if (this.rtcPeerConnection.connectionState === 'failed') {\n        console.error('WebRTC 连接失败！');\n    }\n    };\n\n    this.setupDataChannel()\n}\n```\n\n3. 发送信令并建立连接\n在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。\n\n```javascript\n// 发送 Offer 给目标客户端\nasync sendOffer() {\n    if (this.targetConnectionId) {\n    const offer = await this.rtcPeerConnection.createOffer();\n    await this.rtcPeerConnection.setLocalDescription(offer);\n    try {\n        console.log('发送 Offer:', offer);\n        await this.connection.invoke('SendOffer', offer, this.targetConnectionId);\n    } catch (err) {\n        console.error('发送 Offer 失败：', err);\n    }\n    }\n},\n\n// 目标客户端接收到的 Offer，创建 Answer\nasync receiveOffer(offer) {\n    console.log('收到 Offer:', offer);\n    await this.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n    const answer = await this.rtcPeerConnection.createAnswer();\n    console.log(\"创建 Answer 成功\");\n    await this.rtcPeerConnection.setLocalDescription(answer);\n    console.log(\"Local Description 设置成功\");\n    this.connection.invoke('SendAnswer', answer, this.targetConnectionId);\n},\n```\n4. 传输文件\n在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。\n\n```javascript\n// 选择文件\nhandleFileSelection(event) {\n    const file = event.target.files[0];\n    if (file) {\n    this.file = file;\n    console.log('已选择文件:', file.name);\n    }\n},\n\n// 发送文件\nsendFile() {\n    if (this.dataChannel && this.file) {\n    const chunkSize = 16384;  // 设置块大小为 16KB\n    const fileReader = new FileReader();\n\n    let offset = 0;\n\n    // 发送文件基本信息（如文件名和文件大小）\n    const fileInfo = {\n        name: this.file.name,\n        size: this.file.size,\n    };\n\n    this.dataChannel.send(JSON.stringify(fileInfo));  // 发送文件基本信息\n\n    const sendNextChunk = () => {\n        const fileSlice = this.file.slice(offset, offset + chunkSize);\n        fileReader.onload = () => {\n        this.dataChannel.send(fileReader.result);  // 发送文件块\n        offset += chunkSize;\n        if (offset < this.file.size) {\n            sendNextChunk();  // 继续发送下一个块\n        } else {\n            console.log('文件发送完毕');\n        }\n        };\n        fileReader.readAsArrayBuffer(fileSlice);  // 读取文件块为 ArrayBuffer\n    };\n\n    sendNextChunk();  // 开始发送文件块\n    } else {\n    console.error('数据通道不可用或未选择文件');\n    }\n},\n```\n\n打完收工，最后我们来看看实现的效果：\n![效果](./images/webrtc/result.gif)\n\n# WebRTC的实际应用\nWebRTC已被广泛应用于各种实时通信场景，包括：\n\n1. 视频会议：如Zoom、Google Meet等平台都使用了WebRTC。\n2. 在线教育：利用WebRTC实现师生之间的实时互动和交流。\n3. 文件传输：通过RTCDataChannel实现浏览器间的文件传输。\n4. 在线客服：实现企业与客户之间的实时视频或语音通信。\n\n# WebRTC的优势与挑战\n## 优势\n- 无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。\n- 低延迟：WebRTC专为实时通信设计，支持高效的数据传输。\n- 跨平台：支持各种操作系统和设备，具有良好的兼容性。\n## 挑战\n- NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN/TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。\n- 信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。\n- 浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。\n\n# 小结\nWebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。\n\n----\n\n本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。\n","slug":"web-rtc","published":1,"updated":"2024-12-17T06:53:18.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm96gfawn001frkp16bz08ukt","content":"<h1 id=\"什么是WebRTC？\"><a href=\"#什么是WebRTC？\" class=\"headerlink\" title=\"什么是WebRTC？\"></a>什么是WebRTC？</h1><p>WebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。</p>\n<p>WebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。</p>\n<h1 id=\"WebRTC的三大核心技术\"><a href=\"#WebRTC的三大核心技术\" class=\"headerlink\" title=\"WebRTC的三大核心技术\"></a>WebRTC的三大核心技术</h1><p>WebRTC的功能依赖于三个主要的API：</p>\n<ol>\n<li><p>getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。</p>\n</li>\n<li><p>RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。</p>\n</li>\n<li><p>RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。</p>\n</li>\n</ol>\n<h1 id=\"WebRTC如何工作？\"><a href=\"#WebRTC如何工作？\" class=\"headerlink\" title=\"WebRTC如何工作？\"></a>WebRTC如何工作？</h1><p>WebRTC的工作原理可以概括为以下几个步骤：</p>\n<p><img src=\"/blog/./images/webrtc/architecture.png\" alt=\"结构\"></p>\n<ol>\n<li><p>媒体设备访问：使用getUserMedia API获取音视频流。</p>\n</li>\n<li><p>建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。</p>\n</li>\n<li><p>ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。</p>\n</li>\n<li><p>数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。</p>\n</li>\n</ol>\n<h1 id=\"SDP是什么？\"><a href=\"#SDP是什么？\" class=\"headerlink\" title=\"SDP是什么？\"></a>SDP是什么？</h1><p>SDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。</p>\n<p>在 WebRTC 中，SDP 主要用于两个目的：</p>\n<ul>\n<li>描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。</li>\n<li>建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。</li>\n</ul>\n<h2 id=\"WebRTC-中的-SDP-交换流程\"><a href=\"#WebRTC-中的-SDP-交换流程\" class=\"headerlink\" title=\"WebRTC 中的 SDP 交换流程\"></a>WebRTC 中的 SDP 交换流程</h2><p>WebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：</p>\n<h3 id=\"创建-Offer-和-Answer\"><a href=\"#创建-Offer-和-Answer\" class=\"headerlink\" title=\"创建 Offer 和 Answer\"></a>创建 Offer 和 Answer</h3><ul>\n<li>Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。</li>\n<li>Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。</li>\n</ul>\n<h2 id=\"SDP-交换过程\"><a href=\"#SDP-交换过程\" class=\"headerlink\" title=\"SDP 交换过程\"></a>SDP 交换过程</h2><ol>\n<li>发起方创建 SDP offer：</li>\n</ol>\n<ul>\n<li>发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。</li>\n<li>发起方将 offer 通过信令通道发送给接收方。</li>\n</ul>\n<ol start=\"2\">\n<li>接收方收到 offer 后创建 SDP answer：</li>\n</ol>\n<ul>\n<li>接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。</li>\n<li>接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。</li>\n</ul>\n<ol start=\"3\">\n<li>双方交换 ICE 候选：</li>\n</ol>\n<ul>\n<li>在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。</li>\n</ul>\n<h1 id=\"使用WebRTC实现文件传输\"><a href=\"#使用WebRTC实现文件传输\" class=\"headerlink\" title=\"使用WebRTC实现文件传输\"></a>使用WebRTC实现文件传输</h1><p>下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。<br><img src=\"/blog/./images/webrtc/process.png\" alt=\"流程\"></p>\n<ol>\n<li>连接信令服务器<br>WebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">HubConnectionBuilder</span>()</span><br><span class=\"line\">    .<span class=\"title function_\">withUrl</span>(<span class=\"string\">&#x27;http://localhost:5217/signalr&#x27;</span>)  <span class=\"comment\">// .NET SignalR 服务的 URL</span></span><br><span class=\"line\">    .<span class=\"title function_\">build</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始连接</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">start</span>();</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">isConnected</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connectionId</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"property\">connectionId</span>;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;SignalR 连接成功！&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取所有连接的 ID</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;GetAllConnections&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 初始化 WebRTC</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setupWebRTC</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;SignalR 连接失败！&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。<br><img src=\"/blog/./images/webrtc/connections.png\" alt=\"连接\"></p>\n<ol start=\"2\">\n<li>初始化 WebRTC<br>创建一个RTCPeerConnection实例</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">setupWebRTC</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">RTCPeerConnection</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 收集 ICE 候选并发送给目标连接</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onicecandidate</span> = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.<span class=\"property\">candidate</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收集到 ICE 候选:&#x27;</span>, event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">sendIceCandidate</span>(event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听连接状态变化</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">oniceconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ICE 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;ICE 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;WebRTC 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;WebRTC 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setupDataChannel</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>发送信令并建立连接<br>在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送 Offer 给目标客户端</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">sendOffer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> offer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createOffer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(offer);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;发送 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendOffer&#x27;</span>, offer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;发送 Offer 失败：&#x27;</span>, err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标客户端接收到的 Offer，创建 Answer</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">receiveOffer</span>(<span class=\"params\">offer</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收到 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setRemoteDescription</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RTCSessionDescription</span>(offer));</span><br><span class=\"line\">    <span class=\"keyword\">const</span> answer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createAnswer</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;创建 Answer 成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(answer);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Local Description 设置成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendAnswer&#x27;</span>, answer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>传输文件<br>在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择文件</span></span><br><span class=\"line\"><span class=\"title function_\">handleFileSelection</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> file = event.<span class=\"property\">target</span>.<span class=\"property\">files</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">file</span> = file;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;已选择文件:&#x27;</span>, file.<span class=\"property\">name</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送文件</span></span><br><span class=\"line\"><span class=\"title function_\">sendFile</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> chunkSize = <span class=\"number\">16384</span>;  <span class=\"comment\">// 设置块大小为 16KB</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件基本信息（如文件名和文件大小）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileInfo = &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">name</span>,</span><br><span class=\"line\">        <span class=\"attr\">size</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(fileInfo));  <span class=\"comment\">// 发送文件基本信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">sendNextChunk</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> fileSlice = <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"title function_\">slice</span>(offset, offset + chunkSize);</span><br><span class=\"line\">        fileReader.<span class=\"property\">onload</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(fileReader.<span class=\"property\">result</span>);  <span class=\"comment\">// 发送文件块</span></span><br><span class=\"line\">        offset += chunkSize;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (offset &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 继续发送下一个块</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;文件发送完毕&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        fileReader.<span class=\"title function_\">readAsArrayBuffer</span>(fileSlice);  <span class=\"comment\">// 读取文件块为 ArrayBuffer</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 开始发送文件块</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;数据通道不可用或未选择文件&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>打完收工，最后我们来看看实现的效果：<br><img src=\"/blog/./images/webrtc/result.gif\" alt=\"效果\"></p>\n<h1 id=\"WebRTC的实际应用\"><a href=\"#WebRTC的实际应用\" class=\"headerlink\" title=\"WebRTC的实际应用\"></a>WebRTC的实际应用</h1><p>WebRTC已被广泛应用于各种实时通信场景，包括：</p>\n<ol>\n<li>视频会议：如Zoom、Google Meet等平台都使用了WebRTC。</li>\n<li>在线教育：利用WebRTC实现师生之间的实时互动和交流。</li>\n<li>文件传输：通过RTCDataChannel实现浏览器间的文件传输。</li>\n<li>在线客服：实现企业与客户之间的实时视频或语音通信。</li>\n</ol>\n<h1 id=\"WebRTC的优势与挑战\"><a href=\"#WebRTC的优势与挑战\" class=\"headerlink\" title=\"WebRTC的优势与挑战\"></a>WebRTC的优势与挑战</h1><h2 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h2><ul>\n<li>无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。</li>\n<li>低延迟：WebRTC专为实时通信设计，支持高效的数据传输。</li>\n<li>跨平台：支持各种操作系统和设备，具有良好的兼容性。</li>\n</ul>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><ul>\n<li>NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN&#x2F;TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。</li>\n<li>信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。</li>\n<li>浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>WebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。</p>\n<hr>\n<p>本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是WebRTC？\"><a href=\"#什么是WebRTC？\" class=\"headerlink\" title=\"什么是WebRTC？\"></a>什么是WebRTC？</h1><p>WebRTC（Web Real-Time Communication）是一项支持网页和移动应用程序进行实时语音、视频和数据共享的技术，允许用户直接在浏览器中进行通信，无需安装额外的插件或应用。WebRTC是一项开放标准，由W3C和IETF共同推动，广泛应用于视频会议、即时通讯、文件共享等场景。</p>\n<p>WebRTC的核心优势在于其低延迟、高效率和跨平台支持，使得不同设备和浏览器之间的实时通信变得简单和快速。</p>\n<h1 id=\"WebRTC的三大核心技术\"><a href=\"#WebRTC的三大核心技术\" class=\"headerlink\" title=\"WebRTC的三大核心技术\"></a>WebRTC的三大核心技术</h1><p>WebRTC的功能依赖于三个主要的API：</p>\n<ol>\n<li><p>getUserMedia API：这个API允许浏览器访问用户的媒体设备，如摄像头和麦克风，捕获音视频流。</p>\n</li>\n<li><p>RTCPeerConnection API：这个API负责处理浏览器之间的点对点连接，确保音视频数据能够在浏览器间高效、稳定地传输。</p>\n</li>\n<li><p>RTCDataChannel API：这个API允许浏览器之间传输任意类型的数据，如文本、文件或其他媒体文件。</p>\n</li>\n</ol>\n<h1 id=\"WebRTC如何工作？\"><a href=\"#WebRTC如何工作？\" class=\"headerlink\" title=\"WebRTC如何工作？\"></a>WebRTC如何工作？</h1><p>WebRTC的工作原理可以概括为以下几个步骤：</p>\n<p><img src=\"/blog/./images/webrtc/architecture.png\" alt=\"结构\"></p>\n<ol>\n<li><p>媒体设备访问：使用getUserMedia API获取音视频流。</p>\n</li>\n<li><p>建立连接：使用RTCPeerConnection API建立点对点连接。此时，浏览器之间需要交换一些“信令”信息（如SDP，Session Description Protocol）以建立连接。</p>\n</li>\n<li><p>ICE协议：WebRTC使用ICE（Interactive Connectivity Establishment）协议在浏览器间选择最佳的传输路径，以确保点对点连接的质量和稳定性。</p>\n</li>\n<li><p>数据传输：通过RTCDataChannel API，浏览器之间可以直接传输任意数据。</p>\n</li>\n</ol>\n<h1 id=\"SDP是什么？\"><a href=\"#SDP是什么？\" class=\"headerlink\" title=\"SDP是什么？\"></a>SDP是什么？</h1><p>SDP（Session Description Protocol） 是一个描述多媒体会话的协议，它用于提供多媒体通信的会话参数，包括音频、视频、数据等流的格式、编解码器信息、网络地址等。在 WebRTC 中，SDP 协议扮演着一个非常重要的角色，它被用来在建立点对点连接时描述会话的各项参数，如音视频的编解码方式、网络传输信息等。</p>\n<p>在 WebRTC 中，SDP 主要用于两个目的：</p>\n<ul>\n<li>描述媒体会话：通过 SDP 来描述媒体会话的格式、编解码器、网络传输信息等。</li>\n<li>建立连接：通过交换 SDP offer 和 answer，WebRTC 的两端可以协商连接的参数并建立 P2P 连接。</li>\n</ul>\n<h2 id=\"WebRTC-中的-SDP-交换流程\"><a href=\"#WebRTC-中的-SDP-交换流程\" class=\"headerlink\" title=\"WebRTC 中的 SDP 交换流程\"></a>WebRTC 中的 SDP 交换流程</h2><p>WebRTC 使用 SDP 来交换会话的描述，通常通过信令通道（如 WebSocket、Socket.io 等）在两个端点之间交换 offer 和 answer：</p>\n<h3 id=\"创建-Offer-和-Answer\"><a href=\"#创建-Offer-和-Answer\" class=\"headerlink\" title=\"创建 Offer 和 Answer\"></a>创建 Offer 和 Answer</h3><ul>\n<li>Offer：由发起方（通常是客户端 A）创建，表示该方希望建立连接。offer 会包含可支持的媒体格式、编解码器、传输协议等信息。</li>\n<li>Answer：由接收方（通常是客户端 B）创建，表示同意建立连接，并返回支持的媒体格式、编解码器等信息。接收方根据 offer 的内容来选择合适的媒体参数，并生成 answer。</li>\n</ul>\n<h2 id=\"SDP-交换过程\"><a href=\"#SDP-交换过程\" class=\"headerlink\" title=\"SDP 交换过程\"></a>SDP 交换过程</h2><ol>\n<li>发起方创建 SDP offer：</li>\n</ol>\n<ul>\n<li>发起方通过 RTCPeerConnection.createOffer() 创建一个包含媒体信息的 offer。</li>\n<li>发起方将 offer 通过信令通道发送给接收方。</li>\n</ul>\n<ol start=\"2\">\n<li>接收方收到 offer 后创建 SDP answer：</li>\n</ol>\n<ul>\n<li>接收方收到 offer 后，通过 RTCPeerConnection.createAnswer() 创建 answer。</li>\n<li>接收方根据自身的能力（如支持的编解码器、分辨率等）生成适合的 answer，并通过信令通道发送给发起方。</li>\n</ul>\n<ol start=\"3\">\n<li>双方交换 ICE 候选：</li>\n</ol>\n<ul>\n<li>在 offer 和 answer 交换后，双方会通过 ICE 候选交换（通过 onicecandidate 事件），确保点对点连接的稳定性。</li>\n</ul>\n<h1 id=\"使用WebRTC实现文件传输\"><a href=\"#使用WebRTC实现文件传输\" class=\"headerlink\" title=\"使用WebRTC实现文件传输\"></a>使用WebRTC实现文件传输</h1><p>下面是一个简单的WebRTC文件传输的示例。我们将用.net实现一个简单的信令服务器，然后通过RTCPeerConnection进行连接，最终实现点对点的文件传输。<br><img src=\"/blog/./images/webrtc/process.png\" alt=\"流程\"></p>\n<ol>\n<li>连接信令服务器<br>WebRTC 作为 P2P（点对点）通信协议，首先需要通过一个信令通道（通常是通过 WebSocket、HTTP 或其他通信机制）来交换信息，建立两端之间的连接。这个信令过程是 WebRTC 的必备部分，它不属于 WebRTC 标准的一部分，因此需要开发者自行实现。这里我们在前端使用SignalR来实现信令的发送和接收。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">HubConnectionBuilder</span>()</span><br><span class=\"line\">    .<span class=\"title function_\">withUrl</span>(<span class=\"string\">&#x27;http://localhost:5217/signalr&#x27;</span>)  <span class=\"comment\">// .NET SignalR 服务的 URL</span></span><br><span class=\"line\">    .<span class=\"title function_\">build</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始连接</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">start</span>();</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">isConnected</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connectionId</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"property\">connectionId</span>;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;SignalR 连接成功！&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取所有连接的 ID</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;GetAllConnections&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 初始化 WebRTC</span></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setupWebRTC</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\"><span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;SignalR 连接失败！&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我希望能够选择目标客户端进行连接，所以在后端维护了一个连接的字典，前端获取连接列表，通过选择不同的连接来建立连接。<br><img src=\"/blog/./images/webrtc/connections.png\" alt=\"连接\"></p>\n<ol start=\"2\">\n<li>初始化 WebRTC<br>创建一个RTCPeerConnection实例</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">setupWebRTC</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">RTCPeerConnection</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 收集 ICE 候选并发送给目标连接</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onicecandidate</span> = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event.<span class=\"property\">candidate</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收集到 ICE 候选:&#x27;</span>, event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">sendIceCandidate</span>(event.<span class=\"property\">candidate</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 监听连接状态变化</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">oniceconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;ICE 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">iceConnectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;ICE 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">onconnectionstatechange</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;WebRTC 连接状态:&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"property\">connectionState</span> === <span class=\"string\">&#x27;failed&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;WebRTC 连接失败！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setupDataChannel</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>发送信令并建立连接<br>在信令通道上交换信息以完成连接设置。信令本身不是WebRTC的一部分，因此我们可以使用WebSocket、WebRTC DataChannel等方式来交换这些信令。在界面上手动选择要连接的客户端。然后发送信令给目标客户端，建立连接。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送 Offer 给目标客户端</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">sendOffer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> offer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createOffer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(offer);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;发送 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendOffer&#x27;</span>, offer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;发送 Offer 失败：&#x27;</span>, err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标客户端接收到的 Offer，创建 Answer</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"title function_\">receiveOffer</span>(<span class=\"params\">offer</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;收到 Offer:&#x27;</span>, offer);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setRemoteDescription</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">RTCSessionDescription</span>(offer));</span><br><span class=\"line\">    <span class=\"keyword\">const</span> answer = <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">createAnswer</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;创建 Answer 成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"variable language_\">this</span>.<span class=\"property\">rtcPeerConnection</span>.<span class=\"title function_\">setLocalDescription</span>(answer);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Local Description 设置成功&quot;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">connection</span>.<span class=\"title function_\">invoke</span>(<span class=\"string\">&#x27;SendAnswer&#x27;</span>, answer, <span class=\"variable language_\">this</span>.<span class=\"property\">targetConnectionId</span>);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>传输文件<br>在WebRTC连接建立后，我们可以使用RTCDataChannel来传输任意类型的数据，包括文件。这里我们使用RTCDataChannel来传输文件，并且在接收方直接把图片展示出来。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择文件</span></span><br><span class=\"line\"><span class=\"title function_\">handleFileSelection</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> file = event.<span class=\"property\">target</span>.<span class=\"property\">files</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">file</span> = file;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;已选择文件:&#x27;</span>, file.<span class=\"property\">name</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送文件</span></span><br><span class=\"line\"><span class=\"title function_\">sendFile</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> chunkSize = <span class=\"number\">16384</span>;  <span class=\"comment\">// 设置块大小为 16KB</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送文件基本信息（如文件名和文件大小）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileInfo = &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">name</span>,</span><br><span class=\"line\">        <span class=\"attr\">size</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(fileInfo));  <span class=\"comment\">// 发送文件基本信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">sendNextChunk</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> fileSlice = <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"title function_\">slice</span>(offset, offset + chunkSize);</span><br><span class=\"line\">        fileReader.<span class=\"property\">onload</span> = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">dataChannel</span>.<span class=\"title function_\">send</span>(fileReader.<span class=\"property\">result</span>);  <span class=\"comment\">// 发送文件块</span></span><br><span class=\"line\">        offset += chunkSize;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (offset &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">file</span>.<span class=\"property\">size</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 继续发送下一个块</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;文件发送完毕&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        fileReader.<span class=\"title function_\">readAsArrayBuffer</span>(fileSlice);  <span class=\"comment\">// 读取文件块为 ArrayBuffer</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">sendNextChunk</span>();  <span class=\"comment\">// 开始发送文件块</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;数据通道不可用或未选择文件&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>打完收工，最后我们来看看实现的效果：<br><img src=\"/blog/./images/webrtc/result.gif\" alt=\"效果\"></p>\n<h1 id=\"WebRTC的实际应用\"><a href=\"#WebRTC的实际应用\" class=\"headerlink\" title=\"WebRTC的实际应用\"></a>WebRTC的实际应用</h1><p>WebRTC已被广泛应用于各种实时通信场景，包括：</p>\n<ol>\n<li>视频会议：如Zoom、Google Meet等平台都使用了WebRTC。</li>\n<li>在线教育：利用WebRTC实现师生之间的实时互动和交流。</li>\n<li>文件传输：通过RTCDataChannel实现浏览器间的文件传输。</li>\n<li>在线客服：实现企业与客户之间的实时视频或语音通信。</li>\n</ol>\n<h1 id=\"WebRTC的优势与挑战\"><a href=\"#WebRTC的优势与挑战\" class=\"headerlink\" title=\"WebRTC的优势与挑战\"></a>WebRTC的优势与挑战</h1><h2 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h2><ul>\n<li>无需插件：WebRTC支持浏览器原生实现，不需要安装额外插件。</li>\n<li>低延迟：WebRTC专为实时通信设计，支持高效的数据传输。</li>\n<li>跨平台：支持各种操作系统和设备，具有良好的兼容性。</li>\n</ul>\n<h2 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h2><ul>\n<li>NAT穿透：由于大多数用户在NAT（网络地址转换）后面，WebRTC需要使用STUN&#x2F;TURN服务器来处理NAT穿透，这增加了开发和部署的复杂性。</li>\n<li>信令：WebRTC本身不定义信令协议，因此开发者需要自己选择一种信令方式。</li>\n<li>浏览器兼容性：尽管大部分现代浏览器支持WebRTC，但仍存在一些兼容性问题，尤其是在移动设备上。</li>\n</ul>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>WebRTC为浏览器之间提供了高效、低延迟的实时通信解决方案，应用场景广泛，能够帮助开发者构建出更丰富的实时交互体验。虽然在开发过程中可能会遇到一些挑战，如信令协议、NAT穿透等问题，但随着技术的不断发展，WebRTC的应用前景仍然非常广阔。</p>\n<hr>\n<p>本文只是对WebRTC的简单介绍和概念引入，更多细节和实际应用可以参考官方文档和相关资源。</p>\n"},{"title":"手写一个微型 Spring 框架（二）:从路由到生命周期管理","date":"2025-04-27T07:42:39.000Z","_content":"\n书接上回，在上一篇文章中，我们展示了如何构建一个简单的微型 Spring 框架，涵盖了端口监听、路由动态注册和依赖注入（IoC）。本篇将进一步扩展我们的框架，涵盖 参数绑定、中间件机制、全局异常处理、JSON 返回支持 以及 生命周期管理。\n\n这些功能将使我们的微型框架更加完整，能够处理更多的应用场景。让我们开始深入探讨这些新增功能。\n\n# 参数绑定\n在上一篇文章里面虽然我们已经能够通过访问接口来获取返回值。但是请求的参数是如何绑定到方法的参数上的呢？这就是参数绑定的作用。\n在 Web 开发中，参数绑定是一个非常重要的特性，通常用于从请求中提取参数并绑定到方法的参数上。在 Spring 框架中，我们通过注解如 @RequestParam 和 @RequestBody 来实现这一功能， 这里我们也直接参照实现。\n\n## 目标：\n1. 使用 @FromQuery 注解实现 URL 查询参数的绑定。\n2. 使用 @FromBody 注解将请求体中的 JSON 数据绑定为 Java 对象。\n3. 使用 @FromRoute 注解将路径变量绑定到方法参数。\n\n## 实现方法：\n\n### 动态路由\n在之前的路由注册过程中，我们已经将路径和对应的处理方法进行了映射。为了实现路径参数（/user/{id}）绑定，我们需要实现动态路由，即根据请求的 URL 路径来动态确定要调用的处理方法。只有这样我们才能过滤出请求的参数。\n```java\n// 之前的路由注册\n//  server.createContext(path, exchange -> {\n//      // 这里我们需要根据请求的 URL 路径来确定要调用的处理方法\n//  });\n\n// 现在我们需要实现动态路由（在程序启动的时候扫描所有controller、action，然后缓存起来）\nprivate final List<RouteDefinition> dynamicRoutes = new ArrayList<>();\n for (Class<?> clazz : classes) {\n    for (Method method : clazz.getDeclaredMethods()) {\n        dynamicRoutes.add(new RouteDefinition(httpMethod, path, pathPattern, pathVaribleNames, controllerInstance, method));\n    }\n }\n\nserver.createContext(\"/\", exchange -> {\n    String requestPath = exchange.getRequestURI().getPath();\n\n    // 根据请求路径找到对应的处理方法\n    RouteDefinition matchedRoute = findMatchRoute(requestPath);\n\n    // 执行具体的处理方法\n});\n```\n### 解析参数\n这里注解的实现就不多说了，我们主要看看参数绑定的实现。\n我们在框架中通过反射机制来解析方法参数，根据注解从请求中提取相应的参数。以下是参数绑定的代码示例：\n\n```java\npublic Object[] resolveMethodParameters(HttpExchange exchange, RouteDefinition route, Map<String, String> pathVariables) throws Exception {\n    Parameter[] parameters = route.handlerMethod.getParameters();\n    Object[] args = new Object[parameters.length];\n\n    for (int i = 0; i < parameters.length; i++) {\n        Parameter parameter = parameters[i];\n\n        if (parameter.isAnnotationPresent(FromQuery.class)) {\n            // 从 URL 查询参数中提取\n            Map<String, String> queryParams = UrlExtensions.parseQueryParams(exchange.getRequestURI().getRawQuery());\n            args[i] = StringExtensions.convertTo(queryParams.get(parameter.getName()), parameter.getType());\n        } else if (parameter.isAnnotationPresent(FromBody.class)) {\n            // 从请求体中提取 JSON 数据并绑定\n            String bodyString = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);\n            args[i] = new Gson().fromJson(bodyString, parameter.getType());\n        } else if (parameter.isAnnotationPresent(FromRoute.class)) {\n            // 从路径变量中提取\n            args[i] = StringExtensions.convertTo(pathVariables.get(parameter.getName()), parameter.getType());\n        }\n    }\n\n    return args;\n}\n```\n此方法确保可以将查询参数、请求体和路径变量自动绑定到控制器方法的参数上。\n\n我们来一起看看效果\n1. get参数\n![post](./images/javelin-2/query-params.png)\n2. post参数\n![post](./images/javelin-2/post-params.png)\n3. 路径参数\n![post](./images/javelin-2/route-params.png)\n\n\n# JSON 返回支持\n在此之前我们返回接口返回的都是String类型，现在我们来实现JSON返回支持。同时我们希望可以根据返回值的类型自动判断是否需要转换为 JSON 格式。\n\n## 目标：\n\n支持返回 String 类型或自定义对象类型。\n\n如果返回的是对象，则自动将其转换为 JSON 格式。\n\n## 实现方式：\n\n```java\n// 获取返回值的类型\nClass<?> returnType = route.action.getReturnType();\n\nString responseBody;\nif(returnType == String.class || returnType == void.class || returnType == int.class) {\n    responseBody = (String) result;\n    exchange.getResponseHeaders().set(\"Content-Type\", \"text/plain; charset=UTF-8\");\n} else {\n    responseBody = gson.toJson(result);\n    exchange.getResponseHeaders().set(\"Content-Type\", \"application/json; charset=UTF-8\");\n}\n```\n此逻辑将根据返回类型自动决定响应类型。对于 Java 对象，将使用 Gson 转换为 JSON 格式返回。\n## 实现效果\n![json](./images/javelin-2/json.png)\n\n# 中间件机制\n中间件（Middleware）是框架中一个非常强大的特性，它允许你在请求处理流程的各个阶段插入额外的处理逻辑。比如，我们可以在请求到达控制器之前，进行权限验证、日志记录等操作。 这里有一个需要关注的地方，我并没有使用现在比较流行的委托链式的中间件，而是参考类似asp.net 的HTTP 管道的方式实现的。\n\n之所以有这样的选择是因为委托链式的中间件在处理过程中会有一些问题，比如：\n1. 中间件的执行顺序难以控制，可能会导致请求处理流程出现问题。\n2. 一旦出现异常，中间件的异常处理逻辑可能会变得复杂， 异常链非常的深。\n\n所以我选择了类似asp.net 的HTTP 管道的方式实现的中间件，这样可以更加清晰的控制中间件的执行顺序，并且异常处理也更加方便。\n![管道](./images/javelin-2/pipeline.png)\n\n## 实现目标：\n\n1. 在请求处理流程中添加拦截器，允许在方法调用之前或之后执行特定操作。\n2. 可以添加多个中间件。\n3. 支持定义中间件的执行顺序。\n\n## 实现方式：\n\n```java\n// 框架初始化的时候注册中间件\nprivate static void loadModules() {\n    NHttpModuleFactory.registerModule(OprLogModule.class);\n\n    NHttpModuleFactory.registerModule(AuthenticateModule.class);\n    NHttpModuleFactory.registerModule(AuthorizeModule.class);\n}\n```\n在路由处理程序中，我们执行中间件链：\n\n```java\npublic void execute(NHttpContext context) throws Exception {\n    NHttpApplication app = NHttpApplication.INSTANCE;\n\n    preHandle(context);\n    try{\n        app.beginRequest(context);\n        app.authenticateRequest(context);\n        app.postAuthenticateRequest(context);\n        app.resolveRequestCache(context);\n\n        handlerRequest(context);\n    } catch ( AbortRequestException e) {\n        // 提前结束请求，啥也不干了\n    } catch (Exception e) {\n        context.pipelineContext.setException(e);\n        app.onError(context);\n    } finally {\n        app.endRequest(context);\n    }\n\n}\n```\n通过这种方式，我们能够在请求处理过程中插入不同的功能，增加灵活性和可扩展性。\n\n## 实现效果\n这里我们新增了一个权限验证的中间件，在请求到达控制器之前进行验证。\n![权限](./images/javelin-2/authorize.png)\n\n# 全局日志处理\n在我们的框架中，我们可以通过中间件机制来实现全局日志处理。这样，我们就可以在请求处理的各个阶段记录日志，方便调试和监控。\n\n## 目标：\n1. 在请求到达控制器之前记录请求信息。\n2. 在请求处理完成后记录响应信息。\n3. 捕获所有未处理的异常。\n4. 返回适当的错误响应。\n\n## 实现方式：\n我们可以创建一个日志中间件，在请求到达控制器之前和处理完成后记录日志：\n```java\npublic class OprLogModule extends NHttpModule {\n    @Override\n    public void beginRequest(NHttpContext httpContext) {\n        // 请求到达之前记录请求信息\n    }\n\n    @Override\n    public void endRequest(NHttpContext httpContext) {\n        // 请求处理完成后记录响应信息\n    }\n\n    @Override\n    public void onError(NHttpContext httpContext) {\n        // 请求发生异常的时候记录异常信息\n    }\n}\n```\n通过统一的异常处理，可以确保系统稳定性和一致的错误响应。\n\n## 实现效果\n为了测试，我们直接在控制器中抛出一个异常：\n```java\n @GetMapping(\"/error\")\n@AllowAnonymous\npublic void error() throws Exception {\n    throw new Exception(\"测试异常\");\n}\n```\n![日志](./images/javelin-2/error.png)\n最后我们来看看日志的记录结果，这是初版的日志，直接记录在文件里面。\n这里记录一个TODO，后期需要优化日志记录。（日志异步上报， ELK等等）\n![日志](./images/javelin-2/log.png)\n\n\n\n# 生命周期管理\n生命周期管理是一个框架的重要组成部分。在 Spring 中，我们有 @PostConstruct 和 @PreDestroy 等注解来管理对象的生命周期。在我们的微型框架中，我们可以模拟类似的生命周期管理。\n\n## 目标：\n\n1. 在创建控制器实例时进行初始化。\n2. 在销毁时执行清理操作。\n\n## 实现方式：\n\n```java\npublic class JavelinContext {\n    private final Map<Class<?>, Object> singletonMap = new HashMap<>();\n\n    public <T> T getBean(Class<T> clazz) {\n        if (!singletonMap.containsKey(clazz)) {\n            try {\n                T instance = createBean(clazz);\n                singletonMap.put(clazz, instance);\n                return instance;\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to create bean: \" + clazz.getName(), e);\n            }\n        }\n        return (T) singletonMap.get(clazz);\n    }\n\n    private <T> T createBean(Class<T> clazz) throws Exception {\n        // 创建实例并调用初始化方法\n        T instance = (T) injectConstructor.newInstance(args.toArray());\n        callPostConstruct(instance);\n        return instance;\n    }\n\n    private void callPostConstruct(Object instance) throws Exception {\n        // 调用初始化方法\n    }\n\n    public void callPreDestroy(Object instance) {\n        // 调用销毁方法\n    }\n}\n```\n通过这种方式，框架在创建实例时调用 @PostConstruct 注解的方法, 请求处理完成之后调用 @PreDestroy 注解的方法。帮助我们在对象生命周期中插入初始化逻辑。\n## 实现效果\n![生命周期](./images/javelin-2/life-cycle.png)\n\n\n# 总结与下步计划\n在本篇文章中，我们深入探讨了如何将更多实用的功能添加到我们自定义的微型 Spring 框架中，包括参数绑定、中间件机制、全局异常处理、JSON 返回支持以及生命周期管理。这些功能的实现使得框架的功能更加完善，能够更好地应对复杂的 Web 应用需求。\n\n- 参数绑定：我们通过 @FromQuery, @FromBody, 和 @FromRoute 注解来实现请求参数与方法参数的自动绑定。这一机制可以让控制器方法直接接收 URL 查询参数、请求体数据和路径变量，提高了开发效率。\n\n- 中间件机制：我们参考了 ASP.NET 的 HTTP 管道模式，实现了一个可扩展的中间件机制。通过中间件，可以在请求处理过程中插入额外的逻辑，如权限验证、日志记录等，极大提升了框架的灵活性和可维护性。\n\n- 全局异常处理：通过中间件，框架能够统一处理请求过程中可能出现的异常，确保系统的稳定性，并能够返回一致的错误响应，便于调试和监控。\n\n- JSON 返回支持：我们实现了自动判断返回值的类型并根据类型转换为 JSON 格式。这使得框架能够支持更加复杂的数据返回类型，便于处理 JSON 响应。\n\n- 生命周期管理：模拟了 Spring 的 @PostConstruct 和 @PreDestroy 注解功能，确保在对象生命周期中能够执行初始化和销毁操作，为框架的管理提供了更多控制。\n\n通过实现这些功能，我们不仅提升了框架的可用性，也使其更加完善，能够更好地适应复杂的业务场景。在接下来的文章中，我们将继续扩展更多功能，进一步增强框架的灵活性和实用性。\n\n后续我们将继续拓展：\n- 权限与角色管理\n- 支持定时任务与后台任务\n- 支持数据库操作\n\n如果你对框架有更多的扩展需求，或者希望了解其他细节，请继续关注我们的后续文章！\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/Javelin)仓库。","source":"_posts/javelin-2.md","raw":"---\ntitle: 手写一个微型 Spring 框架（二）:从路由到生命周期管理\ndate: 2025-04-27 15:42:39\ntags:\n---\n\n书接上回，在上一篇文章中，我们展示了如何构建一个简单的微型 Spring 框架，涵盖了端口监听、路由动态注册和依赖注入（IoC）。本篇将进一步扩展我们的框架，涵盖 参数绑定、中间件机制、全局异常处理、JSON 返回支持 以及 生命周期管理。\n\n这些功能将使我们的微型框架更加完整，能够处理更多的应用场景。让我们开始深入探讨这些新增功能。\n\n# 参数绑定\n在上一篇文章里面虽然我们已经能够通过访问接口来获取返回值。但是请求的参数是如何绑定到方法的参数上的呢？这就是参数绑定的作用。\n在 Web 开发中，参数绑定是一个非常重要的特性，通常用于从请求中提取参数并绑定到方法的参数上。在 Spring 框架中，我们通过注解如 @RequestParam 和 @RequestBody 来实现这一功能， 这里我们也直接参照实现。\n\n## 目标：\n1. 使用 @FromQuery 注解实现 URL 查询参数的绑定。\n2. 使用 @FromBody 注解将请求体中的 JSON 数据绑定为 Java 对象。\n3. 使用 @FromRoute 注解将路径变量绑定到方法参数。\n\n## 实现方法：\n\n### 动态路由\n在之前的路由注册过程中，我们已经将路径和对应的处理方法进行了映射。为了实现路径参数（/user/{id}）绑定，我们需要实现动态路由，即根据请求的 URL 路径来动态确定要调用的处理方法。只有这样我们才能过滤出请求的参数。\n```java\n// 之前的路由注册\n//  server.createContext(path, exchange -> {\n//      // 这里我们需要根据请求的 URL 路径来确定要调用的处理方法\n//  });\n\n// 现在我们需要实现动态路由（在程序启动的时候扫描所有controller、action，然后缓存起来）\nprivate final List<RouteDefinition> dynamicRoutes = new ArrayList<>();\n for (Class<?> clazz : classes) {\n    for (Method method : clazz.getDeclaredMethods()) {\n        dynamicRoutes.add(new RouteDefinition(httpMethod, path, pathPattern, pathVaribleNames, controllerInstance, method));\n    }\n }\n\nserver.createContext(\"/\", exchange -> {\n    String requestPath = exchange.getRequestURI().getPath();\n\n    // 根据请求路径找到对应的处理方法\n    RouteDefinition matchedRoute = findMatchRoute(requestPath);\n\n    // 执行具体的处理方法\n});\n```\n### 解析参数\n这里注解的实现就不多说了，我们主要看看参数绑定的实现。\n我们在框架中通过反射机制来解析方法参数，根据注解从请求中提取相应的参数。以下是参数绑定的代码示例：\n\n```java\npublic Object[] resolveMethodParameters(HttpExchange exchange, RouteDefinition route, Map<String, String> pathVariables) throws Exception {\n    Parameter[] parameters = route.handlerMethod.getParameters();\n    Object[] args = new Object[parameters.length];\n\n    for (int i = 0; i < parameters.length; i++) {\n        Parameter parameter = parameters[i];\n\n        if (parameter.isAnnotationPresent(FromQuery.class)) {\n            // 从 URL 查询参数中提取\n            Map<String, String> queryParams = UrlExtensions.parseQueryParams(exchange.getRequestURI().getRawQuery());\n            args[i] = StringExtensions.convertTo(queryParams.get(parameter.getName()), parameter.getType());\n        } else if (parameter.isAnnotationPresent(FromBody.class)) {\n            // 从请求体中提取 JSON 数据并绑定\n            String bodyString = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);\n            args[i] = new Gson().fromJson(bodyString, parameter.getType());\n        } else if (parameter.isAnnotationPresent(FromRoute.class)) {\n            // 从路径变量中提取\n            args[i] = StringExtensions.convertTo(pathVariables.get(parameter.getName()), parameter.getType());\n        }\n    }\n\n    return args;\n}\n```\n此方法确保可以将查询参数、请求体和路径变量自动绑定到控制器方法的参数上。\n\n我们来一起看看效果\n1. get参数\n![post](./images/javelin-2/query-params.png)\n2. post参数\n![post](./images/javelin-2/post-params.png)\n3. 路径参数\n![post](./images/javelin-2/route-params.png)\n\n\n# JSON 返回支持\n在此之前我们返回接口返回的都是String类型，现在我们来实现JSON返回支持。同时我们希望可以根据返回值的类型自动判断是否需要转换为 JSON 格式。\n\n## 目标：\n\n支持返回 String 类型或自定义对象类型。\n\n如果返回的是对象，则自动将其转换为 JSON 格式。\n\n## 实现方式：\n\n```java\n// 获取返回值的类型\nClass<?> returnType = route.action.getReturnType();\n\nString responseBody;\nif(returnType == String.class || returnType == void.class || returnType == int.class) {\n    responseBody = (String) result;\n    exchange.getResponseHeaders().set(\"Content-Type\", \"text/plain; charset=UTF-8\");\n} else {\n    responseBody = gson.toJson(result);\n    exchange.getResponseHeaders().set(\"Content-Type\", \"application/json; charset=UTF-8\");\n}\n```\n此逻辑将根据返回类型自动决定响应类型。对于 Java 对象，将使用 Gson 转换为 JSON 格式返回。\n## 实现效果\n![json](./images/javelin-2/json.png)\n\n# 中间件机制\n中间件（Middleware）是框架中一个非常强大的特性，它允许你在请求处理流程的各个阶段插入额外的处理逻辑。比如，我们可以在请求到达控制器之前，进行权限验证、日志记录等操作。 这里有一个需要关注的地方，我并没有使用现在比较流行的委托链式的中间件，而是参考类似asp.net 的HTTP 管道的方式实现的。\n\n之所以有这样的选择是因为委托链式的中间件在处理过程中会有一些问题，比如：\n1. 中间件的执行顺序难以控制，可能会导致请求处理流程出现问题。\n2. 一旦出现异常，中间件的异常处理逻辑可能会变得复杂， 异常链非常的深。\n\n所以我选择了类似asp.net 的HTTP 管道的方式实现的中间件，这样可以更加清晰的控制中间件的执行顺序，并且异常处理也更加方便。\n![管道](./images/javelin-2/pipeline.png)\n\n## 实现目标：\n\n1. 在请求处理流程中添加拦截器，允许在方法调用之前或之后执行特定操作。\n2. 可以添加多个中间件。\n3. 支持定义中间件的执行顺序。\n\n## 实现方式：\n\n```java\n// 框架初始化的时候注册中间件\nprivate static void loadModules() {\n    NHttpModuleFactory.registerModule(OprLogModule.class);\n\n    NHttpModuleFactory.registerModule(AuthenticateModule.class);\n    NHttpModuleFactory.registerModule(AuthorizeModule.class);\n}\n```\n在路由处理程序中，我们执行中间件链：\n\n```java\npublic void execute(NHttpContext context) throws Exception {\n    NHttpApplication app = NHttpApplication.INSTANCE;\n\n    preHandle(context);\n    try{\n        app.beginRequest(context);\n        app.authenticateRequest(context);\n        app.postAuthenticateRequest(context);\n        app.resolveRequestCache(context);\n\n        handlerRequest(context);\n    } catch ( AbortRequestException e) {\n        // 提前结束请求，啥也不干了\n    } catch (Exception e) {\n        context.pipelineContext.setException(e);\n        app.onError(context);\n    } finally {\n        app.endRequest(context);\n    }\n\n}\n```\n通过这种方式，我们能够在请求处理过程中插入不同的功能，增加灵活性和可扩展性。\n\n## 实现效果\n这里我们新增了一个权限验证的中间件，在请求到达控制器之前进行验证。\n![权限](./images/javelin-2/authorize.png)\n\n# 全局日志处理\n在我们的框架中，我们可以通过中间件机制来实现全局日志处理。这样，我们就可以在请求处理的各个阶段记录日志，方便调试和监控。\n\n## 目标：\n1. 在请求到达控制器之前记录请求信息。\n2. 在请求处理完成后记录响应信息。\n3. 捕获所有未处理的异常。\n4. 返回适当的错误响应。\n\n## 实现方式：\n我们可以创建一个日志中间件，在请求到达控制器之前和处理完成后记录日志：\n```java\npublic class OprLogModule extends NHttpModule {\n    @Override\n    public void beginRequest(NHttpContext httpContext) {\n        // 请求到达之前记录请求信息\n    }\n\n    @Override\n    public void endRequest(NHttpContext httpContext) {\n        // 请求处理完成后记录响应信息\n    }\n\n    @Override\n    public void onError(NHttpContext httpContext) {\n        // 请求发生异常的时候记录异常信息\n    }\n}\n```\n通过统一的异常处理，可以确保系统稳定性和一致的错误响应。\n\n## 实现效果\n为了测试，我们直接在控制器中抛出一个异常：\n```java\n @GetMapping(\"/error\")\n@AllowAnonymous\npublic void error() throws Exception {\n    throw new Exception(\"测试异常\");\n}\n```\n![日志](./images/javelin-2/error.png)\n最后我们来看看日志的记录结果，这是初版的日志，直接记录在文件里面。\n这里记录一个TODO，后期需要优化日志记录。（日志异步上报， ELK等等）\n![日志](./images/javelin-2/log.png)\n\n\n\n# 生命周期管理\n生命周期管理是一个框架的重要组成部分。在 Spring 中，我们有 @PostConstruct 和 @PreDestroy 等注解来管理对象的生命周期。在我们的微型框架中，我们可以模拟类似的生命周期管理。\n\n## 目标：\n\n1. 在创建控制器实例时进行初始化。\n2. 在销毁时执行清理操作。\n\n## 实现方式：\n\n```java\npublic class JavelinContext {\n    private final Map<Class<?>, Object> singletonMap = new HashMap<>();\n\n    public <T> T getBean(Class<T> clazz) {\n        if (!singletonMap.containsKey(clazz)) {\n            try {\n                T instance = createBean(clazz);\n                singletonMap.put(clazz, instance);\n                return instance;\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to create bean: \" + clazz.getName(), e);\n            }\n        }\n        return (T) singletonMap.get(clazz);\n    }\n\n    private <T> T createBean(Class<T> clazz) throws Exception {\n        // 创建实例并调用初始化方法\n        T instance = (T) injectConstructor.newInstance(args.toArray());\n        callPostConstruct(instance);\n        return instance;\n    }\n\n    private void callPostConstruct(Object instance) throws Exception {\n        // 调用初始化方法\n    }\n\n    public void callPreDestroy(Object instance) {\n        // 调用销毁方法\n    }\n}\n```\n通过这种方式，框架在创建实例时调用 @PostConstruct 注解的方法, 请求处理完成之后调用 @PreDestroy 注解的方法。帮助我们在对象生命周期中插入初始化逻辑。\n## 实现效果\n![生命周期](./images/javelin-2/life-cycle.png)\n\n\n# 总结与下步计划\n在本篇文章中，我们深入探讨了如何将更多实用的功能添加到我们自定义的微型 Spring 框架中，包括参数绑定、中间件机制、全局异常处理、JSON 返回支持以及生命周期管理。这些功能的实现使得框架的功能更加完善，能够更好地应对复杂的 Web 应用需求。\n\n- 参数绑定：我们通过 @FromQuery, @FromBody, 和 @FromRoute 注解来实现请求参数与方法参数的自动绑定。这一机制可以让控制器方法直接接收 URL 查询参数、请求体数据和路径变量，提高了开发效率。\n\n- 中间件机制：我们参考了 ASP.NET 的 HTTP 管道模式，实现了一个可扩展的中间件机制。通过中间件，可以在请求处理过程中插入额外的逻辑，如权限验证、日志记录等，极大提升了框架的灵活性和可维护性。\n\n- 全局异常处理：通过中间件，框架能够统一处理请求过程中可能出现的异常，确保系统的稳定性，并能够返回一致的错误响应，便于调试和监控。\n\n- JSON 返回支持：我们实现了自动判断返回值的类型并根据类型转换为 JSON 格式。这使得框架能够支持更加复杂的数据返回类型，便于处理 JSON 响应。\n\n- 生命周期管理：模拟了 Spring 的 @PostConstruct 和 @PreDestroy 注解功能，确保在对象生命周期中能够执行初始化和销毁操作，为框架的管理提供了更多控制。\n\n通过实现这些功能，我们不仅提升了框架的可用性，也使其更加完善，能够更好地适应复杂的业务场景。在接下来的文章中，我们将继续扩展更多功能，进一步增强框架的灵活性和实用性。\n\n后续我们将继续拓展：\n- 权限与角色管理\n- 支持定时任务与后台任务\n- 支持数据库操作\n\n如果你对框架有更多的扩展需求，或者希望了解其他细节，请继续关注我们的后续文章！\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/Javelin)仓库。","slug":"javelin-2","published":1,"updated":"2025-04-29T09:33:56.621Z","_id":"cm9zdtu920000wop1am2seyyq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>书接上回，在上一篇文章中，我们展示了如何构建一个简单的微型 Spring 框架，涵盖了端口监听、路由动态注册和依赖注入（IoC）。本篇将进一步扩展我们的框架，涵盖 参数绑定、中间件机制、全局异常处理、JSON 返回支持 以及 生命周期管理。</p>\n<p>这些功能将使我们的微型框架更加完整，能够处理更多的应用场景。让我们开始深入探讨这些新增功能。</p>\n<h1 id=\"参数绑定\"><a href=\"#参数绑定\" class=\"headerlink\" title=\"参数绑定\"></a>参数绑定</h1><p>在上一篇文章里面虽然我们已经能够通过访问接口来获取返回值。但是请求的参数是如何绑定到方法的参数上的呢？这就是参数绑定的作用。<br>在 Web 开发中，参数绑定是一个非常重要的特性，通常用于从请求中提取参数并绑定到方法的参数上。在 Spring 框架中，我们通过注解如 @RequestParam 和 @RequestBody 来实现这一功能， 这里我们也直接参照实现。</p>\n<h2 id=\"目标：\"><a href=\"#目标：\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><ol>\n<li>使用 @FromQuery 注解实现 URL 查询参数的绑定。</li>\n<li>使用 @FromBody 注解将请求体中的 JSON 数据绑定为 Java 对象。</li>\n<li>使用 @FromRoute 注解将路径变量绑定到方法参数。</li>\n</ol>\n<h2 id=\"实现方法：\"><a href=\"#实现方法：\" class=\"headerlink\" title=\"实现方法：\"></a>实现方法：</h2><h3 id=\"动态路由\"><a href=\"#动态路由\" class=\"headerlink\" title=\"动态路由\"></a>动态路由</h3><p>在之前的路由注册过程中，我们已经将路径和对应的处理方法进行了映射。为了实现路径参数（&#x2F;user&#x2F;{id}）绑定，我们需要实现动态路由，即根据请求的 URL 路径来动态确定要调用的处理方法。只有这样我们才能过滤出请求的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 之前的路由注册</span></span><br><span class=\"line\"><span class=\"comment\">//  server.createContext(path, exchange -&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      // 这里我们需要根据请求的 URL 路径来确定要调用的处理方法</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在我们需要实现动态路由（在程序启动的时候扫描所有controller、action，然后缓存起来）</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;RouteDefinition&gt; dynamicRoutes = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class=\"line\">        dynamicRoutes.add(<span class=\"keyword\">new</span> <span class=\"title class_\">RouteDefinition</span>(httpMethod, path, pathPattern, pathVaribleNames, controllerInstance, method));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server.createContext(<span class=\"string\">&quot;/&quot;</span>, exchange -&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">requestPath</span> <span class=\"operator\">=</span> exchange.getRequestURI().getPath();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据请求路径找到对应的处理方法</span></span><br><span class=\"line\">    <span class=\"type\">RouteDefinition</span> <span class=\"variable\">matchedRoute</span> <span class=\"operator\">=</span> findMatchRoute(requestPath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行具体的处理方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析参数\"><a href=\"#解析参数\" class=\"headerlink\" title=\"解析参数\"></a>解析参数</h3><p>这里注解的实现就不多说了，我们主要看看参数绑定的实现。<br>我们在框架中通过反射机制来解析方法参数，根据注解从请求中提取相应的参数。以下是参数绑定的代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object[] resolveMethodParameters(HttpExchange exchange, RouteDefinition route, Map&lt;String, String&gt; pathVariables) <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    Parameter[] parameters = route.handlerMethod.getParameters();</span><br><span class=\"line\">    Object[] args = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[parameters.length];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Parameter</span> <span class=\"variable\">parameter</span> <span class=\"operator\">=</span> parameters[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameter.isAnnotationPresent(FromQuery.class)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从 URL 查询参数中提取</span></span><br><span class=\"line\">            Map&lt;String, String&gt; queryParams = UrlExtensions.parseQueryParams(exchange.getRequestURI().getRawQuery());</span><br><span class=\"line\">            args[i] = StringExtensions.convertTo(queryParams.get(parameter.getName()), parameter.getType());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameter.isAnnotationPresent(FromBody.class)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从请求体中提取 JSON 数据并绑定</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">bodyString</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);</span><br><span class=\"line\">            args[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>().fromJson(bodyString, parameter.getType());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameter.isAnnotationPresent(FromRoute.class)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从路径变量中提取</span></span><br><span class=\"line\">            args[i] = StringExtensions.convertTo(pathVariables.get(parameter.getName()), parameter.getType());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> args;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法确保可以将查询参数、请求体和路径变量自动绑定到控制器方法的参数上。</p>\n<p>我们来一起看看效果</p>\n<ol>\n<li>get参数<br><img src=\"/blog/./images/javelin-2/query-params.png\" alt=\"post\"></li>\n<li>post参数<br><img src=\"/blog/./images/javelin-2/post-params.png\" alt=\"post\"></li>\n<li>路径参数<br><img src=\"/blog/./images/javelin-2/route-params.png\" alt=\"post\"></li>\n</ol>\n<h1 id=\"JSON-返回支持\"><a href=\"#JSON-返回支持\" class=\"headerlink\" title=\"JSON 返回支持\"></a>JSON 返回支持</h1><p>在此之前我们返回接口返回的都是String类型，现在我们来实现JSON返回支持。同时我们希望可以根据返回值的类型自动判断是否需要转换为 JSON 格式。</p>\n<h2 id=\"目标：-1\"><a href=\"#目标：-1\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><p>支持返回 String 类型或自定义对象类型。</p>\n<p>如果返回的是对象，则自动将其转换为 JSON 格式。</p>\n<h2 id=\"实现方式：\"><a href=\"#实现方式：\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取返回值的类型</span></span><br><span class=\"line\">Class&lt;?&gt; returnType = route.action.getReturnType();</span><br><span class=\"line\"></span><br><span class=\"line\">String responseBody;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(returnType == String.class || returnType == <span class=\"keyword\">void</span>.class || returnType == <span class=\"type\">int</span>.class) &#123;</span><br><span class=\"line\">    responseBody = (String) result;</span><br><span class=\"line\">    exchange.getResponseHeaders().set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/plain; charset=UTF-8&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    responseBody = gson.toJson(result);</span><br><span class=\"line\">    exchange.getResponseHeaders().set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json; charset=UTF-8&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此逻辑将根据返回类型自动决定响应类型。对于 Java 对象，将使用 Gson 转换为 JSON 格式返回。</p>\n<h2 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/blog/./images/javelin-2/json.png\" alt=\"json\"></p>\n<h1 id=\"中间件机制\"><a href=\"#中间件机制\" class=\"headerlink\" title=\"中间件机制\"></a>中间件机制</h1><p>中间件（Middleware）是框架中一个非常强大的特性，它允许你在请求处理流程的各个阶段插入额外的处理逻辑。比如，我们可以在请求到达控制器之前，进行权限验证、日志记录等操作。 这里有一个需要关注的地方，我并没有使用现在比较流行的委托链式的中间件，而是参考类似asp.net 的HTTP 管道的方式实现的。</p>\n<p>之所以有这样的选择是因为委托链式的中间件在处理过程中会有一些问题，比如：</p>\n<ol>\n<li>中间件的执行顺序难以控制，可能会导致请求处理流程出现问题。</li>\n<li>一旦出现异常，中间件的异常处理逻辑可能会变得复杂， 异常链非常的深。</li>\n</ol>\n<p>所以我选择了类似asp.net 的HTTP 管道的方式实现的中间件，这样可以更加清晰的控制中间件的执行顺序，并且异常处理也更加方便。<br><img src=\"/blog/./images/javelin-2/pipeline.png\" alt=\"管道\"></p>\n<h2 id=\"实现目标：\"><a href=\"#实现目标：\" class=\"headerlink\" title=\"实现目标：\"></a>实现目标：</h2><ol>\n<li>在请求处理流程中添加拦截器，允许在方法调用之前或之后执行特定操作。</li>\n<li>可以添加多个中间件。</li>\n<li>支持定义中间件的执行顺序。</li>\n</ol>\n<h2 id=\"实现方式：-1\"><a href=\"#实现方式：-1\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 框架初始化的时候注册中间件</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadModules</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    NHttpModuleFactory.registerModule(OprLogModule.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    NHttpModuleFactory.registerModule(AuthenticateModule.class);</span><br><span class=\"line\">    NHttpModuleFactory.registerModule(AuthorizeModule.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在路由处理程序中，我们执行中间件链：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(NHttpContext context)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">NHttpApplication</span> <span class=\"variable\">app</span> <span class=\"operator\">=</span> NHttpApplication.INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    preHandle(context);</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        app.beginRequest(context);</span><br><span class=\"line\">        app.authenticateRequest(context);</span><br><span class=\"line\">        app.postAuthenticateRequest(context);</span><br><span class=\"line\">        app.resolveRequestCache(context);</span><br><span class=\"line\"></span><br><span class=\"line\">        handlerRequest(context);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> ( AbortRequestException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 提前结束请求，啥也不干了</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        context.pipelineContext.setException(e);</span><br><span class=\"line\">        app.onError(context);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        app.endRequest(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，我们能够在请求处理过程中插入不同的功能，增加灵活性和可扩展性。</p>\n<h2 id=\"实现效果-1\"><a href=\"#实现效果-1\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p>这里我们新增了一个权限验证的中间件，在请求到达控制器之前进行验证。<br><img src=\"/blog/./images/javelin-2/authorize.png\" alt=\"权限\"></p>\n<h1 id=\"全局日志处理\"><a href=\"#全局日志处理\" class=\"headerlink\" title=\"全局日志处理\"></a>全局日志处理</h1><p>在我们的框架中，我们可以通过中间件机制来实现全局日志处理。这样，我们就可以在请求处理的各个阶段记录日志，方便调试和监控。</p>\n<h2 id=\"目标：-2\"><a href=\"#目标：-2\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><ol>\n<li>在请求到达控制器之前记录请求信息。</li>\n<li>在请求处理完成后记录响应信息。</li>\n<li>捕获所有未处理的异常。</li>\n<li>返回适当的错误响应。</li>\n</ol>\n<h2 id=\"实现方式：-2\"><a href=\"#实现方式：-2\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><p>我们可以创建一个日志中间件，在请求到达控制器之前和处理完成后记录日志：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OprLogModule</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">NHttpModule</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beginRequest</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求到达之前记录请求信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">endRequest</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求处理完成后记录响应信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求发生异常的时候记录异常信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过统一的异常处理，可以确保系统稳定性和一致的错误响应。</p>\n<h2 id=\"实现效果-2\"><a href=\"#实现效果-2\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p>为了测试，我们直接在控制器中抛出一个异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@GetMapping(&quot;/error&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@AllowAnonymous</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">error</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;测试异常&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/javelin-2/error.png\" alt=\"日志\"><br>最后我们来看看日志的记录结果，这是初版的日志，直接记录在文件里面。<br>这里记录一个TODO，后期需要优化日志记录。（日志异步上报， ELK等等）<br><img src=\"/blog/./images/javelin-2/log.png\" alt=\"日志\"></p>\n<h1 id=\"生命周期管理\"><a href=\"#生命周期管理\" class=\"headerlink\" title=\"生命周期管理\"></a>生命周期管理</h1><p>生命周期管理是一个框架的重要组成部分。在 Spring 中，我们有 @PostConstruct 和 @PreDestroy 等注解来管理对象的生命周期。在我们的微型框架中，我们可以模拟类似的生命周期管理。</p>\n<h2 id=\"目标：-3\"><a href=\"#目标：-3\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><ol>\n<li>在创建控制器实例时进行初始化。</li>\n<li>在销毁时执行清理操作。</li>\n</ol>\n<h2 id=\"实现方式：-3\"><a href=\"#实现方式：-3\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinContext</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;, Object&gt; singletonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!singletonMap.containsKey(clazz)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">T</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> createBean(clazz);</span><br><span class=\"line\">                singletonMap.put(clazz, instance);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Failed to create bean: &quot;</span> + clazz.getName(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) singletonMap.get(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> &lt;T&gt; T <span class=\"title function_\">createBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建实例并调用初始化方法</span></span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> (T) injectConstructor.newInstance(args.toArray());</span><br><span class=\"line\">        callPostConstruct(instance);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">callPostConstruct</span><span class=\"params\">(Object instance)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用初始化方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">callPreDestroy</span><span class=\"params\">(Object instance)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用销毁方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，框架在创建实例时调用 @PostConstruct 注解的方法, 请求处理完成之后调用 @PreDestroy 注解的方法。帮助我们在对象生命周期中插入初始化逻辑。</p>\n<h2 id=\"实现效果-3\"><a href=\"#实现效果-3\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/blog/./images/javelin-2/life-cycle.png\" alt=\"生命周期\"></p>\n<h1 id=\"总结与下步计划\"><a href=\"#总结与下步计划\" class=\"headerlink\" title=\"总结与下步计划\"></a>总结与下步计划</h1><p>在本篇文章中，我们深入探讨了如何将更多实用的功能添加到我们自定义的微型 Spring 框架中，包括参数绑定、中间件机制、全局异常处理、JSON 返回支持以及生命周期管理。这些功能的实现使得框架的功能更加完善，能够更好地应对复杂的 Web 应用需求。</p>\n<ul>\n<li><p>参数绑定：我们通过 @FromQuery, @FromBody, 和 @FromRoute 注解来实现请求参数与方法参数的自动绑定。这一机制可以让控制器方法直接接收 URL 查询参数、请求体数据和路径变量，提高了开发效率。</p>\n</li>\n<li><p>中间件机制：我们参考了 ASP.NET 的 HTTP 管道模式，实现了一个可扩展的中间件机制。通过中间件，可以在请求处理过程中插入额外的逻辑，如权限验证、日志记录等，极大提升了框架的灵活性和可维护性。</p>\n</li>\n<li><p>全局异常处理：通过中间件，框架能够统一处理请求过程中可能出现的异常，确保系统的稳定性，并能够返回一致的错误响应，便于调试和监控。</p>\n</li>\n<li><p>JSON 返回支持：我们实现了自动判断返回值的类型并根据类型转换为 JSON 格式。这使得框架能够支持更加复杂的数据返回类型，便于处理 JSON 响应。</p>\n</li>\n<li><p>生命周期管理：模拟了 Spring 的 @PostConstruct 和 @PreDestroy 注解功能，确保在对象生命周期中能够执行初始化和销毁操作，为框架的管理提供了更多控制。</p>\n</li>\n</ul>\n<p>通过实现这些功能，我们不仅提升了框架的可用性，也使其更加完善，能够更好地适应复杂的业务场景。在接下来的文章中，我们将继续扩展更多功能，进一步增强框架的灵活性和实用性。</p>\n<p>后续我们将继续拓展：</p>\n<ul>\n<li>权限与角色管理</li>\n<li>支持定时任务与后台任务</li>\n<li>支持数据库操作</li>\n</ul>\n<p>如果你对框架有更多的扩展需求，或者希望了解其他细节，请继续关注我们的后续文章！</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/Javelin\">GitHub</a>仓库。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>书接上回，在上一篇文章中，我们展示了如何构建一个简单的微型 Spring 框架，涵盖了端口监听、路由动态注册和依赖注入（IoC）。本篇将进一步扩展我们的框架，涵盖 参数绑定、中间件机制、全局异常处理、JSON 返回支持 以及 生命周期管理。</p>\n<p>这些功能将使我们的微型框架更加完整，能够处理更多的应用场景。让我们开始深入探讨这些新增功能。</p>\n<h1 id=\"参数绑定\"><a href=\"#参数绑定\" class=\"headerlink\" title=\"参数绑定\"></a>参数绑定</h1><p>在上一篇文章里面虽然我们已经能够通过访问接口来获取返回值。但是请求的参数是如何绑定到方法的参数上的呢？这就是参数绑定的作用。<br>在 Web 开发中，参数绑定是一个非常重要的特性，通常用于从请求中提取参数并绑定到方法的参数上。在 Spring 框架中，我们通过注解如 @RequestParam 和 @RequestBody 来实现这一功能， 这里我们也直接参照实现。</p>\n<h2 id=\"目标：\"><a href=\"#目标：\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><ol>\n<li>使用 @FromQuery 注解实现 URL 查询参数的绑定。</li>\n<li>使用 @FromBody 注解将请求体中的 JSON 数据绑定为 Java 对象。</li>\n<li>使用 @FromRoute 注解将路径变量绑定到方法参数。</li>\n</ol>\n<h2 id=\"实现方法：\"><a href=\"#实现方法：\" class=\"headerlink\" title=\"实现方法：\"></a>实现方法：</h2><h3 id=\"动态路由\"><a href=\"#动态路由\" class=\"headerlink\" title=\"动态路由\"></a>动态路由</h3><p>在之前的路由注册过程中，我们已经将路径和对应的处理方法进行了映射。为了实现路径参数（&#x2F;user&#x2F;{id}）绑定，我们需要实现动态路由，即根据请求的 URL 路径来动态确定要调用的处理方法。只有这样我们才能过滤出请求的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 之前的路由注册</span></span><br><span class=\"line\"><span class=\"comment\">//  server.createContext(path, exchange -&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      // 这里我们需要根据请求的 URL 路径来确定要调用的处理方法</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在我们需要实现动态路由（在程序启动的时候扫描所有controller、action，然后缓存起来）</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;RouteDefinition&gt; dynamicRoutes = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class=\"line\">        dynamicRoutes.add(<span class=\"keyword\">new</span> <span class=\"title class_\">RouteDefinition</span>(httpMethod, path, pathPattern, pathVaribleNames, controllerInstance, method));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server.createContext(<span class=\"string\">&quot;/&quot;</span>, exchange -&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">requestPath</span> <span class=\"operator\">=</span> exchange.getRequestURI().getPath();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据请求路径找到对应的处理方法</span></span><br><span class=\"line\">    <span class=\"type\">RouteDefinition</span> <span class=\"variable\">matchedRoute</span> <span class=\"operator\">=</span> findMatchRoute(requestPath);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行具体的处理方法</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"解析参数\"><a href=\"#解析参数\" class=\"headerlink\" title=\"解析参数\"></a>解析参数</h3><p>这里注解的实现就不多说了，我们主要看看参数绑定的实现。<br>我们在框架中通过反射机制来解析方法参数，根据注解从请求中提取相应的参数。以下是参数绑定的代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object[] resolveMethodParameters(HttpExchange exchange, RouteDefinition route, Map&lt;String, String&gt; pathVariables) <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    Parameter[] parameters = route.handlerMethod.getParameters();</span><br><span class=\"line\">    Object[] args = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[parameters.length];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Parameter</span> <span class=\"variable\">parameter</span> <span class=\"operator\">=</span> parameters[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameter.isAnnotationPresent(FromQuery.class)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从 URL 查询参数中提取</span></span><br><span class=\"line\">            Map&lt;String, String&gt; queryParams = UrlExtensions.parseQueryParams(exchange.getRequestURI().getRawQuery());</span><br><span class=\"line\">            args[i] = StringExtensions.convertTo(queryParams.get(parameter.getName()), parameter.getType());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameter.isAnnotationPresent(FromBody.class)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从请求体中提取 JSON 数据并绑定</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">bodyString</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);</span><br><span class=\"line\">            args[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>().fromJson(bodyString, parameter.getType());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameter.isAnnotationPresent(FromRoute.class)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从路径变量中提取</span></span><br><span class=\"line\">            args[i] = StringExtensions.convertTo(pathVariables.get(parameter.getName()), parameter.getType());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> args;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此方法确保可以将查询参数、请求体和路径变量自动绑定到控制器方法的参数上。</p>\n<p>我们来一起看看效果</p>\n<ol>\n<li>get参数<br><img src=\"/blog/./images/javelin-2/query-params.png\" alt=\"post\"></li>\n<li>post参数<br><img src=\"/blog/./images/javelin-2/post-params.png\" alt=\"post\"></li>\n<li>路径参数<br><img src=\"/blog/./images/javelin-2/route-params.png\" alt=\"post\"></li>\n</ol>\n<h1 id=\"JSON-返回支持\"><a href=\"#JSON-返回支持\" class=\"headerlink\" title=\"JSON 返回支持\"></a>JSON 返回支持</h1><p>在此之前我们返回接口返回的都是String类型，现在我们来实现JSON返回支持。同时我们希望可以根据返回值的类型自动判断是否需要转换为 JSON 格式。</p>\n<h2 id=\"目标：-1\"><a href=\"#目标：-1\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><p>支持返回 String 类型或自定义对象类型。</p>\n<p>如果返回的是对象，则自动将其转换为 JSON 格式。</p>\n<h2 id=\"实现方式：\"><a href=\"#实现方式：\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取返回值的类型</span></span><br><span class=\"line\">Class&lt;?&gt; returnType = route.action.getReturnType();</span><br><span class=\"line\"></span><br><span class=\"line\">String responseBody;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(returnType == String.class || returnType == <span class=\"keyword\">void</span>.class || returnType == <span class=\"type\">int</span>.class) &#123;</span><br><span class=\"line\">    responseBody = (String) result;</span><br><span class=\"line\">    exchange.getResponseHeaders().set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/plain; charset=UTF-8&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    responseBody = gson.toJson(result);</span><br><span class=\"line\">    exchange.getResponseHeaders().set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json; charset=UTF-8&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此逻辑将根据返回类型自动决定响应类型。对于 Java 对象，将使用 Gson 转换为 JSON 格式返回。</p>\n<h2 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/blog/./images/javelin-2/json.png\" alt=\"json\"></p>\n<h1 id=\"中间件机制\"><a href=\"#中间件机制\" class=\"headerlink\" title=\"中间件机制\"></a>中间件机制</h1><p>中间件（Middleware）是框架中一个非常强大的特性，它允许你在请求处理流程的各个阶段插入额外的处理逻辑。比如，我们可以在请求到达控制器之前，进行权限验证、日志记录等操作。 这里有一个需要关注的地方，我并没有使用现在比较流行的委托链式的中间件，而是参考类似asp.net 的HTTP 管道的方式实现的。</p>\n<p>之所以有这样的选择是因为委托链式的中间件在处理过程中会有一些问题，比如：</p>\n<ol>\n<li>中间件的执行顺序难以控制，可能会导致请求处理流程出现问题。</li>\n<li>一旦出现异常，中间件的异常处理逻辑可能会变得复杂， 异常链非常的深。</li>\n</ol>\n<p>所以我选择了类似asp.net 的HTTP 管道的方式实现的中间件，这样可以更加清晰的控制中间件的执行顺序，并且异常处理也更加方便。<br><img src=\"/blog/./images/javelin-2/pipeline.png\" alt=\"管道\"></p>\n<h2 id=\"实现目标：\"><a href=\"#实现目标：\" class=\"headerlink\" title=\"实现目标：\"></a>实现目标：</h2><ol>\n<li>在请求处理流程中添加拦截器，允许在方法调用之前或之后执行特定操作。</li>\n<li>可以添加多个中间件。</li>\n<li>支持定义中间件的执行顺序。</li>\n</ol>\n<h2 id=\"实现方式：-1\"><a href=\"#实现方式：-1\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 框架初始化的时候注册中间件</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadModules</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    NHttpModuleFactory.registerModule(OprLogModule.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    NHttpModuleFactory.registerModule(AuthenticateModule.class);</span><br><span class=\"line\">    NHttpModuleFactory.registerModule(AuthorizeModule.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在路由处理程序中，我们执行中间件链：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(NHttpContext context)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">NHttpApplication</span> <span class=\"variable\">app</span> <span class=\"operator\">=</span> NHttpApplication.INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    preHandle(context);</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        app.beginRequest(context);</span><br><span class=\"line\">        app.authenticateRequest(context);</span><br><span class=\"line\">        app.postAuthenticateRequest(context);</span><br><span class=\"line\">        app.resolveRequestCache(context);</span><br><span class=\"line\"></span><br><span class=\"line\">        handlerRequest(context);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> ( AbortRequestException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 提前结束请求，啥也不干了</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        context.pipelineContext.setException(e);</span><br><span class=\"line\">        app.onError(context);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        app.endRequest(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，我们能够在请求处理过程中插入不同的功能，增加灵活性和可扩展性。</p>\n<h2 id=\"实现效果-1\"><a href=\"#实现效果-1\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p>这里我们新增了一个权限验证的中间件，在请求到达控制器之前进行验证。<br><img src=\"/blog/./images/javelin-2/authorize.png\" alt=\"权限\"></p>\n<h1 id=\"全局日志处理\"><a href=\"#全局日志处理\" class=\"headerlink\" title=\"全局日志处理\"></a>全局日志处理</h1><p>在我们的框架中，我们可以通过中间件机制来实现全局日志处理。这样，我们就可以在请求处理的各个阶段记录日志，方便调试和监控。</p>\n<h2 id=\"目标：-2\"><a href=\"#目标：-2\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><ol>\n<li>在请求到达控制器之前记录请求信息。</li>\n<li>在请求处理完成后记录响应信息。</li>\n<li>捕获所有未处理的异常。</li>\n<li>返回适当的错误响应。</li>\n</ol>\n<h2 id=\"实现方式：-2\"><a href=\"#实现方式：-2\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><p>我们可以创建一个日志中间件，在请求到达控制器之前和处理完成后记录日志：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OprLogModule</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">NHttpModule</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beginRequest</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求到达之前记录请求信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">endRequest</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求处理完成后记录响应信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求发生异常的时候记录异常信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过统一的异常处理，可以确保系统稳定性和一致的错误响应。</p>\n<h2 id=\"实现效果-2\"><a href=\"#实现效果-2\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p>为了测试，我们直接在控制器中抛出一个异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@GetMapping(&quot;/error&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@AllowAnonymous</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">error</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;测试异常&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/javelin-2/error.png\" alt=\"日志\"><br>最后我们来看看日志的记录结果，这是初版的日志，直接记录在文件里面。<br>这里记录一个TODO，后期需要优化日志记录。（日志异步上报， ELK等等）<br><img src=\"/blog/./images/javelin-2/log.png\" alt=\"日志\"></p>\n<h1 id=\"生命周期管理\"><a href=\"#生命周期管理\" class=\"headerlink\" title=\"生命周期管理\"></a>生命周期管理</h1><p>生命周期管理是一个框架的重要组成部分。在 Spring 中，我们有 @PostConstruct 和 @PreDestroy 等注解来管理对象的生命周期。在我们的微型框架中，我们可以模拟类似的生命周期管理。</p>\n<h2 id=\"目标：-3\"><a href=\"#目标：-3\" class=\"headerlink\" title=\"目标：\"></a>目标：</h2><ol>\n<li>在创建控制器实例时进行初始化。</li>\n<li>在销毁时执行清理操作。</li>\n</ol>\n<h2 id=\"实现方式：-3\"><a href=\"#实现方式：-3\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinContext</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;, Object&gt; singletonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!singletonMap.containsKey(clazz)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">T</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> createBean(clazz);</span><br><span class=\"line\">                singletonMap.put(clazz, instance);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Failed to create bean: &quot;</span> + clazz.getName(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) singletonMap.get(clazz);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> &lt;T&gt; T <span class=\"title function_\">createBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建实例并调用初始化方法</span></span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> (T) injectConstructor.newInstance(args.toArray());</span><br><span class=\"line\">        callPostConstruct(instance);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">callPostConstruct</span><span class=\"params\">(Object instance)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用初始化方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">callPreDestroy</span><span class=\"params\">(Object instance)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用销毁方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，框架在创建实例时调用 @PostConstruct 注解的方法, 请求处理完成之后调用 @PreDestroy 注解的方法。帮助我们在对象生命周期中插入初始化逻辑。</p>\n<h2 id=\"实现效果-3\"><a href=\"#实现效果-3\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/blog/./images/javelin-2/life-cycle.png\" alt=\"生命周期\"></p>\n<h1 id=\"总结与下步计划\"><a href=\"#总结与下步计划\" class=\"headerlink\" title=\"总结与下步计划\"></a>总结与下步计划</h1><p>在本篇文章中，我们深入探讨了如何将更多实用的功能添加到我们自定义的微型 Spring 框架中，包括参数绑定、中间件机制、全局异常处理、JSON 返回支持以及生命周期管理。这些功能的实现使得框架的功能更加完善，能够更好地应对复杂的 Web 应用需求。</p>\n<ul>\n<li><p>参数绑定：我们通过 @FromQuery, @FromBody, 和 @FromRoute 注解来实现请求参数与方法参数的自动绑定。这一机制可以让控制器方法直接接收 URL 查询参数、请求体数据和路径变量，提高了开发效率。</p>\n</li>\n<li><p>中间件机制：我们参考了 ASP.NET 的 HTTP 管道模式，实现了一个可扩展的中间件机制。通过中间件，可以在请求处理过程中插入额外的逻辑，如权限验证、日志记录等，极大提升了框架的灵活性和可维护性。</p>\n</li>\n<li><p>全局异常处理：通过中间件，框架能够统一处理请求过程中可能出现的异常，确保系统的稳定性，并能够返回一致的错误响应，便于调试和监控。</p>\n</li>\n<li><p>JSON 返回支持：我们实现了自动判断返回值的类型并根据类型转换为 JSON 格式。这使得框架能够支持更加复杂的数据返回类型，便于处理 JSON 响应。</p>\n</li>\n<li><p>生命周期管理：模拟了 Spring 的 @PostConstruct 和 @PreDestroy 注解功能，确保在对象生命周期中能够执行初始化和销毁操作，为框架的管理提供了更多控制。</p>\n</li>\n</ul>\n<p>通过实现这些功能，我们不仅提升了框架的可用性，也使其更加完善，能够更好地适应复杂的业务场景。在接下来的文章中，我们将继续扩展更多功能，进一步增强框架的灵活性和实用性。</p>\n<p>后续我们将继续拓展：</p>\n<ul>\n<li>权限与角色管理</li>\n<li>支持定时任务与后台任务</li>\n<li>支持数据库操作</li>\n</ul>\n<p>如果你对框架有更多的扩展需求，或者希望了解其他细节，请继续关注我们的后续文章！</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/Javelin\">GitHub</a>仓库。</p>\n"},{"title":"手写一个微型 Spring 框架：从端口监听到依赖注入","date":"2025-04-14T02:17:55.000Z","_content":"书接上回，作为一个从.NET转Java的开发人员，Spring框架肯定是无法绕过的。在学习 Spring 框架的过程中，我们往往只是停留在“使用”层面，而对其底层实现机制知之甚少。但我始终觉得，学习框架的过程中，理解其设计思想和实现原理是非常重要的。因此，我决定手写一个微型的Spring框架，来深入理解Spring的核心设计思想。为了加深我对 Spring 的理解，并锻炼 Java 框架设计能力，我决定手写一个微型的 Spring 框架 —— Javelin。\n\n这篇文章我们将实现：\n\n- 一个简单的 IoC 容器 `JavelinContext`，用于管理 Bean 实例的生命周期。\n- 支持 `@RestController`、`@GetMapping`、`@PostMapping` 等注解的自动扫描与注册。\n- 基于 `HttpServer` 的端口监听与请求路由分发。\n\n> 本文适合有 Java 或 .NET 框架开发经验的读者，特别是希望深入理解 Spring、探索其核心设计思想的人群。\n\n---\n\n## 为什么要手写一个 Spring 框架？\n\n首先Spring 是 Java 生态中最具代表性的框架之一，而作为一个搬砖多年的开发人员，CURD显然不再是我们的追求。但，学习框架的设计思想和实现原理还是非常有价值的。Sping框架核心理念在于控制反转（IoC）、面向切面编程（AOP）和基于注解的声明式编程。手写框架可以帮助我们：\n\n1. **理解 IoC 容器原理**：Bean 是如何被发现、实例化、依赖注入的？\n2. **掌握路由注册机制**：Spring MVC 如何基于注解将请求分发给具体的方法？\n3. **探索类扫描与反射机制**：如何实现自动发现注解的类与方法？\n4. **对比 .NET**：Spring 与 ASP.NET Core 的设计思路在某些地方是相通的，比如 `@RestController` 和 `[ApiController]`，但实现方式有差异。\n\n通过实战构建 Javelin，我们能够站在框架设计者的角度重新思考“约定优于配置”的设计哲学。\n\n---\n\n## 项目结构\n我们手写的框架名叫 `Javelin`，目前已经实现了三个核心模块：\n\n| 模块 | 功能 |\n|------|------|\n| `JavelinContext` | 提供简化版 IoC 容器，实现基于注解的构造函数注入 |\n| `Router` | 自动扫描 `@RestController`，绑定 GET/POST 请求路径 |\n| `AppStartup` | 应用启动入口，配置端口监听、类扫描路径等 |\n\n\n![结构](./images/spring-1/architecture.png)\n\n项目结构如下：\n```\njavelin-core/\n├── annotations/        // 自定义注解（@RestController, @Inject 等）\n├── context/            // IoC 容器\n├── rest/               // 路由注册\n├── core/               // 类扫描器\n└── startup/            // 启动类\n```\n\n\n## 构建核心 IoC 容器 `JavelinContext`\n\n我们首先需要一个容器类来负责扫描、实例化 Bean，并支持构造函数注入。代码结构如下：\n\n```java\npublic class JavelinContext {\n\n    private final Map<Class<?>, Object> singletonMap = new HashMap<>();\n\n    public <T> T getBean(Class<T> clazz) {\n        if (singletonMap.containsKey(clazz)) {\n            return (T) singletonMap.get(clazz);\n        }\n\n        T instance = (T) createBean(clazz);\n        singletonMap.put(clazz, instance);\n        return instance;\n        \n    }\n\n    public <T> T createBean(Class<T> clazz) {\n        try {\n            Constructor<?>[] constructors = clazz.getDeclaredConstructors();\n            \n            injectConstructor = clazz.getDeclaredConstructor();\n            // ...\n\n            return (T) injectConstructor.newInstance(args.toArray());\n        }  catch (Exception e) {\n            throw new RuntimeException(\"Failed to instantiate: \" + clazz.getName(), e); \n        }\n    }\n}\n\n```\n\n这段代码的核心思路与 .NET Core 的构造函数注入类似（例如通过 `IServiceCollection.AddTransient()` 注册服务并注入）。\n\n\n---\n\n## 自动路由注册 Router\n\n我们手动实现了基于注解的请求路由注册机制。Javelin 支持如下注解：\n\n控制器注解\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RestController {}\n```\n\n请求映射注解\n```java\n@Target(ElementType.ANNOTATION_TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface HttpMethodMapping {\n    String method();\n}\n\n@HttpMethodMapping(method = \"POST\")\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface PostMapping {\n    String value();\n}\n\n// ...\n```\n\n而 `Router` 类的核心逻辑如下：\n\n```java\npublic class Router {\n    public void registerRoutes(HttpServer server, Set<Class<?>> classes, JavelinContext context) {\n        for (Class<?> clazz : classes) {\n            if (!clazz.isAnnotationPresent(RestController.class)) continue;\n\n            Object controller = context.getBean(clazz);\n\n            for (Method method : clazz.getDeclaredMethods()) {\n                HttpMethodMapping mapping = annotation.annotationType().getAnnotation(HttpMethodMapping.class);\n                if (mapping != null) {\n                       String httpMethod = mapping.method();                       \n                       try{\n                           String path = (String) annotation.annotationType().getMethod(\"value\").invoke(annotation);\n                           registerHandler(server, path, httpMethod, controllerInstance, method);\n                       } catch (Exception e) {\n                           e.printStackTrace(); \n                       }\n\n                    }\n            }\n        }\n    }\n\n    private void registerHandler(HttpServer server, String path, String expectedMethod, Object controllerInstance, Method method) {\n        server.createContext(path, exchange -> {\n            // 判断请求的合法性\n\n            try {\n                // 反射调用方法\n            } catch (Exception e) {\n                exchange.sendResponseHeaders(500, 0);\n                e.printStackTrace();\n            }\n        });\n\n        System.out.println(\"➡️  [\" + httpMethod + \"] \" + path + \" → \" + controller.getClass().getSimpleName() + \".\" + method.getName());\n    }\n}\n```\n\n\n.NET 中这部分功能相当于 ASP.NET Core 中的 `MapControllers()` + `[HttpGet(\"/api/foo\")]` 等特性。\n\n---\n\n## 启动类 AppStartup\n\n```java\npublic class AppStartup {\n    public static void run(Class<?> appClass, String[] args)\n    {\n        String basePackage = appClass.getPackage().getName(); // 自动获取包名\n        Set<Class<?>> controllers = ClassScanner.scan(basePackage);\n\n        int port = resolvePort(); // ✅ 获取端口号\n        HttpServer server;\n        try {\n            server = HttpServer.create(new InetSocketAddress(port), 0); // 默认端口8080     \n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start HTTP server\", e);\n        }           \n\n        JavelinContext context = new JavelinContext();\n        new Router().registerRoutes(server, controllers, context);\n\n        server.start();\n        System.out.println(\"🚀 Server started at http://localhost:\" + port);\n    }\n}\n```\n\n## Service 注入\n```java\n\n@RestController\npublic class HelloController {\n    private UserService userService;\n\n    @Inject\n    public HelloController(UserService userService) {\n        this.userService = userService; // ✅ 注入UserService实例 \n    }\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World from \" + userService.getUserById(1) ;\n    }\n}\n```\n接下面让我们看看我们的Hello World\n![运行效果](./images/spring-1/result.png)\n当我们用get方式访问post时，会报405错误。\n![运行效果](./images/spring-1/fail.png)\n\n\n## 💡和 .NET 框架的对比分析\n在开发 Javelin 的过程中，我时常联想到 .NET 的实现，尤其是 ASP.NET Core，它与 Spring 在设计理念上高度一致，但细节又有一些差异，下面进行系统性对比：\n\n### 控制器与路由\n|特性 |\tJavelin (Java) |\tASP.NET Core (.NET) |\n|------|------|------|\n| 控制器注解/特性 |\t@RestController | [ApiController] |\n|路由声明方式 |\t@GetMapping(\"/path\") |\t[HttpGet(\"path\")] |\n|路由注册机制 |\t手动反射扫描注册 |\t中间件动态注册至 EndpointRouting |\n|请求处理 |\tHttpExchangeHandler |\tControllerInvoker 中间件链 |\n\n### 依赖注入与服务容器\n|特性 |\tJavelin (Java) |\tASP.NET Core (.NET) |\n|------|------|------|\n|服务注册方式 |\t自动递归构造，无需注册 |\t显式调用 services.AddXyz() |\n|注入方式 |\t构造函数 + @Inject |\t构造函数 + 内建 IoC 容器 |\n|生命周期管理 |\t默认单例 |\t支持 Transient / Scoped / Singleton |\n|循环依赖检测 |\t暂不支持 |\t默认会在启动时检测并抛出异常 |\n\n### 底层运行机制\n|特性 |\tJavelin |\tASP.NET Core |\n|------|------|------|\n|HTTP 服务器 |\tcom.sun.net.httpserver.HttpServer |\tKestrel 内置服务器 |\n|请求派发模型 |\t映射到类方法，反射调用 |\t中间件链 + 路由匹配 + ControllerInvoker |\n\n可以看出，Javelin 更加简洁直观，适合做教学或理解框架底层流程，而 ASP.NET Core 更加强大和工程化，适用于复杂企业级应用。\n\n\n## 总结与下步计划\n\n通过上面的内容，我们已经实现了 Spring 框架的三个关键能力：\n\n- 简易 IoC 容器支持构造函数注入\n- 使用 `@RestController`/`@GetMapping`/`@PostMapping` 注解注册请求处理器\n- 类似 Spring Boot 的端口监听启动类\n\n后续我们将继续拓展：\n\n- 参数绑定（如 `@RequestParam`, `@RequestBody`）\n- 中间件机制（如拦截器）\n- 全局异常处理\n- JSON 返回支持\n- 生命周期管理\n\n敬请期待下一篇：**实现请求参数自动注入与 JSON 响应支持**！\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/Javelin)仓库。","source":"_posts/javelin-1.md","raw":"---\ntitle: 手写一个微型 Spring 框架：从端口监听到依赖注入\ndate: 2025-04-14 10:17:55\ntags:\n---\n书接上回，作为一个从.NET转Java的开发人员，Spring框架肯定是无法绕过的。在学习 Spring 框架的过程中，我们往往只是停留在“使用”层面，而对其底层实现机制知之甚少。但我始终觉得，学习框架的过程中，理解其设计思想和实现原理是非常重要的。因此，我决定手写一个微型的Spring框架，来深入理解Spring的核心设计思想。为了加深我对 Spring 的理解，并锻炼 Java 框架设计能力，我决定手写一个微型的 Spring 框架 —— Javelin。\n\n这篇文章我们将实现：\n\n- 一个简单的 IoC 容器 `JavelinContext`，用于管理 Bean 实例的生命周期。\n- 支持 `@RestController`、`@GetMapping`、`@PostMapping` 等注解的自动扫描与注册。\n- 基于 `HttpServer` 的端口监听与请求路由分发。\n\n> 本文适合有 Java 或 .NET 框架开发经验的读者，特别是希望深入理解 Spring、探索其核心设计思想的人群。\n\n---\n\n## 为什么要手写一个 Spring 框架？\n\n首先Spring 是 Java 生态中最具代表性的框架之一，而作为一个搬砖多年的开发人员，CURD显然不再是我们的追求。但，学习框架的设计思想和实现原理还是非常有价值的。Sping框架核心理念在于控制反转（IoC）、面向切面编程（AOP）和基于注解的声明式编程。手写框架可以帮助我们：\n\n1. **理解 IoC 容器原理**：Bean 是如何被发现、实例化、依赖注入的？\n2. **掌握路由注册机制**：Spring MVC 如何基于注解将请求分发给具体的方法？\n3. **探索类扫描与反射机制**：如何实现自动发现注解的类与方法？\n4. **对比 .NET**：Spring 与 ASP.NET Core 的设计思路在某些地方是相通的，比如 `@RestController` 和 `[ApiController]`，但实现方式有差异。\n\n通过实战构建 Javelin，我们能够站在框架设计者的角度重新思考“约定优于配置”的设计哲学。\n\n---\n\n## 项目结构\n我们手写的框架名叫 `Javelin`，目前已经实现了三个核心模块：\n\n| 模块 | 功能 |\n|------|------|\n| `JavelinContext` | 提供简化版 IoC 容器，实现基于注解的构造函数注入 |\n| `Router` | 自动扫描 `@RestController`，绑定 GET/POST 请求路径 |\n| `AppStartup` | 应用启动入口，配置端口监听、类扫描路径等 |\n\n\n![结构](./images/spring-1/architecture.png)\n\n项目结构如下：\n```\njavelin-core/\n├── annotations/        // 自定义注解（@RestController, @Inject 等）\n├── context/            // IoC 容器\n├── rest/               // 路由注册\n├── core/               // 类扫描器\n└── startup/            // 启动类\n```\n\n\n## 构建核心 IoC 容器 `JavelinContext`\n\n我们首先需要一个容器类来负责扫描、实例化 Bean，并支持构造函数注入。代码结构如下：\n\n```java\npublic class JavelinContext {\n\n    private final Map<Class<?>, Object> singletonMap = new HashMap<>();\n\n    public <T> T getBean(Class<T> clazz) {\n        if (singletonMap.containsKey(clazz)) {\n            return (T) singletonMap.get(clazz);\n        }\n\n        T instance = (T) createBean(clazz);\n        singletonMap.put(clazz, instance);\n        return instance;\n        \n    }\n\n    public <T> T createBean(Class<T> clazz) {\n        try {\n            Constructor<?>[] constructors = clazz.getDeclaredConstructors();\n            \n            injectConstructor = clazz.getDeclaredConstructor();\n            // ...\n\n            return (T) injectConstructor.newInstance(args.toArray());\n        }  catch (Exception e) {\n            throw new RuntimeException(\"Failed to instantiate: \" + clazz.getName(), e); \n        }\n    }\n}\n\n```\n\n这段代码的核心思路与 .NET Core 的构造函数注入类似（例如通过 `IServiceCollection.AddTransient()` 注册服务并注入）。\n\n\n---\n\n## 自动路由注册 Router\n\n我们手动实现了基于注解的请求路由注册机制。Javelin 支持如下注解：\n\n控制器注解\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RestController {}\n```\n\n请求映射注解\n```java\n@Target(ElementType.ANNOTATION_TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface HttpMethodMapping {\n    String method();\n}\n\n@HttpMethodMapping(method = \"POST\")\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface PostMapping {\n    String value();\n}\n\n// ...\n```\n\n而 `Router` 类的核心逻辑如下：\n\n```java\npublic class Router {\n    public void registerRoutes(HttpServer server, Set<Class<?>> classes, JavelinContext context) {\n        for (Class<?> clazz : classes) {\n            if (!clazz.isAnnotationPresent(RestController.class)) continue;\n\n            Object controller = context.getBean(clazz);\n\n            for (Method method : clazz.getDeclaredMethods()) {\n                HttpMethodMapping mapping = annotation.annotationType().getAnnotation(HttpMethodMapping.class);\n                if (mapping != null) {\n                       String httpMethod = mapping.method();                       \n                       try{\n                           String path = (String) annotation.annotationType().getMethod(\"value\").invoke(annotation);\n                           registerHandler(server, path, httpMethod, controllerInstance, method);\n                       } catch (Exception e) {\n                           e.printStackTrace(); \n                       }\n\n                    }\n            }\n        }\n    }\n\n    private void registerHandler(HttpServer server, String path, String expectedMethod, Object controllerInstance, Method method) {\n        server.createContext(path, exchange -> {\n            // 判断请求的合法性\n\n            try {\n                // 反射调用方法\n            } catch (Exception e) {\n                exchange.sendResponseHeaders(500, 0);\n                e.printStackTrace();\n            }\n        });\n\n        System.out.println(\"➡️  [\" + httpMethod + \"] \" + path + \" → \" + controller.getClass().getSimpleName() + \".\" + method.getName());\n    }\n}\n```\n\n\n.NET 中这部分功能相当于 ASP.NET Core 中的 `MapControllers()` + `[HttpGet(\"/api/foo\")]` 等特性。\n\n---\n\n## 启动类 AppStartup\n\n```java\npublic class AppStartup {\n    public static void run(Class<?> appClass, String[] args)\n    {\n        String basePackage = appClass.getPackage().getName(); // 自动获取包名\n        Set<Class<?>> controllers = ClassScanner.scan(basePackage);\n\n        int port = resolvePort(); // ✅ 获取端口号\n        HttpServer server;\n        try {\n            server = HttpServer.create(new InetSocketAddress(port), 0); // 默认端口8080     \n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start HTTP server\", e);\n        }           \n\n        JavelinContext context = new JavelinContext();\n        new Router().registerRoutes(server, controllers, context);\n\n        server.start();\n        System.out.println(\"🚀 Server started at http://localhost:\" + port);\n    }\n}\n```\n\n## Service 注入\n```java\n\n@RestController\npublic class HelloController {\n    private UserService userService;\n\n    @Inject\n    public HelloController(UserService userService) {\n        this.userService = userService; // ✅ 注入UserService实例 \n    }\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World from \" + userService.getUserById(1) ;\n    }\n}\n```\n接下面让我们看看我们的Hello World\n![运行效果](./images/spring-1/result.png)\n当我们用get方式访问post时，会报405错误。\n![运行效果](./images/spring-1/fail.png)\n\n\n## 💡和 .NET 框架的对比分析\n在开发 Javelin 的过程中，我时常联想到 .NET 的实现，尤其是 ASP.NET Core，它与 Spring 在设计理念上高度一致，但细节又有一些差异，下面进行系统性对比：\n\n### 控制器与路由\n|特性 |\tJavelin (Java) |\tASP.NET Core (.NET) |\n|------|------|------|\n| 控制器注解/特性 |\t@RestController | [ApiController] |\n|路由声明方式 |\t@GetMapping(\"/path\") |\t[HttpGet(\"path\")] |\n|路由注册机制 |\t手动反射扫描注册 |\t中间件动态注册至 EndpointRouting |\n|请求处理 |\tHttpExchangeHandler |\tControllerInvoker 中间件链 |\n\n### 依赖注入与服务容器\n|特性 |\tJavelin (Java) |\tASP.NET Core (.NET) |\n|------|------|------|\n|服务注册方式 |\t自动递归构造，无需注册 |\t显式调用 services.AddXyz() |\n|注入方式 |\t构造函数 + @Inject |\t构造函数 + 内建 IoC 容器 |\n|生命周期管理 |\t默认单例 |\t支持 Transient / Scoped / Singleton |\n|循环依赖检测 |\t暂不支持 |\t默认会在启动时检测并抛出异常 |\n\n### 底层运行机制\n|特性 |\tJavelin |\tASP.NET Core |\n|------|------|------|\n|HTTP 服务器 |\tcom.sun.net.httpserver.HttpServer |\tKestrel 内置服务器 |\n|请求派发模型 |\t映射到类方法，反射调用 |\t中间件链 + 路由匹配 + ControllerInvoker |\n\n可以看出，Javelin 更加简洁直观，适合做教学或理解框架底层流程，而 ASP.NET Core 更加强大和工程化，适用于复杂企业级应用。\n\n\n## 总结与下步计划\n\n通过上面的内容，我们已经实现了 Spring 框架的三个关键能力：\n\n- 简易 IoC 容器支持构造函数注入\n- 使用 `@RestController`/`@GetMapping`/`@PostMapping` 注解注册请求处理器\n- 类似 Spring Boot 的端口监听启动类\n\n后续我们将继续拓展：\n\n- 参数绑定（如 `@RequestParam`, `@RequestBody`）\n- 中间件机制（如拦截器）\n- 全局异常处理\n- JSON 返回支持\n- 生命周期管理\n\n敬请期待下一篇：**实现请求参数自动注入与 JSON 响应支持**！\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/Javelin)仓库。","slug":"javelin-1","published":1,"updated":"2025-04-15T03:37:53.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm9zdtu990001wop10d8q8mud","content":"<p>书接上回，作为一个从.NET转Java的开发人员，Spring框架肯定是无法绕过的。在学习 Spring 框架的过程中，我们往往只是停留在“使用”层面，而对其底层实现机制知之甚少。但我始终觉得，学习框架的过程中，理解其设计思想和实现原理是非常重要的。因此，我决定手写一个微型的Spring框架，来深入理解Spring的核心设计思想。为了加深我对 Spring 的理解，并锻炼 Java 框架设计能力，我决定手写一个微型的 Spring 框架 —— Javelin。</p>\n<p>这篇文章我们将实现：</p>\n<ul>\n<li>一个简单的 IoC 容器 <code>JavelinContext</code>，用于管理 Bean 实例的生命周期。</li>\n<li>支持 <code>@RestController</code>、<code>@GetMapping</code>、<code>@PostMapping</code> 等注解的自动扫描与注册。</li>\n<li>基于 <code>HttpServer</code> 的端口监听与请求路由分发。</li>\n</ul>\n<blockquote>\n<p>本文适合有 Java 或 .NET 框架开发经验的读者，特别是希望深入理解 Spring、探索其核心设计思想的人群。</p>\n</blockquote>\n<hr>\n<h2 id=\"为什么要手写一个-Spring-框架？\"><a href=\"#为什么要手写一个-Spring-框架？\" class=\"headerlink\" title=\"为什么要手写一个 Spring 框架？\"></a>为什么要手写一个 Spring 框架？</h2><p>首先Spring 是 Java 生态中最具代表性的框架之一，而作为一个搬砖多年的开发人员，CURD显然不再是我们的追求。但，学习框架的设计思想和实现原理还是非常有价值的。Sping框架核心理念在于控制反转（IoC）、面向切面编程（AOP）和基于注解的声明式编程。手写框架可以帮助我们：</p>\n<ol>\n<li><strong>理解 IoC 容器原理</strong>：Bean 是如何被发现、实例化、依赖注入的？</li>\n<li><strong>掌握路由注册机制</strong>：Spring MVC 如何基于注解将请求分发给具体的方法？</li>\n<li><strong>探索类扫描与反射机制</strong>：如何实现自动发现注解的类与方法？</li>\n<li><strong>对比 .NET</strong>：Spring 与 ASP.NET Core 的设计思路在某些地方是相通的，比如 <code>@RestController</code> 和 <code>[ApiController]</code>，但实现方式有差异。</li>\n</ol>\n<p>通过实战构建 Javelin，我们能够站在框架设计者的角度重新思考“约定优于配置”的设计哲学。</p>\n<hr>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>我们手写的框架名叫 <code>Javelin</code>，目前已经实现了三个核心模块：</p>\n<table>\n<thead>\n<tr>\n<th>模块</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>JavelinContext</code></td>\n<td>提供简化版 IoC 容器，实现基于注解的构造函数注入</td>\n</tr>\n<tr>\n<td><code>Router</code></td>\n<td>自动扫描 <code>@RestController</code>，绑定 GET&#x2F;POST 请求路径</td>\n</tr>\n<tr>\n<td><code>AppStartup</code></td>\n<td>应用启动入口，配置端口监听、类扫描路径等</td>\n</tr>\n</tbody></table>\n<p><img src=\"/blog/./images/spring-1/architecture.png\" alt=\"结构\"></p>\n<p>项目结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javelin-core/</span><br><span class=\"line\">├── annotations/        // 自定义注解（@RestController, @Inject 等）</span><br><span class=\"line\">├── context/            // IoC 容器</span><br><span class=\"line\">├── rest/               // 路由注册</span><br><span class=\"line\">├── core/               // 类扫描器</span><br><span class=\"line\">└── startup/            // 启动类</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"构建核心-IoC-容器-JavelinContext\"><a href=\"#构建核心-IoC-容器-JavelinContext\" class=\"headerlink\" title=\"构建核心 IoC 容器 JavelinContext\"></a>构建核心 IoC 容器 <code>JavelinContext</code></h2><p>我们首先需要一个容器类来负责扫描、实例化 Bean，并支持构造函数注入。代码结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinContext</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;, Object&gt; singletonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singletonMap.containsKey(clazz)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T) singletonMap.get(clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> (T) createBean(clazz);</span><br><span class=\"line\">        singletonMap.put(clazz, instance);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">createBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span><br><span class=\"line\">            </span><br><span class=\"line\">            injectConstructor = clazz.getDeclaredConstructor();</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T) injectConstructor.newInstance(args.toArray());</span><br><span class=\"line\">        &#125;  <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Failed to instantiate: &quot;</span> + clazz.getName(), e); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码的核心思路与 .NET Core 的构造函数注入类似（例如通过 <code>IServiceCollection.AddTransient()</code> 注册服务并注入）。</p>\n<hr>\n<h2 id=\"自动路由注册-Router\"><a href=\"#自动路由注册-Router\" class=\"headerlink\" title=\"自动路由注册 Router\"></a>自动路由注册 Router</h2><p>我们手动实现了基于注解的请求路由注册机制。Javelin 支持如下注解：</p>\n<p>控制器注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RestController &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请求映射注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> HttpMethodMapping &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">method</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HttpMethodMapping(method = &quot;POST&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> PostMapping &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>而 <code>Router</code> 类的核心逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Router</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerRoutes</span><span class=\"params\">(HttpServer server, Set&lt;Class&lt;?&gt;&gt; classes, JavelinContext context)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!clazz.isAnnotationPresent(RestController.class)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">controller</span> <span class=\"operator\">=</span> context.getBean(clazz);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class=\"line\">                <span class=\"type\">HttpMethodMapping</span> <span class=\"variable\">mapping</span> <span class=\"operator\">=</span> annotation.annotationType().getAnnotation(HttpMethodMapping.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mapping != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                       <span class=\"type\">String</span> <span class=\"variable\">httpMethod</span> <span class=\"operator\">=</span> mapping.method();                       </span><br><span class=\"line\">                       <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                           <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (String) annotation.annotationType().getMethod(<span class=\"string\">&quot;value&quot;</span>).invoke(annotation);</span><br><span class=\"line\">                           registerHandler(server, path, httpMethod, controllerInstance, method);</span><br><span class=\"line\">                       &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                           e.printStackTrace(); </span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerHandler</span><span class=\"params\">(HttpServer server, String path, String expectedMethod, Object controllerInstance, Method method)</span> &#123;</span><br><span class=\"line\">        server.createContext(path, exchange -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断请求的合法性</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 反射调用方法</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                exchange.sendResponseHeaders(<span class=\"number\">500</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;➡️  [&quot;</span> + httpMethod + <span class=\"string\">&quot;] &quot;</span> + path + <span class=\"string\">&quot; → &quot;</span> + controller.getClass().getSimpleName() + <span class=\"string\">&quot;.&quot;</span> + method.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>.NET 中这部分功能相当于 ASP.NET Core 中的 <code>MapControllers()</code> + <code>[HttpGet(&quot;/api/foo&quot;)]</code> 等特性。</p>\n<hr>\n<h2 id=\"启动类-AppStartup\"><a href=\"#启动类-AppStartup\" class=\"headerlink\" title=\"启动类 AppStartup\"></a>启动类 AppStartup</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppStartup</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt; appClass, String[] args)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">basePackage</span> <span class=\"operator\">=</span> appClass.getPackage().getName(); <span class=\"comment\">// 自动获取包名</span></span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; controllers = ClassScanner.scan(basePackage);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">port</span> <span class=\"operator\">=</span> resolvePort(); <span class=\"comment\">// ✅ 获取端口号</span></span><br><span class=\"line\">        HttpServer server;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            server = HttpServer.create(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(port), <span class=\"number\">0</span>); <span class=\"comment\">// 默认端口8080     </span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Failed to start HTTP server&quot;</span>, e);</span><br><span class=\"line\">        &#125;           </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">JavelinContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavelinContext</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>().registerRoutes(server, controllers, context);</span><br><span class=\"line\"></span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;🚀 Server started at http://localhost:&quot;</span> + port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Service-注入\"><a href=\"#Service-注入\" class=\"headerlink\" title=\"Service 注入\"></a>Service 注入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HelloController</span><span class=\"params\">(UserService userService)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userService = userService; <span class=\"comment\">// ✅ 注入UserService实例 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/hello&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World from &quot;</span> + userService.getUserById(<span class=\"number\">1</span>) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下面让我们看看我们的Hello World<br><img src=\"/blog/./images/spring-1/result.png\" alt=\"运行效果\"><br>当我们用get方式访问post时，会报405错误。<br><img src=\"/blog/./images/spring-1/fail.png\" alt=\"运行效果\"></p>\n<h2 id=\"💡和-NET-框架的对比分析\"><a href=\"#💡和-NET-框架的对比分析\" class=\"headerlink\" title=\"💡和 .NET 框架的对比分析\"></a>💡和 .NET 框架的对比分析</h2><p>在开发 Javelin 的过程中，我时常联想到 .NET 的实现，尤其是 ASP.NET Core，它与 Spring 在设计理念上高度一致，但细节又有一些差异，下面进行系统性对比：</p>\n<h3 id=\"控制器与路由\"><a href=\"#控制器与路由\" class=\"headerlink\" title=\"控制器与路由\"></a>控制器与路由</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Javelin (Java)</th>\n<th>ASP.NET Core (.NET)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>控制器注解&#x2F;特性</td>\n<td>@RestController</td>\n<td>[ApiController]</td>\n</tr>\n<tr>\n<td>路由声明方式</td>\n<td>@GetMapping(“&#x2F;path”)</td>\n<td>[HttpGet(“path”)]</td>\n</tr>\n<tr>\n<td>路由注册机制</td>\n<td>手动反射扫描注册</td>\n<td>中间件动态注册至 EndpointRouting</td>\n</tr>\n<tr>\n<td>请求处理</td>\n<td>HttpExchangeHandler</td>\n<td>ControllerInvoker 中间件链</td>\n</tr>\n</tbody></table>\n<h3 id=\"依赖注入与服务容器\"><a href=\"#依赖注入与服务容器\" class=\"headerlink\" title=\"依赖注入与服务容器\"></a>依赖注入与服务容器</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Javelin (Java)</th>\n<th>ASP.NET Core (.NET)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册方式</td>\n<td>自动递归构造，无需注册</td>\n<td>显式调用 services.AddXyz()</td>\n</tr>\n<tr>\n<td>注入方式</td>\n<td>构造函数 + @Inject</td>\n<td>构造函数 + 内建 IoC 容器</td>\n</tr>\n<tr>\n<td>生命周期管理</td>\n<td>默认单例</td>\n<td>支持 Transient &#x2F; Scoped &#x2F; Singleton</td>\n</tr>\n<tr>\n<td>循环依赖检测</td>\n<td>暂不支持</td>\n<td>默认会在启动时检测并抛出异常</td>\n</tr>\n</tbody></table>\n<h3 id=\"底层运行机制\"><a href=\"#底层运行机制\" class=\"headerlink\" title=\"底层运行机制\"></a>底层运行机制</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Javelin</th>\n<th>ASP.NET Core</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP 服务器</td>\n<td>com.sun.net.httpserver.HttpServer</td>\n<td>Kestrel 内置服务器</td>\n</tr>\n<tr>\n<td>请求派发模型</td>\n<td>映射到类方法，反射调用</td>\n<td>中间件链 + 路由匹配 + ControllerInvoker</td>\n</tr>\n</tbody></table>\n<p>可以看出，Javelin 更加简洁直观，适合做教学或理解框架底层流程，而 ASP.NET Core 更加强大和工程化，适用于复杂企业级应用。</p>\n<h2 id=\"总结与下步计划\"><a href=\"#总结与下步计划\" class=\"headerlink\" title=\"总结与下步计划\"></a>总结与下步计划</h2><p>通过上面的内容，我们已经实现了 Spring 框架的三个关键能力：</p>\n<ul>\n<li>简易 IoC 容器支持构造函数注入</li>\n<li>使用 <code>@RestController</code>&#x2F;<code>@GetMapping</code>&#x2F;<code>@PostMapping</code> 注解注册请求处理器</li>\n<li>类似 Spring Boot 的端口监听启动类</li>\n</ul>\n<p>后续我们将继续拓展：</p>\n<ul>\n<li>参数绑定（如 <code>@RequestParam</code>, <code>@RequestBody</code>）</li>\n<li>中间件机制（如拦截器）</li>\n<li>全局异常处理</li>\n<li>JSON 返回支持</li>\n<li>生命周期管理</li>\n</ul>\n<p>敬请期待下一篇：<strong>实现请求参数自动注入与 JSON 响应支持</strong>！</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/Javelin\">GitHub</a>仓库。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>书接上回，作为一个从.NET转Java的开发人员，Spring框架肯定是无法绕过的。在学习 Spring 框架的过程中，我们往往只是停留在“使用”层面，而对其底层实现机制知之甚少。但我始终觉得，学习框架的过程中，理解其设计思想和实现原理是非常重要的。因此，我决定手写一个微型的Spring框架，来深入理解Spring的核心设计思想。为了加深我对 Spring 的理解，并锻炼 Java 框架设计能力，我决定手写一个微型的 Spring 框架 —— Javelin。</p>\n<p>这篇文章我们将实现：</p>\n<ul>\n<li>一个简单的 IoC 容器 <code>JavelinContext</code>，用于管理 Bean 实例的生命周期。</li>\n<li>支持 <code>@RestController</code>、<code>@GetMapping</code>、<code>@PostMapping</code> 等注解的自动扫描与注册。</li>\n<li>基于 <code>HttpServer</code> 的端口监听与请求路由分发。</li>\n</ul>\n<blockquote>\n<p>本文适合有 Java 或 .NET 框架开发经验的读者，特别是希望深入理解 Spring、探索其核心设计思想的人群。</p>\n</blockquote>\n<hr>\n<h2 id=\"为什么要手写一个-Spring-框架？\"><a href=\"#为什么要手写一个-Spring-框架？\" class=\"headerlink\" title=\"为什么要手写一个 Spring 框架？\"></a>为什么要手写一个 Spring 框架？</h2><p>首先Spring 是 Java 生态中最具代表性的框架之一，而作为一个搬砖多年的开发人员，CURD显然不再是我们的追求。但，学习框架的设计思想和实现原理还是非常有价值的。Sping框架核心理念在于控制反转（IoC）、面向切面编程（AOP）和基于注解的声明式编程。手写框架可以帮助我们：</p>\n<ol>\n<li><strong>理解 IoC 容器原理</strong>：Bean 是如何被发现、实例化、依赖注入的？</li>\n<li><strong>掌握路由注册机制</strong>：Spring MVC 如何基于注解将请求分发给具体的方法？</li>\n<li><strong>探索类扫描与反射机制</strong>：如何实现自动发现注解的类与方法？</li>\n<li><strong>对比 .NET</strong>：Spring 与 ASP.NET Core 的设计思路在某些地方是相通的，比如 <code>@RestController</code> 和 <code>[ApiController]</code>，但实现方式有差异。</li>\n</ol>\n<p>通过实战构建 Javelin，我们能够站在框架设计者的角度重新思考“约定优于配置”的设计哲学。</p>\n<hr>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>我们手写的框架名叫 <code>Javelin</code>，目前已经实现了三个核心模块：</p>\n<table>\n<thead>\n<tr>\n<th>模块</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>JavelinContext</code></td>\n<td>提供简化版 IoC 容器，实现基于注解的构造函数注入</td>\n</tr>\n<tr>\n<td><code>Router</code></td>\n<td>自动扫描 <code>@RestController</code>，绑定 GET&#x2F;POST 请求路径</td>\n</tr>\n<tr>\n<td><code>AppStartup</code></td>\n<td>应用启动入口，配置端口监听、类扫描路径等</td>\n</tr>\n</tbody></table>\n<p><img src=\"/blog/./images/spring-1/architecture.png\" alt=\"结构\"></p>\n<p>项目结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javelin-core/</span><br><span class=\"line\">├── annotations/        // 自定义注解（@RestController, @Inject 等）</span><br><span class=\"line\">├── context/            // IoC 容器</span><br><span class=\"line\">├── rest/               // 路由注册</span><br><span class=\"line\">├── core/               // 类扫描器</span><br><span class=\"line\">└── startup/            // 启动类</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"构建核心-IoC-容器-JavelinContext\"><a href=\"#构建核心-IoC-容器-JavelinContext\" class=\"headerlink\" title=\"构建核心 IoC 容器 JavelinContext\"></a>构建核心 IoC 容器 <code>JavelinContext</code></h2><p>我们首先需要一个容器类来负责扫描、实例化 Bean，并支持构造函数注入。代码结构如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinContext</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;, Object&gt; singletonMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singletonMap.containsKey(clazz)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T) singletonMap.get(clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> (T) createBean(clazz);</span><br><span class=\"line\">        singletonMap.put(clazz, instance);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">createBean</span><span class=\"params\">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span><br><span class=\"line\">            </span><br><span class=\"line\">            injectConstructor = clazz.getDeclaredConstructor();</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T) injectConstructor.newInstance(args.toArray());</span><br><span class=\"line\">        &#125;  <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Failed to instantiate: &quot;</span> + clazz.getName(), e); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码的核心思路与 .NET Core 的构造函数注入类似（例如通过 <code>IServiceCollection.AddTransient()</code> 注册服务并注入）。</p>\n<hr>\n<h2 id=\"自动路由注册-Router\"><a href=\"#自动路由注册-Router\" class=\"headerlink\" title=\"自动路由注册 Router\"></a>自动路由注册 Router</h2><p>我们手动实现了基于注解的请求路由注册机制。Javelin 支持如下注解：</p>\n<p>控制器注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RestController &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请求映射注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> HttpMethodMapping &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">method</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HttpMethodMapping(method = &quot;POST&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> PostMapping &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>而 <code>Router</code> 类的核心逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Router</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerRoutes</span><span class=\"params\">(HttpServer server, Set&lt;Class&lt;?&gt;&gt; classes, JavelinContext context)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!clazz.isAnnotationPresent(RestController.class)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">controller</span> <span class=\"operator\">=</span> context.getBean(clazz);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class=\"line\">                <span class=\"type\">HttpMethodMapping</span> <span class=\"variable\">mapping</span> <span class=\"operator\">=</span> annotation.annotationType().getAnnotation(HttpMethodMapping.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mapping != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                       <span class=\"type\">String</span> <span class=\"variable\">httpMethod</span> <span class=\"operator\">=</span> mapping.method();                       </span><br><span class=\"line\">                       <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                           <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (String) annotation.annotationType().getMethod(<span class=\"string\">&quot;value&quot;</span>).invoke(annotation);</span><br><span class=\"line\">                           registerHandler(server, path, httpMethod, controllerInstance, method);</span><br><span class=\"line\">                       &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                           e.printStackTrace(); </span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerHandler</span><span class=\"params\">(HttpServer server, String path, String expectedMethod, Object controllerInstance, Method method)</span> &#123;</span><br><span class=\"line\">        server.createContext(path, exchange -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断请求的合法性</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 反射调用方法</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                exchange.sendResponseHeaders(<span class=\"number\">500</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;➡️  [&quot;</span> + httpMethod + <span class=\"string\">&quot;] &quot;</span> + path + <span class=\"string\">&quot; → &quot;</span> + controller.getClass().getSimpleName() + <span class=\"string\">&quot;.&quot;</span> + method.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>.NET 中这部分功能相当于 ASP.NET Core 中的 <code>MapControllers()</code> + <code>[HttpGet(&quot;/api/foo&quot;)]</code> 等特性。</p>\n<hr>\n<h2 id=\"启动类-AppStartup\"><a href=\"#启动类-AppStartup\" class=\"headerlink\" title=\"启动类 AppStartup\"></a>启动类 AppStartup</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppStartup</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt; appClass, String[] args)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">basePackage</span> <span class=\"operator\">=</span> appClass.getPackage().getName(); <span class=\"comment\">// 自动获取包名</span></span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; controllers = ClassScanner.scan(basePackage);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">port</span> <span class=\"operator\">=</span> resolvePort(); <span class=\"comment\">// ✅ 获取端口号</span></span><br><span class=\"line\">        HttpServer server;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            server = HttpServer.create(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(port), <span class=\"number\">0</span>); <span class=\"comment\">// 默认端口8080     </span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;Failed to start HTTP server&quot;</span>, e);</span><br><span class=\"line\">        &#125;           </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">JavelinContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavelinContext</span>();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>().registerRoutes(server, controllers, context);</span><br><span class=\"line\"></span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;🚀 Server started at http://localhost:&quot;</span> + port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Service-注入\"><a href=\"#Service-注入\" class=\"headerlink\" title=\"Service 注入\"></a>Service 注入</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HelloController</span><span class=\"params\">(UserService userService)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userService = userService; <span class=\"comment\">// ✅ 注入UserService实例 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/hello&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">hello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World from &quot;</span> + userService.getUserById(<span class=\"number\">1</span>) ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下面让我们看看我们的Hello World<br><img src=\"/blog/./images/spring-1/result.png\" alt=\"运行效果\"><br>当我们用get方式访问post时，会报405错误。<br><img src=\"/blog/./images/spring-1/fail.png\" alt=\"运行效果\"></p>\n<h2 id=\"💡和-NET-框架的对比分析\"><a href=\"#💡和-NET-框架的对比分析\" class=\"headerlink\" title=\"💡和 .NET 框架的对比分析\"></a>💡和 .NET 框架的对比分析</h2><p>在开发 Javelin 的过程中，我时常联想到 .NET 的实现，尤其是 ASP.NET Core，它与 Spring 在设计理念上高度一致，但细节又有一些差异，下面进行系统性对比：</p>\n<h3 id=\"控制器与路由\"><a href=\"#控制器与路由\" class=\"headerlink\" title=\"控制器与路由\"></a>控制器与路由</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Javelin (Java)</th>\n<th>ASP.NET Core (.NET)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>控制器注解&#x2F;特性</td>\n<td>@RestController</td>\n<td>[ApiController]</td>\n</tr>\n<tr>\n<td>路由声明方式</td>\n<td>@GetMapping(“&#x2F;path”)</td>\n<td>[HttpGet(“path”)]</td>\n</tr>\n<tr>\n<td>路由注册机制</td>\n<td>手动反射扫描注册</td>\n<td>中间件动态注册至 EndpointRouting</td>\n</tr>\n<tr>\n<td>请求处理</td>\n<td>HttpExchangeHandler</td>\n<td>ControllerInvoker 中间件链</td>\n</tr>\n</tbody></table>\n<h3 id=\"依赖注入与服务容器\"><a href=\"#依赖注入与服务容器\" class=\"headerlink\" title=\"依赖注入与服务容器\"></a>依赖注入与服务容器</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Javelin (Java)</th>\n<th>ASP.NET Core (.NET)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册方式</td>\n<td>自动递归构造，无需注册</td>\n<td>显式调用 services.AddXyz()</td>\n</tr>\n<tr>\n<td>注入方式</td>\n<td>构造函数 + @Inject</td>\n<td>构造函数 + 内建 IoC 容器</td>\n</tr>\n<tr>\n<td>生命周期管理</td>\n<td>默认单例</td>\n<td>支持 Transient &#x2F; Scoped &#x2F; Singleton</td>\n</tr>\n<tr>\n<td>循环依赖检测</td>\n<td>暂不支持</td>\n<td>默认会在启动时检测并抛出异常</td>\n</tr>\n</tbody></table>\n<h3 id=\"底层运行机制\"><a href=\"#底层运行机制\" class=\"headerlink\" title=\"底层运行机制\"></a>底层运行机制</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Javelin</th>\n<th>ASP.NET Core</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP 服务器</td>\n<td>com.sun.net.httpserver.HttpServer</td>\n<td>Kestrel 内置服务器</td>\n</tr>\n<tr>\n<td>请求派发模型</td>\n<td>映射到类方法，反射调用</td>\n<td>中间件链 + 路由匹配 + ControllerInvoker</td>\n</tr>\n</tbody></table>\n<p>可以看出，Javelin 更加简洁直观，适合做教学或理解框架底层流程，而 ASP.NET Core 更加强大和工程化，适用于复杂企业级应用。</p>\n<h2 id=\"总结与下步计划\"><a href=\"#总结与下步计划\" class=\"headerlink\" title=\"总结与下步计划\"></a>总结与下步计划</h2><p>通过上面的内容，我们已经实现了 Spring 框架的三个关键能力：</p>\n<ul>\n<li>简易 IoC 容器支持构造函数注入</li>\n<li>使用 <code>@RestController</code>&#x2F;<code>@GetMapping</code>&#x2F;<code>@PostMapping</code> 注解注册请求处理器</li>\n<li>类似 Spring Boot 的端口监听启动类</li>\n</ul>\n<p>后续我们将继续拓展：</p>\n<ul>\n<li>参数绑定（如 <code>@RequestParam</code>, <code>@RequestBody</code>）</li>\n<li>中间件机制（如拦截器）</li>\n<li>全局异常处理</li>\n<li>JSON 返回支持</li>\n<li>生命周期管理</li>\n</ul>\n<p>敬请期待下一篇：<strong>实现请求参数自动注入与 JSON 响应支持</strong>！</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/Javelin\">GitHub</a>仓库。</p>\n"},{"title":"手写一个微型Spring框架（三）：NHttpContext的详解","date":"2025-04-30T01:58:18.000Z","_content":"\n在Javelin框架中，`NHttpContext`类在HTTP请求处理流水线中扮演着至关重要的角色。它是一个封装了请求-响应生命周期各个方面的对象，管理着HTTP请求的各个环节。下面我们将深入探讨`NHttpContext`的功能、组成部分及其设计思路。\n\n---\n\n# `NHttpContext`概述\n\n`NHttpContext`是一个容器，保存了处理HTTP请求所需的所有必要元素。它不仅代表当前HTTP交换的状态，还管理流水线上下文、日志记录、错误处理等内容。其设计使其成为HTTP请求生命周期中的主要上下文对象，提供了一种有组织的方式来管理请求和响应。\n\n![NHttpContext](./images/javelin-3/uml.png)\n\n以下是`NHttpContext`中主要属性的介绍：\n\n1. **HttpExchange exchange**：  \n   这是实际的HTTP交换对象，代表了HTTP请求和响应。它是Java HTTP服务器提供的标准`HttpExchange`对象，但在Javelin中，它被封装在`NHttpContext`中，以便提供更简洁和定制化的处理流程。\n\n2. **HttpPipelineContext pipelineContext**：  \n   `pipelineContext`负责管理HTTP请求处理流水线的各个阶段。这个流水线包括路由、认证、日志记录等步骤。它确保HTTP请求在每个阶段都能被正确处理。\n\n3. **OprLogScope oprLogScope**：  \n   该对象用于在请求处理过程中管理日志记录的作用域。它允许Javelin在特定的作用域内创建和处理日志，确保与特定HTTP请求相关的日志能被准确捕捉。\n\n4. **Exception lastException**：  \n   如果在请求处理过程中发生任何异常，这个字段存储最后的异常。这个功能对调试非常有用，因为它允许开发者访问可能干扰HTTP请求处理的异常信息。\n\n5. **boolean skipAuthentication**：  \n   该布尔标志控制是否跳过当前请求的认证。对于某些请求，不需要认证时可以设置为`true`，这样请求就不需要经过认证步骤。\n\n```java\npublic class NHttpContext {\n    public HttpExchange exchange;\n    public HttpPipelineContext pipelineContext;\n    public OprLogScope oprLogScope;\n    public Exception lastException;\n    public boolean skipAuthentication;\n\n    public NHttpContext(HttpExchange exchange, RouteDefinition routeDefinition) {\n        this.exchange = exchange;\n        this.pipelineContext = HttpPipelineContext.start(this);\n        this.pipelineContext.routeDefinition = routeDefinition;\n    }\n\n    void setOprLogScope(OprLogScope oprLogScope) {\n        this.oprLogScope = oprLogScope;\n    }\n\n    public void httpReply(int statusCode, String message) {\n        try {\n            this.exchange.sendResponseHeaders(statusCode, 0);\n            this.exchange.getResponseBody().write(message.getBytes());\n            this.exchange.close(); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n---\n\n# HttpPipelineContext 类\n\n`HttpPipelineContext` 类主要负责管理与请求处理流水线相关的信息。其功能包括：\n\n- **processId**：每个请求都应该有一个唯一的 ID，方便跟踪和调试。\n- **startTime** 和 **endTime**：记录请求的开始和结束时间，用于性能分析和日志记录。\n- **routeDefinition**：该字段关联当前请求处理的路由定义，确保请求按正确的路由规则进行处理。\n- **setException**：设置请求处理过程中发生的异常，便于在整个流程中传递和记录错误。\n\n```java\npublic class HttpPipelineContext {\n    public String processId;\n    public Date startTime;\n    public Date endTime;\n    public NHttpContext httpContext;\n    public RouteDefinition routeDefinition;\n    public Exception lastException;\n\n    public static HttpPipelineContext start(NHttpContext httpContext) {\n        HttpPipelineContext pipelineContext = new HttpPipelineContext(httpContext);\n\n        OprLogScope oprLogScope = OprLogScope.start(httpContext.pipelineContext);\n        pipelineContext.httpContext.setOprLogScope(oprLogScope);\n\n        return pipelineContext;\n    }\n\n    public void setRouteDefinition(RouteDefinition routeDefinition) {\n        this.routeDefinition = routeDefinition;\n    }\n\n    private HttpPipelineContext(NHttpContext httpContext) {\n        if (httpContext == null) {\n            throw new IllegalArgumentException(\"httpContext cannot be null\");\n        }\n        this.httpContext = httpContext;\n        httpContext.pipelineContext = this;\n    }\n\n    public void setException(Exception ex) {\n        if (ex != null) {\n            httpContext.lastException = ex;\n        }\n    }\n\n    public void completeRequest() {\n        throw new AbortRequestException();\n    }\n\n    public void dispose() {\n        this.httpContext = null;\n    }\n}\n```\n---\n\n# OprLogScope 类\n\n`OprLogScope` 类负责在请求的生命周期内进行操作日志的记录和异常的处理。它的设计包括：\n\n- **steps**：记录操作的每个步骤。\n- **oprlog**：操作日志对象，记录请求处理过程中的各项操作。\n- **start**：启动操作日志范围的方法，负责创建和初始化操作日志。\n\n```java\npublic class OprLogScope {\n    private List<StepItem> steps;\n    public OprLog oprlog;\n\n    public static OprLogScope start(HttpPipelineContext pipelineContext) {\n        OprLogScope scope = new OprLogScope();\n        scope.oprlog = OprLog.create(pipelineContext);\n        return scope;\n    }\n\n    public int setException(Exception ex) {\n        return oprlog.setException(ex); \n    }\n\n    public int saveOprLog(HttpPipelineContext pipelineContext) {\n        LogHelper.Write(this.oprlog);\n        return 1;\n    }\n}\n```\n---\n\n# `NHttpContext`的设计思路\n\n在设计`NHttpContext`时，重点考虑了模块化、扩展性、易用性以及与Javelin框架中的其他组件的集成。作为Javelin HTTP请求处理流水线的一部分，`NHttpContext`的设计思路围绕着以下几个核心原则展开：\n\n## **单一责任原则（Single Responsibility Principle）**\n\n`NHttpContext`的设计遵循单一责任原则，它主要负责管理和维护一个HTTP请求生命周期中的各种上下文信息。通过将HTTP交换的相关信息（如请求、响应、路由信息、日志记录等）集中到一个对象中，`NHttpContext`避免了将过多责任分散到多个地方，从而提升了代码的可读性和可维护性。\n\n**责任划分**:\n- `HttpExchange`：处理请求和响应。\n- `HttpPipelineContext`：管理HTTP请求处理的流水线上下文，确保请求按顺序经过不同阶段的处理。\n- `OprLogScope`：处理日志记录的作用域，确保所有操作的日志能够被正确追踪。\n- `Exception`：捕捉并存储在请求处理过程中出现的异常信息。\n\n---\n\n## **灵活的流水线处理（Flexible Pipeline Handling）**\n\n`NHttpContext`将HTTP请求处理流程分为多个阶段，每个阶段由`HttpPipelineContext`负责。这使得Javelin的请求处理流水线具有很高的灵活性和可定制性，开发者可以根据具体需求在不同阶段插入中间件、路由逻辑、认证步骤等。\n\n- **流水线的动态性**：`HttpPipelineContext`会根据具体的路由定义和配置动态调整请求的处理流程。每次请求的流水线都可以根据具体的业务需求进行配置，使得请求处理过程更加高效和灵活。\n\n---\n\n## **高度模块化（Modularization）**\n\n在`NHttpContext`的设计中，各个功能模块之间的耦合度较低。例如，`HttpExchange`与`HttpPipelineContext`之间并没有强依赖，而是通过`NHttpContext`进行解耦，使得每个模块都能够独立工作并实现其特定功能。\n\n- **分离关注点**：日志处理、异常处理、HTTP请求和响应的处理等不同的关注点被封装在不同的对象中，使得每个对象都专注于其核心功能。\n- **扩展性**：这种设计使得开发者可以根据需求向`NHttpContext`中添加新的处理模块，例如，新的认证方式、日志记录策略等，保持了较高的扩展性。\n\n---\n\n## **集成式错误处理（Integrated Error Handling）**\n\n`NHttpContext`内建了异常处理机制，通过`lastException`字段记录发生的异常，使得开发者能够快速定位和处理错误。错误信息被集中管理，有助于后续的调试和问题追踪。\n\n- **集中管理异常**：`NHttpContext`会捕获并存储处理过程中发生的异常，避免了异常分散在各个模块中。这样开发者可以通过`lastException`迅速获取异常详情，并进行统一的处理。\n\n```java\npublic class ActionExecutor {\n    public void execute(NHttpContext context) throws Exception {\n        try{\n            // ...\n            handlerRequest(context);\n        } catch ( AbortRequestException e) {\n            // 提前结束请求，啥也不干了\n        } catch (Exception e) {\n            Throwable cause = e.getCause();\n            // 记录原始异常\n            context.pipelineContext.setException((Exception)cause);\n            app.onError(context);\n        } finally {\n            app.endRequest(context);\n        }\n\n    }\n```\n---\n\n## **响应处理简化（Simplified Response Handling）**\n\n`NHttpContext`提供了一个简单的接口`httpReply`，用于发送响应。通过该接口，开发者无需过多关注底层的`HttpExchange`细节，而只需传递状态码和响应体。这样简化了响应处理流程，提高了开发效率。\n\n- **简洁的API**：`httpReply`方法为响应发送提供了统一的接口，使得请求的响应处理变得直观和高效。\n- **自动化的关闭连接**：在异常发生后，调用`httpReply`方法自动关闭`HttpExchange`连接，无需手动干预。\n\n---\n\n## **面向操作的日志记录（Operation-Oriented Logging）**\n\n`NHttpContext`设计了`OprLogScope`来管理每个HTTP请求的操作日志。这使得每个请求的日志记录都能与当前操作（例如，路由、认证等）相关联，方便进行精准的日志追踪。\n\n- **作用域管理**：`OprLogScope`允许每个请求在特定的操作上下文内生成日志。这种方式增强了日志的可读性，帮助开发者清晰地追踪每个请求在不同阶段的执行情况。\n- **日志隔离**：通过为每个请求提供独立的日志作用域，避免了不同请求之间日志的混淆，提高了日志的准确性和可操作性。\n\n```java\npublic static HttpPipelineContext start(NHttpContext httpContext) {\n    HttpPipelineContext pipelineContext = new HttpPipelineContext(httpContext);\n    // 为每个请求创建独立的日志作用域\n    OprLogScope oprLogScope = OprLogScope.start(httpContext.pipelineContext);\n    pipelineContext.httpContext.setOprLogScope(oprLogScope);\n\n    return pipelineContext;\n}\n```\n---\n\n## **可配置的认证机制（Configurable Authentication Mechanism）**\n\n`NHttpContext`通过`skipAuthentication`标志允许开发者灵活地控制是否需要认证。这使得在某些场景下（如公共API或不需要身份验证的请求）可以跳过认证过程，减少了不必要的性能开销。\n\n- **认证跳过机制**：开发者可以根据业务需求灵活地跳过认证步骤，而无需修改底层认证逻辑。\n- **灵活性**：认证机制的可配置性增加了框架的灵活性，使得它能够适应不同类型的Web应用。\n\n在认证中间件里面我们可以这样使用：\n```java\npublic void authenticateRequest(NHttpContext httpContext) throws Exception {\n    // 如果skipAuthentication为true，则跳过认证\n    if (httpContext.skipAuthentication) \n        return;        \n\n    for (NHttpModule module : modules) {\n        module.authenticateRequest(httpContext);\n    }\n}\n```\n---\n\n# 结论\n\n`NHttpContext`类是Javelin框架中处理HTTP请求的关键组件之一。它帮助封装了请求-响应管理的核心元素，提供了一个有组织的方式来处理HTTP交换，包括认证、日志记录、异常处理和响应生成。\n\n通过理解并使用`NHttpContext`，开发者可以更好地管理和定制HTTP请求的处理行为，确保应用保持模块化、可维护且高效。当然目前这个类还有很多缺点，后续我会在过程中继续完善。中间很多的细节没有展开，大家可以自行查看源码。\n\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/Javelin)仓库。","source":"_posts/javelin-nhttpcontext.md","raw":"---\ntitle: 手写一个微型Spring框架（三）：NHttpContext的详解\ndate: 2025-04-30 09:58:18\ntags:\n---\n\n在Javelin框架中，`NHttpContext`类在HTTP请求处理流水线中扮演着至关重要的角色。它是一个封装了请求-响应生命周期各个方面的对象，管理着HTTP请求的各个环节。下面我们将深入探讨`NHttpContext`的功能、组成部分及其设计思路。\n\n---\n\n# `NHttpContext`概述\n\n`NHttpContext`是一个容器，保存了处理HTTP请求所需的所有必要元素。它不仅代表当前HTTP交换的状态，还管理流水线上下文、日志记录、错误处理等内容。其设计使其成为HTTP请求生命周期中的主要上下文对象，提供了一种有组织的方式来管理请求和响应。\n\n![NHttpContext](./images/javelin-3/uml.png)\n\n以下是`NHttpContext`中主要属性的介绍：\n\n1. **HttpExchange exchange**：  \n   这是实际的HTTP交换对象，代表了HTTP请求和响应。它是Java HTTP服务器提供的标准`HttpExchange`对象，但在Javelin中，它被封装在`NHttpContext`中，以便提供更简洁和定制化的处理流程。\n\n2. **HttpPipelineContext pipelineContext**：  \n   `pipelineContext`负责管理HTTP请求处理流水线的各个阶段。这个流水线包括路由、认证、日志记录等步骤。它确保HTTP请求在每个阶段都能被正确处理。\n\n3. **OprLogScope oprLogScope**：  \n   该对象用于在请求处理过程中管理日志记录的作用域。它允许Javelin在特定的作用域内创建和处理日志，确保与特定HTTP请求相关的日志能被准确捕捉。\n\n4. **Exception lastException**：  \n   如果在请求处理过程中发生任何异常，这个字段存储最后的异常。这个功能对调试非常有用，因为它允许开发者访问可能干扰HTTP请求处理的异常信息。\n\n5. **boolean skipAuthentication**：  \n   该布尔标志控制是否跳过当前请求的认证。对于某些请求，不需要认证时可以设置为`true`，这样请求就不需要经过认证步骤。\n\n```java\npublic class NHttpContext {\n    public HttpExchange exchange;\n    public HttpPipelineContext pipelineContext;\n    public OprLogScope oprLogScope;\n    public Exception lastException;\n    public boolean skipAuthentication;\n\n    public NHttpContext(HttpExchange exchange, RouteDefinition routeDefinition) {\n        this.exchange = exchange;\n        this.pipelineContext = HttpPipelineContext.start(this);\n        this.pipelineContext.routeDefinition = routeDefinition;\n    }\n\n    void setOprLogScope(OprLogScope oprLogScope) {\n        this.oprLogScope = oprLogScope;\n    }\n\n    public void httpReply(int statusCode, String message) {\n        try {\n            this.exchange.sendResponseHeaders(statusCode, 0);\n            this.exchange.getResponseBody().write(message.getBytes());\n            this.exchange.close(); \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n---\n\n# HttpPipelineContext 类\n\n`HttpPipelineContext` 类主要负责管理与请求处理流水线相关的信息。其功能包括：\n\n- **processId**：每个请求都应该有一个唯一的 ID，方便跟踪和调试。\n- **startTime** 和 **endTime**：记录请求的开始和结束时间，用于性能分析和日志记录。\n- **routeDefinition**：该字段关联当前请求处理的路由定义，确保请求按正确的路由规则进行处理。\n- **setException**：设置请求处理过程中发生的异常，便于在整个流程中传递和记录错误。\n\n```java\npublic class HttpPipelineContext {\n    public String processId;\n    public Date startTime;\n    public Date endTime;\n    public NHttpContext httpContext;\n    public RouteDefinition routeDefinition;\n    public Exception lastException;\n\n    public static HttpPipelineContext start(NHttpContext httpContext) {\n        HttpPipelineContext pipelineContext = new HttpPipelineContext(httpContext);\n\n        OprLogScope oprLogScope = OprLogScope.start(httpContext.pipelineContext);\n        pipelineContext.httpContext.setOprLogScope(oprLogScope);\n\n        return pipelineContext;\n    }\n\n    public void setRouteDefinition(RouteDefinition routeDefinition) {\n        this.routeDefinition = routeDefinition;\n    }\n\n    private HttpPipelineContext(NHttpContext httpContext) {\n        if (httpContext == null) {\n            throw new IllegalArgumentException(\"httpContext cannot be null\");\n        }\n        this.httpContext = httpContext;\n        httpContext.pipelineContext = this;\n    }\n\n    public void setException(Exception ex) {\n        if (ex != null) {\n            httpContext.lastException = ex;\n        }\n    }\n\n    public void completeRequest() {\n        throw new AbortRequestException();\n    }\n\n    public void dispose() {\n        this.httpContext = null;\n    }\n}\n```\n---\n\n# OprLogScope 类\n\n`OprLogScope` 类负责在请求的生命周期内进行操作日志的记录和异常的处理。它的设计包括：\n\n- **steps**：记录操作的每个步骤。\n- **oprlog**：操作日志对象，记录请求处理过程中的各项操作。\n- **start**：启动操作日志范围的方法，负责创建和初始化操作日志。\n\n```java\npublic class OprLogScope {\n    private List<StepItem> steps;\n    public OprLog oprlog;\n\n    public static OprLogScope start(HttpPipelineContext pipelineContext) {\n        OprLogScope scope = new OprLogScope();\n        scope.oprlog = OprLog.create(pipelineContext);\n        return scope;\n    }\n\n    public int setException(Exception ex) {\n        return oprlog.setException(ex); \n    }\n\n    public int saveOprLog(HttpPipelineContext pipelineContext) {\n        LogHelper.Write(this.oprlog);\n        return 1;\n    }\n}\n```\n---\n\n# `NHttpContext`的设计思路\n\n在设计`NHttpContext`时，重点考虑了模块化、扩展性、易用性以及与Javelin框架中的其他组件的集成。作为Javelin HTTP请求处理流水线的一部分，`NHttpContext`的设计思路围绕着以下几个核心原则展开：\n\n## **单一责任原则（Single Responsibility Principle）**\n\n`NHttpContext`的设计遵循单一责任原则，它主要负责管理和维护一个HTTP请求生命周期中的各种上下文信息。通过将HTTP交换的相关信息（如请求、响应、路由信息、日志记录等）集中到一个对象中，`NHttpContext`避免了将过多责任分散到多个地方，从而提升了代码的可读性和可维护性。\n\n**责任划分**:\n- `HttpExchange`：处理请求和响应。\n- `HttpPipelineContext`：管理HTTP请求处理的流水线上下文，确保请求按顺序经过不同阶段的处理。\n- `OprLogScope`：处理日志记录的作用域，确保所有操作的日志能够被正确追踪。\n- `Exception`：捕捉并存储在请求处理过程中出现的异常信息。\n\n---\n\n## **灵活的流水线处理（Flexible Pipeline Handling）**\n\n`NHttpContext`将HTTP请求处理流程分为多个阶段，每个阶段由`HttpPipelineContext`负责。这使得Javelin的请求处理流水线具有很高的灵活性和可定制性，开发者可以根据具体需求在不同阶段插入中间件、路由逻辑、认证步骤等。\n\n- **流水线的动态性**：`HttpPipelineContext`会根据具体的路由定义和配置动态调整请求的处理流程。每次请求的流水线都可以根据具体的业务需求进行配置，使得请求处理过程更加高效和灵活。\n\n---\n\n## **高度模块化（Modularization）**\n\n在`NHttpContext`的设计中，各个功能模块之间的耦合度较低。例如，`HttpExchange`与`HttpPipelineContext`之间并没有强依赖，而是通过`NHttpContext`进行解耦，使得每个模块都能够独立工作并实现其特定功能。\n\n- **分离关注点**：日志处理、异常处理、HTTP请求和响应的处理等不同的关注点被封装在不同的对象中，使得每个对象都专注于其核心功能。\n- **扩展性**：这种设计使得开发者可以根据需求向`NHttpContext`中添加新的处理模块，例如，新的认证方式、日志记录策略等，保持了较高的扩展性。\n\n---\n\n## **集成式错误处理（Integrated Error Handling）**\n\n`NHttpContext`内建了异常处理机制，通过`lastException`字段记录发生的异常，使得开发者能够快速定位和处理错误。错误信息被集中管理，有助于后续的调试和问题追踪。\n\n- **集中管理异常**：`NHttpContext`会捕获并存储处理过程中发生的异常，避免了异常分散在各个模块中。这样开发者可以通过`lastException`迅速获取异常详情，并进行统一的处理。\n\n```java\npublic class ActionExecutor {\n    public void execute(NHttpContext context) throws Exception {\n        try{\n            // ...\n            handlerRequest(context);\n        } catch ( AbortRequestException e) {\n            // 提前结束请求，啥也不干了\n        } catch (Exception e) {\n            Throwable cause = e.getCause();\n            // 记录原始异常\n            context.pipelineContext.setException((Exception)cause);\n            app.onError(context);\n        } finally {\n            app.endRequest(context);\n        }\n\n    }\n```\n---\n\n## **响应处理简化（Simplified Response Handling）**\n\n`NHttpContext`提供了一个简单的接口`httpReply`，用于发送响应。通过该接口，开发者无需过多关注底层的`HttpExchange`细节，而只需传递状态码和响应体。这样简化了响应处理流程，提高了开发效率。\n\n- **简洁的API**：`httpReply`方法为响应发送提供了统一的接口，使得请求的响应处理变得直观和高效。\n- **自动化的关闭连接**：在异常发生后，调用`httpReply`方法自动关闭`HttpExchange`连接，无需手动干预。\n\n---\n\n## **面向操作的日志记录（Operation-Oriented Logging）**\n\n`NHttpContext`设计了`OprLogScope`来管理每个HTTP请求的操作日志。这使得每个请求的日志记录都能与当前操作（例如，路由、认证等）相关联，方便进行精准的日志追踪。\n\n- **作用域管理**：`OprLogScope`允许每个请求在特定的操作上下文内生成日志。这种方式增强了日志的可读性，帮助开发者清晰地追踪每个请求在不同阶段的执行情况。\n- **日志隔离**：通过为每个请求提供独立的日志作用域，避免了不同请求之间日志的混淆，提高了日志的准确性和可操作性。\n\n```java\npublic static HttpPipelineContext start(NHttpContext httpContext) {\n    HttpPipelineContext pipelineContext = new HttpPipelineContext(httpContext);\n    // 为每个请求创建独立的日志作用域\n    OprLogScope oprLogScope = OprLogScope.start(httpContext.pipelineContext);\n    pipelineContext.httpContext.setOprLogScope(oprLogScope);\n\n    return pipelineContext;\n}\n```\n---\n\n## **可配置的认证机制（Configurable Authentication Mechanism）**\n\n`NHttpContext`通过`skipAuthentication`标志允许开发者灵活地控制是否需要认证。这使得在某些场景下（如公共API或不需要身份验证的请求）可以跳过认证过程，减少了不必要的性能开销。\n\n- **认证跳过机制**：开发者可以根据业务需求灵活地跳过认证步骤，而无需修改底层认证逻辑。\n- **灵活性**：认证机制的可配置性增加了框架的灵活性，使得它能够适应不同类型的Web应用。\n\n在认证中间件里面我们可以这样使用：\n```java\npublic void authenticateRequest(NHttpContext httpContext) throws Exception {\n    // 如果skipAuthentication为true，则跳过认证\n    if (httpContext.skipAuthentication) \n        return;        \n\n    for (NHttpModule module : modules) {\n        module.authenticateRequest(httpContext);\n    }\n}\n```\n---\n\n# 结论\n\n`NHttpContext`类是Javelin框架中处理HTTP请求的关键组件之一。它帮助封装了请求-响应管理的核心元素，提供了一个有组织的方式来处理HTTP交换，包括认证、日志记录、异常处理和响应生成。\n\n通过理解并使用`NHttpContext`，开发者可以更好地管理和定制HTTP请求的处理行为，确保应用保持模块化、可维护且高效。当然目前这个类还有很多缺点，后续我会在过程中继续完善。中间很多的细节没有展开，大家可以自行查看源码。\n\n\n由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考[GitHub](https://github.com/ItProHub/Javelin)仓库。","slug":"javelin-nhttpcontext","published":1,"updated":"2025-04-30T08:54:01.956Z","_id":"cma3am9iw0000a8p16mgkanra","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在Javelin框架中，<code>NHttpContext</code>类在HTTP请求处理流水线中扮演着至关重要的角色。它是一个封装了请求-响应生命周期各个方面的对象，管理着HTTP请求的各个环节。下面我们将深入探讨<code>NHttpContext</code>的功能、组成部分及其设计思路。</p>\n<hr>\n<h1 id=\"NHttpContext概述\"><a href=\"#NHttpContext概述\" class=\"headerlink\" title=\"NHttpContext概述\"></a><code>NHttpContext</code>概述</h1><p><code>NHttpContext</code>是一个容器，保存了处理HTTP请求所需的所有必要元素。它不仅代表当前HTTP交换的状态，还管理流水线上下文、日志记录、错误处理等内容。其设计使其成为HTTP请求生命周期中的主要上下文对象，提供了一种有组织的方式来管理请求和响应。</p>\n<p><img src=\"/blog/./images/javelin-3/uml.png\" alt=\"NHttpContext\"></p>\n<p>以下是<code>NHttpContext</code>中主要属性的介绍：</p>\n<ol>\n<li><p><strong>HttpExchange exchange</strong>：<br>这是实际的HTTP交换对象，代表了HTTP请求和响应。它是Java HTTP服务器提供的标准<code>HttpExchange</code>对象，但在Javelin中，它被封装在<code>NHttpContext</code>中，以便提供更简洁和定制化的处理流程。</p>\n</li>\n<li><p><strong>HttpPipelineContext pipelineContext</strong>：<br><code>pipelineContext</code>负责管理HTTP请求处理流水线的各个阶段。这个流水线包括路由、认证、日志记录等步骤。它确保HTTP请求在每个阶段都能被正确处理。</p>\n</li>\n<li><p><strong>OprLogScope oprLogScope</strong>：<br>该对象用于在请求处理过程中管理日志记录的作用域。它允许Javelin在特定的作用域内创建和处理日志，确保与特定HTTP请求相关的日志能被准确捕捉。</p>\n</li>\n<li><p><strong>Exception lastException</strong>：<br>如果在请求处理过程中发生任何异常，这个字段存储最后的异常。这个功能对调试非常有用，因为它允许开发者访问可能干扰HTTP请求处理的异常信息。</p>\n</li>\n<li><p><strong>boolean skipAuthentication</strong>：<br>该布尔标志控制是否跳过当前请求的认证。对于某些请求，不需要认证时可以设置为<code>true</code>，这样请求就不需要经过认证步骤。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NHttpContext</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HttpExchange exchange;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HttpPipelineContext pipelineContext;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> OprLogScope oprLogScope;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Exception lastException;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> skipAuthentication;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">NHttpContext</span><span class=\"params\">(HttpExchange exchange, RouteDefinition routeDefinition)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.exchange = exchange;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.pipelineContext = HttpPipelineContext.start(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.pipelineContext.routeDefinition = routeDefinition;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setOprLogScope</span><span class=\"params\">(OprLogScope oprLogScope)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.oprLogScope = oprLogScope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">httpReply</span><span class=\"params\">(<span class=\"type\">int</span> statusCode, String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.exchange.sendResponseHeaders(statusCode, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.exchange.getResponseBody().write(message.getBytes());</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.exchange.close(); </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"HttpPipelineContext-类\"><a href=\"#HttpPipelineContext-类\" class=\"headerlink\" title=\"HttpPipelineContext 类\"></a>HttpPipelineContext 类</h1><p><code>HttpPipelineContext</code> 类主要负责管理与请求处理流水线相关的信息。其功能包括：</p>\n<ul>\n<li><strong>processId</strong>：每个请求都应该有一个唯一的 ID，方便跟踪和调试。</li>\n<li><strong>startTime</strong> 和 <strong>endTime</strong>：记录请求的开始和结束时间，用于性能分析和日志记录。</li>\n<li><strong>routeDefinition</strong>：该字段关联当前请求处理的路由定义，确保请求按正确的路由规则进行处理。</li>\n<li><strong>setException</strong>：设置请求处理过程中发生的异常，便于在整个流程中传递和记录错误。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HttpPipelineContext</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String processId;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date startTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date endTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> NHttpContext httpContext;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> RouteDefinition routeDefinition;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Exception lastException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HttpPipelineContext <span class=\"title function_\">start</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HttpPipelineContext</span> <span class=\"variable\">pipelineContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPipelineContext</span>(httpContext);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">OprLogScope</span> <span class=\"variable\">oprLogScope</span> <span class=\"operator\">=</span> OprLogScope.start(httpContext.pipelineContext);</span><br><span class=\"line\">        pipelineContext.httpContext.setOprLogScope(oprLogScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipelineContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setRouteDefinition</span><span class=\"params\">(RouteDefinition routeDefinition)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.routeDefinition = routeDefinition;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">HttpPipelineContext</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (httpContext == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;httpContext cannot be null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.httpContext = httpContext;</span><br><span class=\"line\">        httpContext.pipelineContext = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setException</span><span class=\"params\">(Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ex != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            httpContext.lastException = ex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completeRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AbortRequestException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dispose</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.httpContext = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"OprLogScope-类\"><a href=\"#OprLogScope-类\" class=\"headerlink\" title=\"OprLogScope 类\"></a>OprLogScope 类</h1><p><code>OprLogScope</code> 类负责在请求的生命周期内进行操作日志的记录和异常的处理。它的设计包括：</p>\n<ul>\n<li><strong>steps</strong>：记录操作的每个步骤。</li>\n<li><strong>oprlog</strong>：操作日志对象，记录请求处理过程中的各项操作。</li>\n<li><strong>start</strong>：启动操作日志范围的方法，负责创建和初始化操作日志。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OprLogScope</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;StepItem&gt; steps;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> OprLog oprlog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> OprLogScope <span class=\"title function_\">start</span><span class=\"params\">(HttpPipelineContext pipelineContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">OprLogScope</span> <span class=\"variable\">scope</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OprLogScope</span>();</span><br><span class=\"line\">        scope.oprlog = OprLog.create(pipelineContext);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">setException</span><span class=\"params\">(Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oprlog.setException(ex); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">saveOprLog</span><span class=\"params\">(HttpPipelineContext pipelineContext)</span> &#123;</span><br><span class=\"line\">        LogHelper.Write(<span class=\"built_in\">this</span>.oprlog);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"NHttpContext的设计思路\"><a href=\"#NHttpContext的设计思路\" class=\"headerlink\" title=\"NHttpContext的设计思路\"></a><code>NHttpContext</code>的设计思路</h1><p>在设计<code>NHttpContext</code>时，重点考虑了模块化、扩展性、易用性以及与Javelin框架中的其他组件的集成。作为Javelin HTTP请求处理流水线的一部分，<code>NHttpContext</code>的设计思路围绕着以下几个核心原则展开：</p>\n<h2 id=\"单一责任原则（Single-Responsibility-Principle）\"><a href=\"#单一责任原则（Single-Responsibility-Principle）\" class=\"headerlink\" title=\"单一责任原则（Single Responsibility Principle）\"></a><strong>单一责任原则（Single Responsibility Principle）</strong></h2><p><code>NHttpContext</code>的设计遵循单一责任原则，它主要负责管理和维护一个HTTP请求生命周期中的各种上下文信息。通过将HTTP交换的相关信息（如请求、响应、路由信息、日志记录等）集中到一个对象中，<code>NHttpContext</code>避免了将过多责任分散到多个地方，从而提升了代码的可读性和可维护性。</p>\n<p><strong>责任划分</strong>:</p>\n<ul>\n<li><code>HttpExchange</code>：处理请求和响应。</li>\n<li><code>HttpPipelineContext</code>：管理HTTP请求处理的流水线上下文，确保请求按顺序经过不同阶段的处理。</li>\n<li><code>OprLogScope</code>：处理日志记录的作用域，确保所有操作的日志能够被正确追踪。</li>\n<li><code>Exception</code>：捕捉并存储在请求处理过程中出现的异常信息。</li>\n</ul>\n<hr>\n<h2 id=\"灵活的流水线处理（Flexible-Pipeline-Handling）\"><a href=\"#灵活的流水线处理（Flexible-Pipeline-Handling）\" class=\"headerlink\" title=\"灵活的流水线处理（Flexible Pipeline Handling）\"></a><strong>灵活的流水线处理（Flexible Pipeline Handling）</strong></h2><p><code>NHttpContext</code>将HTTP请求处理流程分为多个阶段，每个阶段由<code>HttpPipelineContext</code>负责。这使得Javelin的请求处理流水线具有很高的灵活性和可定制性，开发者可以根据具体需求在不同阶段插入中间件、路由逻辑、认证步骤等。</p>\n<ul>\n<li><strong>流水线的动态性</strong>：<code>HttpPipelineContext</code>会根据具体的路由定义和配置动态调整请求的处理流程。每次请求的流水线都可以根据具体的业务需求进行配置，使得请求处理过程更加高效和灵活。</li>\n</ul>\n<hr>\n<h2 id=\"高度模块化（Modularization）\"><a href=\"#高度模块化（Modularization）\" class=\"headerlink\" title=\"高度模块化（Modularization）\"></a><strong>高度模块化（Modularization）</strong></h2><p>在<code>NHttpContext</code>的设计中，各个功能模块之间的耦合度较低。例如，<code>HttpExchange</code>与<code>HttpPipelineContext</code>之间并没有强依赖，而是通过<code>NHttpContext</code>进行解耦，使得每个模块都能够独立工作并实现其特定功能。</p>\n<ul>\n<li><strong>分离关注点</strong>：日志处理、异常处理、HTTP请求和响应的处理等不同的关注点被封装在不同的对象中，使得每个对象都专注于其核心功能。</li>\n<li><strong>扩展性</strong>：这种设计使得开发者可以根据需求向<code>NHttpContext</code>中添加新的处理模块，例如，新的认证方式、日志记录策略等，保持了较高的扩展性。</li>\n</ul>\n<hr>\n<h2 id=\"集成式错误处理（Integrated-Error-Handling）\"><a href=\"#集成式错误处理（Integrated-Error-Handling）\" class=\"headerlink\" title=\"集成式错误处理（Integrated Error Handling）\"></a><strong>集成式错误处理（Integrated Error Handling）</strong></h2><p><code>NHttpContext</code>内建了异常处理机制，通过<code>lastException</code>字段记录发生的异常，使得开发者能够快速定位和处理错误。错误信息被集中管理，有助于后续的调试和问题追踪。</p>\n<ul>\n<li><strong>集中管理异常</strong>：<code>NHttpContext</code>会捕获并存储处理过程中发生的异常，避免了异常分散在各个模块中。这样开发者可以通过<code>lastException</code>迅速获取异常详情，并进行统一的处理。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ActionExecutor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(NHttpContext context)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            handlerRequest(context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> ( AbortRequestException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 提前结束请求，啥也不干了</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> e.getCause();</span><br><span class=\"line\">            <span class=\"comment\">// 记录原始异常</span></span><br><span class=\"line\">            context.pipelineContext.setException((Exception)cause);</span><br><span class=\"line\">            app.onError(context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            app.endRequest(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"响应处理简化（Simplified-Response-Handling）\"><a href=\"#响应处理简化（Simplified-Response-Handling）\" class=\"headerlink\" title=\"响应处理简化（Simplified Response Handling）\"></a><strong>响应处理简化（Simplified Response Handling）</strong></h2><p><code>NHttpContext</code>提供了一个简单的接口<code>httpReply</code>，用于发送响应。通过该接口，开发者无需过多关注底层的<code>HttpExchange</code>细节，而只需传递状态码和响应体。这样简化了响应处理流程，提高了开发效率。</p>\n<ul>\n<li><strong>简洁的API</strong>：<code>httpReply</code>方法为响应发送提供了统一的接口，使得请求的响应处理变得直观和高效。</li>\n<li><strong>自动化的关闭连接</strong>：在异常发生后，调用<code>httpReply</code>方法自动关闭<code>HttpExchange</code>连接，无需手动干预。</li>\n</ul>\n<hr>\n<h2 id=\"面向操作的日志记录（Operation-Oriented-Logging）\"><a href=\"#面向操作的日志记录（Operation-Oriented-Logging）\" class=\"headerlink\" title=\"面向操作的日志记录（Operation-Oriented Logging）\"></a><strong>面向操作的日志记录（Operation-Oriented Logging）</strong></h2><p><code>NHttpContext</code>设计了<code>OprLogScope</code>来管理每个HTTP请求的操作日志。这使得每个请求的日志记录都能与当前操作（例如，路由、认证等）相关联，方便进行精准的日志追踪。</p>\n<ul>\n<li><strong>作用域管理</strong>：<code>OprLogScope</code>允许每个请求在特定的操作上下文内生成日志。这种方式增强了日志的可读性，帮助开发者清晰地追踪每个请求在不同阶段的执行情况。</li>\n<li><strong>日志隔离</strong>：通过为每个请求提供独立的日志作用域，避免了不同请求之间日志的混淆，提高了日志的准确性和可操作性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HttpPipelineContext <span class=\"title function_\">start</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">HttpPipelineContext</span> <span class=\"variable\">pipelineContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPipelineContext</span>(httpContext);</span><br><span class=\"line\">    <span class=\"comment\">// 为每个请求创建独立的日志作用域</span></span><br><span class=\"line\">    <span class=\"type\">OprLogScope</span> <span class=\"variable\">oprLogScope</span> <span class=\"operator\">=</span> OprLogScope.start(httpContext.pipelineContext);</span><br><span class=\"line\">    pipelineContext.httpContext.setOprLogScope(oprLogScope);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pipelineContext;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"可配置的认证机制（Configurable-Authentication-Mechanism）\"><a href=\"#可配置的认证机制（Configurable-Authentication-Mechanism）\" class=\"headerlink\" title=\"可配置的认证机制（Configurable Authentication Mechanism）\"></a><strong>可配置的认证机制（Configurable Authentication Mechanism）</strong></h2><p><code>NHttpContext</code>通过<code>skipAuthentication</code>标志允许开发者灵活地控制是否需要认证。这使得在某些场景下（如公共API或不需要身份验证的请求）可以跳过认证过程，减少了不必要的性能开销。</p>\n<ul>\n<li><strong>认证跳过机制</strong>：开发者可以根据业务需求灵活地跳过认证步骤，而无需修改底层认证逻辑。</li>\n<li><strong>灵活性</strong>：认证机制的可配置性增加了框架的灵活性，使得它能够适应不同类型的Web应用。</li>\n</ul>\n<h2 id=\"在认证中间件里面我们可以这样使用：\"><a href=\"#在认证中间件里面我们可以这样使用：\" class=\"headerlink\" title=\"在认证中间件里面我们可以这样使用：\"></a>在认证中间件里面我们可以这样使用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticateRequest</span><span class=\"params\">(NHttpContext httpContext)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果skipAuthentication为true，则跳过认证</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpContext.skipAuthentication) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;        </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (NHttpModule <span class=\"keyword\">module</span> : modules) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">module</span>.authenticateRequest(httpContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p><code>NHttpContext</code>类是Javelin框架中处理HTTP请求的关键组件之一。它帮助封装了请求-响应管理的核心元素，提供了一个有组织的方式来处理HTTP交换，包括认证、日志记录、异常处理和响应生成。</p>\n<p>通过理解并使用<code>NHttpContext</code>，开发者可以更好地管理和定制HTTP请求的处理行为，确保应用保持模块化、可维护且高效。当然目前这个类还有很多缺点，后续我会在过程中继续完善。中间很多的细节没有展开，大家可以自行查看源码。</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/Javelin\">GitHub</a>仓库。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Javelin框架中，<code>NHttpContext</code>类在HTTP请求处理流水线中扮演着至关重要的角色。它是一个封装了请求-响应生命周期各个方面的对象，管理着HTTP请求的各个环节。下面我们将深入探讨<code>NHttpContext</code>的功能、组成部分及其设计思路。</p>\n<hr>\n<h1 id=\"NHttpContext概述\"><a href=\"#NHttpContext概述\" class=\"headerlink\" title=\"NHttpContext概述\"></a><code>NHttpContext</code>概述</h1><p><code>NHttpContext</code>是一个容器，保存了处理HTTP请求所需的所有必要元素。它不仅代表当前HTTP交换的状态，还管理流水线上下文、日志记录、错误处理等内容。其设计使其成为HTTP请求生命周期中的主要上下文对象，提供了一种有组织的方式来管理请求和响应。</p>\n<p><img src=\"/blog/./images/javelin-3/uml.png\" alt=\"NHttpContext\"></p>\n<p>以下是<code>NHttpContext</code>中主要属性的介绍：</p>\n<ol>\n<li><p><strong>HttpExchange exchange</strong>：<br>这是实际的HTTP交换对象，代表了HTTP请求和响应。它是Java HTTP服务器提供的标准<code>HttpExchange</code>对象，但在Javelin中，它被封装在<code>NHttpContext</code>中，以便提供更简洁和定制化的处理流程。</p>\n</li>\n<li><p><strong>HttpPipelineContext pipelineContext</strong>：<br><code>pipelineContext</code>负责管理HTTP请求处理流水线的各个阶段。这个流水线包括路由、认证、日志记录等步骤。它确保HTTP请求在每个阶段都能被正确处理。</p>\n</li>\n<li><p><strong>OprLogScope oprLogScope</strong>：<br>该对象用于在请求处理过程中管理日志记录的作用域。它允许Javelin在特定的作用域内创建和处理日志，确保与特定HTTP请求相关的日志能被准确捕捉。</p>\n</li>\n<li><p><strong>Exception lastException</strong>：<br>如果在请求处理过程中发生任何异常，这个字段存储最后的异常。这个功能对调试非常有用，因为它允许开发者访问可能干扰HTTP请求处理的异常信息。</p>\n</li>\n<li><p><strong>boolean skipAuthentication</strong>：<br>该布尔标志控制是否跳过当前请求的认证。对于某些请求，不需要认证时可以设置为<code>true</code>，这样请求就不需要经过认证步骤。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NHttpContext</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HttpExchange exchange;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HttpPipelineContext pipelineContext;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> OprLogScope oprLogScope;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Exception lastException;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> skipAuthentication;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">NHttpContext</span><span class=\"params\">(HttpExchange exchange, RouteDefinition routeDefinition)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.exchange = exchange;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.pipelineContext = HttpPipelineContext.start(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.pipelineContext.routeDefinition = routeDefinition;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setOprLogScope</span><span class=\"params\">(OprLogScope oprLogScope)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.oprLogScope = oprLogScope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">httpReply</span><span class=\"params\">(<span class=\"type\">int</span> statusCode, String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.exchange.sendResponseHeaders(statusCode, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.exchange.getResponseBody().write(message.getBytes());</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.exchange.close(); </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"HttpPipelineContext-类\"><a href=\"#HttpPipelineContext-类\" class=\"headerlink\" title=\"HttpPipelineContext 类\"></a>HttpPipelineContext 类</h1><p><code>HttpPipelineContext</code> 类主要负责管理与请求处理流水线相关的信息。其功能包括：</p>\n<ul>\n<li><strong>processId</strong>：每个请求都应该有一个唯一的 ID，方便跟踪和调试。</li>\n<li><strong>startTime</strong> 和 <strong>endTime</strong>：记录请求的开始和结束时间，用于性能分析和日志记录。</li>\n<li><strong>routeDefinition</strong>：该字段关联当前请求处理的路由定义，确保请求按正确的路由规则进行处理。</li>\n<li><strong>setException</strong>：设置请求处理过程中发生的异常，便于在整个流程中传递和记录错误。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HttpPipelineContext</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String processId;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date startTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date endTime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> NHttpContext httpContext;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> RouteDefinition routeDefinition;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Exception lastException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HttpPipelineContext <span class=\"title function_\">start</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HttpPipelineContext</span> <span class=\"variable\">pipelineContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPipelineContext</span>(httpContext);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">OprLogScope</span> <span class=\"variable\">oprLogScope</span> <span class=\"operator\">=</span> OprLogScope.start(httpContext.pipelineContext);</span><br><span class=\"line\">        pipelineContext.httpContext.setOprLogScope(oprLogScope);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipelineContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setRouteDefinition</span><span class=\"params\">(RouteDefinition routeDefinition)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.routeDefinition = routeDefinition;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">HttpPipelineContext</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (httpContext == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;httpContext cannot be null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.httpContext = httpContext;</span><br><span class=\"line\">        httpContext.pipelineContext = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setException</span><span class=\"params\">(Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ex != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            httpContext.lastException = ex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completeRequest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AbortRequestException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dispose</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.httpContext = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"OprLogScope-类\"><a href=\"#OprLogScope-类\" class=\"headerlink\" title=\"OprLogScope 类\"></a>OprLogScope 类</h1><p><code>OprLogScope</code> 类负责在请求的生命周期内进行操作日志的记录和异常的处理。它的设计包括：</p>\n<ul>\n<li><strong>steps</strong>：记录操作的每个步骤。</li>\n<li><strong>oprlog</strong>：操作日志对象，记录请求处理过程中的各项操作。</li>\n<li><strong>start</strong>：启动操作日志范围的方法，负责创建和初始化操作日志。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OprLogScope</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;StepItem&gt; steps;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> OprLog oprlog;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> OprLogScope <span class=\"title function_\">start</span><span class=\"params\">(HttpPipelineContext pipelineContext)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">OprLogScope</span> <span class=\"variable\">scope</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OprLogScope</span>();</span><br><span class=\"line\">        scope.oprlog = OprLog.create(pipelineContext);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> scope;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">setException</span><span class=\"params\">(Exception ex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oprlog.setException(ex); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">saveOprLog</span><span class=\"params\">(HttpPipelineContext pipelineContext)</span> &#123;</span><br><span class=\"line\">        LogHelper.Write(<span class=\"built_in\">this</span>.oprlog);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"NHttpContext的设计思路\"><a href=\"#NHttpContext的设计思路\" class=\"headerlink\" title=\"NHttpContext的设计思路\"></a><code>NHttpContext</code>的设计思路</h1><p>在设计<code>NHttpContext</code>时，重点考虑了模块化、扩展性、易用性以及与Javelin框架中的其他组件的集成。作为Javelin HTTP请求处理流水线的一部分，<code>NHttpContext</code>的设计思路围绕着以下几个核心原则展开：</p>\n<h2 id=\"单一责任原则（Single-Responsibility-Principle）\"><a href=\"#单一责任原则（Single-Responsibility-Principle）\" class=\"headerlink\" title=\"单一责任原则（Single Responsibility Principle）\"></a><strong>单一责任原则（Single Responsibility Principle）</strong></h2><p><code>NHttpContext</code>的设计遵循单一责任原则，它主要负责管理和维护一个HTTP请求生命周期中的各种上下文信息。通过将HTTP交换的相关信息（如请求、响应、路由信息、日志记录等）集中到一个对象中，<code>NHttpContext</code>避免了将过多责任分散到多个地方，从而提升了代码的可读性和可维护性。</p>\n<p><strong>责任划分</strong>:</p>\n<ul>\n<li><code>HttpExchange</code>：处理请求和响应。</li>\n<li><code>HttpPipelineContext</code>：管理HTTP请求处理的流水线上下文，确保请求按顺序经过不同阶段的处理。</li>\n<li><code>OprLogScope</code>：处理日志记录的作用域，确保所有操作的日志能够被正确追踪。</li>\n<li><code>Exception</code>：捕捉并存储在请求处理过程中出现的异常信息。</li>\n</ul>\n<hr>\n<h2 id=\"灵活的流水线处理（Flexible-Pipeline-Handling）\"><a href=\"#灵活的流水线处理（Flexible-Pipeline-Handling）\" class=\"headerlink\" title=\"灵活的流水线处理（Flexible Pipeline Handling）\"></a><strong>灵活的流水线处理（Flexible Pipeline Handling）</strong></h2><p><code>NHttpContext</code>将HTTP请求处理流程分为多个阶段，每个阶段由<code>HttpPipelineContext</code>负责。这使得Javelin的请求处理流水线具有很高的灵活性和可定制性，开发者可以根据具体需求在不同阶段插入中间件、路由逻辑、认证步骤等。</p>\n<ul>\n<li><strong>流水线的动态性</strong>：<code>HttpPipelineContext</code>会根据具体的路由定义和配置动态调整请求的处理流程。每次请求的流水线都可以根据具体的业务需求进行配置，使得请求处理过程更加高效和灵活。</li>\n</ul>\n<hr>\n<h2 id=\"高度模块化（Modularization）\"><a href=\"#高度模块化（Modularization）\" class=\"headerlink\" title=\"高度模块化（Modularization）\"></a><strong>高度模块化（Modularization）</strong></h2><p>在<code>NHttpContext</code>的设计中，各个功能模块之间的耦合度较低。例如，<code>HttpExchange</code>与<code>HttpPipelineContext</code>之间并没有强依赖，而是通过<code>NHttpContext</code>进行解耦，使得每个模块都能够独立工作并实现其特定功能。</p>\n<ul>\n<li><strong>分离关注点</strong>：日志处理、异常处理、HTTP请求和响应的处理等不同的关注点被封装在不同的对象中，使得每个对象都专注于其核心功能。</li>\n<li><strong>扩展性</strong>：这种设计使得开发者可以根据需求向<code>NHttpContext</code>中添加新的处理模块，例如，新的认证方式、日志记录策略等，保持了较高的扩展性。</li>\n</ul>\n<hr>\n<h2 id=\"集成式错误处理（Integrated-Error-Handling）\"><a href=\"#集成式错误处理（Integrated-Error-Handling）\" class=\"headerlink\" title=\"集成式错误处理（Integrated Error Handling）\"></a><strong>集成式错误处理（Integrated Error Handling）</strong></h2><p><code>NHttpContext</code>内建了异常处理机制，通过<code>lastException</code>字段记录发生的异常，使得开发者能够快速定位和处理错误。错误信息被集中管理，有助于后续的调试和问题追踪。</p>\n<ul>\n<li><strong>集中管理异常</strong>：<code>NHttpContext</code>会捕获并存储处理过程中发生的异常，避免了异常分散在各个模块中。这样开发者可以通过<code>lastException</code>迅速获取异常详情，并进行统一的处理。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ActionExecutor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(NHttpContext context)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">            handlerRequest(context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> ( AbortRequestException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 提前结束请求，啥也不干了</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> e.getCause();</span><br><span class=\"line\">            <span class=\"comment\">// 记录原始异常</span></span><br><span class=\"line\">            context.pipelineContext.setException((Exception)cause);</span><br><span class=\"line\">            app.onError(context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            app.endRequest(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"响应处理简化（Simplified-Response-Handling）\"><a href=\"#响应处理简化（Simplified-Response-Handling）\" class=\"headerlink\" title=\"响应处理简化（Simplified Response Handling）\"></a><strong>响应处理简化（Simplified Response Handling）</strong></h2><p><code>NHttpContext</code>提供了一个简单的接口<code>httpReply</code>，用于发送响应。通过该接口，开发者无需过多关注底层的<code>HttpExchange</code>细节，而只需传递状态码和响应体。这样简化了响应处理流程，提高了开发效率。</p>\n<ul>\n<li><strong>简洁的API</strong>：<code>httpReply</code>方法为响应发送提供了统一的接口，使得请求的响应处理变得直观和高效。</li>\n<li><strong>自动化的关闭连接</strong>：在异常发生后，调用<code>httpReply</code>方法自动关闭<code>HttpExchange</code>连接，无需手动干预。</li>\n</ul>\n<hr>\n<h2 id=\"面向操作的日志记录（Operation-Oriented-Logging）\"><a href=\"#面向操作的日志记录（Operation-Oriented-Logging）\" class=\"headerlink\" title=\"面向操作的日志记录（Operation-Oriented Logging）\"></a><strong>面向操作的日志记录（Operation-Oriented Logging）</strong></h2><p><code>NHttpContext</code>设计了<code>OprLogScope</code>来管理每个HTTP请求的操作日志。这使得每个请求的日志记录都能与当前操作（例如，路由、认证等）相关联，方便进行精准的日志追踪。</p>\n<ul>\n<li><strong>作用域管理</strong>：<code>OprLogScope</code>允许每个请求在特定的操作上下文内生成日志。这种方式增强了日志的可读性，帮助开发者清晰地追踪每个请求在不同阶段的执行情况。</li>\n<li><strong>日志隔离</strong>：通过为每个请求提供独立的日志作用域，避免了不同请求之间日志的混淆，提高了日志的准确性和可操作性。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HttpPipelineContext <span class=\"title function_\">start</span><span class=\"params\">(NHttpContext httpContext)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">HttpPipelineContext</span> <span class=\"variable\">pipelineContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPipelineContext</span>(httpContext);</span><br><span class=\"line\">    <span class=\"comment\">// 为每个请求创建独立的日志作用域</span></span><br><span class=\"line\">    <span class=\"type\">OprLogScope</span> <span class=\"variable\">oprLogScope</span> <span class=\"operator\">=</span> OprLogScope.start(httpContext.pipelineContext);</span><br><span class=\"line\">    pipelineContext.httpContext.setOprLogScope(oprLogScope);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pipelineContext;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"可配置的认证机制（Configurable-Authentication-Mechanism）\"><a href=\"#可配置的认证机制（Configurable-Authentication-Mechanism）\" class=\"headerlink\" title=\"可配置的认证机制（Configurable Authentication Mechanism）\"></a><strong>可配置的认证机制（Configurable Authentication Mechanism）</strong></h2><p><code>NHttpContext</code>通过<code>skipAuthentication</code>标志允许开发者灵活地控制是否需要认证。这使得在某些场景下（如公共API或不需要身份验证的请求）可以跳过认证过程，减少了不必要的性能开销。</p>\n<ul>\n<li><strong>认证跳过机制</strong>：开发者可以根据业务需求灵活地跳过认证步骤，而无需修改底层认证逻辑。</li>\n<li><strong>灵活性</strong>：认证机制的可配置性增加了框架的灵活性，使得它能够适应不同类型的Web应用。</li>\n</ul>\n<h2 id=\"在认证中间件里面我们可以这样使用：\"><a href=\"#在认证中间件里面我们可以这样使用：\" class=\"headerlink\" title=\"在认证中间件里面我们可以这样使用：\"></a>在认证中间件里面我们可以这样使用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">authenticateRequest</span><span class=\"params\">(NHttpContext httpContext)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果skipAuthentication为true，则跳过认证</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpContext.skipAuthentication) </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;        </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (NHttpModule <span class=\"keyword\">module</span> : modules) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">module</span>.authenticateRequest(httpContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p><code>NHttpContext</code>类是Javelin框架中处理HTTP请求的关键组件之一。它帮助封装了请求-响应管理的核心元素，提供了一个有组织的方式来处理HTTP交换，包括认证、日志记录、异常处理和响应生成。</p>\n<p>通过理解并使用<code>NHttpContext</code>，开发者可以更好地管理和定制HTTP请求的处理行为，确保应用保持模块化、可维护且高效。当然目前这个类还有很多缺点，后续我会在过程中继续完善。中间很多的细节没有展开，大家可以自行查看源码。</p>\n<p>由于篇幅原因，示例中的代码仅展示了部分关键实现细节，完整代码请参考<a href=\"https://github.com/ItProHub/Javelin\">GitHub</a>仓库。</p>\n"},{"title":"构建自己的微型 Spring 框架（三）：接入内嵌 Tomcat 与 Servlet","date":"2025-05-06T07:07:53.000Z","_content":"\n在前两篇中，我们已经实现了一个具备依赖注入、路由注册、参数绑定、中间件、JSON 返回、异常处理的微型 Web 框架 —— Javelin，它基于 JDK 自带的 `HttpServer` 实现了最小运行闭环。\n\n曾几何时，我一度以为HttpServer就是我的最终目标，直到我被告知它存在一定的局限性，不适合生产使用。显然我们的目标不仅仅是一个简单的最小闭环，而是一个完整的、可扩展的、强壮的 Web 框架。本篇将带你将 Javelin **接入内嵌 Tomcat，并运行在标准 Servlet 容器之上**，向真正的工程化迈进一步。\n\n---\n\n# 为什么 HttpServer 不适合生产环境？\n| 项目          | 说明                                                                   |\n| ----------- | -------------------------------------------------------------------- |\n| ❌ 性能较低      | 它使用阻塞 IO（虽然支持线程池），但并不擅长高并发处理。                                        |\n| ❌ 功能简陋      | 不支持 HTTPS 配置灵活性、不支持 HTTP/2、缺少对请求体/响应流的高级控制。                          |\n| ❌ 安全性弱      | 缺少成熟的安全机制（如防 XSS/CORS/session 注入等），也没有专门的安全更新机制。                     |\n| ❌ 缺乏标准支持    | 不支持 Servlet、Filter、Multipart 等常用 Web 标准，无法使用 Spring MVC、Shiro 等主流组件。 |\n| ❌ 没有压缩/缓存机制 | 不支持 GZIP 压缩、缓存控制等特性，效率低下。                                            |\n| ❌ 维护成本高     | 基础功能要自己手写，中间件、安全、监控都要自己造轮子。                                          |\n\n# 什么是 Servlet 容器/Web 容器？\nWeb 容器（也称为 Servlet 容器）是驻留在 Web 服务器内部与 Java Servlet 交互的组件。Web 容器负责管理 Servlet 的生命周期、将 URL 映射到特定的 Servlet、从 Servlet 获取响应以及将响应发送给请求者。\n\nWeb 容器创建 servlet 实例、加载和卸载 servlet、创建和管理请求和响应对象，以及执行其他 servlet 管理任务。\n\nServlet 容器由三个组件组成：过滤器 (Filter)、Servlet 和监听器 (Listener)。当请求到达 Tomcat（即 Servlet 容器）时，它会被发送到 Servlet 过滤器 (Filter)。Servlet 处理请求并生成响应。\n![Servlet 容器与 Web 服务器的关系](./images/javelin-servlet/servlet-container.png)\n\n从上图可以看出，Servlet 容器位于 Web 服务器内部。静态内容由 Web 服务器提供，而任何动态请求则由 Servlet 容器组件处理，该组件负责启动 Servlet 并管理其生命周期。\n\n# 为什么使用内嵌 Tomcat\n\nJDK 的 `HttpServer` 非常轻量，但它的问题是：\n\n* 不支持 Servlet 规范，无法与主流框架生态兼容\n* 缺少压缩、过滤器、Session 等高级特性\n* 不适合高并发或复杂业务场景\n\n而 Tomcat 作为最主流的 Servlet 容器，性能成熟、生态完善。通过嵌入式启动方式，我们既可以保留 Javelin 的轻量特性，又可以获得生产级的服务能力。\n\n---\n\n# Servlet 架构说明与类图\n![Servlet 架构说明](./images/javelin-servlet/servlet.png)\n\n\n为了实现标准 Servlet 支持，Javelin 框架在原有基础上新增了如下组件：\n\n- JavelinEmbeddedTomcatServer：内嵌 Tomcat 启动器，负责创建 Servlet 容器、注册 DispatcherServlet。\n\n- JavelinDispatcherServlet：自定义 HttpServlet，用作框架的统一入口，初始化 Router 并转发请求。\n\n- Router：负责路由匹配与控制器分发，调用中间件与控制器方法。\n\n- ActionExecutor：处理参数绑定、生命周期方法、中间件链执行。\n\n- NHttpContext：请求上下文，在不同协议（如 HttpServer、Servlet）中作为桥梁。\n\n![Servlet 架构说明与类图](./images/javelin-servlet/architecture.png)\n\n---\n\n# 启动内嵌 Tomcat\n\n在 `javelin-core` 中添加如下 Gradle 依赖：\n\n```groovy\ndependencies {\n    implementation 'org.apache.tomcat.embed:tomcat-embed-core:10.1.20'\n    implementation 'jakarta.servlet:jakarta.servlet-api:6.0.0'\n}\n```\n\n> 注意：Tomcat 10 之后已经迁移到 `jakarta.servlet` 命名空间。\n\n我们在 `javelin-core.http.tomcat` 包下新增了一个启动器类：\n\n```java\npublic class JavelinEmbeddedTomcatServer {\n    public JavelinEmbeddedTomcatServer(int port, String basePackage) { ... }\n\n    public void start() throws Exception {\n        tomcat.setPort(port);\n        tomcat.setBaseDir(...);\n        Context context = tomcat.addContext(\"\", new File(\".\").getAbsolutePath());\n\n        // 注册 DispatcherServlet\n        JavelinDispatcherServlet servlet = new JavelinDispatcherServlet(basePackage);\n        Tomcat.addServlet(context, \"Javelin\", servlet);\n        context.addServletMappingDecoded(\"/*\", \"Javelin\");\n\n        tomcat.getConnector(); // 强制初始化协议监听器\n        tomcat.start();\n        tomcat.getServer().await();\n    }\n}\n```\n\n通过该类，我们可以像 Spring Boot 一样，直接启动一个内嵌的 Web 服务。\n\n---\n\n# 自定义 HttpServlet\n\n## Servlet 生命周期\nServlet 的生命周期包括以下几个阶段：\n![Servlet 生命周期](./images/javelin-servlet/servlet-lifecycle.png)\n\n1. 加载和实例化：当容器接收到 Servlet 的请求时，ClassLoader 会加载该 Servlet 类。\n    - 加载：加载 Servlet 类。\n    - 实例化：创建 Servlet 的一个实例。为了创建 Servlet 的新实例，容器使用无参数构造函数。\n2. 初始化 Servlet：Servlet 成功实例化后，Servlet 容器将初始化 Servlet 对象。容器将调用 Servlet 的 init() 方法。\n\n3. 处理请求：初始化后，Servlet 实例将处理客户端请求。容器将为 Servlet 创建HttpServletResponse和HttpServletRequest对象，以处理 HTTP 请求。然后，容器将调用 Servlet 的 Service() 方法来处理请求。\n\n4. 销毁 Servlet：Servlet 处理完请求并提供响应后，容器将通过调用 Servlet 的 destroy() 方法将其销毁。此时，Servlet 将清理所有不再需要的内存、线程等。\n\n## DispatcherServlet 类\n为了与现有框架的路由机制对接，我们实现了一个简化的 `HttpServlet`：\n\n```java\npublic class JavelinDispatcherServlet extends HttpServlet {\n\n    private final Router router;\n\n    public JavelinDispatcherServlet() { \n        this.router = new Router(); // 初始化router变量\n    }\n\n    @Override\n    public void init() throws ServletException {\n        router.registerRoutes();\n    }\n\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        try {\n            ServletHttpContext context = new ServletHttpContext(req, resp); // 创建ServeletHttpContext实例\n            router.handle(context); // 调用router的handle方法，传入ServeletHttpContext实例\n        } catch (Exception e) { \n            // 捕获异常\n            resp.setStatus(500);\n            resp.getWriter().write(\"Internal Server Error\");\n        }\n    }\n    \n}\n```\n\n此 Servlet 会在初始化时扫描注解控制器，并注册到 Javelin 的路由表中。\n\n---\n\n\n# ServletHttpContext 的设计与实现\n\n为了实现框架对 Servlet 请求的无缝支持，Javelin 提供了 `ServletHttpContext` 类作为 `NHttpContext` 的具体实现之一。\n\n其设计目标是将标准的 `HttpServletRequest` 与 `HttpServletResponse` 封装为统一的上下文对象，供框架内部使用。\n\n该类的实现如下：\n\n```java\npublic class ServletHttpContext extends NHttpContext {    \n\n    public ServletHttpContext(HttpServletRequest request, HttpServletResponse response) {\n        super();\n        this.request = request;\n        this.response = response;\n    }\n\n    // 提供 getHeader, getMethod, getPath, getBodyStream 等\n    public String getHeader(String name) { \n        return request.getHeader(name); \n    }\n\n    public String getMethod() { \n        return request.getMethod(); \n    }\n\n    public String getPath() { \n        return request.getRequestURI(); \n    }\n}\n```\n\n## 设计说明：\n\n* 该类继承自 `NHttpContext`，复用其中间件链、异常捕获、属性容器等机制；\n* 构造函数中注入标准 Servlet 对象并保存；\n* 对外暴露统一接口，如 `getHeader()`、`getPath()`、`getMethod()` 等，屏蔽底层实现差异；\n* 可以与 `HttpServerHttpContext` 等其他协议上下文实现共享处理逻辑。\n\n这种抽象方式实现了协议无关性，使得中间件、控制器、异常处理器等逻辑无需关心底层运行环境，是实现跨容器兼容性的基础。\n\n\n# 运行效果\n\n启动入口如下：\n\n```java\npublic class JavelinStarter {\n\n    public void run(Class<?> appClass, String[] args, AppStartupOption option) throws Exception\n    {\n        BASE_PACKAGE = appClass.getPackage().getName(); // 自动获取包名\n        \n        JavelinEmbeddedTomcatServer server = new JavelinEmbeddedTomcatServer(BASE_PACKAGE); \n\n        System.out.println(\" Javelin initialized!\");\n\n        server.start();\n    }\n}\n```\n\n控制台输出：\n\n```\n5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol init\n信息: Initializing ProtocolHandler [\"http-nio-8080\"]\n5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardService startInternal\n信息: Starting service [Tomcat]\n5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardEngine startInternal\n信息: Starting Servlet engine: [Apache Tomcat/10.1.20]\n5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-nio-8080\"]\n```\n\n浏览器访问 `http://localhost:8080/`，可看到返回：\n\n![浏览器访问效果](./images/javelin-servlet/result.png)\n\n---\n\n# 下一步计划\n\n目前我们已完成：\n\n* ✅ 替换 HttpServer 为 Servlet 容器\n* ✅ 手动注册 DispatcherServlet\n* ✅ 支持包名动态传入，实现灵活控制器扫描\n* ✅ 封装 ServletHttpContext\n\n下一篇我们将实现：\n\n* 🔁 抽象 `IHttpContext` 接口，兼容多种后端\n* 🌐 支持静态资源、session、filter 等 Servlet 功能\n\n欢迎关注继续升级版的 Javelin 框架设计！\n","source":"_posts/javelin-servlet.md","raw":"---\ntitle: 构建自己的微型 Spring 框架（三）：接入内嵌 Tomcat 与 Servlet\ndate: 2025-05-06 15:07:53\ntags:\n---\n\n在前两篇中，我们已经实现了一个具备依赖注入、路由注册、参数绑定、中间件、JSON 返回、异常处理的微型 Web 框架 —— Javelin，它基于 JDK 自带的 `HttpServer` 实现了最小运行闭环。\n\n曾几何时，我一度以为HttpServer就是我的最终目标，直到我被告知它存在一定的局限性，不适合生产使用。显然我们的目标不仅仅是一个简单的最小闭环，而是一个完整的、可扩展的、强壮的 Web 框架。本篇将带你将 Javelin **接入内嵌 Tomcat，并运行在标准 Servlet 容器之上**，向真正的工程化迈进一步。\n\n---\n\n# 为什么 HttpServer 不适合生产环境？\n| 项目          | 说明                                                                   |\n| ----------- | -------------------------------------------------------------------- |\n| ❌ 性能较低      | 它使用阻塞 IO（虽然支持线程池），但并不擅长高并发处理。                                        |\n| ❌ 功能简陋      | 不支持 HTTPS 配置灵活性、不支持 HTTP/2、缺少对请求体/响应流的高级控制。                          |\n| ❌ 安全性弱      | 缺少成熟的安全机制（如防 XSS/CORS/session 注入等），也没有专门的安全更新机制。                     |\n| ❌ 缺乏标准支持    | 不支持 Servlet、Filter、Multipart 等常用 Web 标准，无法使用 Spring MVC、Shiro 等主流组件。 |\n| ❌ 没有压缩/缓存机制 | 不支持 GZIP 压缩、缓存控制等特性，效率低下。                                            |\n| ❌ 维护成本高     | 基础功能要自己手写，中间件、安全、监控都要自己造轮子。                                          |\n\n# 什么是 Servlet 容器/Web 容器？\nWeb 容器（也称为 Servlet 容器）是驻留在 Web 服务器内部与 Java Servlet 交互的组件。Web 容器负责管理 Servlet 的生命周期、将 URL 映射到特定的 Servlet、从 Servlet 获取响应以及将响应发送给请求者。\n\nWeb 容器创建 servlet 实例、加载和卸载 servlet、创建和管理请求和响应对象，以及执行其他 servlet 管理任务。\n\nServlet 容器由三个组件组成：过滤器 (Filter)、Servlet 和监听器 (Listener)。当请求到达 Tomcat（即 Servlet 容器）时，它会被发送到 Servlet 过滤器 (Filter)。Servlet 处理请求并生成响应。\n![Servlet 容器与 Web 服务器的关系](./images/javelin-servlet/servlet-container.png)\n\n从上图可以看出，Servlet 容器位于 Web 服务器内部。静态内容由 Web 服务器提供，而任何动态请求则由 Servlet 容器组件处理，该组件负责启动 Servlet 并管理其生命周期。\n\n# 为什么使用内嵌 Tomcat\n\nJDK 的 `HttpServer` 非常轻量，但它的问题是：\n\n* 不支持 Servlet 规范，无法与主流框架生态兼容\n* 缺少压缩、过滤器、Session 等高级特性\n* 不适合高并发或复杂业务场景\n\n而 Tomcat 作为最主流的 Servlet 容器，性能成熟、生态完善。通过嵌入式启动方式，我们既可以保留 Javelin 的轻量特性，又可以获得生产级的服务能力。\n\n---\n\n# Servlet 架构说明与类图\n![Servlet 架构说明](./images/javelin-servlet/servlet.png)\n\n\n为了实现标准 Servlet 支持，Javelin 框架在原有基础上新增了如下组件：\n\n- JavelinEmbeddedTomcatServer：内嵌 Tomcat 启动器，负责创建 Servlet 容器、注册 DispatcherServlet。\n\n- JavelinDispatcherServlet：自定义 HttpServlet，用作框架的统一入口，初始化 Router 并转发请求。\n\n- Router：负责路由匹配与控制器分发，调用中间件与控制器方法。\n\n- ActionExecutor：处理参数绑定、生命周期方法、中间件链执行。\n\n- NHttpContext：请求上下文，在不同协议（如 HttpServer、Servlet）中作为桥梁。\n\n![Servlet 架构说明与类图](./images/javelin-servlet/architecture.png)\n\n---\n\n# 启动内嵌 Tomcat\n\n在 `javelin-core` 中添加如下 Gradle 依赖：\n\n```groovy\ndependencies {\n    implementation 'org.apache.tomcat.embed:tomcat-embed-core:10.1.20'\n    implementation 'jakarta.servlet:jakarta.servlet-api:6.0.0'\n}\n```\n\n> 注意：Tomcat 10 之后已经迁移到 `jakarta.servlet` 命名空间。\n\n我们在 `javelin-core.http.tomcat` 包下新增了一个启动器类：\n\n```java\npublic class JavelinEmbeddedTomcatServer {\n    public JavelinEmbeddedTomcatServer(int port, String basePackage) { ... }\n\n    public void start() throws Exception {\n        tomcat.setPort(port);\n        tomcat.setBaseDir(...);\n        Context context = tomcat.addContext(\"\", new File(\".\").getAbsolutePath());\n\n        // 注册 DispatcherServlet\n        JavelinDispatcherServlet servlet = new JavelinDispatcherServlet(basePackage);\n        Tomcat.addServlet(context, \"Javelin\", servlet);\n        context.addServletMappingDecoded(\"/*\", \"Javelin\");\n\n        tomcat.getConnector(); // 强制初始化协议监听器\n        tomcat.start();\n        tomcat.getServer().await();\n    }\n}\n```\n\n通过该类，我们可以像 Spring Boot 一样，直接启动一个内嵌的 Web 服务。\n\n---\n\n# 自定义 HttpServlet\n\n## Servlet 生命周期\nServlet 的生命周期包括以下几个阶段：\n![Servlet 生命周期](./images/javelin-servlet/servlet-lifecycle.png)\n\n1. 加载和实例化：当容器接收到 Servlet 的请求时，ClassLoader 会加载该 Servlet 类。\n    - 加载：加载 Servlet 类。\n    - 实例化：创建 Servlet 的一个实例。为了创建 Servlet 的新实例，容器使用无参数构造函数。\n2. 初始化 Servlet：Servlet 成功实例化后，Servlet 容器将初始化 Servlet 对象。容器将调用 Servlet 的 init() 方法。\n\n3. 处理请求：初始化后，Servlet 实例将处理客户端请求。容器将为 Servlet 创建HttpServletResponse和HttpServletRequest对象，以处理 HTTP 请求。然后，容器将调用 Servlet 的 Service() 方法来处理请求。\n\n4. 销毁 Servlet：Servlet 处理完请求并提供响应后，容器将通过调用 Servlet 的 destroy() 方法将其销毁。此时，Servlet 将清理所有不再需要的内存、线程等。\n\n## DispatcherServlet 类\n为了与现有框架的路由机制对接，我们实现了一个简化的 `HttpServlet`：\n\n```java\npublic class JavelinDispatcherServlet extends HttpServlet {\n\n    private final Router router;\n\n    public JavelinDispatcherServlet() { \n        this.router = new Router(); // 初始化router变量\n    }\n\n    @Override\n    public void init() throws ServletException {\n        router.registerRoutes();\n    }\n\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        try {\n            ServletHttpContext context = new ServletHttpContext(req, resp); // 创建ServeletHttpContext实例\n            router.handle(context); // 调用router的handle方法，传入ServeletHttpContext实例\n        } catch (Exception e) { \n            // 捕获异常\n            resp.setStatus(500);\n            resp.getWriter().write(\"Internal Server Error\");\n        }\n    }\n    \n}\n```\n\n此 Servlet 会在初始化时扫描注解控制器，并注册到 Javelin 的路由表中。\n\n---\n\n\n# ServletHttpContext 的设计与实现\n\n为了实现框架对 Servlet 请求的无缝支持，Javelin 提供了 `ServletHttpContext` 类作为 `NHttpContext` 的具体实现之一。\n\n其设计目标是将标准的 `HttpServletRequest` 与 `HttpServletResponse` 封装为统一的上下文对象，供框架内部使用。\n\n该类的实现如下：\n\n```java\npublic class ServletHttpContext extends NHttpContext {    \n\n    public ServletHttpContext(HttpServletRequest request, HttpServletResponse response) {\n        super();\n        this.request = request;\n        this.response = response;\n    }\n\n    // 提供 getHeader, getMethod, getPath, getBodyStream 等\n    public String getHeader(String name) { \n        return request.getHeader(name); \n    }\n\n    public String getMethod() { \n        return request.getMethod(); \n    }\n\n    public String getPath() { \n        return request.getRequestURI(); \n    }\n}\n```\n\n## 设计说明：\n\n* 该类继承自 `NHttpContext`，复用其中间件链、异常捕获、属性容器等机制；\n* 构造函数中注入标准 Servlet 对象并保存；\n* 对外暴露统一接口，如 `getHeader()`、`getPath()`、`getMethod()` 等，屏蔽底层实现差异；\n* 可以与 `HttpServerHttpContext` 等其他协议上下文实现共享处理逻辑。\n\n这种抽象方式实现了协议无关性，使得中间件、控制器、异常处理器等逻辑无需关心底层运行环境，是实现跨容器兼容性的基础。\n\n\n# 运行效果\n\n启动入口如下：\n\n```java\npublic class JavelinStarter {\n\n    public void run(Class<?> appClass, String[] args, AppStartupOption option) throws Exception\n    {\n        BASE_PACKAGE = appClass.getPackage().getName(); // 自动获取包名\n        \n        JavelinEmbeddedTomcatServer server = new JavelinEmbeddedTomcatServer(BASE_PACKAGE); \n\n        System.out.println(\" Javelin initialized!\");\n\n        server.start();\n    }\n}\n```\n\n控制台输出：\n\n```\n5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol init\n信息: Initializing ProtocolHandler [\"http-nio-8080\"]\n5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardService startInternal\n信息: Starting service [Tomcat]\n5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardEngine startInternal\n信息: Starting Servlet engine: [Apache Tomcat/10.1.20]\n5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-nio-8080\"]\n```\n\n浏览器访问 `http://localhost:8080/`，可看到返回：\n\n![浏览器访问效果](./images/javelin-servlet/result.png)\n\n---\n\n# 下一步计划\n\n目前我们已完成：\n\n* ✅ 替换 HttpServer 为 Servlet 容器\n* ✅ 手动注册 DispatcherServlet\n* ✅ 支持包名动态传入，实现灵活控制器扫描\n* ✅ 封装 ServletHttpContext\n\n下一篇我们将实现：\n\n* 🔁 抽象 `IHttpContext` 接口，兼容多种后端\n* 🌐 支持静态资源、session、filter 等 Servlet 功能\n\n欢迎关注继续升级版的 Javelin 框架设计！\n","slug":"javelin-servlet","published":1,"updated":"2025-05-07T07:50:00.379Z","_id":"cmac66ewx00007cp18cji7j8u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在前两篇中，我们已经实现了一个具备依赖注入、路由注册、参数绑定、中间件、JSON 返回、异常处理的微型 Web 框架 —— Javelin，它基于 JDK 自带的 <code>HttpServer</code> 实现了最小运行闭环。</p>\n<p>曾几何时，我一度以为HttpServer就是我的最终目标，直到我被告知它存在一定的局限性，不适合生产使用。显然我们的目标不仅仅是一个简单的最小闭环，而是一个完整的、可扩展的、强壮的 Web 框架。本篇将带你将 Javelin <strong>接入内嵌 Tomcat，并运行在标准 Servlet 容器之上</strong>，向真正的工程化迈进一步。</p>\n<hr>\n<h1 id=\"为什么-HttpServer-不适合生产环境？\"><a href=\"#为什么-HttpServer-不适合生产环境？\" class=\"headerlink\" title=\"为什么 HttpServer 不适合生产环境？\"></a>为什么 HttpServer 不适合生产环境？</h1><table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>❌ 性能较低</td>\n<td>它使用阻塞 IO（虽然支持线程池），但并不擅长高并发处理。</td>\n</tr>\n<tr>\n<td>❌ 功能简陋</td>\n<td>不支持 HTTPS 配置灵活性、不支持 HTTP&#x2F;2、缺少对请求体&#x2F;响应流的高级控制。</td>\n</tr>\n<tr>\n<td>❌ 安全性弱</td>\n<td>缺少成熟的安全机制（如防 XSS&#x2F;CORS&#x2F;session 注入等），也没有专门的安全更新机制。</td>\n</tr>\n<tr>\n<td>❌ 缺乏标准支持</td>\n<td>不支持 Servlet、Filter、Multipart 等常用 Web 标准，无法使用 Spring MVC、Shiro 等主流组件。</td>\n</tr>\n<tr>\n<td>❌ 没有压缩&#x2F;缓存机制</td>\n<td>不支持 GZIP 压缩、缓存控制等特性，效率低下。</td>\n</tr>\n<tr>\n<td>❌ 维护成本高</td>\n<td>基础功能要自己手写，中间件、安全、监控都要自己造轮子。</td>\n</tr>\n</tbody></table>\n<h1 id=\"什么是-Servlet-容器-Web-容器？\"><a href=\"#什么是-Servlet-容器-Web-容器？\" class=\"headerlink\" title=\"什么是 Servlet 容器&#x2F;Web 容器？\"></a>什么是 Servlet 容器&#x2F;Web 容器？</h1><p>Web 容器（也称为 Servlet 容器）是驻留在 Web 服务器内部与 Java Servlet 交互的组件。Web 容器负责管理 Servlet 的生命周期、将 URL 映射到特定的 Servlet、从 Servlet 获取响应以及将响应发送给请求者。</p>\n<p>Web 容器创建 servlet 实例、加载和卸载 servlet、创建和管理请求和响应对象，以及执行其他 servlet 管理任务。</p>\n<p>Servlet 容器由三个组件组成：过滤器 (Filter)、Servlet 和监听器 (Listener)。当请求到达 Tomcat（即 Servlet 容器）时，它会被发送到 Servlet 过滤器 (Filter)。Servlet 处理请求并生成响应。<br><img src=\"/blog/./images/javelin-servlet/servlet-container.png\" alt=\"Servlet 容器与 Web 服务器的关系\"></p>\n<p>从上图可以看出，Servlet 容器位于 Web 服务器内部。静态内容由 Web 服务器提供，而任何动态请求则由 Servlet 容器组件处理，该组件负责启动 Servlet 并管理其生命周期。</p>\n<h1 id=\"为什么使用内嵌-Tomcat\"><a href=\"#为什么使用内嵌-Tomcat\" class=\"headerlink\" title=\"为什么使用内嵌 Tomcat\"></a>为什么使用内嵌 Tomcat</h1><p>JDK 的 <code>HttpServer</code> 非常轻量，但它的问题是：</p>\n<ul>\n<li>不支持 Servlet 规范，无法与主流框架生态兼容</li>\n<li>缺少压缩、过滤器、Session 等高级特性</li>\n<li>不适合高并发或复杂业务场景</li>\n</ul>\n<p>而 Tomcat 作为最主流的 Servlet 容器，性能成熟、生态完善。通过嵌入式启动方式，我们既可以保留 Javelin 的轻量特性，又可以获得生产级的服务能力。</p>\n<hr>\n<h1 id=\"Servlet-架构说明与类图\"><a href=\"#Servlet-架构说明与类图\" class=\"headerlink\" title=\"Servlet 架构说明与类图\"></a>Servlet 架构说明与类图</h1><p><img src=\"/blog/./images/javelin-servlet/servlet.png\" alt=\"Servlet 架构说明\"></p>\n<p>为了实现标准 Servlet 支持，Javelin 框架在原有基础上新增了如下组件：</p>\n<ul>\n<li><p>JavelinEmbeddedTomcatServer：内嵌 Tomcat 启动器，负责创建 Servlet 容器、注册 DispatcherServlet。</p>\n</li>\n<li><p>JavelinDispatcherServlet：自定义 HttpServlet，用作框架的统一入口，初始化 Router 并转发请求。</p>\n</li>\n<li><p>Router：负责路由匹配与控制器分发，调用中间件与控制器方法。</p>\n</li>\n<li><p>ActionExecutor：处理参数绑定、生命周期方法、中间件链执行。</p>\n</li>\n<li><p>NHttpContext：请求上下文，在不同协议（如 HttpServer、Servlet）中作为桥梁。</p>\n</li>\n</ul>\n<p><img src=\"/blog/./images/javelin-servlet/architecture.png\" alt=\"Servlet 架构说明与类图\"></p>\n<hr>\n<h1 id=\"启动内嵌-Tomcat\"><a href=\"#启动内嵌-Tomcat\" class=\"headerlink\" title=\"启动内嵌 Tomcat\"></a>启动内嵌 Tomcat</h1><p>在 <code>javelin-core</code> 中添加如下 Gradle 依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;org.apache.tomcat.embed:tomcat-embed-core:10.1.20&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;jakarta.servlet:jakarta.servlet-api:6.0.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：Tomcat 10 之后已经迁移到 <code>jakarta.servlet</code> 命名空间。</p>\n</blockquote>\n<p>我们在 <code>javelin-core.http.tomcat</code> 包下新增了一个启动器类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinEmbeddedTomcatServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JavelinEmbeddedTomcatServer</span><span class=\"params\">(<span class=\"type\">int</span> port, String basePackage)</span> &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        tomcat.setPort(port);</span><br><span class=\"line\">        tomcat.setBaseDir(...);</span><br><span class=\"line\">        <span class=\"type\">Context</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> tomcat.addContext(<span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;.&quot;</span>).getAbsolutePath());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册 DispatcherServlet</span></span><br><span class=\"line\">        <span class=\"type\">JavelinDispatcherServlet</span> <span class=\"variable\">servlet</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavelinDispatcherServlet</span>(basePackage);</span><br><span class=\"line\">        Tomcat.addServlet(context, <span class=\"string\">&quot;Javelin&quot;</span>, servlet);</span><br><span class=\"line\">        context.addServletMappingDecoded(<span class=\"string\">&quot;/*&quot;</span>, <span class=\"string\">&quot;Javelin&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        tomcat.getConnector(); <span class=\"comment\">// 强制初始化协议监听器</span></span><br><span class=\"line\">        tomcat.start();</span><br><span class=\"line\">        tomcat.getServer().await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过该类，我们可以像 Spring Boot 一样，直接启动一个内嵌的 Web 服务。</p>\n<hr>\n<h1 id=\"自定义-HttpServlet\"><a href=\"#自定义-HttpServlet\" class=\"headerlink\" title=\"自定义 HttpServlet\"></a>自定义 HttpServlet</h1><h2 id=\"Servlet-生命周期\"><a href=\"#Servlet-生命周期\" class=\"headerlink\" title=\"Servlet 生命周期\"></a>Servlet 生命周期</h2><p>Servlet 的生命周期包括以下几个阶段：<br><img src=\"/blog/./images/javelin-servlet/servlet-lifecycle.png\" alt=\"Servlet 生命周期\"></p>\n<ol>\n<li><p>加载和实例化：当容器接收到 Servlet 的请求时，ClassLoader 会加载该 Servlet 类。</p>\n<ul>\n<li>加载：加载 Servlet 类。</li>\n<li>实例化：创建 Servlet 的一个实例。为了创建 Servlet 的新实例，容器使用无参数构造函数。</li>\n</ul>\n</li>\n<li><p>初始化 Servlet：Servlet 成功实例化后，Servlet 容器将初始化 Servlet 对象。容器将调用 Servlet 的 init() 方法。</p>\n</li>\n<li><p>处理请求：初始化后，Servlet 实例将处理客户端请求。容器将为 Servlet 创建HttpServletResponse和HttpServletRequest对象，以处理 HTTP 请求。然后，容器将调用 Servlet 的 Service() 方法来处理请求。</p>\n</li>\n<li><p>销毁 Servlet：Servlet 处理完请求并提供响应后，容器将通过调用 Servlet 的 destroy() 方法将其销毁。此时，Servlet 将清理所有不再需要的内存、线程等。</p>\n</li>\n</ol>\n<h2 id=\"DispatcherServlet-类\"><a href=\"#DispatcherServlet-类\" class=\"headerlink\" title=\"DispatcherServlet 类\"></a>DispatcherServlet 类</h2><p>为了与现有框架的路由机制对接，我们实现了一个简化的 <code>HttpServlet</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinDispatcherServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Router router;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JavelinDispatcherServlet</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>(); <span class=\"comment\">// 初始化router变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException &#123;</span><br><span class=\"line\">        router.registerRoutes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServletHttpContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServletHttpContext</span>(req, resp); <span class=\"comment\">// 创建ServeletHttpContext实例</span></span><br><span class=\"line\">            router.handle(context); <span class=\"comment\">// 调用router的handle方法，传入ServeletHttpContext实例</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 捕获异常</span></span><br><span class=\"line\">            resp.setStatus(<span class=\"number\">500</span>);</span><br><span class=\"line\">            resp.getWriter().write(<span class=\"string\">&quot;Internal Server Error&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此 Servlet 会在初始化时扫描注解控制器，并注册到 Javelin 的路由表中。</p>\n<hr>\n<h1 id=\"ServletHttpContext-的设计与实现\"><a href=\"#ServletHttpContext-的设计与实现\" class=\"headerlink\" title=\"ServletHttpContext 的设计与实现\"></a>ServletHttpContext 的设计与实现</h1><p>为了实现框架对 Servlet 请求的无缝支持，Javelin 提供了 <code>ServletHttpContext</code> 类作为 <code>NHttpContext</code> 的具体实现之一。</p>\n<p>其设计目标是将标准的 <code>HttpServletRequest</code> 与 <code>HttpServletResponse</code> 封装为统一的上下文对象，供框架内部使用。</p>\n<p>该类的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServletHttpContext</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">NHttpContext</span> &#123;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServletHttpContext</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.request = request;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.response = response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提供 getHeader, getMethod, getPath, getBodyStream 等</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getHeader</span><span class=\"params\">(String name)</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> request.getHeader(name); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMethod</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> request.getMethod(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getPath</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> request.getRequestURI(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设计说明：\"><a href=\"#设计说明：\" class=\"headerlink\" title=\"设计说明：\"></a>设计说明：</h2><ul>\n<li>该类继承自 <code>NHttpContext</code>，复用其中间件链、异常捕获、属性容器等机制；</li>\n<li>构造函数中注入标准 Servlet 对象并保存；</li>\n<li>对外暴露统一接口，如 <code>getHeader()</code>、<code>getPath()</code>、<code>getMethod()</code> 等，屏蔽底层实现差异；</li>\n<li>可以与 <code>HttpServerHttpContext</code> 等其他协议上下文实现共享处理逻辑。</li>\n</ul>\n<p>这种抽象方式实现了协议无关性，使得中间件、控制器、异常处理器等逻辑无需关心底层运行环境，是实现跨容器兼容性的基础。</p>\n<h1 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a>运行效果</h1><p>启动入口如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinStarter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt; appClass, String[] args, AppStartupOption option)</span> <span class=\"keyword\">throws</span> Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BASE_PACKAGE = appClass.getPackage().getName(); <span class=\"comment\">// 自动获取包名</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">JavelinEmbeddedTomcatServer</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavelinEmbeddedTomcatServer</span>(BASE_PACKAGE); </span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; Javelin initialized!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol init</span><br><span class=\"line\">信息: Initializing ProtocolHandler [&quot;http-nio-8080&quot;]</span><br><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardService startInternal</span><br><span class=\"line\">信息: Starting service [Tomcat]</span><br><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardEngine startInternal</span><br><span class=\"line\">信息: Starting Servlet engine: [Apache Tomcat/10.1.20]</span><br><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol start</span><br><span class=\"line\">信息: Starting ProtocolHandler [&quot;http-nio-8080&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>浏览器访问 <code>http://localhost:8080/</code>，可看到返回：</p>\n<p><img src=\"/blog/./images/javelin-servlet/result.png\" alt=\"浏览器访问效果\"></p>\n<hr>\n<h1 id=\"下一步计划\"><a href=\"#下一步计划\" class=\"headerlink\" title=\"下一步计划\"></a>下一步计划</h1><p>目前我们已完成：</p>\n<ul>\n<li>✅ 替换 HttpServer 为 Servlet 容器</li>\n<li>✅ 手动注册 DispatcherServlet</li>\n<li>✅ 支持包名动态传入，实现灵活控制器扫描</li>\n<li>✅ 封装 ServletHttpContext</li>\n</ul>\n<p>下一篇我们将实现：</p>\n<ul>\n<li>🔁 抽象 <code>IHttpContext</code> 接口，兼容多种后端</li>\n<li>🌐 支持静态资源、session、filter 等 Servlet 功能</li>\n</ul>\n<p>欢迎关注继续升级版的 Javelin 框架设计！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前两篇中，我们已经实现了一个具备依赖注入、路由注册、参数绑定、中间件、JSON 返回、异常处理的微型 Web 框架 —— Javelin，它基于 JDK 自带的 <code>HttpServer</code> 实现了最小运行闭环。</p>\n<p>曾几何时，我一度以为HttpServer就是我的最终目标，直到我被告知它存在一定的局限性，不适合生产使用。显然我们的目标不仅仅是一个简单的最小闭环，而是一个完整的、可扩展的、强壮的 Web 框架。本篇将带你将 Javelin <strong>接入内嵌 Tomcat，并运行在标准 Servlet 容器之上</strong>，向真正的工程化迈进一步。</p>\n<hr>\n<h1 id=\"为什么-HttpServer-不适合生产环境？\"><a href=\"#为什么-HttpServer-不适合生产环境？\" class=\"headerlink\" title=\"为什么 HttpServer 不适合生产环境？\"></a>为什么 HttpServer 不适合生产环境？</h1><table>\n<thead>\n<tr>\n<th>项目</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>❌ 性能较低</td>\n<td>它使用阻塞 IO（虽然支持线程池），但并不擅长高并发处理。</td>\n</tr>\n<tr>\n<td>❌ 功能简陋</td>\n<td>不支持 HTTPS 配置灵活性、不支持 HTTP&#x2F;2、缺少对请求体&#x2F;响应流的高级控制。</td>\n</tr>\n<tr>\n<td>❌ 安全性弱</td>\n<td>缺少成熟的安全机制（如防 XSS&#x2F;CORS&#x2F;session 注入等），也没有专门的安全更新机制。</td>\n</tr>\n<tr>\n<td>❌ 缺乏标准支持</td>\n<td>不支持 Servlet、Filter、Multipart 等常用 Web 标准，无法使用 Spring MVC、Shiro 等主流组件。</td>\n</tr>\n<tr>\n<td>❌ 没有压缩&#x2F;缓存机制</td>\n<td>不支持 GZIP 压缩、缓存控制等特性，效率低下。</td>\n</tr>\n<tr>\n<td>❌ 维护成本高</td>\n<td>基础功能要自己手写，中间件、安全、监控都要自己造轮子。</td>\n</tr>\n</tbody></table>\n<h1 id=\"什么是-Servlet-容器-Web-容器？\"><a href=\"#什么是-Servlet-容器-Web-容器？\" class=\"headerlink\" title=\"什么是 Servlet 容器&#x2F;Web 容器？\"></a>什么是 Servlet 容器&#x2F;Web 容器？</h1><p>Web 容器（也称为 Servlet 容器）是驻留在 Web 服务器内部与 Java Servlet 交互的组件。Web 容器负责管理 Servlet 的生命周期、将 URL 映射到特定的 Servlet、从 Servlet 获取响应以及将响应发送给请求者。</p>\n<p>Web 容器创建 servlet 实例、加载和卸载 servlet、创建和管理请求和响应对象，以及执行其他 servlet 管理任务。</p>\n<p>Servlet 容器由三个组件组成：过滤器 (Filter)、Servlet 和监听器 (Listener)。当请求到达 Tomcat（即 Servlet 容器）时，它会被发送到 Servlet 过滤器 (Filter)。Servlet 处理请求并生成响应。<br><img src=\"/blog/./images/javelin-servlet/servlet-container.png\" alt=\"Servlet 容器与 Web 服务器的关系\"></p>\n<p>从上图可以看出，Servlet 容器位于 Web 服务器内部。静态内容由 Web 服务器提供，而任何动态请求则由 Servlet 容器组件处理，该组件负责启动 Servlet 并管理其生命周期。</p>\n<h1 id=\"为什么使用内嵌-Tomcat\"><a href=\"#为什么使用内嵌-Tomcat\" class=\"headerlink\" title=\"为什么使用内嵌 Tomcat\"></a>为什么使用内嵌 Tomcat</h1><p>JDK 的 <code>HttpServer</code> 非常轻量，但它的问题是：</p>\n<ul>\n<li>不支持 Servlet 规范，无法与主流框架生态兼容</li>\n<li>缺少压缩、过滤器、Session 等高级特性</li>\n<li>不适合高并发或复杂业务场景</li>\n</ul>\n<p>而 Tomcat 作为最主流的 Servlet 容器，性能成熟、生态完善。通过嵌入式启动方式，我们既可以保留 Javelin 的轻量特性，又可以获得生产级的服务能力。</p>\n<hr>\n<h1 id=\"Servlet-架构说明与类图\"><a href=\"#Servlet-架构说明与类图\" class=\"headerlink\" title=\"Servlet 架构说明与类图\"></a>Servlet 架构说明与类图</h1><p><img src=\"/blog/./images/javelin-servlet/servlet.png\" alt=\"Servlet 架构说明\"></p>\n<p>为了实现标准 Servlet 支持，Javelin 框架在原有基础上新增了如下组件：</p>\n<ul>\n<li><p>JavelinEmbeddedTomcatServer：内嵌 Tomcat 启动器，负责创建 Servlet 容器、注册 DispatcherServlet。</p>\n</li>\n<li><p>JavelinDispatcherServlet：自定义 HttpServlet，用作框架的统一入口，初始化 Router 并转发请求。</p>\n</li>\n<li><p>Router：负责路由匹配与控制器分发，调用中间件与控制器方法。</p>\n</li>\n<li><p>ActionExecutor：处理参数绑定、生命周期方法、中间件链执行。</p>\n</li>\n<li><p>NHttpContext：请求上下文，在不同协议（如 HttpServer、Servlet）中作为桥梁。</p>\n</li>\n</ul>\n<p><img src=\"/blog/./images/javelin-servlet/architecture.png\" alt=\"Servlet 架构说明与类图\"></p>\n<hr>\n<h1 id=\"启动内嵌-Tomcat\"><a href=\"#启动内嵌-Tomcat\" class=\"headerlink\" title=\"启动内嵌 Tomcat\"></a>启动内嵌 Tomcat</h1><p>在 <code>javelin-core</code> 中添加如下 Gradle 依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;org.apache.tomcat.embed:tomcat-embed-core:10.1.20&#x27;</span></span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;jakarta.servlet:jakarta.servlet-api:6.0.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：Tomcat 10 之后已经迁移到 <code>jakarta.servlet</code> 命名空间。</p>\n</blockquote>\n<p>我们在 <code>javelin-core.http.tomcat</code> 包下新增了一个启动器类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinEmbeddedTomcatServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JavelinEmbeddedTomcatServer</span><span class=\"params\">(<span class=\"type\">int</span> port, String basePackage)</span> &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        tomcat.setPort(port);</span><br><span class=\"line\">        tomcat.setBaseDir(...);</span><br><span class=\"line\">        <span class=\"type\">Context</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> tomcat.addContext(<span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;.&quot;</span>).getAbsolutePath());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 注册 DispatcherServlet</span></span><br><span class=\"line\">        <span class=\"type\">JavelinDispatcherServlet</span> <span class=\"variable\">servlet</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavelinDispatcherServlet</span>(basePackage);</span><br><span class=\"line\">        Tomcat.addServlet(context, <span class=\"string\">&quot;Javelin&quot;</span>, servlet);</span><br><span class=\"line\">        context.addServletMappingDecoded(<span class=\"string\">&quot;/*&quot;</span>, <span class=\"string\">&quot;Javelin&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        tomcat.getConnector(); <span class=\"comment\">// 强制初始化协议监听器</span></span><br><span class=\"line\">        tomcat.start();</span><br><span class=\"line\">        tomcat.getServer().await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过该类，我们可以像 Spring Boot 一样，直接启动一个内嵌的 Web 服务。</p>\n<hr>\n<h1 id=\"自定义-HttpServlet\"><a href=\"#自定义-HttpServlet\" class=\"headerlink\" title=\"自定义 HttpServlet\"></a>自定义 HttpServlet</h1><h2 id=\"Servlet-生命周期\"><a href=\"#Servlet-生命周期\" class=\"headerlink\" title=\"Servlet 生命周期\"></a>Servlet 生命周期</h2><p>Servlet 的生命周期包括以下几个阶段：<br><img src=\"/blog/./images/javelin-servlet/servlet-lifecycle.png\" alt=\"Servlet 生命周期\"></p>\n<ol>\n<li><p>加载和实例化：当容器接收到 Servlet 的请求时，ClassLoader 会加载该 Servlet 类。</p>\n<ul>\n<li>加载：加载 Servlet 类。</li>\n<li>实例化：创建 Servlet 的一个实例。为了创建 Servlet 的新实例，容器使用无参数构造函数。</li>\n</ul>\n</li>\n<li><p>初始化 Servlet：Servlet 成功实例化后，Servlet 容器将初始化 Servlet 对象。容器将调用 Servlet 的 init() 方法。</p>\n</li>\n<li><p>处理请求：初始化后，Servlet 实例将处理客户端请求。容器将为 Servlet 创建HttpServletResponse和HttpServletRequest对象，以处理 HTTP 请求。然后，容器将调用 Servlet 的 Service() 方法来处理请求。</p>\n</li>\n<li><p>销毁 Servlet：Servlet 处理完请求并提供响应后，容器将通过调用 Servlet 的 destroy() 方法将其销毁。此时，Servlet 将清理所有不再需要的内存、线程等。</p>\n</li>\n</ol>\n<h2 id=\"DispatcherServlet-类\"><a href=\"#DispatcherServlet-类\" class=\"headerlink\" title=\"DispatcherServlet 类\"></a>DispatcherServlet 类</h2><p>为了与现有框架的路由机制对接，我们实现了一个简化的 <code>HttpServlet</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinDispatcherServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Router router;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JavelinDispatcherServlet</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>(); <span class=\"comment\">// 初始化router变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException &#123;</span><br><span class=\"line\">        router.registerRoutes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServletHttpContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServletHttpContext</span>(req, resp); <span class=\"comment\">// 创建ServeletHttpContext实例</span></span><br><span class=\"line\">            router.handle(context); <span class=\"comment\">// 调用router的handle方法，传入ServeletHttpContext实例</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 捕获异常</span></span><br><span class=\"line\">            resp.setStatus(<span class=\"number\">500</span>);</span><br><span class=\"line\">            resp.getWriter().write(<span class=\"string\">&quot;Internal Server Error&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此 Servlet 会在初始化时扫描注解控制器，并注册到 Javelin 的路由表中。</p>\n<hr>\n<h1 id=\"ServletHttpContext-的设计与实现\"><a href=\"#ServletHttpContext-的设计与实现\" class=\"headerlink\" title=\"ServletHttpContext 的设计与实现\"></a>ServletHttpContext 的设计与实现</h1><p>为了实现框架对 Servlet 请求的无缝支持，Javelin 提供了 <code>ServletHttpContext</code> 类作为 <code>NHttpContext</code> 的具体实现之一。</p>\n<p>其设计目标是将标准的 <code>HttpServletRequest</code> 与 <code>HttpServletResponse</code> 封装为统一的上下文对象，供框架内部使用。</p>\n<p>该类的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServletHttpContext</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">NHttpContext</span> &#123;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServletHttpContext</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.request = request;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.response = response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 提供 getHeader, getMethod, getPath, getBodyStream 等</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getHeader</span><span class=\"params\">(String name)</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> request.getHeader(name); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMethod</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> request.getMethod(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getPath</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> request.getRequestURI(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"设计说明：\"><a href=\"#设计说明：\" class=\"headerlink\" title=\"设计说明：\"></a>设计说明：</h2><ul>\n<li>该类继承自 <code>NHttpContext</code>，复用其中间件链、异常捕获、属性容器等机制；</li>\n<li>构造函数中注入标准 Servlet 对象并保存；</li>\n<li>对外暴露统一接口，如 <code>getHeader()</code>、<code>getPath()</code>、<code>getMethod()</code> 等，屏蔽底层实现差异；</li>\n<li>可以与 <code>HttpServerHttpContext</code> 等其他协议上下文实现共享处理逻辑。</li>\n</ul>\n<p>这种抽象方式实现了协议无关性，使得中间件、控制器、异常处理器等逻辑无需关心底层运行环境，是实现跨容器兼容性的基础。</p>\n<h1 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a>运行效果</h1><p>启动入口如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JavelinStarter</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt; appClass, String[] args, AppStartupOption option)</span> <span class=\"keyword\">throws</span> Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        BASE_PACKAGE = appClass.getPackage().getName(); <span class=\"comment\">// 自动获取包名</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">JavelinEmbeddedTomcatServer</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JavelinEmbeddedTomcatServer</span>(BASE_PACKAGE); </span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; Javelin initialized!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        server.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制台输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol init</span><br><span class=\"line\">信息: Initializing ProtocolHandler [&quot;http-nio-8080&quot;]</span><br><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardService startInternal</span><br><span class=\"line\">信息: Starting service [Tomcat]</span><br><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.catalina.core.StandardEngine startInternal</span><br><span class=\"line\">信息: Starting Servlet engine: [Apache Tomcat/10.1.20]</span><br><span class=\"line\">5月 06, 2025 2:52:31 下午 org.apache.coyote.AbstractProtocol start</span><br><span class=\"line\">信息: Starting ProtocolHandler [&quot;http-nio-8080&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>浏览器访问 <code>http://localhost:8080/</code>，可看到返回：</p>\n<p><img src=\"/blog/./images/javelin-servlet/result.png\" alt=\"浏览器访问效果\"></p>\n<hr>\n<h1 id=\"下一步计划\"><a href=\"#下一步计划\" class=\"headerlink\" title=\"下一步计划\"></a>下一步计划</h1><p>目前我们已完成：</p>\n<ul>\n<li>✅ 替换 HttpServer 为 Servlet 容器</li>\n<li>✅ 手动注册 DispatcherServlet</li>\n<li>✅ 支持包名动态传入，实现灵活控制器扫描</li>\n<li>✅ 封装 ServletHttpContext</li>\n</ul>\n<p>下一篇我们将实现：</p>\n<ul>\n<li>🔁 抽象 <code>IHttpContext</code> 接口，兼容多种后端</li>\n<li>🌐 支持静态资源、session、filter 等 Servlet 功能</li>\n</ul>\n<p>欢迎关注继续升级版的 Javelin 框架设计！</p>\n"},{"title":"手写一个微型 Spring 框架（四）：数据访问层设计实战","date":"2025-05-12T06:55:12.000Z","_content":"\n在前几篇文章中，我们已经完成了 Javelin 框架的核心功能构建，包括 HTTP 路由注册、注解扫描与 IoC 容器等内容。本篇将深入探讨 数据访问层（DAL，Data Access Layer） 的设计与实现，从理念到代码，全面展示如何在 Javelin 中构建一个灵活、可维护、可扩展的数据访问模块。\n\n---\n\n# 痛点驱动设计\n\n在构建 Javelin 的数据访问层过程中，我们并不是一开始就拥有完整的设计蓝图，而是源于开发过程中反复遇到的一些实际痛点。下面列举几个典型问题，并结合示例代码说明 Javelin 是如何逐一解决这些问题的：\n\n**1. JDBC 样板代码冗余、可读性差**\n\n原始写法：\n\n```java\nConnection conn = DriverManager.getConnection(url, user, pwd);\nPreparedStatement ps = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\nps.setInt(1, id);\nResultSet rs = ps.executeQuery();\nif (rs.next()) {\n    User user = new User();\n    user.setId(rs.getInt(\"id\"));\n    user.setName(rs.getString(\"name\"));\n    return user;\n}\n```\n\n问题：SQL 与 Java 混杂、资源管理复杂、字段映射重复。\n\nJavelin 写法：\n\n```java\nUser user = CPQueryFactory.create()\n    .sql(\"SELECT * FROM users WHERE id = ?\")\n    .params(id)\n    .queryOne(User.class);\n```\n\n通过 `CPQuery` 和 `BeanPropertyRowMapper` 简化了所有模板逻辑。\n\n**2. 手动管理连接生命周期，易出错**\n\n原始 JDBC 写法中，开发者需要自行处理连接关闭，若中间有异常，极易遗漏关闭：\n\n```java\ntry {\n    Connection conn = ...\n    // do something\n} catch (Exception e) {\n    // handle\n} finally {\n    conn.close(); // 容易忘记\n}\n```\n\nJavelin 使用 `DbContext` 实现 `AutoCloseable`，并结合 try-with-resources 自动释放资源：\n\n```java\ntry (DbContext db = DbConnManager.createAppDb(\"test\")) {\n    // safe use\n}\n```\n\n**3. 事务控制分散，耦合混乱**\n\n在 JDBC 中常见写法：\n\n```java\nconn.setAutoCommit(false);\ntry {\n    // 执行多条语句\n    conn.commit();\n} catch(Exception e) {\n    conn.rollback();\n}\n```\n\nJavelin 中的 `DbContext` 可以结合 `ThreadLocal` 保证一个线程内的事务连接复用，并支持后续统一事务管理器拓展。\n\n**4. 单元测试困难**\n\n传统 JDBC 紧耦合真实连接，测试时需要真实数据库支持。\nJavelin 的抽象如 `DbContext` 与 `CPQuery` 均可通过接口注入和 Mock 替换，适合单元测试或内存数据库测试。\n\n正是以上这些痛点——重复性高、维护成本大、可测试性差、事务管理易错——推动我们一步步抽象出 CPQuery、DbContext、EntityFactory 等组件，形成 Javelin 当前结构清晰、职责明确的数据访问模型。\n\n# 整体设计思路\n\nJavelin 的数据访问层设计秉承“职责清晰、分层解耦、灵活适配”的核心思想，整个数据访问层围绕以下几个核心目标展开：\n\n1. 统一数据库连接管理：抽象数据库类型与连接池配置。\n\n2. 简化 SQL 执行逻辑：封装 JDBC 的模板化操作。\n\n3. 对象关系映射（ORM）初探：通过 BeanPropertyRowMapper 映射结果集。\n\n4. 提供声明式查询构造器：提升 SQL 的可读性与复用性。\n\n数据访问层主要由以下几个模块组成：\n\n```\ndata/\n├── DbConnManager.java        // 数据库连接池统一管理\n├── DbContext.java            // 提供数据库上下文环境（连接获取、关闭）\n├── command/\n│   ├── CPQuery.java          // 核心查询对象，封装 SQL 执行模板\n│   ├── CPQueryFactory.java   // 工厂类，创建 CPQuery 实例\n│   └── BeanPropertyRowMapper.java // 结果集映射工具\n├── config/\n│   └── DbConfigProvider.java // 数据库配置信息提供器\n└── DatabaseType.java         // 支持的数据库类型枚举\n```\n\n![框架](./images/javelin-dal/architecture.png)\n\n---\n\n# 核心类解析\n\n## DbConnManager：连接池统一管理\n\n`DbConnManager` 是一个典型的连接管理器类，负责初始化并维护数据库连接池（如 Druid、HikariCP）。它的职责包括：\n\n* 从配置加载数据库信息；\n* 创建与缓存连接池实例；\n* 提供 `DataSource` 给上层组件调用。\n\n**设计亮点**：\n\n* 将连接池隔离成可插拔模块，支持多数据库；\n* 懒加载初始化，优化资源占用；\n* 支持连接池复用，避免重复创建。\n\n---\n\n## DbContext：数据库上下文载体\n\n`DbContext` 承担着线程安全的数据库连接提供工作。它采用 `ThreadLocal` 管理当前线程的数据库连接，确保每个线程使用独立连接，避免并发问题。\n\n**设计亮点**：\n\n* 使用 `ThreadLocal<Connection>` 实现事务管理；\n* 提供 `getConnection()`、`close()` 等静态方法统一访问；\n* 解耦 SQL 执行逻辑与连接生命周期管理。\n\n---\n\n## CPQuery / CPQueryFactory：SQL 执行模板\n\n`CPQuery` 是项目中的 JDBC 模板核心类，类似 Spring 的 `JdbcTemplate`。它封装了 PreparedStatement 的参数绑定、SQL 执行、结果映射等常见流程：\n\n```java\nCPQuery query = CPQueryFactory.create()\n    .sql(\"SELECT * FROM user WHERE id = ?\")\n    .params(1);\n\nUser user = query.queryOne(User.class);\n```\n\n**设计亮点**：\n\n* 提供链式编程接口，构造直观简洁；\n* 支持 `queryList`, `queryOne`, `update`, `batch` 等通用操作；\n* 与 `DbContext` 解耦，使用者无需关心连接。\n\n---\n\n## BeanPropertyRowMapper：结果集自动映射\n\n这个类实现了一个轻量级的 ORM 映射逻辑。它根据 JDBC 返回的 `ResultSet` 字段，自动匹配 Java Bean 的属性并注入值，实现对象-关系映射：\n\n```java\npublic class User {\n    private Integer id;\n    private String name;\n}\n```\n\n通过反射完成映射，无需手动解析 ResultSet。\n\n**设计亮点**：\n\n* 利用反射技术，提高代码复用；\n* 遵循 JavaBean 命名规范，便于扩展；\n* 可替换为更复杂的 ORM 实现，如 MyBatis。\n\n---\n\n# 数据访问示例\n\n## 原生 SQL 查询\n\n* 保留原生 SQL 的控制力\n* 支持条件拼接、动态查询、分页等复杂需求\n* 设计灵活，可配合事务控制使用\n\n```java\npublic class EmployeeService {\n    public Employee getEmployee(int id) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n           CPQuery query = db.CPQuery().create(\"SELECT * FROM employees WHERE id = ?\", new Object[]{id});\n           return query.toSingle(Employee.class); \n        }\n    }\n\n    public int update(User user) {\n        return CPQueryFactory.create()\n            .sql(\"UPDATE user SET name = ? WHERE id = ?\")\n            .params(user.getName(), user.getId())\n            .update();\n    }\n}\n```\n\n整个过程无需编写冗余的 JDBC 模板代码，调用逻辑清晰直观。\n\n---\n## 基于实体的 CRUD 操作\nJavelin 框架的 DAL 设计支持基于实体的 CRUD 操作，包括：\n* 实体类定义与表结构映射\n* 基于实体的查询构造器\n* 统一的 CRUD 操作接口\n```java\npublic class EmployeeService {\n    public void create(Employee emp) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            db.Entity().create(Employee.class).insert(emp);\n        }\n    }\n\n    public int update(@FromBody Employee employee) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            return db.Entity().create(Employee.class).update(employee);\n        }\n    }\n\n    public Employee getById(@FromRoute int id) throws Exception {\n        return employeeService.getEmployeeEntity(id);\n    }\n\n    public int delete(@FromRoute int id) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            return db.Entity().create(Employee.class).delete(id);\n        }\n    }\n\n}\n```\n\n## 链式查询与条件拼接\n\n\n* 支持 `.where(...)`、`.andWhere(...)` 等链式查询\n* 通过注解映射自动完成字段匹配\n\n这种“类 Repository”风格的设计让每个实体的访问操作集中在一起，符合“按实体聚合 DAL 行为”的设计理念。虽然 Javelin 目前没有实现类似 Spring Data 的 Repository 自动代理机制，但通过 `EntityFactory` 创建出的 `Entity<T>` 实例，已经具备了类似的功能：\n\n* 用户无需手写 CRUD 实现，只需定义好实体类（如 User、Order）\n* 通过链式 API 即可完成查询、插入、更新、删除操作\n\n```java\npublic class EmployeeService {\n    public List<Employee> list() throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            return db.Entity().create(Employee.class)\n              .where(\"age >?\", 18)\n              .andWhere(\"name like?\", \"%张%\")\n              .orderBy(\"create_time desc\")\n        }\n    }\n}\n```\n因此，即便未实现自动代理机制，Javelin 仍然实现了 Repository 模式的核心价值：简洁、统一、按需调用。\n\n\n未来也可加入如下 DSL 风格支持：\n\n```java\n.where(e -> e.getAge() > 18)\n.and(e -> e.getName().contains(\"张\"))\n```\n---\n\n# 总结与展望\n\n通过本篇文章，我们构建了一个结构清晰、职责明确、支持类 LINQ 查询与原生 SQL 混用的微型 ORM 模块，涵盖：\n\n* 数据上下文（DbContext）\n* 注解驱动实体映射\n* 类 LINQ 查询接口\n* 原生 SQL 兼容查询器（CPQuery）\n\n下一篇文章中，我们将继续拓展对事务、Repository 模式以及自动代理注册的支持，进一步增强框架的工程化能力。\n\n敬请期待。\n","source":"_posts/javelin-dal.md","raw":"---\ntitle: 手写一个微型 Spring 框架（四）：数据访问层设计实战\ndate: 2025-05-12 14:55:12\ntags:\n---\n\n在前几篇文章中，我们已经完成了 Javelin 框架的核心功能构建，包括 HTTP 路由注册、注解扫描与 IoC 容器等内容。本篇将深入探讨 数据访问层（DAL，Data Access Layer） 的设计与实现，从理念到代码，全面展示如何在 Javelin 中构建一个灵活、可维护、可扩展的数据访问模块。\n\n---\n\n# 痛点驱动设计\n\n在构建 Javelin 的数据访问层过程中，我们并不是一开始就拥有完整的设计蓝图，而是源于开发过程中反复遇到的一些实际痛点。下面列举几个典型问题，并结合示例代码说明 Javelin 是如何逐一解决这些问题的：\n\n**1. JDBC 样板代码冗余、可读性差**\n\n原始写法：\n\n```java\nConnection conn = DriverManager.getConnection(url, user, pwd);\nPreparedStatement ps = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\nps.setInt(1, id);\nResultSet rs = ps.executeQuery();\nif (rs.next()) {\n    User user = new User();\n    user.setId(rs.getInt(\"id\"));\n    user.setName(rs.getString(\"name\"));\n    return user;\n}\n```\n\n问题：SQL 与 Java 混杂、资源管理复杂、字段映射重复。\n\nJavelin 写法：\n\n```java\nUser user = CPQueryFactory.create()\n    .sql(\"SELECT * FROM users WHERE id = ?\")\n    .params(id)\n    .queryOne(User.class);\n```\n\n通过 `CPQuery` 和 `BeanPropertyRowMapper` 简化了所有模板逻辑。\n\n**2. 手动管理连接生命周期，易出错**\n\n原始 JDBC 写法中，开发者需要自行处理连接关闭，若中间有异常，极易遗漏关闭：\n\n```java\ntry {\n    Connection conn = ...\n    // do something\n} catch (Exception e) {\n    // handle\n} finally {\n    conn.close(); // 容易忘记\n}\n```\n\nJavelin 使用 `DbContext` 实现 `AutoCloseable`，并结合 try-with-resources 自动释放资源：\n\n```java\ntry (DbContext db = DbConnManager.createAppDb(\"test\")) {\n    // safe use\n}\n```\n\n**3. 事务控制分散，耦合混乱**\n\n在 JDBC 中常见写法：\n\n```java\nconn.setAutoCommit(false);\ntry {\n    // 执行多条语句\n    conn.commit();\n} catch(Exception e) {\n    conn.rollback();\n}\n```\n\nJavelin 中的 `DbContext` 可以结合 `ThreadLocal` 保证一个线程内的事务连接复用，并支持后续统一事务管理器拓展。\n\n**4. 单元测试困难**\n\n传统 JDBC 紧耦合真实连接，测试时需要真实数据库支持。\nJavelin 的抽象如 `DbContext` 与 `CPQuery` 均可通过接口注入和 Mock 替换，适合单元测试或内存数据库测试。\n\n正是以上这些痛点——重复性高、维护成本大、可测试性差、事务管理易错——推动我们一步步抽象出 CPQuery、DbContext、EntityFactory 等组件，形成 Javelin 当前结构清晰、职责明确的数据访问模型。\n\n# 整体设计思路\n\nJavelin 的数据访问层设计秉承“职责清晰、分层解耦、灵活适配”的核心思想，整个数据访问层围绕以下几个核心目标展开：\n\n1. 统一数据库连接管理：抽象数据库类型与连接池配置。\n\n2. 简化 SQL 执行逻辑：封装 JDBC 的模板化操作。\n\n3. 对象关系映射（ORM）初探：通过 BeanPropertyRowMapper 映射结果集。\n\n4. 提供声明式查询构造器：提升 SQL 的可读性与复用性。\n\n数据访问层主要由以下几个模块组成：\n\n```\ndata/\n├── DbConnManager.java        // 数据库连接池统一管理\n├── DbContext.java            // 提供数据库上下文环境（连接获取、关闭）\n├── command/\n│   ├── CPQuery.java          // 核心查询对象，封装 SQL 执行模板\n│   ├── CPQueryFactory.java   // 工厂类，创建 CPQuery 实例\n│   └── BeanPropertyRowMapper.java // 结果集映射工具\n├── config/\n│   └── DbConfigProvider.java // 数据库配置信息提供器\n└── DatabaseType.java         // 支持的数据库类型枚举\n```\n\n![框架](./images/javelin-dal/architecture.png)\n\n---\n\n# 核心类解析\n\n## DbConnManager：连接池统一管理\n\n`DbConnManager` 是一个典型的连接管理器类，负责初始化并维护数据库连接池（如 Druid、HikariCP）。它的职责包括：\n\n* 从配置加载数据库信息；\n* 创建与缓存连接池实例；\n* 提供 `DataSource` 给上层组件调用。\n\n**设计亮点**：\n\n* 将连接池隔离成可插拔模块，支持多数据库；\n* 懒加载初始化，优化资源占用；\n* 支持连接池复用，避免重复创建。\n\n---\n\n## DbContext：数据库上下文载体\n\n`DbContext` 承担着线程安全的数据库连接提供工作。它采用 `ThreadLocal` 管理当前线程的数据库连接，确保每个线程使用独立连接，避免并发问题。\n\n**设计亮点**：\n\n* 使用 `ThreadLocal<Connection>` 实现事务管理；\n* 提供 `getConnection()`、`close()` 等静态方法统一访问；\n* 解耦 SQL 执行逻辑与连接生命周期管理。\n\n---\n\n## CPQuery / CPQueryFactory：SQL 执行模板\n\n`CPQuery` 是项目中的 JDBC 模板核心类，类似 Spring 的 `JdbcTemplate`。它封装了 PreparedStatement 的参数绑定、SQL 执行、结果映射等常见流程：\n\n```java\nCPQuery query = CPQueryFactory.create()\n    .sql(\"SELECT * FROM user WHERE id = ?\")\n    .params(1);\n\nUser user = query.queryOne(User.class);\n```\n\n**设计亮点**：\n\n* 提供链式编程接口，构造直观简洁；\n* 支持 `queryList`, `queryOne`, `update`, `batch` 等通用操作；\n* 与 `DbContext` 解耦，使用者无需关心连接。\n\n---\n\n## BeanPropertyRowMapper：结果集自动映射\n\n这个类实现了一个轻量级的 ORM 映射逻辑。它根据 JDBC 返回的 `ResultSet` 字段，自动匹配 Java Bean 的属性并注入值，实现对象-关系映射：\n\n```java\npublic class User {\n    private Integer id;\n    private String name;\n}\n```\n\n通过反射完成映射，无需手动解析 ResultSet。\n\n**设计亮点**：\n\n* 利用反射技术，提高代码复用；\n* 遵循 JavaBean 命名规范，便于扩展；\n* 可替换为更复杂的 ORM 实现，如 MyBatis。\n\n---\n\n# 数据访问示例\n\n## 原生 SQL 查询\n\n* 保留原生 SQL 的控制力\n* 支持条件拼接、动态查询、分页等复杂需求\n* 设计灵活，可配合事务控制使用\n\n```java\npublic class EmployeeService {\n    public Employee getEmployee(int id) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n           CPQuery query = db.CPQuery().create(\"SELECT * FROM employees WHERE id = ?\", new Object[]{id});\n           return query.toSingle(Employee.class); \n        }\n    }\n\n    public int update(User user) {\n        return CPQueryFactory.create()\n            .sql(\"UPDATE user SET name = ? WHERE id = ?\")\n            .params(user.getName(), user.getId())\n            .update();\n    }\n}\n```\n\n整个过程无需编写冗余的 JDBC 模板代码，调用逻辑清晰直观。\n\n---\n## 基于实体的 CRUD 操作\nJavelin 框架的 DAL 设计支持基于实体的 CRUD 操作，包括：\n* 实体类定义与表结构映射\n* 基于实体的查询构造器\n* 统一的 CRUD 操作接口\n```java\npublic class EmployeeService {\n    public void create(Employee emp) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            db.Entity().create(Employee.class).insert(emp);\n        }\n    }\n\n    public int update(@FromBody Employee employee) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            return db.Entity().create(Employee.class).update(employee);\n        }\n    }\n\n    public Employee getById(@FromRoute int id) throws Exception {\n        return employeeService.getEmployeeEntity(id);\n    }\n\n    public int delete(@FromRoute int id) throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            return db.Entity().create(Employee.class).delete(id);\n        }\n    }\n\n}\n```\n\n## 链式查询与条件拼接\n\n\n* 支持 `.where(...)`、`.andWhere(...)` 等链式查询\n* 通过注解映射自动完成字段匹配\n\n这种“类 Repository”风格的设计让每个实体的访问操作集中在一起，符合“按实体聚合 DAL 行为”的设计理念。虽然 Javelin 目前没有实现类似 Spring Data 的 Repository 自动代理机制，但通过 `EntityFactory` 创建出的 `Entity<T>` 实例，已经具备了类似的功能：\n\n* 用户无需手写 CRUD 实现，只需定义好实体类（如 User、Order）\n* 通过链式 API 即可完成查询、插入、更新、删除操作\n\n```java\npublic class EmployeeService {\n    public List<Employee> list() throws Exception {\n        try(DbContext db = DbConnManager.createAppDb(\"test\")) {\n            return db.Entity().create(Employee.class)\n              .where(\"age >?\", 18)\n              .andWhere(\"name like?\", \"%张%\")\n              .orderBy(\"create_time desc\")\n        }\n    }\n}\n```\n因此，即便未实现自动代理机制，Javelin 仍然实现了 Repository 模式的核心价值：简洁、统一、按需调用。\n\n\n未来也可加入如下 DSL 风格支持：\n\n```java\n.where(e -> e.getAge() > 18)\n.and(e -> e.getName().contains(\"张\"))\n```\n---\n\n# 总结与展望\n\n通过本篇文章，我们构建了一个结构清晰、职责明确、支持类 LINQ 查询与原生 SQL 混用的微型 ORM 模块，涵盖：\n\n* 数据上下文（DbContext）\n* 注解驱动实体映射\n* 类 LINQ 查询接口\n* 原生 SQL 兼容查询器（CPQuery）\n\n下一篇文章中，我们将继续拓展对事务、Repository 模式以及自动代理注册的支持，进一步增强框架的工程化能力。\n\n敬请期待。\n","slug":"javelin-dal","published":1,"updated":"2025-05-21T07:30:59.733Z","_id":"cmauqwsdx000018p10j2r38vq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在前几篇文章中，我们已经完成了 Javelin 框架的核心功能构建，包括 HTTP 路由注册、注解扫描与 IoC 容器等内容。本篇将深入探讨 数据访问层（DAL，Data Access Layer） 的设计与实现，从理念到代码，全面展示如何在 Javelin 中构建一个灵活、可维护、可扩展的数据访问模块。</p>\n<hr>\n<h1 id=\"痛点驱动设计\"><a href=\"#痛点驱动设计\" class=\"headerlink\" title=\"痛点驱动设计\"></a>痛点驱动设计</h1><p>在构建 Javelin 的数据访问层过程中，我们并不是一开始就拥有完整的设计蓝图，而是源于开发过程中反复遇到的一些实际痛点。下面列举几个典型问题，并结合示例代码说明 Javelin 是如何逐一解决这些问题的：</p>\n<p><strong>1. JDBC 样板代码冗余、可读性差</strong></p>\n<p>原始写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> DriverManager.getConnection(url, user, pwd);</span><br><span class=\"line\"><span class=\"type\">PreparedStatement</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> conn.prepareStatement(<span class=\"string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>);</span><br><span class=\"line\">ps.setInt(<span class=\"number\">1</span>, id);</span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">rs</span> <span class=\"operator\">=</span> ps.executeQuery();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (rs.next()) &#123;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setId(rs.getInt(<span class=\"string\">&quot;id&quot;</span>));</span><br><span class=\"line\">    user.setName(rs.getString(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题：SQL 与 Java 混杂、资源管理复杂、字段映射重复。</p>\n<p>Javelin 写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> CPQueryFactory.create()</span><br><span class=\"line\">    .sql(<span class=\"string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)</span><br><span class=\"line\">    .params(id)</span><br><span class=\"line\">    .queryOne(User.class);</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>CPQuery</code> 和 <code>BeanPropertyRowMapper</code> 简化了所有模板逻辑。</p>\n<p><strong>2. 手动管理连接生命周期，易出错</strong></p>\n<p>原始 JDBC 写法中，开发者需要自行处理连接关闭，若中间有异常，极易遗漏关闭：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> ...</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    conn.close(); <span class=\"comment\">// 容易忘记</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Javelin 使用 <code>DbContext</code> 实现 <code>AutoCloseable</code>，并结合 try-with-resources 自动释放资源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// safe use</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. 事务控制分散，耦合混乱</strong></p>\n<p>在 JDBC 中常见写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn.setAutoCommit(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行多条语句</span></span><br><span class=\"line\">    conn.commit();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    conn.rollback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Javelin 中的 <code>DbContext</code> 可以结合 <code>ThreadLocal</code> 保证一个线程内的事务连接复用，并支持后续统一事务管理器拓展。</p>\n<p><strong>4. 单元测试困难</strong></p>\n<p>传统 JDBC 紧耦合真实连接，测试时需要真实数据库支持。<br>Javelin 的抽象如 <code>DbContext</code> 与 <code>CPQuery</code> 均可通过接口注入和 Mock 替换，适合单元测试或内存数据库测试。</p>\n<p>正是以上这些痛点——重复性高、维护成本大、可测试性差、事务管理易错——推动我们一步步抽象出 CPQuery、DbContext、EntityFactory 等组件，形成 Javelin 当前结构清晰、职责明确的数据访问模型。</p>\n<h1 id=\"整体设计思路\"><a href=\"#整体设计思路\" class=\"headerlink\" title=\"整体设计思路\"></a>整体设计思路</h1><p>Javelin 的数据访问层设计秉承“职责清晰、分层解耦、灵活适配”的核心思想，整个数据访问层围绕以下几个核心目标展开：</p>\n<ol>\n<li><p>统一数据库连接管理：抽象数据库类型与连接池配置。</p>\n</li>\n<li><p>简化 SQL 执行逻辑：封装 JDBC 的模板化操作。</p>\n</li>\n<li><p>对象关系映射（ORM）初探：通过 BeanPropertyRowMapper 映射结果集。</p>\n</li>\n<li><p>提供声明式查询构造器：提升 SQL 的可读性与复用性。</p>\n</li>\n</ol>\n<p>数据访问层主要由以下几个模块组成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data/</span><br><span class=\"line\">├── DbConnManager.java        // 数据库连接池统一管理</span><br><span class=\"line\">├── DbContext.java            // 提供数据库上下文环境（连接获取、关闭）</span><br><span class=\"line\">├── command/</span><br><span class=\"line\">│   ├── CPQuery.java          // 核心查询对象，封装 SQL 执行模板</span><br><span class=\"line\">│   ├── CPQueryFactory.java   // 工厂类，创建 CPQuery 实例</span><br><span class=\"line\">│   └── BeanPropertyRowMapper.java // 结果集映射工具</span><br><span class=\"line\">├── config/</span><br><span class=\"line\">│   └── DbConfigProvider.java // 数据库配置信息提供器</span><br><span class=\"line\">└── DatabaseType.java         // 支持的数据库类型枚举</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/javelin-dal/architecture.png\" alt=\"框架\"></p>\n<hr>\n<h1 id=\"核心类解析\"><a href=\"#核心类解析\" class=\"headerlink\" title=\"核心类解析\"></a>核心类解析</h1><h2 id=\"DbConnManager：连接池统一管理\"><a href=\"#DbConnManager：连接池统一管理\" class=\"headerlink\" title=\"DbConnManager：连接池统一管理\"></a>DbConnManager：连接池统一管理</h2><p><code>DbConnManager</code> 是一个典型的连接管理器类，负责初始化并维护数据库连接池（如 Druid、HikariCP）。它的职责包括：</p>\n<ul>\n<li>从配置加载数据库信息；</li>\n<li>创建与缓存连接池实例；</li>\n<li>提供 <code>DataSource</code> 给上层组件调用。</li>\n</ul>\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>将连接池隔离成可插拔模块，支持多数据库；</li>\n<li>懒加载初始化，优化资源占用；</li>\n<li>支持连接池复用，避免重复创建。</li>\n</ul>\n<hr>\n<h2 id=\"DbContext：数据库上下文载体\"><a href=\"#DbContext：数据库上下文载体\" class=\"headerlink\" title=\"DbContext：数据库上下文载体\"></a>DbContext：数据库上下文载体</h2><p><code>DbContext</code> 承担着线程安全的数据库连接提供工作。它采用 <code>ThreadLocal</code> 管理当前线程的数据库连接，确保每个线程使用独立连接，避免并发问题。</p>\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>使用 <code>ThreadLocal&lt;Connection&gt;</code> 实现事务管理；</li>\n<li>提供 <code>getConnection()</code>、<code>close()</code> 等静态方法统一访问；</li>\n<li>解耦 SQL 执行逻辑与连接生命周期管理。</li>\n</ul>\n<hr>\n<h2 id=\"CPQuery-CPQueryFactory：SQL-执行模板\"><a href=\"#CPQuery-CPQueryFactory：SQL-执行模板\" class=\"headerlink\" title=\"CPQuery &#x2F; CPQueryFactory：SQL 执行模板\"></a>CPQuery &#x2F; CPQueryFactory：SQL 执行模板</h2><p><code>CPQuery</code> 是项目中的 JDBC 模板核心类，类似 Spring 的 <code>JdbcTemplate</code>。它封装了 PreparedStatement 的参数绑定、SQL 执行、结果映射等常见流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CPQuery</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> CPQueryFactory.create()</span><br><span class=\"line\">    .sql(<span class=\"string\">&quot;SELECT * FROM user WHERE id = ?&quot;</span>)</span><br><span class=\"line\">    .params(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> query.queryOne(User.class);</span><br></pre></td></tr></table></figure>\n\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>提供链式编程接口，构造直观简洁；</li>\n<li>支持 <code>queryList</code>, <code>queryOne</code>, <code>update</code>, <code>batch</code> 等通用操作；</li>\n<li>与 <code>DbContext</code> 解耦，使用者无需关心连接。</li>\n</ul>\n<hr>\n<h2 id=\"BeanPropertyRowMapper：结果集自动映射\"><a href=\"#BeanPropertyRowMapper：结果集自动映射\" class=\"headerlink\" title=\"BeanPropertyRowMapper：结果集自动映射\"></a>BeanPropertyRowMapper：结果集自动映射</h2><p>这个类实现了一个轻量级的 ORM 映射逻辑。它根据 JDBC 返回的 <code>ResultSet</code> 字段，自动匹配 Java Bean 的属性并注入值，实现对象-关系映射：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过反射完成映射，无需手动解析 ResultSet。</p>\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>利用反射技术，提高代码复用；</li>\n<li>遵循 JavaBean 命名规范，便于扩展；</li>\n<li>可替换为更复杂的 ORM 实现，如 MyBatis。</li>\n</ul>\n<hr>\n<h1 id=\"数据访问示例\"><a href=\"#数据访问示例\" class=\"headerlink\" title=\"数据访问示例\"></a>数据访问示例</h1><h2 id=\"原生-SQL-查询\"><a href=\"#原生-SQL-查询\" class=\"headerlink\" title=\"原生 SQL 查询\"></a>原生 SQL 查询</h2><ul>\n<li>保留原生 SQL 的控制力</li>\n<li>支持条件拼接、动态查询、分页等复杂需求</li>\n<li>设计灵活，可配合事务控制使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Employee <span class=\"title function_\">getEmployee</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">           <span class=\"type\">CPQuery</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> db.CPQuery().create(<span class=\"string\">&quot;SELECT * FROM employees WHERE id = ?&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;id&#125;);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> query.toSingle(Employee.class); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">update</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CPQueryFactory.create()</span><br><span class=\"line\">            .sql(<span class=\"string\">&quot;UPDATE user SET name = ? WHERE id = ?&quot;</span>)</span><br><span class=\"line\">            .params(user.getName(), user.getId())</span><br><span class=\"line\">            .update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整个过程无需编写冗余的 JDBC 模板代码，调用逻辑清晰直观。</p>\n<hr>\n<h2 id=\"基于实体的-CRUD-操作\"><a href=\"#基于实体的-CRUD-操作\" class=\"headerlink\" title=\"基于实体的 CRUD 操作\"></a>基于实体的 CRUD 操作</h2><p>Javelin 框架的 DAL 设计支持基于实体的 CRUD 操作，包括：</p>\n<ul>\n<li>实体类定义与表结构映射</li>\n<li>基于实体的查询构造器</li>\n<li>统一的 CRUD 操作接口<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(Employee emp)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            db.Entity().create(Employee.class).insert(emp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"meta\">@FromBody</span> Employee employee)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> db.Entity().create(Employee.class).update(employee);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Employee <span class=\"title function_\">getById</span><span class=\"params\">(<span class=\"meta\">@FromRoute</span> <span class=\"type\">int</span> id)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> employeeService.getEmployeeEntity(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">delete</span><span class=\"params\">(<span class=\"meta\">@FromRoute</span> <span class=\"type\">int</span> id)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> db.Entity().create(Employee.class).delete(id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"链式查询与条件拼接\"><a href=\"#链式查询与条件拼接\" class=\"headerlink\" title=\"链式查询与条件拼接\"></a>链式查询与条件拼接</h2><ul>\n<li>支持 <code>.where(...)</code>、<code>.andWhere(...)</code> 等链式查询</li>\n<li>通过注解映射自动完成字段匹配</li>\n</ul>\n<p>这种“类 Repository”风格的设计让每个实体的访问操作集中在一起，符合“按实体聚合 DAL 行为”的设计理念。虽然 Javelin 目前没有实现类似 Spring Data 的 Repository 自动代理机制，但通过 <code>EntityFactory</code> 创建出的 <code>Entity&lt;T&gt;</code> 实例，已经具备了类似的功能：</p>\n<ul>\n<li>用户无需手写 CRUD 实现，只需定义好实体类（如 User、Order）</li>\n<li>通过链式 API 即可完成查询、插入、更新、删除操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Employee&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> db.Entity().create(Employee.class)</span><br><span class=\"line\">              .where(<span class=\"string\">&quot;age &gt;?&quot;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\">              .andWhere(<span class=\"string\">&quot;name like?&quot;</span>, <span class=\"string\">&quot;%张%&quot;</span>)</span><br><span class=\"line\">              .orderBy(<span class=\"string\">&quot;create_time desc&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此，即便未实现自动代理机制，Javelin 仍然实现了 Repository 模式的核心价值：简洁、统一、按需调用。</p>\n<p>未来也可加入如下 DSL 风格支持：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.where(e -&gt; e.getAge() &gt; <span class=\"number\">18</span>)</span><br><span class=\"line\">.and(e -&gt; e.getName().contains(<span class=\"string\">&quot;张&quot;</span>))</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h1><p>通过本篇文章，我们构建了一个结构清晰、职责明确、支持类 LINQ 查询与原生 SQL 混用的微型 ORM 模块，涵盖：</p>\n<ul>\n<li>数据上下文（DbContext）</li>\n<li>注解驱动实体映射</li>\n<li>类 LINQ 查询接口</li>\n<li>原生 SQL 兼容查询器（CPQuery）</li>\n</ul>\n<p>下一篇文章中，我们将继续拓展对事务、Repository 模式以及自动代理注册的支持，进一步增强框架的工程化能力。</p>\n<p>敬请期待。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前几篇文章中，我们已经完成了 Javelin 框架的核心功能构建，包括 HTTP 路由注册、注解扫描与 IoC 容器等内容。本篇将深入探讨 数据访问层（DAL，Data Access Layer） 的设计与实现，从理念到代码，全面展示如何在 Javelin 中构建一个灵活、可维护、可扩展的数据访问模块。</p>\n<hr>\n<h1 id=\"痛点驱动设计\"><a href=\"#痛点驱动设计\" class=\"headerlink\" title=\"痛点驱动设计\"></a>痛点驱动设计</h1><p>在构建 Javelin 的数据访问层过程中，我们并不是一开始就拥有完整的设计蓝图，而是源于开发过程中反复遇到的一些实际痛点。下面列举几个典型问题，并结合示例代码说明 Javelin 是如何逐一解决这些问题的：</p>\n<p><strong>1. JDBC 样板代码冗余、可读性差</strong></p>\n<p>原始写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> DriverManager.getConnection(url, user, pwd);</span><br><span class=\"line\"><span class=\"type\">PreparedStatement</span> <span class=\"variable\">ps</span> <span class=\"operator\">=</span> conn.prepareStatement(<span class=\"string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>);</span><br><span class=\"line\">ps.setInt(<span class=\"number\">1</span>, id);</span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">rs</span> <span class=\"operator\">=</span> ps.executeQuery();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (rs.next()) &#123;</span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setId(rs.getInt(<span class=\"string\">&quot;id&quot;</span>));</span><br><span class=\"line\">    user.setName(rs.getString(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题：SQL 与 Java 混杂、资源管理复杂、字段映射重复。</p>\n<p>Javelin 写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> CPQueryFactory.create()</span><br><span class=\"line\">    .sql(<span class=\"string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)</span><br><span class=\"line\">    .params(id)</span><br><span class=\"line\">    .queryOne(User.class);</span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>CPQuery</code> 和 <code>BeanPropertyRowMapper</code> 简化了所有模板逻辑。</p>\n<p><strong>2. 手动管理连接生命周期，易出错</strong></p>\n<p>原始 JDBC 写法中，开发者需要自行处理连接关闭，若中间有异常，极易遗漏关闭：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> ...</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    conn.close(); <span class=\"comment\">// 容易忘记</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Javelin 使用 <code>DbContext</code> 实现 <code>AutoCloseable</code>，并结合 try-with-resources 自动释放资源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// safe use</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. 事务控制分散，耦合混乱</strong></p>\n<p>在 JDBC 中常见写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn.setAutoCommit(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行多条语句</span></span><br><span class=\"line\">    conn.commit();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    conn.rollback();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Javelin 中的 <code>DbContext</code> 可以结合 <code>ThreadLocal</code> 保证一个线程内的事务连接复用，并支持后续统一事务管理器拓展。</p>\n<p><strong>4. 单元测试困难</strong></p>\n<p>传统 JDBC 紧耦合真实连接，测试时需要真实数据库支持。<br>Javelin 的抽象如 <code>DbContext</code> 与 <code>CPQuery</code> 均可通过接口注入和 Mock 替换，适合单元测试或内存数据库测试。</p>\n<p>正是以上这些痛点——重复性高、维护成本大、可测试性差、事务管理易错——推动我们一步步抽象出 CPQuery、DbContext、EntityFactory 等组件，形成 Javelin 当前结构清晰、职责明确的数据访问模型。</p>\n<h1 id=\"整体设计思路\"><a href=\"#整体设计思路\" class=\"headerlink\" title=\"整体设计思路\"></a>整体设计思路</h1><p>Javelin 的数据访问层设计秉承“职责清晰、分层解耦、灵活适配”的核心思想，整个数据访问层围绕以下几个核心目标展开：</p>\n<ol>\n<li><p>统一数据库连接管理：抽象数据库类型与连接池配置。</p>\n</li>\n<li><p>简化 SQL 执行逻辑：封装 JDBC 的模板化操作。</p>\n</li>\n<li><p>对象关系映射（ORM）初探：通过 BeanPropertyRowMapper 映射结果集。</p>\n</li>\n<li><p>提供声明式查询构造器：提升 SQL 的可读性与复用性。</p>\n</li>\n</ol>\n<p>数据访问层主要由以下几个模块组成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data/</span><br><span class=\"line\">├── DbConnManager.java        // 数据库连接池统一管理</span><br><span class=\"line\">├── DbContext.java            // 提供数据库上下文环境（连接获取、关闭）</span><br><span class=\"line\">├── command/</span><br><span class=\"line\">│   ├── CPQuery.java          // 核心查询对象，封装 SQL 执行模板</span><br><span class=\"line\">│   ├── CPQueryFactory.java   // 工厂类，创建 CPQuery 实例</span><br><span class=\"line\">│   └── BeanPropertyRowMapper.java // 结果集映射工具</span><br><span class=\"line\">├── config/</span><br><span class=\"line\">│   └── DbConfigProvider.java // 数据库配置信息提供器</span><br><span class=\"line\">└── DatabaseType.java         // 支持的数据库类型枚举</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/javelin-dal/architecture.png\" alt=\"框架\"></p>\n<hr>\n<h1 id=\"核心类解析\"><a href=\"#核心类解析\" class=\"headerlink\" title=\"核心类解析\"></a>核心类解析</h1><h2 id=\"DbConnManager：连接池统一管理\"><a href=\"#DbConnManager：连接池统一管理\" class=\"headerlink\" title=\"DbConnManager：连接池统一管理\"></a>DbConnManager：连接池统一管理</h2><p><code>DbConnManager</code> 是一个典型的连接管理器类，负责初始化并维护数据库连接池（如 Druid、HikariCP）。它的职责包括：</p>\n<ul>\n<li>从配置加载数据库信息；</li>\n<li>创建与缓存连接池实例；</li>\n<li>提供 <code>DataSource</code> 给上层组件调用。</li>\n</ul>\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>将连接池隔离成可插拔模块，支持多数据库；</li>\n<li>懒加载初始化，优化资源占用；</li>\n<li>支持连接池复用，避免重复创建。</li>\n</ul>\n<hr>\n<h2 id=\"DbContext：数据库上下文载体\"><a href=\"#DbContext：数据库上下文载体\" class=\"headerlink\" title=\"DbContext：数据库上下文载体\"></a>DbContext：数据库上下文载体</h2><p><code>DbContext</code> 承担着线程安全的数据库连接提供工作。它采用 <code>ThreadLocal</code> 管理当前线程的数据库连接，确保每个线程使用独立连接，避免并发问题。</p>\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>使用 <code>ThreadLocal&lt;Connection&gt;</code> 实现事务管理；</li>\n<li>提供 <code>getConnection()</code>、<code>close()</code> 等静态方法统一访问；</li>\n<li>解耦 SQL 执行逻辑与连接生命周期管理。</li>\n</ul>\n<hr>\n<h2 id=\"CPQuery-CPQueryFactory：SQL-执行模板\"><a href=\"#CPQuery-CPQueryFactory：SQL-执行模板\" class=\"headerlink\" title=\"CPQuery &#x2F; CPQueryFactory：SQL 执行模板\"></a>CPQuery &#x2F; CPQueryFactory：SQL 执行模板</h2><p><code>CPQuery</code> 是项目中的 JDBC 模板核心类，类似 Spring 的 <code>JdbcTemplate</code>。它封装了 PreparedStatement 的参数绑定、SQL 执行、结果映射等常见流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CPQuery</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> CPQueryFactory.create()</span><br><span class=\"line\">    .sql(<span class=\"string\">&quot;SELECT * FROM user WHERE id = ?&quot;</span>)</span><br><span class=\"line\">    .params(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> query.queryOne(User.class);</span><br></pre></td></tr></table></figure>\n\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>提供链式编程接口，构造直观简洁；</li>\n<li>支持 <code>queryList</code>, <code>queryOne</code>, <code>update</code>, <code>batch</code> 等通用操作；</li>\n<li>与 <code>DbContext</code> 解耦，使用者无需关心连接。</li>\n</ul>\n<hr>\n<h2 id=\"BeanPropertyRowMapper：结果集自动映射\"><a href=\"#BeanPropertyRowMapper：结果集自动映射\" class=\"headerlink\" title=\"BeanPropertyRowMapper：结果集自动映射\"></a>BeanPropertyRowMapper：结果集自动映射</h2><p>这个类实现了一个轻量级的 ORM 映射逻辑。它根据 JDBC 返回的 <code>ResultSet</code> 字段，自动匹配 Java Bean 的属性并注入值，实现对象-关系映射：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过反射完成映射，无需手动解析 ResultSet。</p>\n<p><strong>设计亮点</strong>：</p>\n<ul>\n<li>利用反射技术，提高代码复用；</li>\n<li>遵循 JavaBean 命名规范，便于扩展；</li>\n<li>可替换为更复杂的 ORM 实现，如 MyBatis。</li>\n</ul>\n<hr>\n<h1 id=\"数据访问示例\"><a href=\"#数据访问示例\" class=\"headerlink\" title=\"数据访问示例\"></a>数据访问示例</h1><h2 id=\"原生-SQL-查询\"><a href=\"#原生-SQL-查询\" class=\"headerlink\" title=\"原生 SQL 查询\"></a>原生 SQL 查询</h2><ul>\n<li>保留原生 SQL 的控制力</li>\n<li>支持条件拼接、动态查询、分页等复杂需求</li>\n<li>设计灵活，可配合事务控制使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Employee <span class=\"title function_\">getEmployee</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">           <span class=\"type\">CPQuery</span> <span class=\"variable\">query</span> <span class=\"operator\">=</span> db.CPQuery().create(<span class=\"string\">&quot;SELECT * FROM employees WHERE id = ?&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;id&#125;);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> query.toSingle(Employee.class); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">update</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CPQueryFactory.create()</span><br><span class=\"line\">            .sql(<span class=\"string\">&quot;UPDATE user SET name = ? WHERE id = ?&quot;</span>)</span><br><span class=\"line\">            .params(user.getName(), user.getId())</span><br><span class=\"line\">            .update();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整个过程无需编写冗余的 JDBC 模板代码，调用逻辑清晰直观。</p>\n<hr>\n<h2 id=\"基于实体的-CRUD-操作\"><a href=\"#基于实体的-CRUD-操作\" class=\"headerlink\" title=\"基于实体的 CRUD 操作\"></a>基于实体的 CRUD 操作</h2><p>Javelin 框架的 DAL 设计支持基于实体的 CRUD 操作，包括：</p>\n<ul>\n<li>实体类定义与表结构映射</li>\n<li>基于实体的查询构造器</li>\n<li>统一的 CRUD 操作接口<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">(Employee emp)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            db.Entity().create(Employee.class).insert(emp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">update</span><span class=\"params\">(<span class=\"meta\">@FromBody</span> Employee employee)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> db.Entity().create(Employee.class).update(employee);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Employee <span class=\"title function_\">getById</span><span class=\"params\">(<span class=\"meta\">@FromRoute</span> <span class=\"type\">int</span> id)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> employeeService.getEmployeeEntity(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">delete</span><span class=\"params\">(<span class=\"meta\">@FromRoute</span> <span class=\"type\">int</span> id)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> db.Entity().create(Employee.class).delete(id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"链式查询与条件拼接\"><a href=\"#链式查询与条件拼接\" class=\"headerlink\" title=\"链式查询与条件拼接\"></a>链式查询与条件拼接</h2><ul>\n<li>支持 <code>.where(...)</code>、<code>.andWhere(...)</code> 等链式查询</li>\n<li>通过注解映射自动完成字段匹配</li>\n</ul>\n<p>这种“类 Repository”风格的设计让每个实体的访问操作集中在一起，符合“按实体聚合 DAL 行为”的设计理念。虽然 Javelin 目前没有实现类似 Spring Data 的 Repository 自动代理机制，但通过 <code>EntityFactory</code> 创建出的 <code>Entity&lt;T&gt;</code> 实例，已经具备了类似的功能：</p>\n<ul>\n<li>用户无需手写 CRUD 实现，只需定义好实体类（如 User、Order）</li>\n<li>通过链式 API 即可完成查询、插入、更新、删除操作</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Employee&gt; <span class=\"title function_\">list</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(<span class=\"type\">DbContext</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> DbConnManager.createAppDb(<span class=\"string\">&quot;test&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> db.Entity().create(Employee.class)</span><br><span class=\"line\">              .where(<span class=\"string\">&quot;age &gt;?&quot;</span>, <span class=\"number\">18</span>)</span><br><span class=\"line\">              .andWhere(<span class=\"string\">&quot;name like?&quot;</span>, <span class=\"string\">&quot;%张%&quot;</span>)</span><br><span class=\"line\">              .orderBy(<span class=\"string\">&quot;create_time desc&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此，即便未实现自动代理机制，Javelin 仍然实现了 Repository 模式的核心价值：简洁、统一、按需调用。</p>\n<p>未来也可加入如下 DSL 风格支持：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.where(e -&gt; e.getAge() &gt; <span class=\"number\">18</span>)</span><br><span class=\"line\">.and(e -&gt; e.getName().contains(<span class=\"string\">&quot;张&quot;</span>))</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h1><p>通过本篇文章，我们构建了一个结构清晰、职责明确、支持类 LINQ 查询与原生 SQL 混用的微型 ORM 模块，涵盖：</p>\n<ul>\n<li>数据上下文（DbContext）</li>\n<li>注解驱动实体映射</li>\n<li>类 LINQ 查询接口</li>\n<li>原生 SQL 兼容查询器（CPQuery）</li>\n</ul>\n<p>下一篇文章中，我们将继续拓展对事务、Repository 模式以及自动代理注册的支持，进一步增强框架的工程化能力。</p>\n<p>敬请期待。</p>\n"},{"title":"手写一个微型 Spring 框架（五）：单元测试实践","date":"2025-05-23T08:14:04.000Z","_content":"\n前面我们马不停蹄地实现了 Javelin 框架的许多基础功能。从 HTTP 路由、IoC 容器、注解扫描到数据库访问层，像是在快速奔跑、不断构建着新的地基。但到了某个时刻，我在想是不是应该停下来，回头看看。就像赵雷在《静下来》中唱的那样：\n\n> 我想应该静下来走一段路\n>\n> 我想应该静下来看一本书\n>\n> 我只想静下来做这些事\n>\n> ...\n>\n> 我只想静下来去反省自己\n\n![赵雷](./images/javelin-unit-testing/zhaolei.png)\n\n当我在 IDE 中一行行堆砌代码的时候，突然哼起这首歌，意识到，是时候慢下来——看看自己已经写了什么，有哪些内容真正被验证过，哪些又仅停留在“自信”层面。这篇文章正是在这种状态下写出来的，它或许谈不上多全面的反思，但却记录了我作为框架开发者，在某个时刻静下心来去梳理测试体系的过程。它更像是一份实践记录，一份对“测试意识”的回归笔记。\n\n我们为什么要做单元测试？在这个自建的 Java 框架中，又该如何落地？\n\n---\n\n# 为什么要做单元测试？\n\n单元测试是保障代码质量和持续演进能力的基石。尤其对于框架类项目来说，没有测试就没有安全地“改动”。Javelin 在不断完善功能的同时，如果没有测试作为护栏，每一次功能迭代都可能带来雪崩式风险。\n\n## 📌 原因 1：防止回归\n\n当你的框架被多个业务模块引用，任何一次调整都可能像蝴蝶效应一样影响下游模块。单元测试就像是自动化的“防线”：一旦行为偏离预期，立即发出警报。\n\n## 📌 原因 2：确保逻辑一致性\n\n你写的每一个公共方法、每一个输入输出契约，是否在各种边界条件下都表现正确？手动验证只能覆盖有限场景，而单元测试可以系统、可重复地校验行为。\n\n## 📌 原因 3：促进架构解耦\n\n一个类如果很难被测试，往往意味着它耦合过重。测试驱动设计反过来可以推动我们写出更清晰、更模块化的代码。\n\n## 📌 原因 4：文档即测试\n\n单元测试本质上也是“代码的使用说明书”。别人阅读你的测试用例，比阅读文档更能快速理解接口怎么用、预期行为是什么。\n\n## 📌 原因 5：提高开发信心和效率\n\n当你在一个已有完善单元测试的项目上工作时，每次修改代码都能立即获得验证反馈。你不需要担心“我改了这个会不会影响那个”，只要测试全绿，就可以安心发布。\n\n---\n\n# 基本原则和规范\n\n为了让测试既有效又具备长期维护性，我们在编写 Javelin 的测试时遵循了以下几个核心原则：\n\n## ✅ 原则 1：快速执行\n\n测试应该运行快速，控制在毫秒或秒级，避免依赖真实网络或数据库等慢资源。\n\n## ✅ 原则 2：完全自动化\n\n测试应该一键运行，不依赖人工介入或配置切换，可用于 CI/CD 持续集成场景。\n\n## ✅ 原则 3：只测试单一功能\n\n一个测试用例应聚焦一个功能点，确保测试失败时能快速定位问题源头，避免“一炸炸全家”。\n\n## ✅ 原则 4：避免测试间互相依赖\n\n每个测试都应具备“自给自足性”，不会依赖其他测试先运行成功。\n\n## ✅ 原则 5：断言清晰明确\n\n使用 `assertEquals`、`assertThrows` 等断言 API 明确表达预期行为，减少测试意图歧义。\n\n## ✅ 原则 6：Mock 外部依赖\n\n凡是框架外部（如数据库、文件系统、网络请求）一律 mock 掉，测试只聚焦本类的业务逻辑。\n\n## ✅ 原则 7：保持可读性\n\n测试代码应像示例代码一样易读，变量命名清晰，测试结构一致，可作为“使用手册”供参考。\n\n通过遵循这些原则，我们能确保测试本身具备可维护性、可演进性，并成为代码质量的重要护栏。\n\n\n\n---\n\n# 如何在 Javelin 中做单元测试？\n\nJavelin 涉及很多对外依赖，例如 JDBC、连接池、数据源管理、ORM 映射等，因此测试方式需要结合 Mock 技术、代理机制、覆盖率工具来系统搭建。由于对 Java 生态的不熟悉，技术选型基本上只能通过网络上各种文章的对比与社区经验总结，逐步探索出一套适合自己项目的测试组合方式。\n\n## ✅ 使用 JUnit 5 + Mockito\n\n我们选择了现代 Java 测试组合：\n\n* **JUnit 5**：模块化、注解丰富、支持 Lambda、兼容 Gradle\n* **Mockito**：业界主流 Mock 框架，能轻松隔离外部依赖\n\n```groovy\nplugins {\n    id 'java-library'\n    id 'jacoco'\n}\n\ndependencies {\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'\n    testImplementation 'org.mockito:mockito-core:5.10.0'\n}\n```\n\n## ✅ 对静态依赖使用 Proxy 技术隔离\n\n例如 `DbConfigProvider.getAppDbConfig(...)` 这类静态方法无法直接被 mock。我们通过引入 `DbConnManagerProxy` 类，将原始逻辑包装，并注入 mock 结果，以达到“替身测试”的目的。这种方式兼顾不修改生产代码又能可测的平衡。\n\n## ✅ Mock 掉数据库相关依赖\n\n我们通过 Mockito 模拟 `Connection`、`DataSource`、`DbConfig` 等对象，避免测试中实际连数据库，同时可以验证连接是否被正确获取、是否按期望关闭。\n\n## ✅ 集成 JaCoCo 生成覆盖率报告\n\n我们使用 Gradle 的 `jacoco` 插件自动生成测试覆盖率报告：\n\n```groovy\njacocoTestReport {\n    dependsOn test\n    reports {\n        html.required.set(true)\n    }\n}\n```\n\n运行 `./gradlew test jacocoTestReport` 后，打开：\n\n```\nbuild/reports/jacoco/test/html/index.html\n```\n\n即可看到每个类、每个方法的覆盖率信息。\n![jacoco](./images/javelin-unit-testing/jacoco.png)\n\nJaCoCo 还能输出 XML 报告供 SonarQube 或 GitHub Actions 使用，后续我们也将集成 CI 中的覆盖率检查。\n\n---\n\n## 实践案例：测试 DbContext\n\n```java\n@Test\nvoid testClose_shouldCloseConnection() throws Exception {\n    Connection mockConnection = mock(Connection.class);\n    DataSource mockDataSource = mock(DataSource.class);\n    when(mockDataSource.getConnection()).thenReturn(mockConnection);\n\n    DbContext dbContext = new DbContext(mockDataSource);\n    dbContext.openConnection();\n    dbContext.close();\n\n    verify(mockConnection).close();\n}\n```\n\n该测试用例验证 `DbContext` 是否在 `.close()` 时能如期关闭连接。\n\n你也可以进一步测试连接未初始化时的行为，或反复打开关闭是否存在连接泄露风险。\n\n我们还可以测试 `.getConnection()` 是否懒加载、是否缓存连接、是否线程安全等高级特性。\n\n---\n\n# 进一步的测试实践\n\nJavelin 中的测试不仅仅覆盖正向路径，还包括：\n\n* **异常分支**：例如数据库连接失败时是否能抛出自定义异常？\n* **缓存逻辑**：配置缓存是否命中？配置变更是否生效？\n* **事务机制**：未来加入事务后，我们将通过 ThreadLocal 控制多操作是否共享连接，并断言事务是否提交/回滚。\n* **映射行为**：`BeanPropertyRowMapper` 是否能正确映射字段与 JavaBean 属性？是否支持 null 值？字段名大小写不一致是否能处理？\n* **链式查询 DSL**：测试 where/andWhere/orderBy 等语法是否能正确拼接 SQL，是否支持参数绑定和分页功能。\n\n---\n\n# 拓展：TDD\n\n在实践中我们发现，要写出一个高质量、边界明确、断言清晰、可维护的测试用例，往往比直接实现某个功能要花费更多精力。例如，为了验证一个 SQL 构造器能正确拼接分页语句，我们要写出 mock 数据源、预期参数、模拟连接返回、构造 ResultSet 的行为等大量前置条件。这也正是许多团队虽然强调测试，但却往往难以落地的原因之一。\n\nTDD（Test-Driven Development，测试驱动开发）是一种以测试为设计导向的软件开发方法论。它的核心思想是：**先写测试，再写实现，最后重构**。\n\nTDD 并不仅仅是一种测试方式，它更是一种编程思维。提前设计好测试的各种场景，再进行真是业务代码的实现。让我们在编写代码时，更关注如何让测试通过，而不是在实现功能后考虑如何测试。TDD 给我们的回报是长远的：它让我们思考“我真正要实现的是什么”，让代码变得更可用、更易测、更稳定。虽然覆盖率数字本身并不能代表一切，但它背后的那份“可验证的信心”，才是 TDD 真正想传达的价值。\n\n![TDD](./images/javelin-unit-testing/tdd.jpg)\n\n\n在 Javelin 的后续开发和重构过程中，我们逐渐尝试引入 TDD 的流程：\n\n1. **写一个失败的测试**：思考我们想要实现的功能是什么，先写一个对应的测试用例（它一定会失败，因为实现还不存在）。\n\n2. **快速实现使测试通过**：只实现刚好能让测试通过的最小逻辑。\n\n3. **重构代码结构**：在不改变测试结果的前提下重构代码，让其更简洁、更可维护。\n\n通过 TDD，我们获得了几个关键收益：\n\n* 代码设计更聚焦目标；\n* 测试用例成为开发文档；\n* 实现不偏离预期，测试成为开发的“驱动轮”。\n\n例如在实现 `CPQuery.toList()` 方法时，我们先写出期望的查询行为和数据结构，然后再去补上内部的 SQL 执行和 Bean 映射，整个开发过程始终围绕“测试先行”展开。\n\n虽然 TDD 并不适用于所有模块（例如复杂初始化流程或与外部服务强耦合的部分），但在 Javelin 中，TDD 非常适合用来实现数据访问、实体映射、查询构造器等核心功能。\n\n---\n\n# 总结\n\n在构建微型框架的过程中，Javelin 没有忽视测试体系的建立。通过合理使用 Mock 技术、代理替换、覆盖率报告、JDK Proxy 等机制，我们在功能演进的同时，也保证了框架的稳定性和可维护性。\n\n我们不仅要把功能“做出来”，更要保证它“跑得稳、用得住”。测试不是累赘，而是一种安全感的来源。\n\n单元测试就像是写代码的人留给“未来自己”的礼物，也像是给使用者的承诺：我测试过，我负责。\n\n我们将在后续继续测试更多组件，比如分页查询、事务回滚、实体自动识别、异常处理等，完善每一个关键模块，持续打磨出一个优雅、可测、可维护的 Java 微型框架。\n\n静下来，不只是为了放慢脚步，更是为了走得更远。\n\n","source":"_posts/javelin-unit-testing.md","raw":"---\ntitle: 手写一个微型 Spring 框架（五）：单元测试实践\ndate: 2025-05-23 16:14:04\ntags:\n---\n\n前面我们马不停蹄地实现了 Javelin 框架的许多基础功能。从 HTTP 路由、IoC 容器、注解扫描到数据库访问层，像是在快速奔跑、不断构建着新的地基。但到了某个时刻，我在想是不是应该停下来，回头看看。就像赵雷在《静下来》中唱的那样：\n\n> 我想应该静下来走一段路\n>\n> 我想应该静下来看一本书\n>\n> 我只想静下来做这些事\n>\n> ...\n>\n> 我只想静下来去反省自己\n\n![赵雷](./images/javelin-unit-testing/zhaolei.png)\n\n当我在 IDE 中一行行堆砌代码的时候，突然哼起这首歌，意识到，是时候慢下来——看看自己已经写了什么，有哪些内容真正被验证过，哪些又仅停留在“自信”层面。这篇文章正是在这种状态下写出来的，它或许谈不上多全面的反思，但却记录了我作为框架开发者，在某个时刻静下心来去梳理测试体系的过程。它更像是一份实践记录，一份对“测试意识”的回归笔记。\n\n我们为什么要做单元测试？在这个自建的 Java 框架中，又该如何落地？\n\n---\n\n# 为什么要做单元测试？\n\n单元测试是保障代码质量和持续演进能力的基石。尤其对于框架类项目来说，没有测试就没有安全地“改动”。Javelin 在不断完善功能的同时，如果没有测试作为护栏，每一次功能迭代都可能带来雪崩式风险。\n\n## 📌 原因 1：防止回归\n\n当你的框架被多个业务模块引用，任何一次调整都可能像蝴蝶效应一样影响下游模块。单元测试就像是自动化的“防线”：一旦行为偏离预期，立即发出警报。\n\n## 📌 原因 2：确保逻辑一致性\n\n你写的每一个公共方法、每一个输入输出契约，是否在各种边界条件下都表现正确？手动验证只能覆盖有限场景，而单元测试可以系统、可重复地校验行为。\n\n## 📌 原因 3：促进架构解耦\n\n一个类如果很难被测试，往往意味着它耦合过重。测试驱动设计反过来可以推动我们写出更清晰、更模块化的代码。\n\n## 📌 原因 4：文档即测试\n\n单元测试本质上也是“代码的使用说明书”。别人阅读你的测试用例，比阅读文档更能快速理解接口怎么用、预期行为是什么。\n\n## 📌 原因 5：提高开发信心和效率\n\n当你在一个已有完善单元测试的项目上工作时，每次修改代码都能立即获得验证反馈。你不需要担心“我改了这个会不会影响那个”，只要测试全绿，就可以安心发布。\n\n---\n\n# 基本原则和规范\n\n为了让测试既有效又具备长期维护性，我们在编写 Javelin 的测试时遵循了以下几个核心原则：\n\n## ✅ 原则 1：快速执行\n\n测试应该运行快速，控制在毫秒或秒级，避免依赖真实网络或数据库等慢资源。\n\n## ✅ 原则 2：完全自动化\n\n测试应该一键运行，不依赖人工介入或配置切换，可用于 CI/CD 持续集成场景。\n\n## ✅ 原则 3：只测试单一功能\n\n一个测试用例应聚焦一个功能点，确保测试失败时能快速定位问题源头，避免“一炸炸全家”。\n\n## ✅ 原则 4：避免测试间互相依赖\n\n每个测试都应具备“自给自足性”，不会依赖其他测试先运行成功。\n\n## ✅ 原则 5：断言清晰明确\n\n使用 `assertEquals`、`assertThrows` 等断言 API 明确表达预期行为，减少测试意图歧义。\n\n## ✅ 原则 6：Mock 外部依赖\n\n凡是框架外部（如数据库、文件系统、网络请求）一律 mock 掉，测试只聚焦本类的业务逻辑。\n\n## ✅ 原则 7：保持可读性\n\n测试代码应像示例代码一样易读，变量命名清晰，测试结构一致，可作为“使用手册”供参考。\n\n通过遵循这些原则，我们能确保测试本身具备可维护性、可演进性，并成为代码质量的重要护栏。\n\n\n\n---\n\n# 如何在 Javelin 中做单元测试？\n\nJavelin 涉及很多对外依赖，例如 JDBC、连接池、数据源管理、ORM 映射等，因此测试方式需要结合 Mock 技术、代理机制、覆盖率工具来系统搭建。由于对 Java 生态的不熟悉，技术选型基本上只能通过网络上各种文章的对比与社区经验总结，逐步探索出一套适合自己项目的测试组合方式。\n\n## ✅ 使用 JUnit 5 + Mockito\n\n我们选择了现代 Java 测试组合：\n\n* **JUnit 5**：模块化、注解丰富、支持 Lambda、兼容 Gradle\n* **Mockito**：业界主流 Mock 框架，能轻松隔离外部依赖\n\n```groovy\nplugins {\n    id 'java-library'\n    id 'jacoco'\n}\n\ndependencies {\n    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'\n    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'\n    testImplementation 'org.mockito:mockito-core:5.10.0'\n}\n```\n\n## ✅ 对静态依赖使用 Proxy 技术隔离\n\n例如 `DbConfigProvider.getAppDbConfig(...)` 这类静态方法无法直接被 mock。我们通过引入 `DbConnManagerProxy` 类，将原始逻辑包装，并注入 mock 结果，以达到“替身测试”的目的。这种方式兼顾不修改生产代码又能可测的平衡。\n\n## ✅ Mock 掉数据库相关依赖\n\n我们通过 Mockito 模拟 `Connection`、`DataSource`、`DbConfig` 等对象，避免测试中实际连数据库，同时可以验证连接是否被正确获取、是否按期望关闭。\n\n## ✅ 集成 JaCoCo 生成覆盖率报告\n\n我们使用 Gradle 的 `jacoco` 插件自动生成测试覆盖率报告：\n\n```groovy\njacocoTestReport {\n    dependsOn test\n    reports {\n        html.required.set(true)\n    }\n}\n```\n\n运行 `./gradlew test jacocoTestReport` 后，打开：\n\n```\nbuild/reports/jacoco/test/html/index.html\n```\n\n即可看到每个类、每个方法的覆盖率信息。\n![jacoco](./images/javelin-unit-testing/jacoco.png)\n\nJaCoCo 还能输出 XML 报告供 SonarQube 或 GitHub Actions 使用，后续我们也将集成 CI 中的覆盖率检查。\n\n---\n\n## 实践案例：测试 DbContext\n\n```java\n@Test\nvoid testClose_shouldCloseConnection() throws Exception {\n    Connection mockConnection = mock(Connection.class);\n    DataSource mockDataSource = mock(DataSource.class);\n    when(mockDataSource.getConnection()).thenReturn(mockConnection);\n\n    DbContext dbContext = new DbContext(mockDataSource);\n    dbContext.openConnection();\n    dbContext.close();\n\n    verify(mockConnection).close();\n}\n```\n\n该测试用例验证 `DbContext` 是否在 `.close()` 时能如期关闭连接。\n\n你也可以进一步测试连接未初始化时的行为，或反复打开关闭是否存在连接泄露风险。\n\n我们还可以测试 `.getConnection()` 是否懒加载、是否缓存连接、是否线程安全等高级特性。\n\n---\n\n# 进一步的测试实践\n\nJavelin 中的测试不仅仅覆盖正向路径，还包括：\n\n* **异常分支**：例如数据库连接失败时是否能抛出自定义异常？\n* **缓存逻辑**：配置缓存是否命中？配置变更是否生效？\n* **事务机制**：未来加入事务后，我们将通过 ThreadLocal 控制多操作是否共享连接，并断言事务是否提交/回滚。\n* **映射行为**：`BeanPropertyRowMapper` 是否能正确映射字段与 JavaBean 属性？是否支持 null 值？字段名大小写不一致是否能处理？\n* **链式查询 DSL**：测试 where/andWhere/orderBy 等语法是否能正确拼接 SQL，是否支持参数绑定和分页功能。\n\n---\n\n# 拓展：TDD\n\n在实践中我们发现，要写出一个高质量、边界明确、断言清晰、可维护的测试用例，往往比直接实现某个功能要花费更多精力。例如，为了验证一个 SQL 构造器能正确拼接分页语句，我们要写出 mock 数据源、预期参数、模拟连接返回、构造 ResultSet 的行为等大量前置条件。这也正是许多团队虽然强调测试，但却往往难以落地的原因之一。\n\nTDD（Test-Driven Development，测试驱动开发）是一种以测试为设计导向的软件开发方法论。它的核心思想是：**先写测试，再写实现，最后重构**。\n\nTDD 并不仅仅是一种测试方式，它更是一种编程思维。提前设计好测试的各种场景，再进行真是业务代码的实现。让我们在编写代码时，更关注如何让测试通过，而不是在实现功能后考虑如何测试。TDD 给我们的回报是长远的：它让我们思考“我真正要实现的是什么”，让代码变得更可用、更易测、更稳定。虽然覆盖率数字本身并不能代表一切，但它背后的那份“可验证的信心”，才是 TDD 真正想传达的价值。\n\n![TDD](./images/javelin-unit-testing/tdd.jpg)\n\n\n在 Javelin 的后续开发和重构过程中，我们逐渐尝试引入 TDD 的流程：\n\n1. **写一个失败的测试**：思考我们想要实现的功能是什么，先写一个对应的测试用例（它一定会失败，因为实现还不存在）。\n\n2. **快速实现使测试通过**：只实现刚好能让测试通过的最小逻辑。\n\n3. **重构代码结构**：在不改变测试结果的前提下重构代码，让其更简洁、更可维护。\n\n通过 TDD，我们获得了几个关键收益：\n\n* 代码设计更聚焦目标；\n* 测试用例成为开发文档；\n* 实现不偏离预期，测试成为开发的“驱动轮”。\n\n例如在实现 `CPQuery.toList()` 方法时，我们先写出期望的查询行为和数据结构，然后再去补上内部的 SQL 执行和 Bean 映射，整个开发过程始终围绕“测试先行”展开。\n\n虽然 TDD 并不适用于所有模块（例如复杂初始化流程或与外部服务强耦合的部分），但在 Javelin 中，TDD 非常适合用来实现数据访问、实体映射、查询构造器等核心功能。\n\n---\n\n# 总结\n\n在构建微型框架的过程中，Javelin 没有忽视测试体系的建立。通过合理使用 Mock 技术、代理替换、覆盖率报告、JDK Proxy 等机制，我们在功能演进的同时，也保证了框架的稳定性和可维护性。\n\n我们不仅要把功能“做出来”，更要保证它“跑得稳、用得住”。测试不是累赘，而是一种安全感的来源。\n\n单元测试就像是写代码的人留给“未来自己”的礼物，也像是给使用者的承诺：我测试过，我负责。\n\n我们将在后续继续测试更多组件，比如分页查询、事务回滚、实体自动识别、异常处理等，完善每一个关键模块，持续打磨出一个优雅、可测、可维护的 Java 微型框架。\n\n静下来，不只是为了放慢脚步，更是为了走得更远。\n\n","slug":"javelin-unit-testing","published":1,"updated":"2025-05-28T02:05:59.021Z","_id":"cmb0m4oit0000sop1hefj4zdk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前面我们马不停蹄地实现了 Javelin 框架的许多基础功能。从 HTTP 路由、IoC 容器、注解扫描到数据库访问层，像是在快速奔跑、不断构建着新的地基。但到了某个时刻，我在想是不是应该停下来，回头看看。就像赵雷在《静下来》中唱的那样：</p>\n<blockquote>\n<p>我想应该静下来走一段路</p>\n<p>我想应该静下来看一本书</p>\n<p>我只想静下来做这些事</p>\n<p>…</p>\n<p>我只想静下来去反省自己</p>\n</blockquote>\n<p><img src=\"/blog/./images/javelin-unit-testing/zhaolei.png\" alt=\"赵雷\"></p>\n<p>当我在 IDE 中一行行堆砌代码的时候，突然哼起这首歌，意识到，是时候慢下来——看看自己已经写了什么，有哪些内容真正被验证过，哪些又仅停留在“自信”层面。这篇文章正是在这种状态下写出来的，它或许谈不上多全面的反思，但却记录了我作为框架开发者，在某个时刻静下心来去梳理测试体系的过程。它更像是一份实践记录，一份对“测试意识”的回归笔记。</p>\n<p>我们为什么要做单元测试？在这个自建的 Java 框架中，又该如何落地？</p>\n<hr>\n<h1 id=\"为什么要做单元测试？\"><a href=\"#为什么要做单元测试？\" class=\"headerlink\" title=\"为什么要做单元测试？\"></a>为什么要做单元测试？</h1><p>单元测试是保障代码质量和持续演进能力的基石。尤其对于框架类项目来说，没有测试就没有安全地“改动”。Javelin 在不断完善功能的同时，如果没有测试作为护栏，每一次功能迭代都可能带来雪崩式风险。</p>\n<h2 id=\"📌-原因-1：防止回归\"><a href=\"#📌-原因-1：防止回归\" class=\"headerlink\" title=\"📌 原因 1：防止回归\"></a>📌 原因 1：防止回归</h2><p>当你的框架被多个业务模块引用，任何一次调整都可能像蝴蝶效应一样影响下游模块。单元测试就像是自动化的“防线”：一旦行为偏离预期，立即发出警报。</p>\n<h2 id=\"📌-原因-2：确保逻辑一致性\"><a href=\"#📌-原因-2：确保逻辑一致性\" class=\"headerlink\" title=\"📌 原因 2：确保逻辑一致性\"></a>📌 原因 2：确保逻辑一致性</h2><p>你写的每一个公共方法、每一个输入输出契约，是否在各种边界条件下都表现正确？手动验证只能覆盖有限场景，而单元测试可以系统、可重复地校验行为。</p>\n<h2 id=\"📌-原因-3：促进架构解耦\"><a href=\"#📌-原因-3：促进架构解耦\" class=\"headerlink\" title=\"📌 原因 3：促进架构解耦\"></a>📌 原因 3：促进架构解耦</h2><p>一个类如果很难被测试，往往意味着它耦合过重。测试驱动设计反过来可以推动我们写出更清晰、更模块化的代码。</p>\n<h2 id=\"📌-原因-4：文档即测试\"><a href=\"#📌-原因-4：文档即测试\" class=\"headerlink\" title=\"📌 原因 4：文档即测试\"></a>📌 原因 4：文档即测试</h2><p>单元测试本质上也是“代码的使用说明书”。别人阅读你的测试用例，比阅读文档更能快速理解接口怎么用、预期行为是什么。</p>\n<h2 id=\"📌-原因-5：提高开发信心和效率\"><a href=\"#📌-原因-5：提高开发信心和效率\" class=\"headerlink\" title=\"📌 原因 5：提高开发信心和效率\"></a>📌 原因 5：提高开发信心和效率</h2><p>当你在一个已有完善单元测试的项目上工作时，每次修改代码都能立即获得验证反馈。你不需要担心“我改了这个会不会影响那个”，只要测试全绿，就可以安心发布。</p>\n<hr>\n<h1 id=\"基本原则和规范\"><a href=\"#基本原则和规范\" class=\"headerlink\" title=\"基本原则和规范\"></a>基本原则和规范</h1><p>为了让测试既有效又具备长期维护性，我们在编写 Javelin 的测试时遵循了以下几个核心原则：</p>\n<h2 id=\"✅-原则-1：快速执行\"><a href=\"#✅-原则-1：快速执行\" class=\"headerlink\" title=\"✅ 原则 1：快速执行\"></a>✅ 原则 1：快速执行</h2><p>测试应该运行快速，控制在毫秒或秒级，避免依赖真实网络或数据库等慢资源。</p>\n<h2 id=\"✅-原则-2：完全自动化\"><a href=\"#✅-原则-2：完全自动化\" class=\"headerlink\" title=\"✅ 原则 2：完全自动化\"></a>✅ 原则 2：完全自动化</h2><p>测试应该一键运行，不依赖人工介入或配置切换，可用于 CI&#x2F;CD 持续集成场景。</p>\n<h2 id=\"✅-原则-3：只测试单一功能\"><a href=\"#✅-原则-3：只测试单一功能\" class=\"headerlink\" title=\"✅ 原则 3：只测试单一功能\"></a>✅ 原则 3：只测试单一功能</h2><p>一个测试用例应聚焦一个功能点，确保测试失败时能快速定位问题源头，避免“一炸炸全家”。</p>\n<h2 id=\"✅-原则-4：避免测试间互相依赖\"><a href=\"#✅-原则-4：避免测试间互相依赖\" class=\"headerlink\" title=\"✅ 原则 4：避免测试间互相依赖\"></a>✅ 原则 4：避免测试间互相依赖</h2><p>每个测试都应具备“自给自足性”，不会依赖其他测试先运行成功。</p>\n<h2 id=\"✅-原则-5：断言清晰明确\"><a href=\"#✅-原则-5：断言清晰明确\" class=\"headerlink\" title=\"✅ 原则 5：断言清晰明确\"></a>✅ 原则 5：断言清晰明确</h2><p>使用 <code>assertEquals</code>、<code>assertThrows</code> 等断言 API 明确表达预期行为，减少测试意图歧义。</p>\n<h2 id=\"✅-原则-6：Mock-外部依赖\"><a href=\"#✅-原则-6：Mock-外部依赖\" class=\"headerlink\" title=\"✅ 原则 6：Mock 外部依赖\"></a>✅ 原则 6：Mock 外部依赖</h2><p>凡是框架外部（如数据库、文件系统、网络请求）一律 mock 掉，测试只聚焦本类的业务逻辑。</p>\n<h2 id=\"✅-原则-7：保持可读性\"><a href=\"#✅-原则-7：保持可读性\" class=\"headerlink\" title=\"✅ 原则 7：保持可读性\"></a>✅ 原则 7：保持可读性</h2><p>测试代码应像示例代码一样易读，变量命名清晰，测试结构一致，可作为“使用手册”供参考。</p>\n<p>通过遵循这些原则，我们能确保测试本身具备可维护性、可演进性，并成为代码质量的重要护栏。</p>\n<hr>\n<h1 id=\"如何在-Javelin-中做单元测试？\"><a href=\"#如何在-Javelin-中做单元测试？\" class=\"headerlink\" title=\"如何在 Javelin 中做单元测试？\"></a>如何在 Javelin 中做单元测试？</h1><p>Javelin 涉及很多对外依赖，例如 JDBC、连接池、数据源管理、ORM 映射等，因此测试方式需要结合 Mock 技术、代理机制、覆盖率工具来系统搭建。由于对 Java 生态的不熟悉，技术选型基本上只能通过网络上各种文章的对比与社区经验总结，逐步探索出一套适合自己项目的测试组合方式。</p>\n<h2 id=\"✅-使用-JUnit-5-Mockito\"><a href=\"#✅-使用-JUnit-5-Mockito\" class=\"headerlink\" title=\"✅ 使用 JUnit 5 + Mockito\"></a>✅ 使用 JUnit 5 + Mockito</h2><p>我们选择了现代 Java 测试组合：</p>\n<ul>\n<li><strong>JUnit 5</strong>：模块化、注解丰富、支持 Lambda、兼容 Gradle</li>\n<li><strong>Mockito</strong>：业界主流 Mock 框架，能轻松隔离外部依赖</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;java-library&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;jacoco&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    testImplementation <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-api:5.10.0&#x27;</span></span><br><span class=\"line\">    testRuntimeOnly <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-engine:5.10.0&#x27;</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">&#x27;org.mockito:mockito-core:5.10.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"✅-对静态依赖使用-Proxy-技术隔离\"><a href=\"#✅-对静态依赖使用-Proxy-技术隔离\" class=\"headerlink\" title=\"✅ 对静态依赖使用 Proxy 技术隔离\"></a>✅ 对静态依赖使用 Proxy 技术隔离</h2><p>例如 <code>DbConfigProvider.getAppDbConfig(...)</code> 这类静态方法无法直接被 mock。我们通过引入 <code>DbConnManagerProxy</code> 类，将原始逻辑包装，并注入 mock 结果，以达到“替身测试”的目的。这种方式兼顾不修改生产代码又能可测的平衡。</p>\n<h2 id=\"✅-Mock-掉数据库相关依赖\"><a href=\"#✅-Mock-掉数据库相关依赖\" class=\"headerlink\" title=\"✅ Mock 掉数据库相关依赖\"></a>✅ Mock 掉数据库相关依赖</h2><p>我们通过 Mockito 模拟 <code>Connection</code>、<code>DataSource</code>、<code>DbConfig</code> 等对象，避免测试中实际连数据库，同时可以验证连接是否被正确获取、是否按期望关闭。</p>\n<h2 id=\"✅-集成-JaCoCo-生成覆盖率报告\"><a href=\"#✅-集成-JaCoCo-生成覆盖率报告\" class=\"headerlink\" title=\"✅ 集成 JaCoCo 生成覆盖率报告\"></a>✅ 集成 JaCoCo 生成覆盖率报告</h2><p>我们使用 Gradle 的 <code>jacoco</code> 插件自动生成测试覆盖率报告：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jacocoTestReport &#123;</span><br><span class=\"line\">    dependsOn test</span><br><span class=\"line\">    reports &#123;</span><br><span class=\"line\">        html.required.set(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行 <code>./gradlew test jacocoTestReport</code> 后，打开：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/reports/jacoco/test/html/index.html</span><br></pre></td></tr></table></figure>\n\n<p>即可看到每个类、每个方法的覆盖率信息。<br><img src=\"/blog/./images/javelin-unit-testing/jacoco.png\" alt=\"jacoco\"></p>\n<p>JaCoCo 还能输出 XML 报告供 SonarQube 或 GitHub Actions 使用，后续我们也将集成 CI 中的覆盖率检查。</p>\n<hr>\n<h2 id=\"实践案例：测试-DbContext\"><a href=\"#实践案例：测试-DbContext\" class=\"headerlink\" title=\"实践案例：测试 DbContext\"></a>实践案例：测试 DbContext</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testClose_shouldCloseConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">mockConnection</span> <span class=\"operator\">=</span> mock(Connection.class);</span><br><span class=\"line\">    <span class=\"type\">DataSource</span> <span class=\"variable\">mockDataSource</span> <span class=\"operator\">=</span> mock(DataSource.class);</span><br><span class=\"line\">    when(mockDataSource.getConnection()).thenReturn(mockConnection);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DbContext</span> <span class=\"variable\">dbContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DbContext</span>(mockDataSource);</span><br><span class=\"line\">    dbContext.openConnection();</span><br><span class=\"line\">    dbContext.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    verify(mockConnection).close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该测试用例验证 <code>DbContext</code> 是否在 <code>.close()</code> 时能如期关闭连接。</p>\n<p>你也可以进一步测试连接未初始化时的行为，或反复打开关闭是否存在连接泄露风险。</p>\n<p>我们还可以测试 <code>.getConnection()</code> 是否懒加载、是否缓存连接、是否线程安全等高级特性。</p>\n<hr>\n<h1 id=\"进一步的测试实践\"><a href=\"#进一步的测试实践\" class=\"headerlink\" title=\"进一步的测试实践\"></a>进一步的测试实践</h1><p>Javelin 中的测试不仅仅覆盖正向路径，还包括：</p>\n<ul>\n<li><strong>异常分支</strong>：例如数据库连接失败时是否能抛出自定义异常？</li>\n<li><strong>缓存逻辑</strong>：配置缓存是否命中？配置变更是否生效？</li>\n<li><strong>事务机制</strong>：未来加入事务后，我们将通过 ThreadLocal 控制多操作是否共享连接，并断言事务是否提交&#x2F;回滚。</li>\n<li><strong>映射行为</strong>：<code>BeanPropertyRowMapper</code> 是否能正确映射字段与 JavaBean 属性？是否支持 null 值？字段名大小写不一致是否能处理？</li>\n<li><strong>链式查询 DSL</strong>：测试 where&#x2F;andWhere&#x2F;orderBy 等语法是否能正确拼接 SQL，是否支持参数绑定和分页功能。</li>\n</ul>\n<hr>\n<h1 id=\"拓展：TDD\"><a href=\"#拓展：TDD\" class=\"headerlink\" title=\"拓展：TDD\"></a>拓展：TDD</h1><p>在实践中我们发现，要写出一个高质量、边界明确、断言清晰、可维护的测试用例，往往比直接实现某个功能要花费更多精力。例如，为了验证一个 SQL 构造器能正确拼接分页语句，我们要写出 mock 数据源、预期参数、模拟连接返回、构造 ResultSet 的行为等大量前置条件。这也正是许多团队虽然强调测试，但却往往难以落地的原因之一。</p>\n<p>TDD（Test-Driven Development，测试驱动开发）是一种以测试为设计导向的软件开发方法论。它的核心思想是：<strong>先写测试，再写实现，最后重构</strong>。</p>\n<p>TDD 并不仅仅是一种测试方式，它更是一种编程思维。提前设计好测试的各种场景，再进行真是业务代码的实现。让我们在编写代码时，更关注如何让测试通过，而不是在实现功能后考虑如何测试。TDD 给我们的回报是长远的：它让我们思考“我真正要实现的是什么”，让代码变得更可用、更易测、更稳定。虽然覆盖率数字本身并不能代表一切，但它背后的那份“可验证的信心”，才是 TDD 真正想传达的价值。</p>\n<p><img src=\"/blog/./images/javelin-unit-testing/tdd.jpg\" alt=\"TDD\"></p>\n<p>在 Javelin 的后续开发和重构过程中，我们逐渐尝试引入 TDD 的流程：</p>\n<ol>\n<li><p><strong>写一个失败的测试</strong>：思考我们想要实现的功能是什么，先写一个对应的测试用例（它一定会失败，因为实现还不存在）。</p>\n</li>\n<li><p><strong>快速实现使测试通过</strong>：只实现刚好能让测试通过的最小逻辑。</p>\n</li>\n<li><p><strong>重构代码结构</strong>：在不改变测试结果的前提下重构代码，让其更简洁、更可维护。</p>\n</li>\n</ol>\n<p>通过 TDD，我们获得了几个关键收益：</p>\n<ul>\n<li>代码设计更聚焦目标；</li>\n<li>测试用例成为开发文档；</li>\n<li>实现不偏离预期，测试成为开发的“驱动轮”。</li>\n</ul>\n<p>例如在实现 <code>CPQuery.toList()</code> 方法时，我们先写出期望的查询行为和数据结构，然后再去补上内部的 SQL 执行和 Bean 映射，整个开发过程始终围绕“测试先行”展开。</p>\n<p>虽然 TDD 并不适用于所有模块（例如复杂初始化流程或与外部服务强耦合的部分），但在 Javelin 中，TDD 非常适合用来实现数据访问、实体映射、查询构造器等核心功能。</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在构建微型框架的过程中，Javelin 没有忽视测试体系的建立。通过合理使用 Mock 技术、代理替换、覆盖率报告、JDK Proxy 等机制，我们在功能演进的同时，也保证了框架的稳定性和可维护性。</p>\n<p>我们不仅要把功能“做出来”，更要保证它“跑得稳、用得住”。测试不是累赘，而是一种安全感的来源。</p>\n<p>单元测试就像是写代码的人留给“未来自己”的礼物，也像是给使用者的承诺：我测试过，我负责。</p>\n<p>我们将在后续继续测试更多组件，比如分页查询、事务回滚、实体自动识别、异常处理等，完善每一个关键模块，持续打磨出一个优雅、可测、可维护的 Java 微型框架。</p>\n<p>静下来，不只是为了放慢脚步，更是为了走得更远。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前面我们马不停蹄地实现了 Javelin 框架的许多基础功能。从 HTTP 路由、IoC 容器、注解扫描到数据库访问层，像是在快速奔跑、不断构建着新的地基。但到了某个时刻，我在想是不是应该停下来，回头看看。就像赵雷在《静下来》中唱的那样：</p>\n<blockquote>\n<p>我想应该静下来走一段路</p>\n<p>我想应该静下来看一本书</p>\n<p>我只想静下来做这些事</p>\n<p>…</p>\n<p>我只想静下来去反省自己</p>\n</blockquote>\n<p><img src=\"/blog/./images/javelin-unit-testing/zhaolei.png\" alt=\"赵雷\"></p>\n<p>当我在 IDE 中一行行堆砌代码的时候，突然哼起这首歌，意识到，是时候慢下来——看看自己已经写了什么，有哪些内容真正被验证过，哪些又仅停留在“自信”层面。这篇文章正是在这种状态下写出来的，它或许谈不上多全面的反思，但却记录了我作为框架开发者，在某个时刻静下心来去梳理测试体系的过程。它更像是一份实践记录，一份对“测试意识”的回归笔记。</p>\n<p>我们为什么要做单元测试？在这个自建的 Java 框架中，又该如何落地？</p>\n<hr>\n<h1 id=\"为什么要做单元测试？\"><a href=\"#为什么要做单元测试？\" class=\"headerlink\" title=\"为什么要做单元测试？\"></a>为什么要做单元测试？</h1><p>单元测试是保障代码质量和持续演进能力的基石。尤其对于框架类项目来说，没有测试就没有安全地“改动”。Javelin 在不断完善功能的同时，如果没有测试作为护栏，每一次功能迭代都可能带来雪崩式风险。</p>\n<h2 id=\"📌-原因-1：防止回归\"><a href=\"#📌-原因-1：防止回归\" class=\"headerlink\" title=\"📌 原因 1：防止回归\"></a>📌 原因 1：防止回归</h2><p>当你的框架被多个业务模块引用，任何一次调整都可能像蝴蝶效应一样影响下游模块。单元测试就像是自动化的“防线”：一旦行为偏离预期，立即发出警报。</p>\n<h2 id=\"📌-原因-2：确保逻辑一致性\"><a href=\"#📌-原因-2：确保逻辑一致性\" class=\"headerlink\" title=\"📌 原因 2：确保逻辑一致性\"></a>📌 原因 2：确保逻辑一致性</h2><p>你写的每一个公共方法、每一个输入输出契约，是否在各种边界条件下都表现正确？手动验证只能覆盖有限场景，而单元测试可以系统、可重复地校验行为。</p>\n<h2 id=\"📌-原因-3：促进架构解耦\"><a href=\"#📌-原因-3：促进架构解耦\" class=\"headerlink\" title=\"📌 原因 3：促进架构解耦\"></a>📌 原因 3：促进架构解耦</h2><p>一个类如果很难被测试，往往意味着它耦合过重。测试驱动设计反过来可以推动我们写出更清晰、更模块化的代码。</p>\n<h2 id=\"📌-原因-4：文档即测试\"><a href=\"#📌-原因-4：文档即测试\" class=\"headerlink\" title=\"📌 原因 4：文档即测试\"></a>📌 原因 4：文档即测试</h2><p>单元测试本质上也是“代码的使用说明书”。别人阅读你的测试用例，比阅读文档更能快速理解接口怎么用、预期行为是什么。</p>\n<h2 id=\"📌-原因-5：提高开发信心和效率\"><a href=\"#📌-原因-5：提高开发信心和效率\" class=\"headerlink\" title=\"📌 原因 5：提高开发信心和效率\"></a>📌 原因 5：提高开发信心和效率</h2><p>当你在一个已有完善单元测试的项目上工作时，每次修改代码都能立即获得验证反馈。你不需要担心“我改了这个会不会影响那个”，只要测试全绿，就可以安心发布。</p>\n<hr>\n<h1 id=\"基本原则和规范\"><a href=\"#基本原则和规范\" class=\"headerlink\" title=\"基本原则和规范\"></a>基本原则和规范</h1><p>为了让测试既有效又具备长期维护性，我们在编写 Javelin 的测试时遵循了以下几个核心原则：</p>\n<h2 id=\"✅-原则-1：快速执行\"><a href=\"#✅-原则-1：快速执行\" class=\"headerlink\" title=\"✅ 原则 1：快速执行\"></a>✅ 原则 1：快速执行</h2><p>测试应该运行快速，控制在毫秒或秒级，避免依赖真实网络或数据库等慢资源。</p>\n<h2 id=\"✅-原则-2：完全自动化\"><a href=\"#✅-原则-2：完全自动化\" class=\"headerlink\" title=\"✅ 原则 2：完全自动化\"></a>✅ 原则 2：完全自动化</h2><p>测试应该一键运行，不依赖人工介入或配置切换，可用于 CI&#x2F;CD 持续集成场景。</p>\n<h2 id=\"✅-原则-3：只测试单一功能\"><a href=\"#✅-原则-3：只测试单一功能\" class=\"headerlink\" title=\"✅ 原则 3：只测试单一功能\"></a>✅ 原则 3：只测试单一功能</h2><p>一个测试用例应聚焦一个功能点，确保测试失败时能快速定位问题源头，避免“一炸炸全家”。</p>\n<h2 id=\"✅-原则-4：避免测试间互相依赖\"><a href=\"#✅-原则-4：避免测试间互相依赖\" class=\"headerlink\" title=\"✅ 原则 4：避免测试间互相依赖\"></a>✅ 原则 4：避免测试间互相依赖</h2><p>每个测试都应具备“自给自足性”，不会依赖其他测试先运行成功。</p>\n<h2 id=\"✅-原则-5：断言清晰明确\"><a href=\"#✅-原则-5：断言清晰明确\" class=\"headerlink\" title=\"✅ 原则 5：断言清晰明确\"></a>✅ 原则 5：断言清晰明确</h2><p>使用 <code>assertEquals</code>、<code>assertThrows</code> 等断言 API 明确表达预期行为，减少测试意图歧义。</p>\n<h2 id=\"✅-原则-6：Mock-外部依赖\"><a href=\"#✅-原则-6：Mock-外部依赖\" class=\"headerlink\" title=\"✅ 原则 6：Mock 外部依赖\"></a>✅ 原则 6：Mock 外部依赖</h2><p>凡是框架外部（如数据库、文件系统、网络请求）一律 mock 掉，测试只聚焦本类的业务逻辑。</p>\n<h2 id=\"✅-原则-7：保持可读性\"><a href=\"#✅-原则-7：保持可读性\" class=\"headerlink\" title=\"✅ 原则 7：保持可读性\"></a>✅ 原则 7：保持可读性</h2><p>测试代码应像示例代码一样易读，变量命名清晰，测试结构一致，可作为“使用手册”供参考。</p>\n<p>通过遵循这些原则，我们能确保测试本身具备可维护性、可演进性，并成为代码质量的重要护栏。</p>\n<hr>\n<h1 id=\"如何在-Javelin-中做单元测试？\"><a href=\"#如何在-Javelin-中做单元测试？\" class=\"headerlink\" title=\"如何在 Javelin 中做单元测试？\"></a>如何在 Javelin 中做单元测试？</h1><p>Javelin 涉及很多对外依赖，例如 JDBC、连接池、数据源管理、ORM 映射等，因此测试方式需要结合 Mock 技术、代理机制、覆盖率工具来系统搭建。由于对 Java 生态的不熟悉，技术选型基本上只能通过网络上各种文章的对比与社区经验总结，逐步探索出一套适合自己项目的测试组合方式。</p>\n<h2 id=\"✅-使用-JUnit-5-Mockito\"><a href=\"#✅-使用-JUnit-5-Mockito\" class=\"headerlink\" title=\"✅ 使用 JUnit 5 + Mockito\"></a>✅ 使用 JUnit 5 + Mockito</h2><p>我们选择了现代 Java 测试组合：</p>\n<ul>\n<li><strong>JUnit 5</strong>：模块化、注解丰富、支持 Lambda、兼容 Gradle</li>\n<li><strong>Mockito</strong>：业界主流 Mock 框架，能轻松隔离外部依赖</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;java-library&#x27;</span></span><br><span class=\"line\">    id <span class=\"string\">&#x27;jacoco&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    testImplementation <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-api:5.10.0&#x27;</span></span><br><span class=\"line\">    testRuntimeOnly <span class=\"string\">&#x27;org.junit.jupiter:junit-jupiter-engine:5.10.0&#x27;</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">&#x27;org.mockito:mockito-core:5.10.0&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"✅-对静态依赖使用-Proxy-技术隔离\"><a href=\"#✅-对静态依赖使用-Proxy-技术隔离\" class=\"headerlink\" title=\"✅ 对静态依赖使用 Proxy 技术隔离\"></a>✅ 对静态依赖使用 Proxy 技术隔离</h2><p>例如 <code>DbConfigProvider.getAppDbConfig(...)</code> 这类静态方法无法直接被 mock。我们通过引入 <code>DbConnManagerProxy</code> 类，将原始逻辑包装，并注入 mock 结果，以达到“替身测试”的目的。这种方式兼顾不修改生产代码又能可测的平衡。</p>\n<h2 id=\"✅-Mock-掉数据库相关依赖\"><a href=\"#✅-Mock-掉数据库相关依赖\" class=\"headerlink\" title=\"✅ Mock 掉数据库相关依赖\"></a>✅ Mock 掉数据库相关依赖</h2><p>我们通过 Mockito 模拟 <code>Connection</code>、<code>DataSource</code>、<code>DbConfig</code> 等对象，避免测试中实际连数据库，同时可以验证连接是否被正确获取、是否按期望关闭。</p>\n<h2 id=\"✅-集成-JaCoCo-生成覆盖率报告\"><a href=\"#✅-集成-JaCoCo-生成覆盖率报告\" class=\"headerlink\" title=\"✅ 集成 JaCoCo 生成覆盖率报告\"></a>✅ 集成 JaCoCo 生成覆盖率报告</h2><p>我们使用 Gradle 的 <code>jacoco</code> 插件自动生成测试覆盖率报告：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jacocoTestReport &#123;</span><br><span class=\"line\">    dependsOn test</span><br><span class=\"line\">    reports &#123;</span><br><span class=\"line\">        html.required.set(<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行 <code>./gradlew test jacocoTestReport</code> 后，打开：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/reports/jacoco/test/html/index.html</span><br></pre></td></tr></table></figure>\n\n<p>即可看到每个类、每个方法的覆盖率信息。<br><img src=\"/blog/./images/javelin-unit-testing/jacoco.png\" alt=\"jacoco\"></p>\n<p>JaCoCo 还能输出 XML 报告供 SonarQube 或 GitHub Actions 使用，后续我们也将集成 CI 中的覆盖率检查。</p>\n<hr>\n<h2 id=\"实践案例：测试-DbContext\"><a href=\"#实践案例：测试-DbContext\" class=\"headerlink\" title=\"实践案例：测试 DbContext\"></a>实践案例：测试 DbContext</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">testClose_shouldCloseConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">mockConnection</span> <span class=\"operator\">=</span> mock(Connection.class);</span><br><span class=\"line\">    <span class=\"type\">DataSource</span> <span class=\"variable\">mockDataSource</span> <span class=\"operator\">=</span> mock(DataSource.class);</span><br><span class=\"line\">    when(mockDataSource.getConnection()).thenReturn(mockConnection);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DbContext</span> <span class=\"variable\">dbContext</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DbContext</span>(mockDataSource);</span><br><span class=\"line\">    dbContext.openConnection();</span><br><span class=\"line\">    dbContext.close();</span><br><span class=\"line\"></span><br><span class=\"line\">    verify(mockConnection).close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该测试用例验证 <code>DbContext</code> 是否在 <code>.close()</code> 时能如期关闭连接。</p>\n<p>你也可以进一步测试连接未初始化时的行为，或反复打开关闭是否存在连接泄露风险。</p>\n<p>我们还可以测试 <code>.getConnection()</code> 是否懒加载、是否缓存连接、是否线程安全等高级特性。</p>\n<hr>\n<h1 id=\"进一步的测试实践\"><a href=\"#进一步的测试实践\" class=\"headerlink\" title=\"进一步的测试实践\"></a>进一步的测试实践</h1><p>Javelin 中的测试不仅仅覆盖正向路径，还包括：</p>\n<ul>\n<li><strong>异常分支</strong>：例如数据库连接失败时是否能抛出自定义异常？</li>\n<li><strong>缓存逻辑</strong>：配置缓存是否命中？配置变更是否生效？</li>\n<li><strong>事务机制</strong>：未来加入事务后，我们将通过 ThreadLocal 控制多操作是否共享连接，并断言事务是否提交&#x2F;回滚。</li>\n<li><strong>映射行为</strong>：<code>BeanPropertyRowMapper</code> 是否能正确映射字段与 JavaBean 属性？是否支持 null 值？字段名大小写不一致是否能处理？</li>\n<li><strong>链式查询 DSL</strong>：测试 where&#x2F;andWhere&#x2F;orderBy 等语法是否能正确拼接 SQL，是否支持参数绑定和分页功能。</li>\n</ul>\n<hr>\n<h1 id=\"拓展：TDD\"><a href=\"#拓展：TDD\" class=\"headerlink\" title=\"拓展：TDD\"></a>拓展：TDD</h1><p>在实践中我们发现，要写出一个高质量、边界明确、断言清晰、可维护的测试用例，往往比直接实现某个功能要花费更多精力。例如，为了验证一个 SQL 构造器能正确拼接分页语句，我们要写出 mock 数据源、预期参数、模拟连接返回、构造 ResultSet 的行为等大量前置条件。这也正是许多团队虽然强调测试，但却往往难以落地的原因之一。</p>\n<p>TDD（Test-Driven Development，测试驱动开发）是一种以测试为设计导向的软件开发方法论。它的核心思想是：<strong>先写测试，再写实现，最后重构</strong>。</p>\n<p>TDD 并不仅仅是一种测试方式，它更是一种编程思维。提前设计好测试的各种场景，再进行真是业务代码的实现。让我们在编写代码时，更关注如何让测试通过，而不是在实现功能后考虑如何测试。TDD 给我们的回报是长远的：它让我们思考“我真正要实现的是什么”，让代码变得更可用、更易测、更稳定。虽然覆盖率数字本身并不能代表一切，但它背后的那份“可验证的信心”，才是 TDD 真正想传达的价值。</p>\n<p><img src=\"/blog/./images/javelin-unit-testing/tdd.jpg\" alt=\"TDD\"></p>\n<p>在 Javelin 的后续开发和重构过程中，我们逐渐尝试引入 TDD 的流程：</p>\n<ol>\n<li><p><strong>写一个失败的测试</strong>：思考我们想要实现的功能是什么，先写一个对应的测试用例（它一定会失败，因为实现还不存在）。</p>\n</li>\n<li><p><strong>快速实现使测试通过</strong>：只实现刚好能让测试通过的最小逻辑。</p>\n</li>\n<li><p><strong>重构代码结构</strong>：在不改变测试结果的前提下重构代码，让其更简洁、更可维护。</p>\n</li>\n</ol>\n<p>通过 TDD，我们获得了几个关键收益：</p>\n<ul>\n<li>代码设计更聚焦目标；</li>\n<li>测试用例成为开发文档；</li>\n<li>实现不偏离预期，测试成为开发的“驱动轮”。</li>\n</ul>\n<p>例如在实现 <code>CPQuery.toList()</code> 方法时，我们先写出期望的查询行为和数据结构，然后再去补上内部的 SQL 执行和 Bean 映射，整个开发过程始终围绕“测试先行”展开。</p>\n<p>虽然 TDD 并不适用于所有模块（例如复杂初始化流程或与外部服务强耦合的部分），但在 Javelin 中，TDD 非常适合用来实现数据访问、实体映射、查询构造器等核心功能。</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在构建微型框架的过程中，Javelin 没有忽视测试体系的建立。通过合理使用 Mock 技术、代理替换、覆盖率报告、JDK Proxy 等机制，我们在功能演进的同时，也保证了框架的稳定性和可维护性。</p>\n<p>我们不仅要把功能“做出来”，更要保证它“跑得稳、用得住”。测试不是累赘，而是一种安全感的来源。</p>\n<p>单元测试就像是写代码的人留给“未来自己”的礼物，也像是给使用者的承诺：我测试过，我负责。</p>\n<p>我们将在后续继续测试更多组件，比如分页查询、事务回滚、实体自动识别、异常处理等，完善每一个关键模块，持续打磨出一个优雅、可测、可维护的 Java 微型框架。</p>\n<p>静下来，不只是为了放慢脚步，更是为了走得更远。</p>\n"},{"title":"从 scoped 到 @scope：CSS 样式隔离的进化","date":"2025-06-03T01:56:38.000Z","_content":"\n在前端开发中，“样式污染”一直是一个反复出现的问题。尤其在构建大型项目或维护多个组件库时，全局 CSS 的不确定性会带来许多调试难题。为了实现组件级样式隔离，我们使用过许多手段：BEM 命名规范、CSS Modules、Vue 的 scoped 样式、甚至 Shadow DOM。但今天，我们迎来了一个更加原生、简洁的解决方案：`@scope`。\n\n本文将带你了解 CSS 的这项新特性，以及它在组件样式管理中的应用实践，并结合 Vue 的 scoped 实战与对比，探讨 `@scope` 的优势与适用场景，看看它是否真的值得期待。\n\n# 为什么我们需要作用域 CSS？\n\n我们先从一个经典的例子开始说起：\n\n```html\n<style>\n  h1 {\n    color: red;\n  }\n</style>\n\n<div class=\"my-comp\">\n  <h1>我是红色的</h1>\n</div>\n<h1>我也变红了</h1>\n```\n![test](./images/css-scope/test1.png)\n\n这段样式会作用于页面中所有的 `h1` 标签。这种全局样式一旦覆盖了不该覆盖的部分，可能会导致页面样式出现不可预期的混乱。在多人协作、跨团队开发时，这种“样式污染”现象尤为常见。\n\n为了解决这个问题，我们过去主要依赖以下几种方式：\n\n* 添加命名空间前缀，例如 `.my-comp h1 { color: red }`；\n* 使用构建工具支持的 CSS Modules；\n* 在 Vue 或 React 中使用 scoped 样式特性；\n* 使用 Shadow DOM 实现样式封装。\n\n这些方案都各有优缺点，但本质上都是“曲线救国”。\n\n---\n\n# Vue的scoped style\n\n提到scoped， 前端开发者们肯定会想到Vue的scoped style。它用于实现组件级别的样式隔离，可以让组件的样式只在当前组件内生效，不会影响全局。\nVue 是最早支持 scoped 样式的主流框架之一。\n\n## 实战示例：Vue scoped CSS 的使用方式\n\n```vue\n<template>\n  <div class=\"card\">\n    <h2>我是标题</h2>\n    <p>这是一段内容</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'ScopedCard'\n}\n</script>\n\n<style scoped>\n.card {\n  border: 1px solid #ccc;\n  padding: 1rem;\n  border-radius: 8px;\n}\n\n.card h2 {\n  color: steelblue;\n}\n\n.card p:hover {\n  background-color: #f0f0f0;\n}\n</style>\n```\n\nVue 中的 `<style scoped>` 是通过编译时处理实现的。\n\n## 实现原理\n\n1. 编译模板时，会给组件的根元素自动添加一个唯一的属性（如 `data-v-123456`）。\n2. 所有选择器都会被转化为带这个属性的选择器，例如：\n\n```css\nh1[data-v-123456] { color: red; }\n```\n\n这使得样式局部生效，但依赖构建工具。所以当我们通过开发者工具查看vue开发的项目时，会发现，样式的选择器都带有data-v-xxx的属性。\n![test](./images/css-scope/vue-scoped-style.png)\n\n## 存在的问题\n\n* ❌ 无法自动作用于子组件，除非使用 `::v-deep`；\n* ❌ 缺乏原生支持，不能脱离构建工具；\n* ❌ 编译后的选择器冗长，调试体验差；\n* ❌ 无法完全避免全局样式干扰。\n\n因此，Vue 的 scoped 是构建时 hack，而非 CSS 原生功能。\n\n---\n\n# 什么是 @scope？\n`@scope` 是 CSS 官方提出的作用域语法，它允许我们为样式规则限定作用范围，实现真正原生的样式隔离。\n\n## 基本语法\n\n```css\n<style>\n@scope (.my-comp) {\n  h1 {\n    color: red;\n  }\n}\n</style>\n<div class=\"my-comp\">\n  <h1>我是红色的</h1>\n</div>\n<h1>我没有变红</h1>\n```\n\n只有 `.my-comp` 元素内的 `h1` 才会生效。\n![result](./images/css-scope/result.png)\n\n## 特性优势\n\n* ✅ 原生支持，无需依赖构建工具；\n* ✅ 支持所有标准选择器和伪类；\n* ✅ 可以嵌套和组合使用；\n* ✅ 不依赖类名、属性名等技术手段；\n* ✅ 可与 `<style>` 标签结合，适用于组件化开发。\n\n---\n\n## 内联使用 @scope：更自然的组件化体验\n\n`@scope` 也可以与内联 `<style>` 标签结合使用：\n\n```html\n<div class=\"card\">\n  <style>\n    @scope (.card) {\n      h2 {\n        color: steelblue;\n      }\n      p:hover {\n        background: #f0f0f0;\n      }\n    }\n  </style>\n  <h2>标题</h2>\n  <p>内容段落</p>\n</div>\n```\n![inline](./images/css-scope/inline.png)\n相比传统的 scoped CSS，这种方式不依赖任何构建步骤，语义清晰，维护简单。\n\n---\n\n## 动态添加 @scope 样式\n\n在 JavaScript 中动态插入样式：\n\n```js\nconst style = document.createElement('style');\nstyle.textContent = `\n  @scope (.dynamic-box) {\n    span {\n      font-weight: bold;\n      color: orange;\n    }\n  }\n`;\ndocument.head.appendChild(style);\n```\n\n![dynamic](./images/css-scope/dynamic.png)\n适用于微前端、动态组件等运行时场景。\n\n---\n\n# 对比：@scope 与其他样式隔离方案\n\n| 方案             | 样式隔离 | 支持选择器 | 依赖工具链  | 浏览器支持    |\n| -------------- | ---- | ----- | ------ | -------- |\n| BEM 命名规范       | ❌    | ✅     | ❌      | ✅        |\n| CSS Modules    | ✅    | ✅     | ✅（构建时） | ✅        |\n| Shadow DOM     | ✅    | ✅     | ❌（原生）  | ✅        |\n| Vue scoped CSS | ✅    | 部分支持  | ✅（编译时） | ✅        |\n| **@scope**     | ✅    | ✅     | ❌      | ✅（逐步完善中） |\n\n---\n\n# 浏览器支持情况\n\n截至 2025 年中：\n\n* ✅ Chrome（111+）\n* ✅ Safari（16.4+）\n* ✅ Edge\n* ⚠️ Firefox：需手动开启 `layout.css.scope.enabled`\n\n👉 [Can I Use: @scope](https://caniuse.com/?search=%40scope)\n\n---\n\n# 使用建议\n\n* ✅ 推荐用于组件化样式隔离；\n* ✅ SSR 场景优选，兼容性好；\n* ✅ 可用于构建无依赖的 UI 组件；\n* ⚠️ 老旧浏览器（如 IE11）不支持；\n* ⚠️ 当前阶段可与 scoped CSS 搭配使用；\n\n---\n\n# 总结\n\n`@scope` 的出现为 CSS 带来了“模块化思维”。它弥补了长期以来 CSS 缺乏作用域机制的缺陷，为组件开发带来了新的可能。\n\n相比构建时方案（如 Vue scoped、CSS Modules）或高成本方案（如 Shadow DOM），`@scope` 提供了一种更自然、更贴近语义的写法。\n\n未来，我们或许可以更少依赖工具链，而更多依赖浏览器原生能力来实现高质量的组件样式隔离。\n\n```css\n@scope (.card) {\n  h1 {\n    color: blue;\n  }\n}\n```\n\n简单、直观、强大。\n\n---\n\n# 延伸阅读\n\n* [MDN：@scope](https://developer.mozilla.org/en-US/docs/Web/CSS/@scope)\n* [Chrome Platform Status](https://chromestatus.com/feature/5798754575984640)\n* [Scoped Styles Draft Spec](https://drafts.csswg.org/css-cascade-6/#scope)\n\n---\n\n如果你觉得这篇文章有帮助，欢迎点赞 / 收藏 / 留言交流 🙌\n\n如需更多框架实战例子（如 React / Web Components 中的应用），也欢迎留言告诉我。","source":"_posts/css-scope.md","raw":"---\ntitle: 从 scoped 到 @scope：CSS 样式隔离的进化\ndate: 2025-06-03 09:56:38\ntags:\n---\n\n在前端开发中，“样式污染”一直是一个反复出现的问题。尤其在构建大型项目或维护多个组件库时，全局 CSS 的不确定性会带来许多调试难题。为了实现组件级样式隔离，我们使用过许多手段：BEM 命名规范、CSS Modules、Vue 的 scoped 样式、甚至 Shadow DOM。但今天，我们迎来了一个更加原生、简洁的解决方案：`@scope`。\n\n本文将带你了解 CSS 的这项新特性，以及它在组件样式管理中的应用实践，并结合 Vue 的 scoped 实战与对比，探讨 `@scope` 的优势与适用场景，看看它是否真的值得期待。\n\n# 为什么我们需要作用域 CSS？\n\n我们先从一个经典的例子开始说起：\n\n```html\n<style>\n  h1 {\n    color: red;\n  }\n</style>\n\n<div class=\"my-comp\">\n  <h1>我是红色的</h1>\n</div>\n<h1>我也变红了</h1>\n```\n![test](./images/css-scope/test1.png)\n\n这段样式会作用于页面中所有的 `h1` 标签。这种全局样式一旦覆盖了不该覆盖的部分，可能会导致页面样式出现不可预期的混乱。在多人协作、跨团队开发时，这种“样式污染”现象尤为常见。\n\n为了解决这个问题，我们过去主要依赖以下几种方式：\n\n* 添加命名空间前缀，例如 `.my-comp h1 { color: red }`；\n* 使用构建工具支持的 CSS Modules；\n* 在 Vue 或 React 中使用 scoped 样式特性；\n* 使用 Shadow DOM 实现样式封装。\n\n这些方案都各有优缺点，但本质上都是“曲线救国”。\n\n---\n\n# Vue的scoped style\n\n提到scoped， 前端开发者们肯定会想到Vue的scoped style。它用于实现组件级别的样式隔离，可以让组件的样式只在当前组件内生效，不会影响全局。\nVue 是最早支持 scoped 样式的主流框架之一。\n\n## 实战示例：Vue scoped CSS 的使用方式\n\n```vue\n<template>\n  <div class=\"card\">\n    <h2>我是标题</h2>\n    <p>这是一段内容</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'ScopedCard'\n}\n</script>\n\n<style scoped>\n.card {\n  border: 1px solid #ccc;\n  padding: 1rem;\n  border-radius: 8px;\n}\n\n.card h2 {\n  color: steelblue;\n}\n\n.card p:hover {\n  background-color: #f0f0f0;\n}\n</style>\n```\n\nVue 中的 `<style scoped>` 是通过编译时处理实现的。\n\n## 实现原理\n\n1. 编译模板时，会给组件的根元素自动添加一个唯一的属性（如 `data-v-123456`）。\n2. 所有选择器都会被转化为带这个属性的选择器，例如：\n\n```css\nh1[data-v-123456] { color: red; }\n```\n\n这使得样式局部生效，但依赖构建工具。所以当我们通过开发者工具查看vue开发的项目时，会发现，样式的选择器都带有data-v-xxx的属性。\n![test](./images/css-scope/vue-scoped-style.png)\n\n## 存在的问题\n\n* ❌ 无法自动作用于子组件，除非使用 `::v-deep`；\n* ❌ 缺乏原生支持，不能脱离构建工具；\n* ❌ 编译后的选择器冗长，调试体验差；\n* ❌ 无法完全避免全局样式干扰。\n\n因此，Vue 的 scoped 是构建时 hack，而非 CSS 原生功能。\n\n---\n\n# 什么是 @scope？\n`@scope` 是 CSS 官方提出的作用域语法，它允许我们为样式规则限定作用范围，实现真正原生的样式隔离。\n\n## 基本语法\n\n```css\n<style>\n@scope (.my-comp) {\n  h1 {\n    color: red;\n  }\n}\n</style>\n<div class=\"my-comp\">\n  <h1>我是红色的</h1>\n</div>\n<h1>我没有变红</h1>\n```\n\n只有 `.my-comp` 元素内的 `h1` 才会生效。\n![result](./images/css-scope/result.png)\n\n## 特性优势\n\n* ✅ 原生支持，无需依赖构建工具；\n* ✅ 支持所有标准选择器和伪类；\n* ✅ 可以嵌套和组合使用；\n* ✅ 不依赖类名、属性名等技术手段；\n* ✅ 可与 `<style>` 标签结合，适用于组件化开发。\n\n---\n\n## 内联使用 @scope：更自然的组件化体验\n\n`@scope` 也可以与内联 `<style>` 标签结合使用：\n\n```html\n<div class=\"card\">\n  <style>\n    @scope (.card) {\n      h2 {\n        color: steelblue;\n      }\n      p:hover {\n        background: #f0f0f0;\n      }\n    }\n  </style>\n  <h2>标题</h2>\n  <p>内容段落</p>\n</div>\n```\n![inline](./images/css-scope/inline.png)\n相比传统的 scoped CSS，这种方式不依赖任何构建步骤，语义清晰，维护简单。\n\n---\n\n## 动态添加 @scope 样式\n\n在 JavaScript 中动态插入样式：\n\n```js\nconst style = document.createElement('style');\nstyle.textContent = `\n  @scope (.dynamic-box) {\n    span {\n      font-weight: bold;\n      color: orange;\n    }\n  }\n`;\ndocument.head.appendChild(style);\n```\n\n![dynamic](./images/css-scope/dynamic.png)\n适用于微前端、动态组件等运行时场景。\n\n---\n\n# 对比：@scope 与其他样式隔离方案\n\n| 方案             | 样式隔离 | 支持选择器 | 依赖工具链  | 浏览器支持    |\n| -------------- | ---- | ----- | ------ | -------- |\n| BEM 命名规范       | ❌    | ✅     | ❌      | ✅        |\n| CSS Modules    | ✅    | ✅     | ✅（构建时） | ✅        |\n| Shadow DOM     | ✅    | ✅     | ❌（原生）  | ✅        |\n| Vue scoped CSS | ✅    | 部分支持  | ✅（编译时） | ✅        |\n| **@scope**     | ✅    | ✅     | ❌      | ✅（逐步完善中） |\n\n---\n\n# 浏览器支持情况\n\n截至 2025 年中：\n\n* ✅ Chrome（111+）\n* ✅ Safari（16.4+）\n* ✅ Edge\n* ⚠️ Firefox：需手动开启 `layout.css.scope.enabled`\n\n👉 [Can I Use: @scope](https://caniuse.com/?search=%40scope)\n\n---\n\n# 使用建议\n\n* ✅ 推荐用于组件化样式隔离；\n* ✅ SSR 场景优选，兼容性好；\n* ✅ 可用于构建无依赖的 UI 组件；\n* ⚠️ 老旧浏览器（如 IE11）不支持；\n* ⚠️ 当前阶段可与 scoped CSS 搭配使用；\n\n---\n\n# 总结\n\n`@scope` 的出现为 CSS 带来了“模块化思维”。它弥补了长期以来 CSS 缺乏作用域机制的缺陷，为组件开发带来了新的可能。\n\n相比构建时方案（如 Vue scoped、CSS Modules）或高成本方案（如 Shadow DOM），`@scope` 提供了一种更自然、更贴近语义的写法。\n\n未来，我们或许可以更少依赖工具链，而更多依赖浏览器原生能力来实现高质量的组件样式隔离。\n\n```css\n@scope (.card) {\n  h1 {\n    color: blue;\n  }\n}\n```\n\n简单、直观、强大。\n\n---\n\n# 延伸阅读\n\n* [MDN：@scope](https://developer.mozilla.org/en-US/docs/Web/CSS/@scope)\n* [Chrome Platform Status](https://chromestatus.com/feature/5798754575984640)\n* [Scoped Styles Draft Spec](https://drafts.csswg.org/css-cascade-6/#scope)\n\n---\n\n如果你觉得这篇文章有帮助，欢迎点赞 / 收藏 / 留言交流 🙌\n\n如需更多框架实战例子（如 React / Web Components 中的应用），也欢迎留言告诉我。","slug":"css-scope","published":1,"updated":"2025-06-03T08:22:43.106Z","_id":"cmbfxx8pc00005sp1cy3uhrwb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在前端开发中，“样式污染”一直是一个反复出现的问题。尤其在构建大型项目或维护多个组件库时，全局 CSS 的不确定性会带来许多调试难题。为了实现组件级样式隔离，我们使用过许多手段：BEM 命名规范、CSS Modules、Vue 的 scoped 样式、甚至 Shadow DOM。但今天，我们迎来了一个更加原生、简洁的解决方案：<code>@scope</code>。</p>\n<p>本文将带你了解 CSS 的这项新特性，以及它在组件样式管理中的应用实践，并结合 Vue 的 scoped 实战与对比，探讨 <code>@scope</code> 的优势与适用场景，看看它是否真的值得期待。</p>\n<h1 id=\"为什么我们需要作用域-CSS？\"><a href=\"#为什么我们需要作用域-CSS？\" class=\"headerlink\" title=\"为什么我们需要作用域 CSS？\"></a>为什么我们需要作用域 CSS？</h1><p>我们先从一个经典的例子开始说起：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"selector-tag\">h1</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">color</span>: red;</span></span><br><span class=\"line\"><span class=\"language-css\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my-comp&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是红色的<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我也变红了<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/css-scope/test1.png\" alt=\"test\"></p>\n<p>这段样式会作用于页面中所有的 <code>h1</code> 标签。这种全局样式一旦覆盖了不该覆盖的部分，可能会导致页面样式出现不可预期的混乱。在多人协作、跨团队开发时，这种“样式污染”现象尤为常见。</p>\n<p>为了解决这个问题，我们过去主要依赖以下几种方式：</p>\n<ul>\n<li>添加命名空间前缀，例如 <code>.my-comp h1 &#123; color: red &#125;</code>；</li>\n<li>使用构建工具支持的 CSS Modules；</li>\n<li>在 Vue 或 React 中使用 scoped 样式特性；</li>\n<li>使用 Shadow DOM 实现样式封装。</li>\n</ul>\n<p>这些方案都各有优缺点，但本质上都是“曲线救国”。</p>\n<hr>\n<h1 id=\"Vue的scoped-style\"><a href=\"#Vue的scoped-style\" class=\"headerlink\" title=\"Vue的scoped style\"></a>Vue的scoped style</h1><p>提到scoped， 前端开发者们肯定会想到Vue的scoped style。它用于实现组件级别的样式隔离，可以让组件的样式只在当前组件内生效，不会影响全局。<br>Vue 是最早支持 scoped 样式的主流框架之一。</p>\n<h2 id=\"实战示例：Vue-scoped-CSS-的使用方式\"><a href=\"#实战示例：Vue-scoped-CSS-的使用方式\" class=\"headerlink\" title=\"实战示例：Vue scoped CSS 的使用方式\"></a>实战示例：Vue scoped CSS 的使用方式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class=\"line\">    &lt;p&gt;这是一段内容&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;ScopedCard&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">.card &#123;</span><br><span class=\"line\">  border: 1px solid #ccc;</span><br><span class=\"line\">  padding: 1rem;</span><br><span class=\"line\">  border-radius: 8px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.card h2 &#123;</span><br><span class=\"line\">  color: steelblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.card p:hover &#123;</span><br><span class=\"line\">  background-color: #f0f0f0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>Vue 中的 <code>&lt;style scoped&gt;</code> 是通过编译时处理实现的。</p>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><ol>\n<li>编译模板时，会给组件的根元素自动添加一个唯一的属性（如 <code>data-v-123456</code>）。</li>\n<li>所有选择器都会被转化为带这个属性的选择器，例如：</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span><span class=\"selector-attr\">[data-v-123456]</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这使得样式局部生效，但依赖构建工具。所以当我们通过开发者工具查看vue开发的项目时，会发现，样式的选择器都带有data-v-xxx的属性。<br><img src=\"/blog/./images/css-scope/vue-scoped-style.png\" alt=\"test\"></p>\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><ul>\n<li>❌ 无法自动作用于子组件，除非使用 <code>::v-deep</code>；</li>\n<li>❌ 缺乏原生支持，不能脱离构建工具；</li>\n<li>❌ 编译后的选择器冗长，调试体验差；</li>\n<li>❌ 无法完全避免全局样式干扰。</li>\n</ul>\n<p>因此，Vue 的 scoped 是构建时 hack，而非 CSS 原生功能。</p>\n<hr>\n<h1 id=\"什么是-scope？\"><a href=\"#什么是-scope？\" class=\"headerlink\" title=\"什么是 @scope？\"></a>什么是 @scope？</h1><p><code>@scope</code> 是 CSS 官方提出的作用域语法，它允许我们为样式规则限定作用范围，实现真正原生的样式隔离。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"><span class=\"keyword\">@scope</span> (.my-comp) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=&quot;my-comp&quot;&gt;</span><br><span class=\"line\">  &lt;<span class=\"selector-tag\">h1</span>&gt;我是红色的&lt;/<span class=\"selector-tag\">h1</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">h1</span>&gt;我没有变红&lt;/<span class=\"selector-tag\">h1</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>只有 <code>.my-comp</code> 元素内的 <code>h1</code> 才会生效。<br><img src=\"/blog/./images/css-scope/result.png\" alt=\"result\"></p>\n<h2 id=\"特性优势\"><a href=\"#特性优势\" class=\"headerlink\" title=\"特性优势\"></a>特性优势</h2><ul>\n<li>✅ 原生支持，无需依赖构建工具；</li>\n<li>✅ 支持所有标准选择器和伪类；</li>\n<li>✅ 可以嵌套和组合使用；</li>\n<li>✅ 不依赖类名、属性名等技术手段；</li>\n<li>✅ 可与 <code>&lt;style&gt;</code> 标签结合，适用于组件化开发。</li>\n</ul>\n<hr>\n<h2 id=\"内联使用-scope：更自然的组件化体验\"><a href=\"#内联使用-scope：更自然的组件化体验\" class=\"headerlink\" title=\"内联使用 @scope：更自然的组件化体验\"></a>内联使用 @scope：更自然的组件化体验</h2><p><code>@scope</code> 也可以与内联 <code>&lt;style&gt;</code> 标签结合使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;card&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"keyword\">@scope</span> (.card) &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"selector-tag\">h2</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"attribute\">color</span>: steelblue;</span></span><br><span class=\"line\"><span class=\"language-css\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:hover</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"attribute\">background</span>: <span class=\"number\">#f0f0f0</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>内容段落<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/css-scope/inline.png\" alt=\"inline\"><br>相比传统的 scoped CSS，这种方式不依赖任何构建步骤，语义清晰，维护简单。</p>\n<hr>\n<h2 id=\"动态添加-scope-样式\"><a href=\"#动态添加-scope-样式\" class=\"headerlink\" title=\"动态添加 @scope 样式\"></a>动态添加 @scope 样式</h2><p>在 JavaScript 中动态插入样式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> style = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;style&#x27;</span>);</span><br><span class=\"line\">style.<span class=\"property\">textContent</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  @scope (.dynamic-box) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    span &#123;</span></span><br><span class=\"line\"><span class=\"string\">      font-weight: bold;</span></span><br><span class=\"line\"><span class=\"string\">      color: orange;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"property\">head</span>.<span class=\"title function_\">appendChild</span>(style);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/css-scope/dynamic.png\" alt=\"dynamic\"><br>适用于微前端、动态组件等运行时场景。</p>\n<hr>\n<h1 id=\"对比：-scope-与其他样式隔离方案\"><a href=\"#对比：-scope-与其他样式隔离方案\" class=\"headerlink\" title=\"对比：@scope 与其他样式隔离方案\"></a>对比：@scope 与其他样式隔离方案</h1><table>\n<thead>\n<tr>\n<th>方案</th>\n<th>样式隔离</th>\n<th>支持选择器</th>\n<th>依赖工具链</th>\n<th>浏览器支持</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BEM 命名规范</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>CSS Modules</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅（构建时）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Shadow DOM</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌（原生）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Vue scoped CSS</td>\n<td>✅</td>\n<td>部分支持</td>\n<td>✅（编译时）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>@scope</strong></td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n<td>✅（逐步完善中）</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"浏览器支持情况\"><a href=\"#浏览器支持情况\" class=\"headerlink\" title=\"浏览器支持情况\"></a>浏览器支持情况</h1><p>截至 2025 年中：</p>\n<ul>\n<li>✅ Chrome（111+）</li>\n<li>✅ Safari（16.4+）</li>\n<li>✅ Edge</li>\n<li>⚠️ Firefox：需手动开启 <code>layout.css.scope.enabled</code></li>\n</ul>\n<p>👉 <a href=\"https://caniuse.com/?search=@scope\">Can I Use: @scope</a></p>\n<hr>\n<h1 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h1><ul>\n<li>✅ 推荐用于组件化样式隔离；</li>\n<li>✅ SSR 场景优选，兼容性好；</li>\n<li>✅ 可用于构建无依赖的 UI 组件；</li>\n<li>⚠️ 老旧浏览器（如 IE11）不支持；</li>\n<li>⚠️ 当前阶段可与 scoped CSS 搭配使用；</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><code>@scope</code> 的出现为 CSS 带来了“模块化思维”。它弥补了长期以来 CSS 缺乏作用域机制的缺陷，为组件开发带来了新的可能。</p>\n<p>相比构建时方案（如 Vue scoped、CSS Modules）或高成本方案（如 Shadow DOM），<code>@scope</code> 提供了一种更自然、更贴近语义的写法。</p>\n<p>未来，我们或许可以更少依赖工具链，而更多依赖浏览器原生能力来实现高质量的组件样式隔离。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@scope</span> (.card) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单、直观、强大。</p>\n<hr>\n<h1 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h1><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@scope\">MDN：@scope</a></li>\n<li><a href=\"https://chromestatus.com/feature/5798754575984640\">Chrome Platform Status</a></li>\n<li><a href=\"https://drafts.csswg.org/css-cascade-6/#scope\">Scoped Styles Draft Spec</a></li>\n</ul>\n<hr>\n<p>如果你觉得这篇文章有帮助，欢迎点赞 &#x2F; 收藏 &#x2F; 留言交流 🙌</p>\n<p>如需更多框架实战例子（如 React &#x2F; Web Components 中的应用），也欢迎留言告诉我。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前端开发中，“样式污染”一直是一个反复出现的问题。尤其在构建大型项目或维护多个组件库时，全局 CSS 的不确定性会带来许多调试难题。为了实现组件级样式隔离，我们使用过许多手段：BEM 命名规范、CSS Modules、Vue 的 scoped 样式、甚至 Shadow DOM。但今天，我们迎来了一个更加原生、简洁的解决方案：<code>@scope</code>。</p>\n<p>本文将带你了解 CSS 的这项新特性，以及它在组件样式管理中的应用实践，并结合 Vue 的 scoped 实战与对比，探讨 <code>@scope</code> 的优势与适用场景，看看它是否真的值得期待。</p>\n<h1 id=\"为什么我们需要作用域-CSS？\"><a href=\"#为什么我们需要作用域-CSS？\" class=\"headerlink\" title=\"为什么我们需要作用域 CSS？\"></a>为什么我们需要作用域 CSS？</h1><p>我们先从一个经典的例子开始说起：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"selector-tag\">h1</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">color</span>: red;</span></span><br><span class=\"line\"><span class=\"language-css\">  &#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;my-comp&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是红色的<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我也变红了<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/css-scope/test1.png\" alt=\"test\"></p>\n<p>这段样式会作用于页面中所有的 <code>h1</code> 标签。这种全局样式一旦覆盖了不该覆盖的部分，可能会导致页面样式出现不可预期的混乱。在多人协作、跨团队开发时，这种“样式污染”现象尤为常见。</p>\n<p>为了解决这个问题，我们过去主要依赖以下几种方式：</p>\n<ul>\n<li>添加命名空间前缀，例如 <code>.my-comp h1 &#123; color: red &#125;</code>；</li>\n<li>使用构建工具支持的 CSS Modules；</li>\n<li>在 Vue 或 React 中使用 scoped 样式特性；</li>\n<li>使用 Shadow DOM 实现样式封装。</li>\n</ul>\n<p>这些方案都各有优缺点，但本质上都是“曲线救国”。</p>\n<hr>\n<h1 id=\"Vue的scoped-style\"><a href=\"#Vue的scoped-style\" class=\"headerlink\" title=\"Vue的scoped style\"></a>Vue的scoped style</h1><p>提到scoped， 前端开发者们肯定会想到Vue的scoped style。它用于实现组件级别的样式隔离，可以让组件的样式只在当前组件内生效，不会影响全局。<br>Vue 是最早支持 scoped 样式的主流框架之一。</p>\n<h2 id=\"实战示例：Vue-scoped-CSS-的使用方式\"><a href=\"#实战示例：Vue-scoped-CSS-的使用方式\" class=\"headerlink\" title=\"实战示例：Vue scoped CSS 的使用方式\"></a>实战示例：Vue scoped CSS 的使用方式</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">    &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class=\"line\">    &lt;p&gt;这是一段内容&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &#x27;ScopedCard&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\">.card &#123;</span><br><span class=\"line\">  border: 1px solid #ccc;</span><br><span class=\"line\">  padding: 1rem;</span><br><span class=\"line\">  border-radius: 8px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.card h2 &#123;</span><br><span class=\"line\">  color: steelblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.card p:hover &#123;</span><br><span class=\"line\">  background-color: #f0f0f0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<p>Vue 中的 <code>&lt;style scoped&gt;</code> 是通过编译时处理实现的。</p>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><ol>\n<li>编译模板时，会给组件的根元素自动添加一个唯一的属性（如 <code>data-v-123456</code>）。</li>\n<li>所有选择器都会被转化为带这个属性的选择器，例如：</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span><span class=\"selector-attr\">[data-v-123456]</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这使得样式局部生效，但依赖构建工具。所以当我们通过开发者工具查看vue开发的项目时，会发现，样式的选择器都带有data-v-xxx的属性。<br><img src=\"/blog/./images/css-scope/vue-scoped-style.png\" alt=\"test\"></p>\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><ul>\n<li>❌ 无法自动作用于子组件，除非使用 <code>::v-deep</code>；</li>\n<li>❌ 缺乏原生支持，不能脱离构建工具；</li>\n<li>❌ 编译后的选择器冗长，调试体验差；</li>\n<li>❌ 无法完全避免全局样式干扰。</li>\n</ul>\n<p>因此，Vue 的 scoped 是构建时 hack，而非 CSS 原生功能。</p>\n<hr>\n<h1 id=\"什么是-scope？\"><a href=\"#什么是-scope？\" class=\"headerlink\" title=\"什么是 @scope？\"></a>什么是 @scope？</h1><p><code>@scope</code> 是 CSS 官方提出的作用域语法，它允许我们为样式规则限定作用范围，实现真正原生的样式隔离。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\"><span class=\"keyword\">@scope</span> (.my-comp) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">div</span> class=&quot;my-comp&quot;&gt;</span><br><span class=\"line\">  &lt;<span class=\"selector-tag\">h1</span>&gt;我是红色的&lt;/<span class=\"selector-tag\">h1</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"selector-tag\">div</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">h1</span>&gt;我没有变红&lt;/<span class=\"selector-tag\">h1</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>只有 <code>.my-comp</code> 元素内的 <code>h1</code> 才会生效。<br><img src=\"/blog/./images/css-scope/result.png\" alt=\"result\"></p>\n<h2 id=\"特性优势\"><a href=\"#特性优势\" class=\"headerlink\" title=\"特性优势\"></a>特性优势</h2><ul>\n<li>✅ 原生支持，无需依赖构建工具；</li>\n<li>✅ 支持所有标准选择器和伪类；</li>\n<li>✅ 可以嵌套和组合使用；</li>\n<li>✅ 不依赖类名、属性名等技术手段；</li>\n<li>✅ 可与 <code>&lt;style&gt;</code> 标签结合，适用于组件化开发。</li>\n</ul>\n<hr>\n<h2 id=\"内联使用-scope：更自然的组件化体验\"><a href=\"#内联使用-scope：更自然的组件化体验\" class=\"headerlink\" title=\"内联使用 @scope：更自然的组件化体验\"></a>内联使用 @scope：更自然的组件化体验</h2><p><code>@scope</code> 也可以与内联 <code>&lt;style&gt;</code> 标签结合使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;card&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"keyword\">@scope</span> (.card) &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"selector-tag\">h2</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"attribute\">color</span>: steelblue;</span></span><br><span class=\"line\"><span class=\"language-css\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:hover</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"attribute\">background</span>: <span class=\"number\">#f0f0f0</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">      &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>内容段落<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/./images/css-scope/inline.png\" alt=\"inline\"><br>相比传统的 scoped CSS，这种方式不依赖任何构建步骤，语义清晰，维护简单。</p>\n<hr>\n<h2 id=\"动态添加-scope-样式\"><a href=\"#动态添加-scope-样式\" class=\"headerlink\" title=\"动态添加 @scope 样式\"></a>动态添加 @scope 样式</h2><p>在 JavaScript 中动态插入样式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> style = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;style&#x27;</span>);</span><br><span class=\"line\">style.<span class=\"property\">textContent</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  @scope (.dynamic-box) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    span &#123;</span></span><br><span class=\"line\"><span class=\"string\">      font-weight: bold;</span></span><br><span class=\"line\"><span class=\"string\">      color: orange;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"property\">head</span>.<span class=\"title function_\">appendChild</span>(style);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/./images/css-scope/dynamic.png\" alt=\"dynamic\"><br>适用于微前端、动态组件等运行时场景。</p>\n<hr>\n<h1 id=\"对比：-scope-与其他样式隔离方案\"><a href=\"#对比：-scope-与其他样式隔离方案\" class=\"headerlink\" title=\"对比：@scope 与其他样式隔离方案\"></a>对比：@scope 与其他样式隔离方案</h1><table>\n<thead>\n<tr>\n<th>方案</th>\n<th>样式隔离</th>\n<th>支持选择器</th>\n<th>依赖工具链</th>\n<th>浏览器支持</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BEM 命名规范</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>CSS Modules</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅（构建时）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Shadow DOM</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌（原生）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Vue scoped CSS</td>\n<td>✅</td>\n<td>部分支持</td>\n<td>✅（编译时）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><strong>@scope</strong></td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n<td>✅（逐步完善中）</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"浏览器支持情况\"><a href=\"#浏览器支持情况\" class=\"headerlink\" title=\"浏览器支持情况\"></a>浏览器支持情况</h1><p>截至 2025 年中：</p>\n<ul>\n<li>✅ Chrome（111+）</li>\n<li>✅ Safari（16.4+）</li>\n<li>✅ Edge</li>\n<li>⚠️ Firefox：需手动开启 <code>layout.css.scope.enabled</code></li>\n</ul>\n<p>👉 <a href=\"https://caniuse.com/?search=@scope\">Can I Use: @scope</a></p>\n<hr>\n<h1 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h1><ul>\n<li>✅ 推荐用于组件化样式隔离；</li>\n<li>✅ SSR 场景优选，兼容性好；</li>\n<li>✅ 可用于构建无依赖的 UI 组件；</li>\n<li>⚠️ 老旧浏览器（如 IE11）不支持；</li>\n<li>⚠️ 当前阶段可与 scoped CSS 搭配使用；</li>\n</ul>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><code>@scope</code> 的出现为 CSS 带来了“模块化思维”。它弥补了长期以来 CSS 缺乏作用域机制的缺陷，为组件开发带来了新的可能。</p>\n<p>相比构建时方案（如 Vue scoped、CSS Modules）或高成本方案（如 Shadow DOM），<code>@scope</code> 提供了一种更自然、更贴近语义的写法。</p>\n<p>未来，我们或许可以更少依赖工具链，而更多依赖浏览器原生能力来实现高质量的组件样式隔离。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@scope</span> (.card) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: blue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单、直观、强大。</p>\n<hr>\n<h1 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h1><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/@scope\">MDN：@scope</a></li>\n<li><a href=\"https://chromestatus.com/feature/5798754575984640\">Chrome Platform Status</a></li>\n<li><a href=\"https://drafts.csswg.org/css-cascade-6/#scope\">Scoped Styles Draft Spec</a></li>\n</ul>\n<hr>\n<p>如果你觉得这篇文章有帮助，欢迎点赞 &#x2F; 收藏 &#x2F; 留言交流 🙌</p>\n<p>如需更多框架实战例子（如 React &#x2F; Web Components 中的应用），也欢迎留言告诉我。</p>\n"},{"title":"🚀 我们正在进入“任务级编程”时代，Copilot 已经过时了","date":"2025-06-04T07:30:06.000Z","_content":"\n近日，OpenAI 重大升级的 Codex 终于开放使用了。老夫也在第一时间试用了一下。这个版本的 Codex 不再是我们熟悉的“代码补全助手”Copilot，它开始具备真正的“任务代理”能力——理解你要做什么、自己动手干、并提交一份可以合并的 PR。\n\n这标志着一个全新的时代正在到来：**任务级编程（Task-Level Programming）**。\n\n在这个新时代里，AI 不再只是帮你写几行代码，而是可以理解你提出的目标，自动去完成整个任务的工作流，包括分析上下文、查找 bug、设计变更方案、生成代码、运行测试、再打包成一个 PR 等。开发者的角色也将发生变化：从写代码的“工人”变成分配任务、评估质量的“指挥官”。\n\n---\n\n### 🧠 什么是“任务级编程”？\n\n回顾编程工具的发展，我们可以看到几个阶段性的变革：\n\n* **IDE 智能提示**：代表了“字符级编程”的黄金时代，从 IntelliSense 到 TabNine，自动补全成为开发者的标配工具。\n* **Copilot 式补全**：开启了“函数级编程”时代。你只要写一句注释或函数名，它就能帮你补出整个实现逻辑，甚至包含 edge case 的处理。\n* **Codex 任务代理**：正式迈入“任务级编程”时代。你用自然语言分配一个任务，它能识别全局上下文，查阅依赖关系，主动完成整个功能开发并提交代码。\n\n这是工具能力的飞跃，也意味着开发者思维方式的转型。程序员正在从代码的“创造者”转变为任务的“构建者”，更接近产品经理、架构师的角色。\n\n---\n\n### 🔧 Codex：不再是补全，而是执行\n\nCodex 的 2025.6 更新让它获得了前所未有的执行能力，而不再只是文字预测模型。\n\n#### ✅ 云端执行任务\n\n每个任务在独立沙箱中运行，具备可控联网、环境隔离、依赖安装等能力。用户可以决定是否允许联网（如下载 openjdk）、是否运行测试用例、是否提交 PR。\n\n#### ✅ 自动生成 & 更新 Pull Request\n\nCodex 会根据任务内容自动识别应修改的文件并生成差异内容，随后打包成 PR 推送到你的代码仓库中。如果你后续修改了需求，它也能更新原有 PR，而不是每次新建一个。\n\n#### ✅ 支持语音输入、联网配置、文件变更控制\n\n在 ChatGPT 中，你甚至可以说一句：“修复订单模块中创建订单失败的问题”，Codex 就会扫描代码，找到关键逻辑，分析可能的问题点，并在隔离环境中测试修复建议。\n\n#### ✅ 理解全项目上下文（192K tokens）\n\nCodex 可读取接近 200K 字符的代码上下文，足以分析大型项目结构、模块间依赖、注释与 commit 记录、schema 结构等。这比 Copilot 的窗口大十倍以上，具备了真正的“项目级智能”。\n\n#### ✅ 自动运行测试\n\n在每一个任务执行过程中，Codex 不仅可以生成对应的单元测试，还能自动在隔离的沙箱环境中运行测试用例，验证逻辑正确性。测试失败时，它会尝试修复、重新运行，直到通过或生成说明文档解释原因。这使得它具备了“开发 + 验证”一体化的能力，极大减轻了人工测试与调试负担。\n\n---\n\n### 🎯 Copilot 的边界，也是 Codex 的起点\n\n| 特性              | GitHub Copilot | OpenAI Codex（2025）       |\n| --------------- | -------------- | ------------------------ |\n| 理解粒度            | 当前文件、当前函数      | 整个代码库、多个模块               |\n| 行为              | 辅助补全，开发者主导     | 执行任务，自动 PR，开发者审查         |\n| 工作模式            | 嵌入 IDE，实时建议    | ChatGPT 任务侧栏，沙箱中运行完整开发流程 |\n| 自动化程度           | 代码级补全          | 任务级开发                    |\n| 能否联网执行/安装依赖     | ❌ 不支持          | ✅ 支持（需授权）                |\n| 是否能跑测试/写测试用例    | 手动补全测试模板       | 自动生成测试代码并运行验证            |\n| Pull Request 处理 | 无内建 PR 支持      | 自动创建/更新 PR               |\n\n结论：**Copilot 是一个增强的 IDE 工具，而 Codex 是一个自动化的开发代理。** Copilot 帮你“写得快”，而 Codex 帮你“少写甚至不写”。在未来，“写代码”不再是生产力的衡量标准，“构建解决方案”才是。\n\n---\n\n### 🛠️ 开发者在这个新时代的角色变化\n\n在“任务级编程”中，开发者的身份从传统意义上的“键盘工匠”发生转变，开始更像是一个协调器、产品化思维者、审查员：\n\n* 我们不再是代码的“搬运工”，而是任务的分发者与质量把控者；\n* 我们更多是在告诉 Codex：“我想修复这个问题”，而不是“我来写具体哪几行”；\n* 我们需要关注业务逻辑、系统结构、跨模块一致性等“高阶目标”；\n* 我们的核心竞争力从“代码实现力”变成“需求理解力、判断力与审查力”。\n\n换句话说，AI 帮我们完成的是“代码执行”，而我们要完成的是“需求判断 + 成果验收”。\n\n---\n\n### 📺 实际演示（基于 Java 场景）\n\n#### 初始化项目\n```prompt\n请为我创建一个 Maven Java 项目，包含以下内容：\n\n实体类 User\n\nDTO 类 UserDto\n\n异常类 UserNotFoundException\n\n服务类 UserService，包含 getUserById 方法，使用 Optional<User>\n\n包结构建议为 com.example\n\n并生成对应的 pom.xml、目录结构和测试代码。\n``` \n任务完成，我们可以看到Codex已经按要求帮我们生成了6个文件：\n![project-init](./images/codex/project-init.png)\n\n查看拉取请求：\n![project-init-pr](./images/codex/project-init-pr.png)\n\n#### 🧪 场景：我让 Codex 修复了一个 NPE 错误\n\n1. 在Codex中创建任务：\n\n   > 修复 `UserService.getUserById()` 中可能的 null pointer 问题\n\n2. Codex 自动分析整个代码库，找到该方法：\n\n```java\npublic User getUserById(int id) {\n    return userRepository.findById(id).orElse(null);\n}\n```\n\n3. 它识别出 `null` 返回是导致 NPE 的关键，建议修改为：\n\n```java\npublic Optional<User> getUserById(int id) {\n    return userRepository.findById(id);\n}\n```\n通过查看任务日志我们可以看到Codex的思考过程：\n![npe](./images/codex/npe.png)\n\n4. 它还自动修改了调用该方法的多个文件，并生成了对应的变更说明和 Pull Request。\n\n5. 自动生成了对应的单元测试，并在沙箱环境中运行测试，确保修改不会引入新的问题。\n由于在项目开始，我们让Codex帮我们生成了测试代码，所以它可以直接运行测试，无需人工编写。\n![unit-test](./images/codex/unit-test.png)\n\n整个过程不到两分钟，我只需要看一眼差异内容，点击 Merge。\n\n这就是任务级编程的魅力——你不再“逐行写”，而是在“提出目标”之后让 AI 执行，而你则成为那个决定是否接受成果的人。\n\n---\n\n### 🧭 总结：Copilot 是“写代码”的终点，Codex 是“指挥代码”的起点\n\n* 软件开发的交互方式正在转变为任务驱动，而非字符驱动；\n* 工具不再局限于 IDE 插件，而是深入 DevOps 全链路，嵌入 CI/CD、PR 流程；\n* 我们需要学习的不是 API 文档，而是如何写出让 AI 理解的“开发意图”；\n* 下一代开发者，将不再问“你会写什么语言”，而是“你如何安排 AI 为你完成工作”。\n\n任务级编程不是幻想，而是已来。\n\n欢迎来到新时代。\n","source":"_posts/codex.md","raw":"---\ntitle: 🚀 我们正在进入“任务级编程”时代，Copilot 已经过时了\ndate: 2025-06-04 15:30:06\ntags:\n---\n\n近日，OpenAI 重大升级的 Codex 终于开放使用了。老夫也在第一时间试用了一下。这个版本的 Codex 不再是我们熟悉的“代码补全助手”Copilot，它开始具备真正的“任务代理”能力——理解你要做什么、自己动手干、并提交一份可以合并的 PR。\n\n这标志着一个全新的时代正在到来：**任务级编程（Task-Level Programming）**。\n\n在这个新时代里，AI 不再只是帮你写几行代码，而是可以理解你提出的目标，自动去完成整个任务的工作流，包括分析上下文、查找 bug、设计变更方案、生成代码、运行测试、再打包成一个 PR 等。开发者的角色也将发生变化：从写代码的“工人”变成分配任务、评估质量的“指挥官”。\n\n---\n\n### 🧠 什么是“任务级编程”？\n\n回顾编程工具的发展，我们可以看到几个阶段性的变革：\n\n* **IDE 智能提示**：代表了“字符级编程”的黄金时代，从 IntelliSense 到 TabNine，自动补全成为开发者的标配工具。\n* **Copilot 式补全**：开启了“函数级编程”时代。你只要写一句注释或函数名，它就能帮你补出整个实现逻辑，甚至包含 edge case 的处理。\n* **Codex 任务代理**：正式迈入“任务级编程”时代。你用自然语言分配一个任务，它能识别全局上下文，查阅依赖关系，主动完成整个功能开发并提交代码。\n\n这是工具能力的飞跃，也意味着开发者思维方式的转型。程序员正在从代码的“创造者”转变为任务的“构建者”，更接近产品经理、架构师的角色。\n\n---\n\n### 🔧 Codex：不再是补全，而是执行\n\nCodex 的 2025.6 更新让它获得了前所未有的执行能力，而不再只是文字预测模型。\n\n#### ✅ 云端执行任务\n\n每个任务在独立沙箱中运行，具备可控联网、环境隔离、依赖安装等能力。用户可以决定是否允许联网（如下载 openjdk）、是否运行测试用例、是否提交 PR。\n\n#### ✅ 自动生成 & 更新 Pull Request\n\nCodex 会根据任务内容自动识别应修改的文件并生成差异内容，随后打包成 PR 推送到你的代码仓库中。如果你后续修改了需求，它也能更新原有 PR，而不是每次新建一个。\n\n#### ✅ 支持语音输入、联网配置、文件变更控制\n\n在 ChatGPT 中，你甚至可以说一句：“修复订单模块中创建订单失败的问题”，Codex 就会扫描代码，找到关键逻辑，分析可能的问题点，并在隔离环境中测试修复建议。\n\n#### ✅ 理解全项目上下文（192K tokens）\n\nCodex 可读取接近 200K 字符的代码上下文，足以分析大型项目结构、模块间依赖、注释与 commit 记录、schema 结构等。这比 Copilot 的窗口大十倍以上，具备了真正的“项目级智能”。\n\n#### ✅ 自动运行测试\n\n在每一个任务执行过程中，Codex 不仅可以生成对应的单元测试，还能自动在隔离的沙箱环境中运行测试用例，验证逻辑正确性。测试失败时，它会尝试修复、重新运行，直到通过或生成说明文档解释原因。这使得它具备了“开发 + 验证”一体化的能力，极大减轻了人工测试与调试负担。\n\n---\n\n### 🎯 Copilot 的边界，也是 Codex 的起点\n\n| 特性              | GitHub Copilot | OpenAI Codex（2025）       |\n| --------------- | -------------- | ------------------------ |\n| 理解粒度            | 当前文件、当前函数      | 整个代码库、多个模块               |\n| 行为              | 辅助补全，开发者主导     | 执行任务，自动 PR，开发者审查         |\n| 工作模式            | 嵌入 IDE，实时建议    | ChatGPT 任务侧栏，沙箱中运行完整开发流程 |\n| 自动化程度           | 代码级补全          | 任务级开发                    |\n| 能否联网执行/安装依赖     | ❌ 不支持          | ✅ 支持（需授权）                |\n| 是否能跑测试/写测试用例    | 手动补全测试模板       | 自动生成测试代码并运行验证            |\n| Pull Request 处理 | 无内建 PR 支持      | 自动创建/更新 PR               |\n\n结论：**Copilot 是一个增强的 IDE 工具，而 Codex 是一个自动化的开发代理。** Copilot 帮你“写得快”，而 Codex 帮你“少写甚至不写”。在未来，“写代码”不再是生产力的衡量标准，“构建解决方案”才是。\n\n---\n\n### 🛠️ 开发者在这个新时代的角色变化\n\n在“任务级编程”中，开发者的身份从传统意义上的“键盘工匠”发生转变，开始更像是一个协调器、产品化思维者、审查员：\n\n* 我们不再是代码的“搬运工”，而是任务的分发者与质量把控者；\n* 我们更多是在告诉 Codex：“我想修复这个问题”，而不是“我来写具体哪几行”；\n* 我们需要关注业务逻辑、系统结构、跨模块一致性等“高阶目标”；\n* 我们的核心竞争力从“代码实现力”变成“需求理解力、判断力与审查力”。\n\n换句话说，AI 帮我们完成的是“代码执行”，而我们要完成的是“需求判断 + 成果验收”。\n\n---\n\n### 📺 实际演示（基于 Java 场景）\n\n#### 初始化项目\n```prompt\n请为我创建一个 Maven Java 项目，包含以下内容：\n\n实体类 User\n\nDTO 类 UserDto\n\n异常类 UserNotFoundException\n\n服务类 UserService，包含 getUserById 方法，使用 Optional<User>\n\n包结构建议为 com.example\n\n并生成对应的 pom.xml、目录结构和测试代码。\n``` \n任务完成，我们可以看到Codex已经按要求帮我们生成了6个文件：\n![project-init](./images/codex/project-init.png)\n\n查看拉取请求：\n![project-init-pr](./images/codex/project-init-pr.png)\n\n#### 🧪 场景：我让 Codex 修复了一个 NPE 错误\n\n1. 在Codex中创建任务：\n\n   > 修复 `UserService.getUserById()` 中可能的 null pointer 问题\n\n2. Codex 自动分析整个代码库，找到该方法：\n\n```java\npublic User getUserById(int id) {\n    return userRepository.findById(id).orElse(null);\n}\n```\n\n3. 它识别出 `null` 返回是导致 NPE 的关键，建议修改为：\n\n```java\npublic Optional<User> getUserById(int id) {\n    return userRepository.findById(id);\n}\n```\n通过查看任务日志我们可以看到Codex的思考过程：\n![npe](./images/codex/npe.png)\n\n4. 它还自动修改了调用该方法的多个文件，并生成了对应的变更说明和 Pull Request。\n\n5. 自动生成了对应的单元测试，并在沙箱环境中运行测试，确保修改不会引入新的问题。\n由于在项目开始，我们让Codex帮我们生成了测试代码，所以它可以直接运行测试，无需人工编写。\n![unit-test](./images/codex/unit-test.png)\n\n整个过程不到两分钟，我只需要看一眼差异内容，点击 Merge。\n\n这就是任务级编程的魅力——你不再“逐行写”，而是在“提出目标”之后让 AI 执行，而你则成为那个决定是否接受成果的人。\n\n---\n\n### 🧭 总结：Copilot 是“写代码”的终点，Codex 是“指挥代码”的起点\n\n* 软件开发的交互方式正在转变为任务驱动，而非字符驱动；\n* 工具不再局限于 IDE 插件，而是深入 DevOps 全链路，嵌入 CI/CD、PR 流程；\n* 我们需要学习的不是 API 文档，而是如何写出让 AI 理解的“开发意图”；\n* 下一代开发者，将不再问“你会写什么语言”，而是“你如何安排 AI 为你完成工作”。\n\n任务级编程不是幻想，而是已来。\n\n欢迎来到新时代。\n","slug":"codex","published":1,"updated":"2025-06-05T06:19:02.521Z","_id":"cmbhri8gg0000j8p100hlfr5n","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近日，OpenAI 重大升级的 Codex 终于开放使用了。老夫也在第一时间试用了一下。这个版本的 Codex 不再是我们熟悉的“代码补全助手”Copilot，它开始具备真正的“任务代理”能力——理解你要做什么、自己动手干、并提交一份可以合并的 PR。</p>\n<p>这标志着一个全新的时代正在到来：<strong>任务级编程（Task-Level Programming）</strong>。</p>\n<p>在这个新时代里，AI 不再只是帮你写几行代码，而是可以理解你提出的目标，自动去完成整个任务的工作流，包括分析上下文、查找 bug、设计变更方案、生成代码、运行测试、再打包成一个 PR 等。开发者的角色也将发生变化：从写代码的“工人”变成分配任务、评估质量的“指挥官”。</p>\n<hr>\n<h3 id=\"🧠-什么是“任务级编程”？\"><a href=\"#🧠-什么是“任务级编程”？\" class=\"headerlink\" title=\"🧠 什么是“任务级编程”？\"></a>🧠 什么是“任务级编程”？</h3><p>回顾编程工具的发展，我们可以看到几个阶段性的变革：</p>\n<ul>\n<li><strong>IDE 智能提示</strong>：代表了“字符级编程”的黄金时代，从 IntelliSense 到 TabNine，自动补全成为开发者的标配工具。</li>\n<li><strong>Copilot 式补全</strong>：开启了“函数级编程”时代。你只要写一句注释或函数名，它就能帮你补出整个实现逻辑，甚至包含 edge case 的处理。</li>\n<li><strong>Codex 任务代理</strong>：正式迈入“任务级编程”时代。你用自然语言分配一个任务，它能识别全局上下文，查阅依赖关系，主动完成整个功能开发并提交代码。</li>\n</ul>\n<p>这是工具能力的飞跃，也意味着开发者思维方式的转型。程序员正在从代码的“创造者”转变为任务的“构建者”，更接近产品经理、架构师的角色。</p>\n<hr>\n<h3 id=\"🔧-Codex：不再是补全，而是执行\"><a href=\"#🔧-Codex：不再是补全，而是执行\" class=\"headerlink\" title=\"🔧 Codex：不再是补全，而是执行\"></a>🔧 Codex：不再是补全，而是执行</h3><p>Codex 的 2025.6 更新让它获得了前所未有的执行能力，而不再只是文字预测模型。</p>\n<h4 id=\"✅-云端执行任务\"><a href=\"#✅-云端执行任务\" class=\"headerlink\" title=\"✅ 云端执行任务\"></a>✅ 云端执行任务</h4><p>每个任务在独立沙箱中运行，具备可控联网、环境隔离、依赖安装等能力。用户可以决定是否允许联网（如下载 openjdk）、是否运行测试用例、是否提交 PR。</p>\n<h4 id=\"✅-自动生成-更新-Pull-Request\"><a href=\"#✅-自动生成-更新-Pull-Request\" class=\"headerlink\" title=\"✅ 自动生成 &amp; 更新 Pull Request\"></a>✅ 自动生成 &amp; 更新 Pull Request</h4><p>Codex 会根据任务内容自动识别应修改的文件并生成差异内容，随后打包成 PR 推送到你的代码仓库中。如果你后续修改了需求，它也能更新原有 PR，而不是每次新建一个。</p>\n<h4 id=\"✅-支持语音输入、联网配置、文件变更控制\"><a href=\"#✅-支持语音输入、联网配置、文件变更控制\" class=\"headerlink\" title=\"✅ 支持语音输入、联网配置、文件变更控制\"></a>✅ 支持语音输入、联网配置、文件变更控制</h4><p>在 ChatGPT 中，你甚至可以说一句：“修复订单模块中创建订单失败的问题”，Codex 就会扫描代码，找到关键逻辑，分析可能的问题点，并在隔离环境中测试修复建议。</p>\n<h4 id=\"✅-理解全项目上下文（192K-tokens）\"><a href=\"#✅-理解全项目上下文（192K-tokens）\" class=\"headerlink\" title=\"✅ 理解全项目上下文（192K tokens）\"></a>✅ 理解全项目上下文（192K tokens）</h4><p>Codex 可读取接近 200K 字符的代码上下文，足以分析大型项目结构、模块间依赖、注释与 commit 记录、schema 结构等。这比 Copilot 的窗口大十倍以上，具备了真正的“项目级智能”。</p>\n<h4 id=\"✅-自动运行测试\"><a href=\"#✅-自动运行测试\" class=\"headerlink\" title=\"✅ 自动运行测试\"></a>✅ 自动运行测试</h4><p>在每一个任务执行过程中，Codex 不仅可以生成对应的单元测试，还能自动在隔离的沙箱环境中运行测试用例，验证逻辑正确性。测试失败时，它会尝试修复、重新运行，直到通过或生成说明文档解释原因。这使得它具备了“开发 + 验证”一体化的能力，极大减轻了人工测试与调试负担。</p>\n<hr>\n<h3 id=\"🎯-Copilot-的边界，也是-Codex-的起点\"><a href=\"#🎯-Copilot-的边界，也是-Codex-的起点\" class=\"headerlink\" title=\"🎯 Copilot 的边界，也是 Codex 的起点\"></a>🎯 Copilot 的边界，也是 Codex 的起点</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>GitHub Copilot</th>\n<th>OpenAI Codex（2025）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>理解粒度</td>\n<td>当前文件、当前函数</td>\n<td>整个代码库、多个模块</td>\n</tr>\n<tr>\n<td>行为</td>\n<td>辅助补全，开发者主导</td>\n<td>执行任务，自动 PR，开发者审查</td>\n</tr>\n<tr>\n<td>工作模式</td>\n<td>嵌入 IDE，实时建议</td>\n<td>ChatGPT 任务侧栏，沙箱中运行完整开发流程</td>\n</tr>\n<tr>\n<td>自动化程度</td>\n<td>代码级补全</td>\n<td>任务级开发</td>\n</tr>\n<tr>\n<td>能否联网执行&#x2F;安装依赖</td>\n<td>❌ 不支持</td>\n<td>✅ 支持（需授权）</td>\n</tr>\n<tr>\n<td>是否能跑测试&#x2F;写测试用例</td>\n<td>手动补全测试模板</td>\n<td>自动生成测试代码并运行验证</td>\n</tr>\n<tr>\n<td>Pull Request 处理</td>\n<td>无内建 PR 支持</td>\n<td>自动创建&#x2F;更新 PR</td>\n</tr>\n</tbody></table>\n<p>结论：<strong>Copilot 是一个增强的 IDE 工具，而 Codex 是一个自动化的开发代理。</strong> Copilot 帮你“写得快”，而 Codex 帮你“少写甚至不写”。在未来，“写代码”不再是生产力的衡量标准，“构建解决方案”才是。</p>\n<hr>\n<h3 id=\"🛠️-开发者在这个新时代的角色变化\"><a href=\"#🛠️-开发者在这个新时代的角色变化\" class=\"headerlink\" title=\"🛠️ 开发者在这个新时代的角色变化\"></a>🛠️ 开发者在这个新时代的角色变化</h3><p>在“任务级编程”中，开发者的身份从传统意义上的“键盘工匠”发生转变，开始更像是一个协调器、产品化思维者、审查员：</p>\n<ul>\n<li>我们不再是代码的“搬运工”，而是任务的分发者与质量把控者；</li>\n<li>我们更多是在告诉 Codex：“我想修复这个问题”，而不是“我来写具体哪几行”；</li>\n<li>我们需要关注业务逻辑、系统结构、跨模块一致性等“高阶目标”；</li>\n<li>我们的核心竞争力从“代码实现力”变成“需求理解力、判断力与审查力”。</li>\n</ul>\n<p>换句话说，AI 帮我们完成的是“代码执行”，而我们要完成的是“需求判断 + 成果验收”。</p>\n<hr>\n<h3 id=\"📺-实际演示（基于-Java-场景）\"><a href=\"#📺-实际演示（基于-Java-场景）\" class=\"headerlink\" title=\"📺 实际演示（基于 Java 场景）\"></a>📺 实际演示（基于 Java 场景）</h3><h4 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请为我创建一个 Maven Java 项目，包含以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">实体类 User</span><br><span class=\"line\"></span><br><span class=\"line\">DTO 类 UserDto</span><br><span class=\"line\"></span><br><span class=\"line\">异常类 UserNotFoundException</span><br><span class=\"line\"></span><br><span class=\"line\">服务类 UserService，包含 getUserById 方法，使用 Optional&lt;User&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">包结构建议为 com.example</span><br><span class=\"line\"></span><br><span class=\"line\">并生成对应的 pom.xml、目录结构和测试代码。</span><br></pre></td></tr></table></figure>\n<p>任务完成，我们可以看到Codex已经按要求帮我们生成了6个文件：<br><img src=\"/blog/./images/codex/project-init.png\" alt=\"project-init\"></p>\n<p>查看拉取请求：<br><img src=\"/blog/./images/codex/project-init-pr.png\" alt=\"project-init-pr\"></p>\n<h4 id=\"🧪-场景：我让-Codex-修复了一个-NPE-错误\"><a href=\"#🧪-场景：我让-Codex-修复了一个-NPE-错误\" class=\"headerlink\" title=\"🧪 场景：我让 Codex 修复了一个 NPE 错误\"></a>🧪 场景：我让 Codex 修复了一个 NPE 错误</h4><ol>\n<li><p>在Codex中创建任务：</p>\n<blockquote>\n<p>修复 <code>UserService.getUserById()</code> 中可能的 null pointer 问题</p>\n</blockquote>\n</li>\n<li><p>Codex 自动分析整个代码库，找到该方法：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">getUserById</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userRepository.findById(id).orElse(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>它识别出 <code>null</code> 返回是导致 NPE 的关键，建议修改为：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Optional&lt;User&gt; <span class=\"title function_\">getUserById</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userRepository.findById(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查看任务日志我们可以看到Codex的思考过程：<br><img src=\"/blog/./images/codex/npe.png\" alt=\"npe\"></p>\n<ol start=\"4\">\n<li><p>它还自动修改了调用该方法的多个文件，并生成了对应的变更说明和 Pull Request。</p>\n</li>\n<li><p>自动生成了对应的单元测试，并在沙箱环境中运行测试，确保修改不会引入新的问题。<br>由于在项目开始，我们让Codex帮我们生成了测试代码，所以它可以直接运行测试，无需人工编写。<br><img src=\"/blog/./images/codex/unit-test.png\" alt=\"unit-test\"></p>\n</li>\n</ol>\n<p>整个过程不到两分钟，我只需要看一眼差异内容，点击 Merge。</p>\n<p>这就是任务级编程的魅力——你不再“逐行写”，而是在“提出目标”之后让 AI 执行，而你则成为那个决定是否接受成果的人。</p>\n<hr>\n<h3 id=\"🧭-总结：Copilot-是“写代码”的终点，Codex-是“指挥代码”的起点\"><a href=\"#🧭-总结：Copilot-是“写代码”的终点，Codex-是“指挥代码”的起点\" class=\"headerlink\" title=\"🧭 总结：Copilot 是“写代码”的终点，Codex 是“指挥代码”的起点\"></a>🧭 总结：Copilot 是“写代码”的终点，Codex 是“指挥代码”的起点</h3><ul>\n<li>软件开发的交互方式正在转变为任务驱动，而非字符驱动；</li>\n<li>工具不再局限于 IDE 插件，而是深入 DevOps 全链路，嵌入 CI&#x2F;CD、PR 流程；</li>\n<li>我们需要学习的不是 API 文档，而是如何写出让 AI 理解的“开发意图”；</li>\n<li>下一代开发者，将不再问“你会写什么语言”，而是“你如何安排 AI 为你完成工作”。</li>\n</ul>\n<p>任务级编程不是幻想，而是已来。</p>\n<p>欢迎来到新时代。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>近日，OpenAI 重大升级的 Codex 终于开放使用了。老夫也在第一时间试用了一下。这个版本的 Codex 不再是我们熟悉的“代码补全助手”Copilot，它开始具备真正的“任务代理”能力——理解你要做什么、自己动手干、并提交一份可以合并的 PR。</p>\n<p>这标志着一个全新的时代正在到来：<strong>任务级编程（Task-Level Programming）</strong>。</p>\n<p>在这个新时代里，AI 不再只是帮你写几行代码，而是可以理解你提出的目标，自动去完成整个任务的工作流，包括分析上下文、查找 bug、设计变更方案、生成代码、运行测试、再打包成一个 PR 等。开发者的角色也将发生变化：从写代码的“工人”变成分配任务、评估质量的“指挥官”。</p>\n<hr>\n<h3 id=\"🧠-什么是“任务级编程”？\"><a href=\"#🧠-什么是“任务级编程”？\" class=\"headerlink\" title=\"🧠 什么是“任务级编程”？\"></a>🧠 什么是“任务级编程”？</h3><p>回顾编程工具的发展，我们可以看到几个阶段性的变革：</p>\n<ul>\n<li><strong>IDE 智能提示</strong>：代表了“字符级编程”的黄金时代，从 IntelliSense 到 TabNine，自动补全成为开发者的标配工具。</li>\n<li><strong>Copilot 式补全</strong>：开启了“函数级编程”时代。你只要写一句注释或函数名，它就能帮你补出整个实现逻辑，甚至包含 edge case 的处理。</li>\n<li><strong>Codex 任务代理</strong>：正式迈入“任务级编程”时代。你用自然语言分配一个任务，它能识别全局上下文，查阅依赖关系，主动完成整个功能开发并提交代码。</li>\n</ul>\n<p>这是工具能力的飞跃，也意味着开发者思维方式的转型。程序员正在从代码的“创造者”转变为任务的“构建者”，更接近产品经理、架构师的角色。</p>\n<hr>\n<h3 id=\"🔧-Codex：不再是补全，而是执行\"><a href=\"#🔧-Codex：不再是补全，而是执行\" class=\"headerlink\" title=\"🔧 Codex：不再是补全，而是执行\"></a>🔧 Codex：不再是补全，而是执行</h3><p>Codex 的 2025.6 更新让它获得了前所未有的执行能力，而不再只是文字预测模型。</p>\n<h4 id=\"✅-云端执行任务\"><a href=\"#✅-云端执行任务\" class=\"headerlink\" title=\"✅ 云端执行任务\"></a>✅ 云端执行任务</h4><p>每个任务在独立沙箱中运行，具备可控联网、环境隔离、依赖安装等能力。用户可以决定是否允许联网（如下载 openjdk）、是否运行测试用例、是否提交 PR。</p>\n<h4 id=\"✅-自动生成-更新-Pull-Request\"><a href=\"#✅-自动生成-更新-Pull-Request\" class=\"headerlink\" title=\"✅ 自动生成 &amp; 更新 Pull Request\"></a>✅ 自动生成 &amp; 更新 Pull Request</h4><p>Codex 会根据任务内容自动识别应修改的文件并生成差异内容，随后打包成 PR 推送到你的代码仓库中。如果你后续修改了需求，它也能更新原有 PR，而不是每次新建一个。</p>\n<h4 id=\"✅-支持语音输入、联网配置、文件变更控制\"><a href=\"#✅-支持语音输入、联网配置、文件变更控制\" class=\"headerlink\" title=\"✅ 支持语音输入、联网配置、文件变更控制\"></a>✅ 支持语音输入、联网配置、文件变更控制</h4><p>在 ChatGPT 中，你甚至可以说一句：“修复订单模块中创建订单失败的问题”，Codex 就会扫描代码，找到关键逻辑，分析可能的问题点，并在隔离环境中测试修复建议。</p>\n<h4 id=\"✅-理解全项目上下文（192K-tokens）\"><a href=\"#✅-理解全项目上下文（192K-tokens）\" class=\"headerlink\" title=\"✅ 理解全项目上下文（192K tokens）\"></a>✅ 理解全项目上下文（192K tokens）</h4><p>Codex 可读取接近 200K 字符的代码上下文，足以分析大型项目结构、模块间依赖、注释与 commit 记录、schema 结构等。这比 Copilot 的窗口大十倍以上，具备了真正的“项目级智能”。</p>\n<h4 id=\"✅-自动运行测试\"><a href=\"#✅-自动运行测试\" class=\"headerlink\" title=\"✅ 自动运行测试\"></a>✅ 自动运行测试</h4><p>在每一个任务执行过程中，Codex 不仅可以生成对应的单元测试，还能自动在隔离的沙箱环境中运行测试用例，验证逻辑正确性。测试失败时，它会尝试修复、重新运行，直到通过或生成说明文档解释原因。这使得它具备了“开发 + 验证”一体化的能力，极大减轻了人工测试与调试负担。</p>\n<hr>\n<h3 id=\"🎯-Copilot-的边界，也是-Codex-的起点\"><a href=\"#🎯-Copilot-的边界，也是-Codex-的起点\" class=\"headerlink\" title=\"🎯 Copilot 的边界，也是 Codex 的起点\"></a>🎯 Copilot 的边界，也是 Codex 的起点</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>GitHub Copilot</th>\n<th>OpenAI Codex（2025）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>理解粒度</td>\n<td>当前文件、当前函数</td>\n<td>整个代码库、多个模块</td>\n</tr>\n<tr>\n<td>行为</td>\n<td>辅助补全，开发者主导</td>\n<td>执行任务，自动 PR，开发者审查</td>\n</tr>\n<tr>\n<td>工作模式</td>\n<td>嵌入 IDE，实时建议</td>\n<td>ChatGPT 任务侧栏，沙箱中运行完整开发流程</td>\n</tr>\n<tr>\n<td>自动化程度</td>\n<td>代码级补全</td>\n<td>任务级开发</td>\n</tr>\n<tr>\n<td>能否联网执行&#x2F;安装依赖</td>\n<td>❌ 不支持</td>\n<td>✅ 支持（需授权）</td>\n</tr>\n<tr>\n<td>是否能跑测试&#x2F;写测试用例</td>\n<td>手动补全测试模板</td>\n<td>自动生成测试代码并运行验证</td>\n</tr>\n<tr>\n<td>Pull Request 处理</td>\n<td>无内建 PR 支持</td>\n<td>自动创建&#x2F;更新 PR</td>\n</tr>\n</tbody></table>\n<p>结论：<strong>Copilot 是一个增强的 IDE 工具，而 Codex 是一个自动化的开发代理。</strong> Copilot 帮你“写得快”，而 Codex 帮你“少写甚至不写”。在未来，“写代码”不再是生产力的衡量标准，“构建解决方案”才是。</p>\n<hr>\n<h3 id=\"🛠️-开发者在这个新时代的角色变化\"><a href=\"#🛠️-开发者在这个新时代的角色变化\" class=\"headerlink\" title=\"🛠️ 开发者在这个新时代的角色变化\"></a>🛠️ 开发者在这个新时代的角色变化</h3><p>在“任务级编程”中，开发者的身份从传统意义上的“键盘工匠”发生转变，开始更像是一个协调器、产品化思维者、审查员：</p>\n<ul>\n<li>我们不再是代码的“搬运工”，而是任务的分发者与质量把控者；</li>\n<li>我们更多是在告诉 Codex：“我想修复这个问题”，而不是“我来写具体哪几行”；</li>\n<li>我们需要关注业务逻辑、系统结构、跨模块一致性等“高阶目标”；</li>\n<li>我们的核心竞争力从“代码实现力”变成“需求理解力、判断力与审查力”。</li>\n</ul>\n<p>换句话说，AI 帮我们完成的是“代码执行”，而我们要完成的是“需求判断 + 成果验收”。</p>\n<hr>\n<h3 id=\"📺-实际演示（基于-Java-场景）\"><a href=\"#📺-实际演示（基于-Java-场景）\" class=\"headerlink\" title=\"📺 实际演示（基于 Java 场景）\"></a>📺 实际演示（基于 Java 场景）</h3><h4 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请为我创建一个 Maven Java 项目，包含以下内容：</span><br><span class=\"line\"></span><br><span class=\"line\">实体类 User</span><br><span class=\"line\"></span><br><span class=\"line\">DTO 类 UserDto</span><br><span class=\"line\"></span><br><span class=\"line\">异常类 UserNotFoundException</span><br><span class=\"line\"></span><br><span class=\"line\">服务类 UserService，包含 getUserById 方法，使用 Optional&lt;User&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">包结构建议为 com.example</span><br><span class=\"line\"></span><br><span class=\"line\">并生成对应的 pom.xml、目录结构和测试代码。</span><br></pre></td></tr></table></figure>\n<p>任务完成，我们可以看到Codex已经按要求帮我们生成了6个文件：<br><img src=\"/blog/./images/codex/project-init.png\" alt=\"project-init\"></p>\n<p>查看拉取请求：<br><img src=\"/blog/./images/codex/project-init-pr.png\" alt=\"project-init-pr\"></p>\n<h4 id=\"🧪-场景：我让-Codex-修复了一个-NPE-错误\"><a href=\"#🧪-场景：我让-Codex-修复了一个-NPE-错误\" class=\"headerlink\" title=\"🧪 场景：我让 Codex 修复了一个 NPE 错误\"></a>🧪 场景：我让 Codex 修复了一个 NPE 错误</h4><ol>\n<li><p>在Codex中创建任务：</p>\n<blockquote>\n<p>修复 <code>UserService.getUserById()</code> 中可能的 null pointer 问题</p>\n</blockquote>\n</li>\n<li><p>Codex 自动分析整个代码库，找到该方法：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">getUserById</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userRepository.findById(id).orElse(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>它识别出 <code>null</code> 返回是导致 NPE 的关键，建议修改为：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Optional&lt;User&gt; <span class=\"title function_\">getUserById</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userRepository.findById(id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过查看任务日志我们可以看到Codex的思考过程：<br><img src=\"/blog/./images/codex/npe.png\" alt=\"npe\"></p>\n<ol start=\"4\">\n<li><p>它还自动修改了调用该方法的多个文件，并生成了对应的变更说明和 Pull Request。</p>\n</li>\n<li><p>自动生成了对应的单元测试，并在沙箱环境中运行测试，确保修改不会引入新的问题。<br>由于在项目开始，我们让Codex帮我们生成了测试代码，所以它可以直接运行测试，无需人工编写。<br><img src=\"/blog/./images/codex/unit-test.png\" alt=\"unit-test\"></p>\n</li>\n</ol>\n<p>整个过程不到两分钟，我只需要看一眼差异内容，点击 Merge。</p>\n<p>这就是任务级编程的魅力——你不再“逐行写”，而是在“提出目标”之后让 AI 执行，而你则成为那个决定是否接受成果的人。</p>\n<hr>\n<h3 id=\"🧭-总结：Copilot-是“写代码”的终点，Codex-是“指挥代码”的起点\"><a href=\"#🧭-总结：Copilot-是“写代码”的终点，Codex-是“指挥代码”的起点\" class=\"headerlink\" title=\"🧭 总结：Copilot 是“写代码”的终点，Codex 是“指挥代码”的起点\"></a>🧭 总结：Copilot 是“写代码”的终点，Codex 是“指挥代码”的起点</h3><ul>\n<li>软件开发的交互方式正在转变为任务驱动，而非字符驱动；</li>\n<li>工具不再局限于 IDE 插件，而是深入 DevOps 全链路，嵌入 CI&#x2F;CD、PR 流程；</li>\n<li>我们需要学习的不是 API 文档，而是如何写出让 AI 理解的“开发意图”；</li>\n<li>下一代开发者，将不再问“你会写什么语言”，而是“你如何安排 AI 为你完成工作”。</li>\n</ul>\n<p>任务级编程不是幻想，而是已来。</p>\n<p>欢迎来到新时代。</p>\n"},{"title":"Promise 深度解析：从原理到实战","date":"2025-06-20T01:43:24.000Z","_content":"\n拙荆是一位测试工程师，说她是我的最佳对手也不为过，常常与我这个开发针尖对麦芒、唇枪舌剑。前几天她突然问我：“Promise 到底是啥？是不是非用不可？”我简单地解释了一番，她却似懂非懂，眼神中流露出明显的不满。于是我决定动笔写下这篇文章，一来是给她一个全面的交代，二来也整理一下自己对 Promise 的理解。\n![fight](./images/promise/fight.png)\n\n在 JavaScript 异步编程的世界里，Promise 是几乎无处不在的基础构件。即使你已经习惯使用 `async/await`，理解 Promise 的底层运行机制，仍然是深入掌握异步编程的关键。\n\n本篇文章将从 Promise 的基本用法讲起，逐步深入到微任务队列、链式调用原理、错误处理，再到一些常见的“看不懂输出顺序”的典型案例，并配以可调试的代码示例。\n\n---\n\n# 什么是 Promise?\n\n简单来说，Promise 是 JavaScript 提供的一种异步编程解决方案，用于表示一个**未来才会完成**的操作结果。它有三种状态：\n\n* `pending`：初始状态，既不是成功，也不是失败。\n* `fulfilled`：操作成功完成。\n* `rejected`：操作失败。\n\nPromise 的基本用法如下：\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('Hello, Promise!');\n  }, 1000);\n});\n\npromise.then(result => {\n  console.log(result); // 输出: Hello, Promise!\n});\n```\n\n更详细的介绍可以参考阮一峰的文章[Promise 对象](https://es6.ruanyifeng.com/#docs/promise)\n\n---\n\n# 📌 什么时候用 Promise\n下面是一些常见、实际开发中会用到 Promise 的典型场景：\n\n---\n\n## 1. **异步请求（最常见）**\n\n```js\nfetch('/api/data')\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n```\n\n> HTTP 请求需要时间，结果不是立即返回，必须用异步；而 Promise 能优雅地组织这些操作和错误处理。\n\n---\n\n\n## 2. **异步文件操作（在 Node.js 中）**\n\n```js\nconst fs = require('fs/promises');\n\nfs.readFile('file.txt', 'utf8')\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n```\n\n---\n\n## 3. **串行异步流程控制**\n\n有时候你需要一个任务完成后再执行下一个，不能全并发跑。\n\n```js\ngetUser()\n  .then(user => getPostsByUser(user.id))\n  .then(posts => display(posts));\n```\n\n---\n\n## 4. **并发任务的批量处理**\n\n比如一次加载多个资源，等全部完成后再进行处理：\n\n```js\nPromise.all([\n  fetch('/user'),\n  fetch('/posts'),\n  fetch('/comments')\n]).then(([user, posts, comments]) => {\n  // 全部都加载完了，统一处理\n});\n```\n\n---\n\n## 5. **定时器、延迟执行**\n\n```js\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\ndelay(1000).then(() => {\n  console.log('1秒后执行');\n});\n```\n\n---\n\n\n# 链式调用与返回值穿透\n\n```js\nPromise.resolve(1)\n  .then((res) => {\n    console.log(res); // 输出 1\n    return res + 1;\n  })\n  .then((res) => {\n    console.log(res); // 输出 2\n    return Promise.resolve(res + 1);\n  })\n  .then((res) => {\n    console.log(res); // 输出 3\n  });\n```\n\n* 每个 `.then()` 返回的都是一个新的 Promise。\n* 如果 `.then()` 中返回的是普通值，它会被 `Promise.resolve()` 包装。\n* 如果返回的是一个 Promise，则等待它的状态改变。\n\n---\n\n# 🔄 什么是 Event Loop（事件循环）？\n\nJavaScript 是单线程语言，只能一个任务一个任务地执行。那它是如何做到异步执行 `Promise`、`setTimeout` 等非阻塞任务的呢？这就离不开核心机制 —— **事件循环（Event Loop）**。\n\n事件循环的执行过程可以简化为：\n\n1. 执行主线程上的同步任务；\n2. 取出微任务队列（Microtask Queue）并依次执行完毕；\n3. 如果微任务队列为空，则执行一个宏任务（Macrotask）；\n4. 重复以上过程。\n\n![event_loop](./images/promise/event_loop.gif)\n\n---\n\n## 🧠 更直观地理解：\n\n每次 JavaScript 执行一个宏任务（如 `setTimeout` 回调、主线程代码等）后，会**立即清空当轮产生的所有微任务（如 Promise.then）**，然后再进入下一个宏任务。\n\n---\n\n## 📌 举个例子：\n\n```js\nconsole.log('start');\n\nsetTimeout(() => {\n  console.log('macro');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('micro');\n});\n\nconsole.log('end');\n```\n\n**输出顺序为：**\n\n```\nstart\nend\nmicro\nmacro\n```\n\n* `start` 和 `end` 属于同步任务；\n* `micro` 属于微任务，执行优先级高于宏任务；\n* `macro` 是下一个宏任务，最后执行。\n\n---\n\n# 常见执行顺序陷阱：请你猜猜输出\n## 多个微任务队列\n\n```js\nPromise.resolve().then(() => {\n    console.log(1);\n}).then(() => {\n    console.log(2);\n}).then(() => {\n    console.log(3);\n}).then(() => {\n    console.log(4);\n});\n\n\nPromise.resolve().then(() => {\n    console.log('A');\n}).then(() => {\n    console.log('B');\n}).then(() => {\n    console.log('C');\n}).then(() => {\n    console.log('D');\n});\n```\n\n**输出为：**\n\n```\n1\nA\n2\nB\n3\nC\n4\nD\n```\n### 🧠**原因分析：**\n\n虽然看起来你是写了两条链，但它们会**交错执行**，这与 JavaScript 中的**微任务队列**行为密切相关。\n\n---\n\n### 🔍 执行过程详解：\n\nJavaScript 执行模型是这样的：\n\n1. 执行同步代码（全局同步代码优先）；\n2. 执行微任务队列（microtasks）：包括 Promise 的 `.then()`、`MutationObserver`、`queueMicrotask()`；\n3. 执行宏任务队列（macrotasks）：如 `setTimeout`、`setInterval`、I/O 等。\n\n\n![multi-queue](./images/promise/multi-queue.png)\n---\n\n#### ✅ 第一步：同步阶段\n\n* 没有任何同步 `console.log()`，所以直接进入**微任务阶段**。\n\n---\n\n#### ✅ 第二步：第一轮微任务队列\n\n全局有两个 Promise 链：\n\n```js\n// 链1\nPromise.resolve().then(() => console.log(1)) // 微任务A\n  .then(() => console.log(2))               // 微任务C\n  .then(() => console.log(3))               // 微任务E\n  .then(() => console.log(4));              // 微任务G\n\n// 链2\nPromise.resolve().then(() => console.log('A')) // 微任务B\n  .then(() => console.log('B'))                // 微任务D\n  .then(() => console.log('C'))                // 微任务F\n  .then(() => console.log('D'));               // 微任务H\n```\n\n但**重要的是**：\n\n* `Promise.resolve().then(...)` 是**立即进入微任务队列**的；\n* 后续 `.then(...)` 是在 **前一个 then 执行完后、产生的新微任务**！\n\n---\n\n### 👇 微任务轮次如下（每轮会清空当前所有微任务队列）：\n\n---\n\n#### 🌀 第一轮微任务队列：\n\n* 执行 `console.log(1)`（A）\n* 执行 `console.log('A')`（B）\n\n这两个是**最早入队**的两个 `.then()`，并且没有前置依赖。\n\n**输出：**\n\n```\n1\nA\n```\n\n---\n\n#### 🌀 第二轮微任务队列：\n\n* 上一轮执行完 `console.log(1)`，它的 `.then(() => console.log(2))`（C）被加入；\n* 执行完 `console.log('A')`，它的 `.then(() => console.log('B'))`（D）被加入。\n\n现在队列中是：\n\n* `console.log(2)`（C）\n* `console.log('B')`（D）\n\n**输出：**\n\n```\n2\nB\n```\n后面依次类推完成所有的输出，这里就不再赘述了。\n\n每一个 `.then()` 的回调都是**当前 Promise 链前一个 then 完成后，才加入下一轮微任务队列**，而两个链是**并发推进**的。\n\n---\n\n## 嵌套 Promise + 链式 Promise 组合类型\n\n```js\nPromise.resolve().then(() => {\n    console.log(1);\n    return Promise.resolve(5);\n}).then((res) => {\n    console.log(res);\n});\n\nPromise.resolve().then(() => {\n    console.log(2);\n}).then(() => {\n    console.log(3);\n}).then(() => {\n    console.log(4);\n}).then(() => {\n    console.log(6);\n});\n```\n\n### 💡**输出结果：**\n\n```\n1\n2\n3\n4\n5\n6\n```\n怎么样？惊不惊喜？意不意外？\n\n### 🧠**原因分析：**\n\n**为什么不是 \"1 2 5 3 4 6\"？**\n\n所有的 `.then()` 都是微任务，会按**创建顺序入队并逐步推进**。而且**两个链虽然几乎同时创建，但第二条链会先执行得更快**，这是重点。\n\n---\n\n#### ✅ 还原执行过程（按微任务轮次）：\n\n##### 🌐 同步阶段：\n\n* 两个 `Promise.resolve().then()` 被创建，注册了 `.then()` 回调，但没有同步输出。\n\n---\n\n##### 🌀 第 1 轮微任务队列（按创建顺序执行）：\n\n1. **第一个 `.then()` 回调**（来自第一条链）：\n\n```js\n() => {\n  console.log(1);\n  return Promise.resolve(5);\n}\n```\n\n输出：`1`\n返回值是一个新的 Promise，因此下一个 `.then(res => console.log(res))` 会**等待该 Promise 的结果**，**不会立即进入当前微任务队列**，而是延迟一轮。\n\n2. **第二条链的第一个 `.then()` 回调：**\n\n```js\n() => console.log(2)\n```\n\n输出：`2`\n\n---\n\n##### 🌀 第 2 轮微任务队列：\n\n接着入队的是这两个：\n\n1. 第二条链的 `.then(() => console.log(3))` → 输出：`3`\n2. 第一条链返回的 `Promise.resolve(5)` 被 resolve 后，产生一个新微任务 → `.then(res => console.log(res))` 被延迟到下一轮！\n\n---\n\n##### 🌀 第 3 轮微任务队列：\n\n1. 第二条链的 `.then(() => console.log(4))` → 输出：`4`\n\n---\n\n##### 🌀 第 4 轮微任务队列：\n\n1. 第一条链 `.then(res => console.log(res))` → 输出：`5`\n2. 第二条链 `.then(() => console.log(6))` → 输出：`6`\n\n---\n\n\n# 错误处理：catch 与链路中断\n\n```js\nPromise.resolve()\n  .then(() => {\n    throw new Error('Oops!');\n  })\n  .catch((err) => {\n    console.log('Caught:', err.message);\n  });\n```\n\n注意点：\n\n* 一旦在 `.then()` 中抛出错误，后续的 `.then()` 会被跳过，直到 `.catch()`。\n* `catch` 本质上也是 `then(undefined, onRejected)` 的语法糖。\n\n---\n\n# finally：无论成功失败都执行\n\n```js\nPromise.reject('error')\n  .catch(err => {\n    console.log('catch:', err);\n  })\n  .finally(() => {\n    console.log('finally: clean up');\n  });\n```\n\n* `finally` 不会接收任何参数。\n* 它在 promise 结束（无论成功或失败）后执行。\n* 它不会影响链式传值。\n\n---\n\n# 与 async/await 的融合\n\n`async/await` 其实是 Promise 的语法糖，让异步代码更像同步流程：\n\n```js\nasync function main() {\n  try {\n    const result = await Promise.resolve(123);\n    console.log(result); // 123\n  } catch (err) {\n    console.error('Error:', err);\n  }\n}\nmain();\n```\n\n等价于：\n\n```js\nPromise.resolve(123)\n  .then(res => console.log(res))\n  .catch(err => console.error('Error:', err));\n```\n\n---\n\n# 调试技巧与最佳实践\n\n* **避免嵌套地狱**：通过链式调用或 async/await 展平逻辑结构。\n* **统一错误处理**：链式调用最后用 `.catch()`，或者 try/catch 包裹 async 函数。\n* **使用 `Promise.all` 处理并发**：\n\n```js\nconst results = await Promise.all([fetchUser(), fetchPosts(), fetchComments()]);\n```\n\n* **合理使用 `Promise.race`** 做超时控制：\n\n```js\nconst timeout = new Promise((_, reject) => setTimeout(() => reject('timeout'), 3000));\nconst result = await Promise.race([fetchData(), timeout]);\n```\n\n---\n\n# 结语\n\n虽然现在大家更倾向于使用 `async/await`，但 Promise 是 async 的根基。真正理解 Promise 的行为顺序和状态变化，对于构建稳定、可维护的异步程序至关重要。掌握 Promise，不只是写出能跑的代码，而是写出**能预期、能控制的异步逻辑**。\n\n","source":"_posts/promise.md","raw":"---\ntitle: Promise 深度解析：从原理到实战\ndate: 2025-06-20 09:43:24\ntags:\n---\n\n拙荆是一位测试工程师，说她是我的最佳对手也不为过，常常与我这个开发针尖对麦芒、唇枪舌剑。前几天她突然问我：“Promise 到底是啥？是不是非用不可？”我简单地解释了一番，她却似懂非懂，眼神中流露出明显的不满。于是我决定动笔写下这篇文章，一来是给她一个全面的交代，二来也整理一下自己对 Promise 的理解。\n![fight](./images/promise/fight.png)\n\n在 JavaScript 异步编程的世界里，Promise 是几乎无处不在的基础构件。即使你已经习惯使用 `async/await`，理解 Promise 的底层运行机制，仍然是深入掌握异步编程的关键。\n\n本篇文章将从 Promise 的基本用法讲起，逐步深入到微任务队列、链式调用原理、错误处理，再到一些常见的“看不懂输出顺序”的典型案例，并配以可调试的代码示例。\n\n---\n\n# 什么是 Promise?\n\n简单来说，Promise 是 JavaScript 提供的一种异步编程解决方案，用于表示一个**未来才会完成**的操作结果。它有三种状态：\n\n* `pending`：初始状态，既不是成功，也不是失败。\n* `fulfilled`：操作成功完成。\n* `rejected`：操作失败。\n\nPromise 的基本用法如下：\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('Hello, Promise!');\n  }, 1000);\n});\n\npromise.then(result => {\n  console.log(result); // 输出: Hello, Promise!\n});\n```\n\n更详细的介绍可以参考阮一峰的文章[Promise 对象](https://es6.ruanyifeng.com/#docs/promise)\n\n---\n\n# 📌 什么时候用 Promise\n下面是一些常见、实际开发中会用到 Promise 的典型场景：\n\n---\n\n## 1. **异步请求（最常见）**\n\n```js\nfetch('/api/data')\n  .then(res => res.json())\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n```\n\n> HTTP 请求需要时间，结果不是立即返回，必须用异步；而 Promise 能优雅地组织这些操作和错误处理。\n\n---\n\n\n## 2. **异步文件操作（在 Node.js 中）**\n\n```js\nconst fs = require('fs/promises');\n\nfs.readFile('file.txt', 'utf8')\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n```\n\n---\n\n## 3. **串行异步流程控制**\n\n有时候你需要一个任务完成后再执行下一个，不能全并发跑。\n\n```js\ngetUser()\n  .then(user => getPostsByUser(user.id))\n  .then(posts => display(posts));\n```\n\n---\n\n## 4. **并发任务的批量处理**\n\n比如一次加载多个资源，等全部完成后再进行处理：\n\n```js\nPromise.all([\n  fetch('/user'),\n  fetch('/posts'),\n  fetch('/comments')\n]).then(([user, posts, comments]) => {\n  // 全部都加载完了，统一处理\n});\n```\n\n---\n\n## 5. **定时器、延迟执行**\n\n```js\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\ndelay(1000).then(() => {\n  console.log('1秒后执行');\n});\n```\n\n---\n\n\n# 链式调用与返回值穿透\n\n```js\nPromise.resolve(1)\n  .then((res) => {\n    console.log(res); // 输出 1\n    return res + 1;\n  })\n  .then((res) => {\n    console.log(res); // 输出 2\n    return Promise.resolve(res + 1);\n  })\n  .then((res) => {\n    console.log(res); // 输出 3\n  });\n```\n\n* 每个 `.then()` 返回的都是一个新的 Promise。\n* 如果 `.then()` 中返回的是普通值，它会被 `Promise.resolve()` 包装。\n* 如果返回的是一个 Promise，则等待它的状态改变。\n\n---\n\n# 🔄 什么是 Event Loop（事件循环）？\n\nJavaScript 是单线程语言，只能一个任务一个任务地执行。那它是如何做到异步执行 `Promise`、`setTimeout` 等非阻塞任务的呢？这就离不开核心机制 —— **事件循环（Event Loop）**。\n\n事件循环的执行过程可以简化为：\n\n1. 执行主线程上的同步任务；\n2. 取出微任务队列（Microtask Queue）并依次执行完毕；\n3. 如果微任务队列为空，则执行一个宏任务（Macrotask）；\n4. 重复以上过程。\n\n![event_loop](./images/promise/event_loop.gif)\n\n---\n\n## 🧠 更直观地理解：\n\n每次 JavaScript 执行一个宏任务（如 `setTimeout` 回调、主线程代码等）后，会**立即清空当轮产生的所有微任务（如 Promise.then）**，然后再进入下一个宏任务。\n\n---\n\n## 📌 举个例子：\n\n```js\nconsole.log('start');\n\nsetTimeout(() => {\n  console.log('macro');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('micro');\n});\n\nconsole.log('end');\n```\n\n**输出顺序为：**\n\n```\nstart\nend\nmicro\nmacro\n```\n\n* `start` 和 `end` 属于同步任务；\n* `micro` 属于微任务，执行优先级高于宏任务；\n* `macro` 是下一个宏任务，最后执行。\n\n---\n\n# 常见执行顺序陷阱：请你猜猜输出\n## 多个微任务队列\n\n```js\nPromise.resolve().then(() => {\n    console.log(1);\n}).then(() => {\n    console.log(2);\n}).then(() => {\n    console.log(3);\n}).then(() => {\n    console.log(4);\n});\n\n\nPromise.resolve().then(() => {\n    console.log('A');\n}).then(() => {\n    console.log('B');\n}).then(() => {\n    console.log('C');\n}).then(() => {\n    console.log('D');\n});\n```\n\n**输出为：**\n\n```\n1\nA\n2\nB\n3\nC\n4\nD\n```\n### 🧠**原因分析：**\n\n虽然看起来你是写了两条链，但它们会**交错执行**，这与 JavaScript 中的**微任务队列**行为密切相关。\n\n---\n\n### 🔍 执行过程详解：\n\nJavaScript 执行模型是这样的：\n\n1. 执行同步代码（全局同步代码优先）；\n2. 执行微任务队列（microtasks）：包括 Promise 的 `.then()`、`MutationObserver`、`queueMicrotask()`；\n3. 执行宏任务队列（macrotasks）：如 `setTimeout`、`setInterval`、I/O 等。\n\n\n![multi-queue](./images/promise/multi-queue.png)\n---\n\n#### ✅ 第一步：同步阶段\n\n* 没有任何同步 `console.log()`，所以直接进入**微任务阶段**。\n\n---\n\n#### ✅ 第二步：第一轮微任务队列\n\n全局有两个 Promise 链：\n\n```js\n// 链1\nPromise.resolve().then(() => console.log(1)) // 微任务A\n  .then(() => console.log(2))               // 微任务C\n  .then(() => console.log(3))               // 微任务E\n  .then(() => console.log(4));              // 微任务G\n\n// 链2\nPromise.resolve().then(() => console.log('A')) // 微任务B\n  .then(() => console.log('B'))                // 微任务D\n  .then(() => console.log('C'))                // 微任务F\n  .then(() => console.log('D'));               // 微任务H\n```\n\n但**重要的是**：\n\n* `Promise.resolve().then(...)` 是**立即进入微任务队列**的；\n* 后续 `.then(...)` 是在 **前一个 then 执行完后、产生的新微任务**！\n\n---\n\n### 👇 微任务轮次如下（每轮会清空当前所有微任务队列）：\n\n---\n\n#### 🌀 第一轮微任务队列：\n\n* 执行 `console.log(1)`（A）\n* 执行 `console.log('A')`（B）\n\n这两个是**最早入队**的两个 `.then()`，并且没有前置依赖。\n\n**输出：**\n\n```\n1\nA\n```\n\n---\n\n#### 🌀 第二轮微任务队列：\n\n* 上一轮执行完 `console.log(1)`，它的 `.then(() => console.log(2))`（C）被加入；\n* 执行完 `console.log('A')`，它的 `.then(() => console.log('B'))`（D）被加入。\n\n现在队列中是：\n\n* `console.log(2)`（C）\n* `console.log('B')`（D）\n\n**输出：**\n\n```\n2\nB\n```\n后面依次类推完成所有的输出，这里就不再赘述了。\n\n每一个 `.then()` 的回调都是**当前 Promise 链前一个 then 完成后，才加入下一轮微任务队列**，而两个链是**并发推进**的。\n\n---\n\n## 嵌套 Promise + 链式 Promise 组合类型\n\n```js\nPromise.resolve().then(() => {\n    console.log(1);\n    return Promise.resolve(5);\n}).then((res) => {\n    console.log(res);\n});\n\nPromise.resolve().then(() => {\n    console.log(2);\n}).then(() => {\n    console.log(3);\n}).then(() => {\n    console.log(4);\n}).then(() => {\n    console.log(6);\n});\n```\n\n### 💡**输出结果：**\n\n```\n1\n2\n3\n4\n5\n6\n```\n怎么样？惊不惊喜？意不意外？\n\n### 🧠**原因分析：**\n\n**为什么不是 \"1 2 5 3 4 6\"？**\n\n所有的 `.then()` 都是微任务，会按**创建顺序入队并逐步推进**。而且**两个链虽然几乎同时创建，但第二条链会先执行得更快**，这是重点。\n\n---\n\n#### ✅ 还原执行过程（按微任务轮次）：\n\n##### 🌐 同步阶段：\n\n* 两个 `Promise.resolve().then()` 被创建，注册了 `.then()` 回调，但没有同步输出。\n\n---\n\n##### 🌀 第 1 轮微任务队列（按创建顺序执行）：\n\n1. **第一个 `.then()` 回调**（来自第一条链）：\n\n```js\n() => {\n  console.log(1);\n  return Promise.resolve(5);\n}\n```\n\n输出：`1`\n返回值是一个新的 Promise，因此下一个 `.then(res => console.log(res))` 会**等待该 Promise 的结果**，**不会立即进入当前微任务队列**，而是延迟一轮。\n\n2. **第二条链的第一个 `.then()` 回调：**\n\n```js\n() => console.log(2)\n```\n\n输出：`2`\n\n---\n\n##### 🌀 第 2 轮微任务队列：\n\n接着入队的是这两个：\n\n1. 第二条链的 `.then(() => console.log(3))` → 输出：`3`\n2. 第一条链返回的 `Promise.resolve(5)` 被 resolve 后，产生一个新微任务 → `.then(res => console.log(res))` 被延迟到下一轮！\n\n---\n\n##### 🌀 第 3 轮微任务队列：\n\n1. 第二条链的 `.then(() => console.log(4))` → 输出：`4`\n\n---\n\n##### 🌀 第 4 轮微任务队列：\n\n1. 第一条链 `.then(res => console.log(res))` → 输出：`5`\n2. 第二条链 `.then(() => console.log(6))` → 输出：`6`\n\n---\n\n\n# 错误处理：catch 与链路中断\n\n```js\nPromise.resolve()\n  .then(() => {\n    throw new Error('Oops!');\n  })\n  .catch((err) => {\n    console.log('Caught:', err.message);\n  });\n```\n\n注意点：\n\n* 一旦在 `.then()` 中抛出错误，后续的 `.then()` 会被跳过，直到 `.catch()`。\n* `catch` 本质上也是 `then(undefined, onRejected)` 的语法糖。\n\n---\n\n# finally：无论成功失败都执行\n\n```js\nPromise.reject('error')\n  .catch(err => {\n    console.log('catch:', err);\n  })\n  .finally(() => {\n    console.log('finally: clean up');\n  });\n```\n\n* `finally` 不会接收任何参数。\n* 它在 promise 结束（无论成功或失败）后执行。\n* 它不会影响链式传值。\n\n---\n\n# 与 async/await 的融合\n\n`async/await` 其实是 Promise 的语法糖，让异步代码更像同步流程：\n\n```js\nasync function main() {\n  try {\n    const result = await Promise.resolve(123);\n    console.log(result); // 123\n  } catch (err) {\n    console.error('Error:', err);\n  }\n}\nmain();\n```\n\n等价于：\n\n```js\nPromise.resolve(123)\n  .then(res => console.log(res))\n  .catch(err => console.error('Error:', err));\n```\n\n---\n\n# 调试技巧与最佳实践\n\n* **避免嵌套地狱**：通过链式调用或 async/await 展平逻辑结构。\n* **统一错误处理**：链式调用最后用 `.catch()`，或者 try/catch 包裹 async 函数。\n* **使用 `Promise.all` 处理并发**：\n\n```js\nconst results = await Promise.all([fetchUser(), fetchPosts(), fetchComments()]);\n```\n\n* **合理使用 `Promise.race`** 做超时控制：\n\n```js\nconst timeout = new Promise((_, reject) => setTimeout(() => reject('timeout'), 3000));\nconst result = await Promise.race([fetchData(), timeout]);\n```\n\n---\n\n# 结语\n\n虽然现在大家更倾向于使用 `async/await`，但 Promise 是 async 的根基。真正理解 Promise 的行为顺序和状态变化，对于构建稳定、可维护的异步程序至关重要。掌握 Promise，不只是写出能跑的代码，而是写出**能预期、能控制的异步逻辑**。\n\n","slug":"promise","published":1,"updated":"2025-06-23T06:11:18.197Z","_id":"cmc4j4agh0000owp18rmmf4vn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>拙荆是一位测试工程师，说她是我的最佳对手也不为过，常常与我这个开发针尖对麦芒、唇枪舌剑。前几天她突然问我：“Promise 到底是啥？是不是非用不可？”我简单地解释了一番，她却似懂非懂，眼神中流露出明显的不满。于是我决定动笔写下这篇文章，一来是给她一个全面的交代，二来也整理一下自己对 Promise 的理解。<br><img src=\"/blog/./images/promise/fight.png\" alt=\"fight\"></p>\n<p>在 JavaScript 异步编程的世界里，Promise 是几乎无处不在的基础构件。即使你已经习惯使用 <code>async/await</code>，理解 Promise 的底层运行机制，仍然是深入掌握异步编程的关键。</p>\n<p>本篇文章将从 Promise 的基本用法讲起，逐步深入到微任务队列、链式调用原理、错误处理，再到一些常见的“看不懂输出顺序”的典型案例，并配以可调试的代码示例。</p>\n<hr>\n<h1 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise?\"></a>什么是 Promise?</h1><p>简单来说，Promise 是 JavaScript 提供的一种异步编程解决方案，用于表示一个<strong>未来才会完成</strong>的操作结果。它有三种状态：</p>\n<ul>\n<li><code>pending</code>：初始状态，既不是成功，也不是失败。</li>\n<li><code>fulfilled</code>：操作成功完成。</li>\n<li><code>rejected</code>：操作失败。</li>\n</ul>\n<p>Promise 的基本用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&#x27;Hello, Promise!&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 输出: Hello, Promise!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>更详细的介绍可以参考阮一峰的文章<a href=\"https://es6.ruanyifeng.com/#docs/promise\">Promise 对象</a></p>\n<hr>\n<h1 id=\"📌-什么时候用-Promise\"><a href=\"#📌-什么时候用-Promise\" class=\"headerlink\" title=\"📌 什么时候用 Promise\"></a>📌 什么时候用 Promise</h1><p>下面是一些常见、实际开发中会用到 Promise 的典型场景：</p>\n<hr>\n<h2 id=\"1-异步请求（最常见）\"><a href=\"#1-异步请求（最常见）\" class=\"headerlink\" title=\"1. 异步请求（最常见）\"></a>1. <strong>异步请求（最常见）</strong></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>HTTP 请求需要时间，结果不是立即返回，必须用异步；而 Promise 能优雅地组织这些操作和错误处理。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-异步文件操作（在-Node-js-中）\"><a href=\"#2-异步文件操作（在-Node-js-中）\" class=\"headerlink\" title=\"2. 异步文件操作（在 Node.js 中）\"></a>2. <strong>异步文件操作（在 Node.js 中）</strong></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs/promises&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file.txt&#x27;</span>, <span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-串行异步流程控制\"><a href=\"#3-串行异步流程控制\" class=\"headerlink\" title=\"3. 串行异步流程控制\"></a>3. <strong>串行异步流程控制</strong></h2><p>有时候你需要一个任务完成后再执行下一个，不能全并发跑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">getUser</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> <span class=\"title function_\">getPostsByUser</span>(user.<span class=\"property\">id</span>))</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">posts</span> =&gt;</span> <span class=\"title function_\">display</span>(posts));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-并发任务的批量处理\"><a href=\"#4-并发任务的批量处理\" class=\"headerlink\" title=\"4. 并发任务的批量处理\"></a>4. <strong>并发任务的批量处理</strong></h2><p>比如一次加载多个资源，等全部完成后再进行处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([</span><br><span class=\"line\">  <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/user&#x27;</span>),</span><br><span class=\"line\">  <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/posts&#x27;</span>),</span><br><span class=\"line\">  <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/comments&#x27;</span>)</span><br><span class=\"line\">]).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">[user, posts, comments]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 全部都加载完了，统一处理</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5-定时器、延迟执行\"><a href=\"#5-定时器、延迟执行\" class=\"headerlink\" title=\"5. 定时器、延迟执行\"></a>5. <strong>定时器、延迟执行</strong></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">delay</span>(<span class=\"params\">ms</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">setTimeout</span>(resolve, ms));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1秒后执行&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"链式调用与返回值穿透\"><a href=\"#链式调用与返回值穿透\" class=\"headerlink\" title=\"链式调用与返回值穿透\"></a>链式调用与返回值穿透</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(res + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出 3</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每个 <code>.then()</code> 返回的都是一个新的 Promise。</li>\n<li>如果 <code>.then()</code> 中返回的是普通值，它会被 <code>Promise.resolve()</code> 包装。</li>\n<li>如果返回的是一个 Promise，则等待它的状态改变。</li>\n</ul>\n<hr>\n<h1 id=\"🔄-什么是-Event-Loop（事件循环）？\"><a href=\"#🔄-什么是-Event-Loop（事件循环）？\" class=\"headerlink\" title=\"🔄 什么是 Event Loop（事件循环）？\"></a>🔄 什么是 Event Loop（事件循环）？</h1><p>JavaScript 是单线程语言，只能一个任务一个任务地执行。那它是如何做到异步执行 <code>Promise</code>、<code>setTimeout</code> 等非阻塞任务的呢？这就离不开核心机制 —— <strong>事件循环（Event Loop）</strong>。</p>\n<p>事件循环的执行过程可以简化为：</p>\n<ol>\n<li>执行主线程上的同步任务；</li>\n<li>取出微任务队列（Microtask Queue）并依次执行完毕；</li>\n<li>如果微任务队列为空，则执行一个宏任务（Macrotask）；</li>\n<li>重复以上过程。</li>\n</ol>\n<p><img src=\"/blog/./images/promise/event_loop.gif\" alt=\"event_loop\"></p>\n<hr>\n<h2 id=\"🧠-更直观地理解：\"><a href=\"#🧠-更直观地理解：\" class=\"headerlink\" title=\"🧠 更直观地理解：\"></a>🧠 更直观地理解：</h2><p>每次 JavaScript 执行一个宏任务（如 <code>setTimeout</code> 回调、主线程代码等）后，会<strong>立即清空当轮产生的所有微任务（如 Promise.then）</strong>，然后再进入下一个宏任务。</p>\n<hr>\n<h2 id=\"📌-举个例子：\"><a href=\"#📌-举个例子：\" class=\"headerlink\" title=\"📌 举个例子：\"></a>📌 举个例子：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;macro&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;micro&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出顺序为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start</span><br><span class=\"line\">end</span><br><span class=\"line\">micro</span><br><span class=\"line\">macro</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>start</code> 和 <code>end</code> 属于同步任务；</li>\n<li><code>micro</code> 属于微任务，执行优先级高于宏任务；</li>\n<li><code>macro</code> 是下一个宏任务，最后执行。</li>\n</ul>\n<hr>\n<h1 id=\"常见执行顺序陷阱：请你猜猜输出\"><a href=\"#常见执行顺序陷阱：请你猜猜输出\" class=\"headerlink\" title=\"常见执行顺序陷阱：请你猜猜输出\"></a>常见执行顺序陷阱：请你猜猜输出</h1><h2 id=\"多个微任务队列\"><a href=\"#多个微任务队列\" class=\"headerlink\" title=\"多个微任务队列\"></a>多个微任务队列</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;B&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">A</span><br><span class=\"line\">2</span><br><span class=\"line\">B</span><br><span class=\"line\">3</span><br><span class=\"line\">C</span><br><span class=\"line\">4</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure>\n<h3 id=\"🧠原因分析：\"><a href=\"#🧠原因分析：\" class=\"headerlink\" title=\"🧠原因分析：\"></a>🧠<strong>原因分析：</strong></h3><p>虽然看起来你是写了两条链，但它们会<strong>交错执行</strong>，这与 JavaScript 中的<strong>微任务队列</strong>行为密切相关。</p>\n<hr>\n<h3 id=\"🔍-执行过程详解：\"><a href=\"#🔍-执行过程详解：\" class=\"headerlink\" title=\"🔍 执行过程详解：\"></a>🔍 执行过程详解：</h3><p>JavaScript 执行模型是这样的：</p>\n<ol>\n<li>执行同步代码（全局同步代码优先）；</li>\n<li>执行微任务队列（microtasks）：包括 Promise 的 <code>.then()</code>、<code>MutationObserver</code>、<code>queueMicrotask()</code>；</li>\n<li>执行宏任务队列（macrotasks）：如 <code>setTimeout</code>、<code>setInterval</code>、I&#x2F;O 等。</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/blog/./images/promise/multi-queue.png\" alt=\"multi-queue\"></h2><h4 id=\"✅-第一步：同步阶段\"><a href=\"#✅-第一步：同步阶段\" class=\"headerlink\" title=\"✅ 第一步：同步阶段\"></a>✅ 第一步：同步阶段</h4><ul>\n<li>没有任何同步 <code>console.log()</code>，所以直接进入<strong>微任务阶段</strong>。</li>\n</ul>\n<hr>\n<h4 id=\"✅-第二步：第一轮微任务队列\"><a href=\"#✅-第二步：第一轮微任务队列\" class=\"headerlink\" title=\"✅ 第二步：第一轮微任务队列\"></a>✅ 第二步：第一轮微任务队列</h4><p>全局有两个 Promise 链：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链1</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)) <span class=\"comment\">// 微任务A</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>))               <span class=\"comment\">// 微任务C</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>))               <span class=\"comment\">// 微任务E</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>));              <span class=\"comment\">// 微任务G</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链2</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;A&#x27;</span>)) <span class=\"comment\">// 微任务B</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;B&#x27;</span>))                <span class=\"comment\">// 微任务D</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;C&#x27;</span>))                <span class=\"comment\">// 微任务F</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;D&#x27;</span>));               <span class=\"comment\">// 微任务H</span></span><br></pre></td></tr></table></figure>\n\n<p>但<strong>重要的是</strong>：</p>\n<ul>\n<li><code>Promise.resolve().then(...)</code> 是<strong>立即进入微任务队列</strong>的；</li>\n<li>后续 <code>.then(...)</code> 是在 <strong>前一个 then 执行完后、产生的新微任务</strong>！</li>\n</ul>\n<hr>\n<h3 id=\"👇-微任务轮次如下（每轮会清空当前所有微任务队列）：\"><a href=\"#👇-微任务轮次如下（每轮会清空当前所有微任务队列）：\" class=\"headerlink\" title=\"👇 微任务轮次如下（每轮会清空当前所有微任务队列）：\"></a>👇 微任务轮次如下（每轮会清空当前所有微任务队列）：</h3><hr>\n<h4 id=\"🌀-第一轮微任务队列：\"><a href=\"#🌀-第一轮微任务队列：\" class=\"headerlink\" title=\"🌀 第一轮微任务队列：\"></a>🌀 第一轮微任务队列：</h4><ul>\n<li>执行 <code>console.log(1)</code>（A）</li>\n<li>执行 <code>console.log(&#39;A&#39;)</code>（B）</li>\n</ul>\n<p>这两个是<strong>最早入队</strong>的两个 <code>.then()</code>，并且没有前置依赖。</p>\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"🌀-第二轮微任务队列：\"><a href=\"#🌀-第二轮微任务队列：\" class=\"headerlink\" title=\"🌀 第二轮微任务队列：\"></a>🌀 第二轮微任务队列：</h4><ul>\n<li>上一轮执行完 <code>console.log(1)</code>，它的 <code>.then(() =&gt; console.log(2))</code>（C）被加入；</li>\n<li>执行完 <code>console.log(&#39;A&#39;)</code>，它的 <code>.then(() =&gt; console.log(&#39;B&#39;))</code>（D）被加入。</li>\n</ul>\n<p>现在队列中是：</p>\n<ul>\n<li><code>console.log(2)</code>（C）</li>\n<li><code>console.log(&#39;B&#39;)</code>（D）</li>\n</ul>\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n<p>后面依次类推完成所有的输出，这里就不再赘述了。</p>\n<p>每一个 <code>.then()</code> 的回调都是<strong>当前 Promise 链前一个 then 完成后，才加入下一轮微任务队列</strong>，而两个链是<strong>并发推进</strong>的。</p>\n<hr>\n<h2 id=\"嵌套-Promise-链式-Promise-组合类型\"><a href=\"#嵌套-Promise-链式-Promise-组合类型\" class=\"headerlink\" title=\"嵌套 Promise + 链式 Promise 组合类型\"></a>嵌套 Promise + 链式 Promise 组合类型</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"💡输出结果：\"><a href=\"#💡输出结果：\" class=\"headerlink\" title=\"💡输出结果：\"></a>💡<strong>输出结果：</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n<p>怎么样？惊不惊喜？意不意外？</p>\n<h3 id=\"🧠原因分析：-1\"><a href=\"#🧠原因分析：-1\" class=\"headerlink\" title=\"🧠原因分析：\"></a>🧠<strong>原因分析：</strong></h3><p><strong>为什么不是 “1 2 5 3 4 6”？</strong></p>\n<p>所有的 <code>.then()</code> 都是微任务，会按<strong>创建顺序入队并逐步推进</strong>。而且<strong>两个链虽然几乎同时创建，但第二条链会先执行得更快</strong>，这是重点。</p>\n<hr>\n<h4 id=\"✅-还原执行过程（按微任务轮次）：\"><a href=\"#✅-还原执行过程（按微任务轮次）：\" class=\"headerlink\" title=\"✅ 还原执行过程（按微任务轮次）：\"></a>✅ 还原执行过程（按微任务轮次）：</h4><h5 id=\"🌐-同步阶段：\"><a href=\"#🌐-同步阶段：\" class=\"headerlink\" title=\"🌐 同步阶段：\"></a>🌐 同步阶段：</h5><ul>\n<li>两个 <code>Promise.resolve().then()</code> 被创建，注册了 <code>.then()</code> 回调，但没有同步输出。</li>\n</ul>\n<hr>\n<h5 id=\"🌀-第-1-轮微任务队列（按创建顺序执行）：\"><a href=\"#🌀-第-1-轮微任务队列（按创建顺序执行）：\" class=\"headerlink\" title=\"🌀 第 1 轮微任务队列（按创建顺序执行）：\"></a>🌀 第 1 轮微任务队列（按创建顺序执行）：</h5><ol>\n<li><strong>第一个 <code>.then()</code> 回调</strong>（来自第一条链）：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">() =&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<code>1</code><br>返回值是一个新的 Promise，因此下一个 <code>.then(res =&gt; console.log(res))</code> 会<strong>等待该 Promise 的结果</strong>，<strong>不会立即进入当前微任务队列</strong>，而是延迟一轮。</p>\n<ol start=\"2\">\n<li><strong>第二条链的第一个 <code>.then()</code> 回调：</strong></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">() =&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>输出：<code>2</code></p>\n<hr>\n<h5 id=\"🌀-第-2-轮微任务队列：\"><a href=\"#🌀-第-2-轮微任务队列：\" class=\"headerlink\" title=\"🌀 第 2 轮微任务队列：\"></a>🌀 第 2 轮微任务队列：</h5><p>接着入队的是这两个：</p>\n<ol>\n<li>第二条链的 <code>.then(() =&gt; console.log(3))</code> → 输出：<code>3</code></li>\n<li>第一条链返回的 <code>Promise.resolve(5)</code> 被 resolve 后，产生一个新微任务 → <code>.then(res =&gt; console.log(res))</code> 被延迟到下一轮！</li>\n</ol>\n<hr>\n<h5 id=\"🌀-第-3-轮微任务队列：\"><a href=\"#🌀-第-3-轮微任务队列：\" class=\"headerlink\" title=\"🌀 第 3 轮微任务队列：\"></a>🌀 第 3 轮微任务队列：</h5><ol>\n<li>第二条链的 <code>.then(() =&gt; console.log(4))</code> → 输出：<code>4</code></li>\n</ol>\n<hr>\n<h5 id=\"🌀-第-4-轮微任务队列：\"><a href=\"#🌀-第-4-轮微任务队列：\" class=\"headerlink\" title=\"🌀 第 4 轮微任务队列：\"></a>🌀 第 4 轮微任务队列：</h5><ol>\n<li>第一条链 <code>.then(res =&gt; console.log(res))</code> → 输出：<code>5</code></li>\n<li>第二条链 <code>.then(() =&gt; console.log(6))</code> → 输出：<code>6</code></li>\n</ol>\n<hr>\n<h1 id=\"错误处理：catch-与链路中断\"><a href=\"#错误处理：catch-与链路中断\" class=\"headerlink\" title=\"错误处理：catch 与链路中断\"></a>错误处理：catch 与链路中断</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Oops!&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Caught:&#x27;</span>, err.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>注意点：</p>\n<ul>\n<li>一旦在 <code>.then()</code> 中抛出错误，后续的 <code>.then()</code> 会被跳过，直到 <code>.catch()</code>。</li>\n<li><code>catch</code> 本质上也是 <code>then(undefined, onRejected)</code> 的语法糖。</li>\n</ul>\n<hr>\n<h1 id=\"finally：无论成功失败都执行\"><a href=\"#finally：无论成功失败都执行\" class=\"headerlink\" title=\"finally：无论成功失败都执行\"></a>finally：无论成功失败都执行</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;error&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;catch:&#x27;</span>, err);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;finally: clean up&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>finally</code> 不会接收任何参数。</li>\n<li>它在 promise 结束（无论成功或失败）后执行。</li>\n<li>它不会影响链式传值。</li>\n</ul>\n<hr>\n<h1 id=\"与-async-await-的融合\"><a href=\"#与-async-await-的融合\" class=\"headerlink\" title=\"与 async&#x2F;await 的融合\"></a>与 async&#x2F;await 的融合</h1><p><code>async/await</code> 其实是 Promise 的语法糖，让异步代码更像同步流程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">123</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 123</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Error:&#x27;</span>, err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">main</span>();</span><br></pre></td></tr></table></figure>\n\n<p>等价于：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">123</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Error:&#x27;</span>, err));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"调试技巧与最佳实践\"><a href=\"#调试技巧与最佳实践\" class=\"headerlink\" title=\"调试技巧与最佳实践\"></a>调试技巧与最佳实践</h1><ul>\n<li><strong>避免嵌套地狱</strong>：通过链式调用或 async&#x2F;await 展平逻辑结构。</li>\n<li><strong>统一错误处理</strong>：链式调用最后用 <code>.catch()</code>，或者 try&#x2F;catch 包裹 async 函数。</li>\n<li><strong>使用 <code>Promise.all</code> 处理并发</strong>：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"title function_\">fetchUser</span>(), <span class=\"title function_\">fetchPosts</span>(), <span class=\"title function_\">fetchComments</span>()]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>合理使用 <code>Promise.race</code></strong> 做超时控制：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> timeout = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">_, reject</span>) =&gt;</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;timeout&#x27;</span>), <span class=\"number\">3000</span>));</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([<span class=\"title function_\">fetchData</span>(), timeout]);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>虽然现在大家更倾向于使用 <code>async/await</code>，但 Promise 是 async 的根基。真正理解 Promise 的行为顺序和状态变化，对于构建稳定、可维护的异步程序至关重要。掌握 Promise，不只是写出能跑的代码，而是写出<strong>能预期、能控制的异步逻辑</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>拙荆是一位测试工程师，说她是我的最佳对手也不为过，常常与我这个开发针尖对麦芒、唇枪舌剑。前几天她突然问我：“Promise 到底是啥？是不是非用不可？”我简单地解释了一番，她却似懂非懂，眼神中流露出明显的不满。于是我决定动笔写下这篇文章，一来是给她一个全面的交代，二来也整理一下自己对 Promise 的理解。<br><img src=\"/blog/./images/promise/fight.png\" alt=\"fight\"></p>\n<p>在 JavaScript 异步编程的世界里，Promise 是几乎无处不在的基础构件。即使你已经习惯使用 <code>async/await</code>，理解 Promise 的底层运行机制，仍然是深入掌握异步编程的关键。</p>\n<p>本篇文章将从 Promise 的基本用法讲起，逐步深入到微任务队列、链式调用原理、错误处理，再到一些常见的“看不懂输出顺序”的典型案例，并配以可调试的代码示例。</p>\n<hr>\n<h1 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise?\"></a>什么是 Promise?</h1><p>简单来说，Promise 是 JavaScript 提供的一种异步编程解决方案，用于表示一个<strong>未来才会完成</strong>的操作结果。它有三种状态：</p>\n<ul>\n<li><code>pending</code>：初始状态，既不是成功，也不是失败。</li>\n<li><code>fulfilled</code>：操作成功完成。</li>\n<li><code>rejected</code>：操作失败。</li>\n</ul>\n<p>Promise 的基本用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&#x27;Hello, Promise!&#x27;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 输出: Hello, Promise!</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>更详细的介绍可以参考阮一峰的文章<a href=\"https://es6.ruanyifeng.com/#docs/promise\">Promise 对象</a></p>\n<hr>\n<h1 id=\"📌-什么时候用-Promise\"><a href=\"#📌-什么时候用-Promise\" class=\"headerlink\" title=\"📌 什么时候用 Promise\"></a>📌 什么时候用 Promise</h1><p>下面是一些常见、实际开发中会用到 Promise 的典型场景：</p>\n<hr>\n<h2 id=\"1-异步请求（最常见）\"><a href=\"#1-异步请求（最常见）\" class=\"headerlink\" title=\"1. 异步请求（最常见）\"></a>1. <strong>异步请求（最常见）</strong></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>HTTP 请求需要时间，结果不是立即返回，必须用异步；而 Promise 能优雅地组织这些操作和错误处理。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-异步文件操作（在-Node-js-中）\"><a href=\"#2-异步文件操作（在-Node-js-中）\" class=\"headerlink\" title=\"2. 异步文件操作（在 Node.js 中）\"></a>2. <strong>异步文件操作（在 Node.js 中）</strong></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs/promises&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;file.txt&#x27;</span>, <span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-串行异步流程控制\"><a href=\"#3-串行异步流程控制\" class=\"headerlink\" title=\"3. 串行异步流程控制\"></a>3. <strong>串行异步流程控制</strong></h2><p>有时候你需要一个任务完成后再执行下一个，不能全并发跑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">getUser</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> <span class=\"title function_\">getPostsByUser</span>(user.<span class=\"property\">id</span>))</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">posts</span> =&gt;</span> <span class=\"title function_\">display</span>(posts));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-并发任务的批量处理\"><a href=\"#4-并发任务的批量处理\" class=\"headerlink\" title=\"4. 并发任务的批量处理\"></a>4. <strong>并发任务的批量处理</strong></h2><p>比如一次加载多个资源，等全部完成后再进行处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([</span><br><span class=\"line\">  <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/user&#x27;</span>),</span><br><span class=\"line\">  <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/posts&#x27;</span>),</span><br><span class=\"line\">  <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/comments&#x27;</span>)</span><br><span class=\"line\">]).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">[user, posts, comments]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 全部都加载完了，统一处理</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5-定时器、延迟执行\"><a href=\"#5-定时器、延迟执行\" class=\"headerlink\" title=\"5. 定时器、延迟执行\"></a>5. <strong>定时器、延迟执行</strong></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">delay</span>(<span class=\"params\">ms</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">setTimeout</span>(resolve, ms));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1秒后执行&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"链式调用与返回值穿透\"><a href=\"#链式调用与返回值穿透\" class=\"headerlink\" title=\"链式调用与返回值穿透\"></a>链式调用与返回值穿透</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出 1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(res + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出 3</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>每个 <code>.then()</code> 返回的都是一个新的 Promise。</li>\n<li>如果 <code>.then()</code> 中返回的是普通值，它会被 <code>Promise.resolve()</code> 包装。</li>\n<li>如果返回的是一个 Promise，则等待它的状态改变。</li>\n</ul>\n<hr>\n<h1 id=\"🔄-什么是-Event-Loop（事件循环）？\"><a href=\"#🔄-什么是-Event-Loop（事件循环）？\" class=\"headerlink\" title=\"🔄 什么是 Event Loop（事件循环）？\"></a>🔄 什么是 Event Loop（事件循环）？</h1><p>JavaScript 是单线程语言，只能一个任务一个任务地执行。那它是如何做到异步执行 <code>Promise</code>、<code>setTimeout</code> 等非阻塞任务的呢？这就离不开核心机制 —— <strong>事件循环（Event Loop）</strong>。</p>\n<p>事件循环的执行过程可以简化为：</p>\n<ol>\n<li>执行主线程上的同步任务；</li>\n<li>取出微任务队列（Microtask Queue）并依次执行完毕；</li>\n<li>如果微任务队列为空，则执行一个宏任务（Macrotask）；</li>\n<li>重复以上过程。</li>\n</ol>\n<p><img src=\"/blog/./images/promise/event_loop.gif\" alt=\"event_loop\"></p>\n<hr>\n<h2 id=\"🧠-更直观地理解：\"><a href=\"#🧠-更直观地理解：\" class=\"headerlink\" title=\"🧠 更直观地理解：\"></a>🧠 更直观地理解：</h2><p>每次 JavaScript 执行一个宏任务（如 <code>setTimeout</code> 回调、主线程代码等）后，会<strong>立即清空当轮产生的所有微任务（如 Promise.then）</strong>，然后再进入下一个宏任务。</p>\n<hr>\n<h2 id=\"📌-举个例子：\"><a href=\"#📌-举个例子：\" class=\"headerlink\" title=\"📌 举个例子：\"></a>📌 举个例子：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;start&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;macro&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;micro&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出顺序为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start</span><br><span class=\"line\">end</span><br><span class=\"line\">micro</span><br><span class=\"line\">macro</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>start</code> 和 <code>end</code> 属于同步任务；</li>\n<li><code>micro</code> 属于微任务，执行优先级高于宏任务；</li>\n<li><code>macro</code> 是下一个宏任务，最后执行。</li>\n</ul>\n<hr>\n<h1 id=\"常见执行顺序陷阱：请你猜猜输出\"><a href=\"#常见执行顺序陷阱：请你猜猜输出\" class=\"headerlink\" title=\"常见执行顺序陷阱：请你猜猜输出\"></a>常见执行顺序陷阱：请你猜猜输出</h1><h2 id=\"多个微任务队列\"><a href=\"#多个微任务队列\" class=\"headerlink\" title=\"多个微任务队列\"></a>多个微任务队列</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;B&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;D&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">A</span><br><span class=\"line\">2</span><br><span class=\"line\">B</span><br><span class=\"line\">3</span><br><span class=\"line\">C</span><br><span class=\"line\">4</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure>\n<h3 id=\"🧠原因分析：\"><a href=\"#🧠原因分析：\" class=\"headerlink\" title=\"🧠原因分析：\"></a>🧠<strong>原因分析：</strong></h3><p>虽然看起来你是写了两条链，但它们会<strong>交错执行</strong>，这与 JavaScript 中的<strong>微任务队列</strong>行为密切相关。</p>\n<hr>\n<h3 id=\"🔍-执行过程详解：\"><a href=\"#🔍-执行过程详解：\" class=\"headerlink\" title=\"🔍 执行过程详解：\"></a>🔍 执行过程详解：</h3><p>JavaScript 执行模型是这样的：</p>\n<ol>\n<li>执行同步代码（全局同步代码优先）；</li>\n<li>执行微任务队列（microtasks）：包括 Promise 的 <code>.then()</code>、<code>MutationObserver</code>、<code>queueMicrotask()</code>；</li>\n<li>执行宏任务队列（macrotasks）：如 <code>setTimeout</code>、<code>setInterval</code>、I&#x2F;O 等。</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/blog/./images/promise/multi-queue.png\" alt=\"multi-queue\"></h2><h4 id=\"✅-第一步：同步阶段\"><a href=\"#✅-第一步：同步阶段\" class=\"headerlink\" title=\"✅ 第一步：同步阶段\"></a>✅ 第一步：同步阶段</h4><ul>\n<li>没有任何同步 <code>console.log()</code>，所以直接进入<strong>微任务阶段</strong>。</li>\n</ul>\n<hr>\n<h4 id=\"✅-第二步：第一轮微任务队列\"><a href=\"#✅-第二步：第一轮微任务队列\" class=\"headerlink\" title=\"✅ 第二步：第一轮微任务队列\"></a>✅ 第二步：第一轮微任务队列</h4><p>全局有两个 Promise 链：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链1</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)) <span class=\"comment\">// 微任务A</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>))               <span class=\"comment\">// 微任务C</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>))               <span class=\"comment\">// 微任务E</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>));              <span class=\"comment\">// 微任务G</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链2</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;A&#x27;</span>)) <span class=\"comment\">// 微任务B</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;B&#x27;</span>))                <span class=\"comment\">// 微任务D</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;C&#x27;</span>))                <span class=\"comment\">// 微任务F</span></span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;D&#x27;</span>));               <span class=\"comment\">// 微任务H</span></span><br></pre></td></tr></table></figure>\n\n<p>但<strong>重要的是</strong>：</p>\n<ul>\n<li><code>Promise.resolve().then(...)</code> 是<strong>立即进入微任务队列</strong>的；</li>\n<li>后续 <code>.then(...)</code> 是在 <strong>前一个 then 执行完后、产生的新微任务</strong>！</li>\n</ul>\n<hr>\n<h3 id=\"👇-微任务轮次如下（每轮会清空当前所有微任务队列）：\"><a href=\"#👇-微任务轮次如下（每轮会清空当前所有微任务队列）：\" class=\"headerlink\" title=\"👇 微任务轮次如下（每轮会清空当前所有微任务队列）：\"></a>👇 微任务轮次如下（每轮会清空当前所有微任务队列）：</h3><hr>\n<h4 id=\"🌀-第一轮微任务队列：\"><a href=\"#🌀-第一轮微任务队列：\" class=\"headerlink\" title=\"🌀 第一轮微任务队列：\"></a>🌀 第一轮微任务队列：</h4><ul>\n<li>执行 <code>console.log(1)</code>（A）</li>\n<li>执行 <code>console.log(&#39;A&#39;)</code>（B）</li>\n</ul>\n<p>这两个是<strong>最早入队</strong>的两个 <code>.then()</code>，并且没有前置依赖。</p>\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"🌀-第二轮微任务队列：\"><a href=\"#🌀-第二轮微任务队列：\" class=\"headerlink\" title=\"🌀 第二轮微任务队列：\"></a>🌀 第二轮微任务队列：</h4><ul>\n<li>上一轮执行完 <code>console.log(1)</code>，它的 <code>.then(() =&gt; console.log(2))</code>（C）被加入；</li>\n<li>执行完 <code>console.log(&#39;A&#39;)</code>，它的 <code>.then(() =&gt; console.log(&#39;B&#39;))</code>（D）被加入。</li>\n</ul>\n<p>现在队列中是：</p>\n<ul>\n<li><code>console.log(2)</code>（C）</li>\n<li><code>console.log(&#39;B&#39;)</code>（D）</li>\n</ul>\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n<p>后面依次类推完成所有的输出，这里就不再赘述了。</p>\n<p>每一个 <code>.then()</code> 的回调都是<strong>当前 Promise 链前一个 then 完成后，才加入下一轮微任务队列</strong>，而两个链是<strong>并发推进</strong>的。</p>\n<hr>\n<h2 id=\"嵌套-Promise-链式-Promise-组合类型\"><a href=\"#嵌套-Promise-链式-Promise-组合类型\" class=\"headerlink\" title=\"嵌套 Promise + 链式 Promise 组合类型\"></a>嵌套 Promise + 链式 Promise 组合类型</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"💡输出结果：\"><a href=\"#💡输出结果：\" class=\"headerlink\" title=\"💡输出结果：\"></a>💡<strong>输出结果：</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n<p>怎么样？惊不惊喜？意不意外？</p>\n<h3 id=\"🧠原因分析：-1\"><a href=\"#🧠原因分析：-1\" class=\"headerlink\" title=\"🧠原因分析：\"></a>🧠<strong>原因分析：</strong></h3><p><strong>为什么不是 “1 2 5 3 4 6”？</strong></p>\n<p>所有的 <code>.then()</code> 都是微任务，会按<strong>创建顺序入队并逐步推进</strong>。而且<strong>两个链虽然几乎同时创建，但第二条链会先执行得更快</strong>，这是重点。</p>\n<hr>\n<h4 id=\"✅-还原执行过程（按微任务轮次）：\"><a href=\"#✅-还原执行过程（按微任务轮次）：\" class=\"headerlink\" title=\"✅ 还原执行过程（按微任务轮次）：\"></a>✅ 还原执行过程（按微任务轮次）：</h4><h5 id=\"🌐-同步阶段：\"><a href=\"#🌐-同步阶段：\" class=\"headerlink\" title=\"🌐 同步阶段：\"></a>🌐 同步阶段：</h5><ul>\n<li>两个 <code>Promise.resolve().then()</code> 被创建，注册了 <code>.then()</code> 回调，但没有同步输出。</li>\n</ul>\n<hr>\n<h5 id=\"🌀-第-1-轮微任务队列（按创建顺序执行）：\"><a href=\"#🌀-第-1-轮微任务队列（按创建顺序执行）：\" class=\"headerlink\" title=\"🌀 第 1 轮微任务队列（按创建顺序执行）：\"></a>🌀 第 1 轮微任务队列（按创建顺序执行）：</h5><ol>\n<li><strong>第一个 <code>.then()</code> 回调</strong>（来自第一条链）：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">() =&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<code>1</code><br>返回值是一个新的 Promise，因此下一个 <code>.then(res =&gt; console.log(res))</code> 会<strong>等待该 Promise 的结果</strong>，<strong>不会立即进入当前微任务队列</strong>，而是延迟一轮。</p>\n<ol start=\"2\">\n<li><strong>第二条链的第一个 <code>.then()</code> 回调：</strong></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">() =&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>输出：<code>2</code></p>\n<hr>\n<h5 id=\"🌀-第-2-轮微任务队列：\"><a href=\"#🌀-第-2-轮微任务队列：\" class=\"headerlink\" title=\"🌀 第 2 轮微任务队列：\"></a>🌀 第 2 轮微任务队列：</h5><p>接着入队的是这两个：</p>\n<ol>\n<li>第二条链的 <code>.then(() =&gt; console.log(3))</code> → 输出：<code>3</code></li>\n<li>第一条链返回的 <code>Promise.resolve(5)</code> 被 resolve 后，产生一个新微任务 → <code>.then(res =&gt; console.log(res))</code> 被延迟到下一轮！</li>\n</ol>\n<hr>\n<h5 id=\"🌀-第-3-轮微任务队列：\"><a href=\"#🌀-第-3-轮微任务队列：\" class=\"headerlink\" title=\"🌀 第 3 轮微任务队列：\"></a>🌀 第 3 轮微任务队列：</h5><ol>\n<li>第二条链的 <code>.then(() =&gt; console.log(4))</code> → 输出：<code>4</code></li>\n</ol>\n<hr>\n<h5 id=\"🌀-第-4-轮微任务队列：\"><a href=\"#🌀-第-4-轮微任务队列：\" class=\"headerlink\" title=\"🌀 第 4 轮微任务队列：\"></a>🌀 第 4 轮微任务队列：</h5><ol>\n<li>第一条链 <code>.then(res =&gt; console.log(res))</code> → 输出：<code>5</code></li>\n<li>第二条链 <code>.then(() =&gt; console.log(6))</code> → 输出：<code>6</code></li>\n</ol>\n<hr>\n<h1 id=\"错误处理：catch-与链路中断\"><a href=\"#错误处理：catch-与链路中断\" class=\"headerlink\" title=\"错误处理：catch 与链路中断\"></a>错误处理：catch 与链路中断</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Oops!&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Caught:&#x27;</span>, err.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>注意点：</p>\n<ul>\n<li>一旦在 <code>.then()</code> 中抛出错误，后续的 <code>.then()</code> 会被跳过，直到 <code>.catch()</code>。</li>\n<li><code>catch</code> 本质上也是 <code>then(undefined, onRejected)</code> 的语法糖。</li>\n</ul>\n<hr>\n<h1 id=\"finally：无论成功失败都执行\"><a href=\"#finally：无论成功失败都执行\" class=\"headerlink\" title=\"finally：无论成功失败都执行\"></a>finally：无论成功失败都执行</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;error&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;catch:&#x27;</span>, err);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;finally: clean up&#x27;</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>finally</code> 不会接收任何参数。</li>\n<li>它在 promise 结束（无论成功或失败）后执行。</li>\n<li>它不会影响链式传值。</li>\n</ul>\n<hr>\n<h1 id=\"与-async-await-的融合\"><a href=\"#与-async-await-的融合\" class=\"headerlink\" title=\"与 async&#x2F;await 的融合\"></a>与 async&#x2F;await 的融合</h1><p><code>async/await</code> 其实是 Promise 的语法糖，让异步代码更像同步流程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">123</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 123</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Error:&#x27;</span>, err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">main</span>();</span><br></pre></td></tr></table></figure>\n\n<p>等价于：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">123</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Error:&#x27;</span>, err));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"调试技巧与最佳实践\"><a href=\"#调试技巧与最佳实践\" class=\"headerlink\" title=\"调试技巧与最佳实践\"></a>调试技巧与最佳实践</h1><ul>\n<li><strong>避免嵌套地狱</strong>：通过链式调用或 async&#x2F;await 展平逻辑结构。</li>\n<li><strong>统一错误处理</strong>：链式调用最后用 <code>.catch()</code>，或者 try&#x2F;catch 包裹 async 函数。</li>\n<li><strong>使用 <code>Promise.all</code> 处理并发</strong>：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"title function_\">fetchUser</span>(), <span class=\"title function_\">fetchPosts</span>(), <span class=\"title function_\">fetchComments</span>()]);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>合理使用 <code>Promise.race</code></strong> 做超时控制：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> timeout = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">_, reject</span>) =&gt;</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;timeout&#x27;</span>), <span class=\"number\">3000</span>));</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([<span class=\"title function_\">fetchData</span>(), timeout]);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>虽然现在大家更倾向于使用 <code>async/await</code>，但 Promise 是 async 的根基。真正理解 Promise 的行为顺序和状态变化，对于构建稳定、可维护的异步程序至关重要。掌握 Promise，不只是写出能跑的代码，而是写出<strong>能预期、能控制的异步逻辑</strong>。</p>\n"},{"title":"离别，是为了更好的重逢 —— 送别老同事的一晚","date":"2025-08-01T02:27:59.000Z","_content":"\n昨天晚上，我们几个老同事坐在烧烤店里，为一个特别的人送别。\n\n![喝酒](./images/send-off-1/drink.png)\n\n他，是我刚工作时就认识的同事，也是一起熬夜通宵改代码的战友。我们差不多年纪，入职时间也差不多。不同的是，我是“二进宫”，而他从毕业后就一直待在这家公司，一待就是整整12年，献出了他全部的青春。从青涩懵懂到如今的沉稳可靠，他几乎把最宝贵的年华都留在了这里。那些日子里，他从一个略带羞涩的新人成长为可以独当一面的骨干。他带着责任、热情和倔强，走过了公司最辉煌的几年，也陪它一起走进了低谷。可即便如此，还是没能逃过那份冰冷的裁员名单。\n\n最近公司受大环境影响，业务增长放缓，开始出现亏损。人心开始浮动，办公室的灯不再像以前那样彻夜亮着，茶水间的笑声也少了。裁员这把火，终究还是烧到了他头上。\n\n当他说出“我领大礼包”那一刻，虽有心理准备，但终究还是有点猝不及防。\n\n啤酒瓶的碰撞声、烤串滋滋作响的声音、我们之间的沉默与笑声交织在一起，组成了一场难以复制的送别。\n\n## 回忆里那些不加班也睡不着的日子\n\n喝了几杯，话题就自然而然地飘回了从前。\n\n“你还记得之前发布那个 agent 客户端的 bug 吗？系统疯狂告警。”\n\n“当然记得，咱几个连夜修复代码、打包、测试，忙到凌晨还在发布更新。”\n\n“就为了赶在客户上班前把问题解决。虽然整宿没睡，第二天照样若无其事地上班。”\n\n![喝酒](./images/send-off-1/work-overtime.png)\n\n\n那一夜，我们没有抱怨，没有犹豫，像打仗一样分工明确、默契配合。从研发、测试到运维，每个人都拧成一股绳，只为了把这个坑补上。凌晨十二点半，发版完成后，我们在工位上瘫坐着，看着日志终于不再报错，那种成就感比任何一次表扬都更真实。\n\n我们回忆起刚入行时的青涩，曾因为一个接口设计争得面红耳赤，也曾因为一个“Hello World”跑通就欣喜若狂。那些年，代码写得烂，但热情是真的燃；思路不清晰，但眼睛里有光。工作固然辛苦，但那时候大家都还相信代码能改变一点什么，哪怕只是一点。\n\n他几乎见证了这家公司从草创到壮大的全过程，也陪我们经历了每一次产品的推翻与重来。他是那种“对事不对人”的典型代表，做事讲原则，逻辑清晰，说话从不绕弯子。\n\n他还有个“爱抬杠”的小毛病，我们经常笑他是公司的“ETC”——只要一说话，就能精准地“怼”回来。但越是熟悉他，就越知道他是个刀子嘴豆腐心的人。他会在你犯错时毫不留情地指出，但也会悄悄帮你把问题补救好。他曾说过一句我们都记得的话：**“虽然天天加班累成狗，但能看到自己搭的系统在跑，还是挺有成就感的。”**\n\n## 工作之外，其实我们也是彼此生活的一部分\n\n平时我们斗嘴、互损、抬杠不断，但有事的时候，从来没含糊过。下班后能坐在一起吃个饭、吐个槽，遇到技术上的难题有人第一时间响应、扛事、补位，这种默契不是靠制度约束出来的，是多年协作一点一滴磨出来的。\n\n虽然各自岗位不同，但彼此了解、信任，很多时候一个眼神就知道对方想干嘛。说实话，换了别的环境，想找到这样一群人太难了。\n\n不夸张地说，能在同一家公司共事多年，本身就是一种缘分。不是每个团队都有这样的稳定性，也不是每段关系都能经得起时间的考验。\n\n## 离开，并不代表结束\n\n“你以后准备去哪儿？”\n\n“先休息一下吧，然后想去做点自己真正喜欢的事。”\n\n“好啊，趁现在还来得及。”\n\n他说得轻描淡写，但我们都知道，那些年留下的辛苦和委屈，终究压在心头太久了。12年，是一个人全部的黄金时间。能在这家公司坚持这么久，需要的不只是能力，更是信念。而当信念逐渐被现实磨掉，离开，也是一种成全。\n\n离开，并不是失败，只是另一段旅程的开始。他的离开，就像春天一棵老树落叶，不是凋零，而是在为新的生命腾出空间。或许哪一天，我们会在另一家公司、另一个项目里再次并肩；也或许他真的会远离互联网，开个小店，做点安静的事。\n\n没有人能永远在同一家公司，不变的，是我们之间的记忆和友谊。\n\n这一晚，我们没有刻意煽情，只是在烤串的香气和啤酒的微醺中，把多年共事的点点滴滴都揉进了话语里。大家轮流举杯，有人讲笑话，有人沉默，有人悄悄红了眼眶。最后的告别并没有“再见”二字，只是简单的一句：\n\n**“你走了，咱们少了个队友；但我们也多了一个朋友。”**\n\n![再见](./images/send-off-1/goodbye.png)\n\n愿你前路清澈、身后有光，愿下次再见时，我们都还是彼此骄傲的样子。\n","source":"_posts/send-off-1.md","raw":"---\ntitle: 离别，是为了更好的重逢 —— 送别老同事的一晚\ndate: 2025-08-01 10:27:59\ntags:\n---\n\n昨天晚上，我们几个老同事坐在烧烤店里，为一个特别的人送别。\n\n![喝酒](./images/send-off-1/drink.png)\n\n他，是我刚工作时就认识的同事，也是一起熬夜通宵改代码的战友。我们差不多年纪，入职时间也差不多。不同的是，我是“二进宫”，而他从毕业后就一直待在这家公司，一待就是整整12年，献出了他全部的青春。从青涩懵懂到如今的沉稳可靠，他几乎把最宝贵的年华都留在了这里。那些日子里，他从一个略带羞涩的新人成长为可以独当一面的骨干。他带着责任、热情和倔强，走过了公司最辉煌的几年，也陪它一起走进了低谷。可即便如此，还是没能逃过那份冰冷的裁员名单。\n\n最近公司受大环境影响，业务增长放缓，开始出现亏损。人心开始浮动，办公室的灯不再像以前那样彻夜亮着，茶水间的笑声也少了。裁员这把火，终究还是烧到了他头上。\n\n当他说出“我领大礼包”那一刻，虽有心理准备，但终究还是有点猝不及防。\n\n啤酒瓶的碰撞声、烤串滋滋作响的声音、我们之间的沉默与笑声交织在一起，组成了一场难以复制的送别。\n\n## 回忆里那些不加班也睡不着的日子\n\n喝了几杯，话题就自然而然地飘回了从前。\n\n“你还记得之前发布那个 agent 客户端的 bug 吗？系统疯狂告警。”\n\n“当然记得，咱几个连夜修复代码、打包、测试，忙到凌晨还在发布更新。”\n\n“就为了赶在客户上班前把问题解决。虽然整宿没睡，第二天照样若无其事地上班。”\n\n![喝酒](./images/send-off-1/work-overtime.png)\n\n\n那一夜，我们没有抱怨，没有犹豫，像打仗一样分工明确、默契配合。从研发、测试到运维，每个人都拧成一股绳，只为了把这个坑补上。凌晨十二点半，发版完成后，我们在工位上瘫坐着，看着日志终于不再报错，那种成就感比任何一次表扬都更真实。\n\n我们回忆起刚入行时的青涩，曾因为一个接口设计争得面红耳赤，也曾因为一个“Hello World”跑通就欣喜若狂。那些年，代码写得烂，但热情是真的燃；思路不清晰，但眼睛里有光。工作固然辛苦，但那时候大家都还相信代码能改变一点什么，哪怕只是一点。\n\n他几乎见证了这家公司从草创到壮大的全过程，也陪我们经历了每一次产品的推翻与重来。他是那种“对事不对人”的典型代表，做事讲原则，逻辑清晰，说话从不绕弯子。\n\n他还有个“爱抬杠”的小毛病，我们经常笑他是公司的“ETC”——只要一说话，就能精准地“怼”回来。但越是熟悉他，就越知道他是个刀子嘴豆腐心的人。他会在你犯错时毫不留情地指出，但也会悄悄帮你把问题补救好。他曾说过一句我们都记得的话：**“虽然天天加班累成狗，但能看到自己搭的系统在跑，还是挺有成就感的。”**\n\n## 工作之外，其实我们也是彼此生活的一部分\n\n平时我们斗嘴、互损、抬杠不断，但有事的时候，从来没含糊过。下班后能坐在一起吃个饭、吐个槽，遇到技术上的难题有人第一时间响应、扛事、补位，这种默契不是靠制度约束出来的，是多年协作一点一滴磨出来的。\n\n虽然各自岗位不同，但彼此了解、信任，很多时候一个眼神就知道对方想干嘛。说实话，换了别的环境，想找到这样一群人太难了。\n\n不夸张地说，能在同一家公司共事多年，本身就是一种缘分。不是每个团队都有这样的稳定性，也不是每段关系都能经得起时间的考验。\n\n## 离开，并不代表结束\n\n“你以后准备去哪儿？”\n\n“先休息一下吧，然后想去做点自己真正喜欢的事。”\n\n“好啊，趁现在还来得及。”\n\n他说得轻描淡写，但我们都知道，那些年留下的辛苦和委屈，终究压在心头太久了。12年，是一个人全部的黄金时间。能在这家公司坚持这么久，需要的不只是能力，更是信念。而当信念逐渐被现实磨掉，离开，也是一种成全。\n\n离开，并不是失败，只是另一段旅程的开始。他的离开，就像春天一棵老树落叶，不是凋零，而是在为新的生命腾出空间。或许哪一天，我们会在另一家公司、另一个项目里再次并肩；也或许他真的会远离互联网，开个小店，做点安静的事。\n\n没有人能永远在同一家公司，不变的，是我们之间的记忆和友谊。\n\n这一晚，我们没有刻意煽情，只是在烤串的香气和啤酒的微醺中，把多年共事的点点滴滴都揉进了话语里。大家轮流举杯，有人讲笑话，有人沉默，有人悄悄红了眼眶。最后的告别并没有“再见”二字，只是简单的一句：\n\n**“你走了，咱们少了个队友；但我们也多了一个朋友。”**\n\n![再见](./images/send-off-1/goodbye.png)\n\n愿你前路清澈、身后有光，愿下次再见时，我们都还是彼此骄傲的样子。\n","slug":"send-off-1","published":1,"updated":"2025-08-01T03:17:29.858Z","_id":"cmds94lip0000f8p1g8locq26","comments":1,"layout":"post","photos":[],"link":"","content":"<p>昨天晚上，我们几个老同事坐在烧烤店里，为一个特别的人送别。</p>\n<p><img src=\"/blog/./images/send-off-1/drink.png\" alt=\"喝酒\"></p>\n<p>他，是我刚工作时就认识的同事，也是一起熬夜通宵改代码的战友。我们差不多年纪，入职时间也差不多。不同的是，我是“二进宫”，而他从毕业后就一直待在这家公司，一待就是整整12年，献出了他全部的青春。从青涩懵懂到如今的沉稳可靠，他几乎把最宝贵的年华都留在了这里。那些日子里，他从一个略带羞涩的新人成长为可以独当一面的骨干。他带着责任、热情和倔强，走过了公司最辉煌的几年，也陪它一起走进了低谷。可即便如此，还是没能逃过那份冰冷的裁员名单。</p>\n<p>最近公司受大环境影响，业务增长放缓，开始出现亏损。人心开始浮动，办公室的灯不再像以前那样彻夜亮着，茶水间的笑声也少了。裁员这把火，终究还是烧到了他头上。</p>\n<p>当他说出“我领大礼包”那一刻，虽有心理准备，但终究还是有点猝不及防。</p>\n<p>啤酒瓶的碰撞声、烤串滋滋作响的声音、我们之间的沉默与笑声交织在一起，组成了一场难以复制的送别。</p>\n<h2 id=\"回忆里那些不加班也睡不着的日子\"><a href=\"#回忆里那些不加班也睡不着的日子\" class=\"headerlink\" title=\"回忆里那些不加班也睡不着的日子\"></a>回忆里那些不加班也睡不着的日子</h2><p>喝了几杯，话题就自然而然地飘回了从前。</p>\n<p>“你还记得之前发布那个 agent 客户端的 bug 吗？系统疯狂告警。”</p>\n<p>“当然记得，咱几个连夜修复代码、打包、测试，忙到凌晨还在发布更新。”</p>\n<p>“就为了赶在客户上班前把问题解决。虽然整宿没睡，第二天照样若无其事地上班。”</p>\n<p><img src=\"/blog/./images/send-off-1/work-overtime.png\" alt=\"喝酒\"></p>\n<p>那一夜，我们没有抱怨，没有犹豫，像打仗一样分工明确、默契配合。从研发、测试到运维，每个人都拧成一股绳，只为了把这个坑补上。凌晨十二点半，发版完成后，我们在工位上瘫坐着，看着日志终于不再报错，那种成就感比任何一次表扬都更真实。</p>\n<p>我们回忆起刚入行时的青涩，曾因为一个接口设计争得面红耳赤，也曾因为一个“Hello World”跑通就欣喜若狂。那些年，代码写得烂，但热情是真的燃；思路不清晰，但眼睛里有光。工作固然辛苦，但那时候大家都还相信代码能改变一点什么，哪怕只是一点。</p>\n<p>他几乎见证了这家公司从草创到壮大的全过程，也陪我们经历了每一次产品的推翻与重来。他是那种“对事不对人”的典型代表，做事讲原则，逻辑清晰，说话从不绕弯子。</p>\n<p>他还有个“爱抬杠”的小毛病，我们经常笑他是公司的“ETC”——只要一说话，就能精准地“怼”回来。但越是熟悉他，就越知道他是个刀子嘴豆腐心的人。他会在你犯错时毫不留情地指出，但也会悄悄帮你把问题补救好。他曾说过一句我们都记得的话：<strong>“虽然天天加班累成狗，但能看到自己搭的系统在跑，还是挺有成就感的。”</strong></p>\n<h2 id=\"工作之外，其实我们也是彼此生活的一部分\"><a href=\"#工作之外，其实我们也是彼此生活的一部分\" class=\"headerlink\" title=\"工作之外，其实我们也是彼此生活的一部分\"></a>工作之外，其实我们也是彼此生活的一部分</h2><p>平时我们斗嘴、互损、抬杠不断，但有事的时候，从来没含糊过。下班后能坐在一起吃个饭、吐个槽，遇到技术上的难题有人第一时间响应、扛事、补位，这种默契不是靠制度约束出来的，是多年协作一点一滴磨出来的。</p>\n<p>虽然各自岗位不同，但彼此了解、信任，很多时候一个眼神就知道对方想干嘛。说实话，换了别的环境，想找到这样一群人太难了。</p>\n<p>不夸张地说，能在同一家公司共事多年，本身就是一种缘分。不是每个团队都有这样的稳定性，也不是每段关系都能经得起时间的考验。</p>\n<h2 id=\"离开，并不代表结束\"><a href=\"#离开，并不代表结束\" class=\"headerlink\" title=\"离开，并不代表结束\"></a>离开，并不代表结束</h2><p>“你以后准备去哪儿？”</p>\n<p>“先休息一下吧，然后想去做点自己真正喜欢的事。”</p>\n<p>“好啊，趁现在还来得及。”</p>\n<p>他说得轻描淡写，但我们都知道，那些年留下的辛苦和委屈，终究压在心头太久了。12年，是一个人全部的黄金时间。能在这家公司坚持这么久，需要的不只是能力，更是信念。而当信念逐渐被现实磨掉，离开，也是一种成全。</p>\n<p>离开，并不是失败，只是另一段旅程的开始。他的离开，就像春天一棵老树落叶，不是凋零，而是在为新的生命腾出空间。或许哪一天，我们会在另一家公司、另一个项目里再次并肩；也或许他真的会远离互联网，开个小店，做点安静的事。</p>\n<p>没有人能永远在同一家公司，不变的，是我们之间的记忆和友谊。</p>\n<p>这一晚，我们没有刻意煽情，只是在烤串的香气和啤酒的微醺中，把多年共事的点点滴滴都揉进了话语里。大家轮流举杯，有人讲笑话，有人沉默，有人悄悄红了眼眶。最后的告别并没有“再见”二字，只是简单的一句：</p>\n<p><strong>“你走了，咱们少了个队友；但我们也多了一个朋友。”</strong></p>\n<p><img src=\"/blog/./images/send-off-1/goodbye.png\" alt=\"再见\"></p>\n<p>愿你前路清澈、身后有光，愿下次再见时，我们都还是彼此骄傲的样子。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天晚上，我们几个老同事坐在烧烤店里，为一个特别的人送别。</p>\n<p><img src=\"/blog/./images/send-off-1/drink.png\" alt=\"喝酒\"></p>\n<p>他，是我刚工作时就认识的同事，也是一起熬夜通宵改代码的战友。我们差不多年纪，入职时间也差不多。不同的是，我是“二进宫”，而他从毕业后就一直待在这家公司，一待就是整整12年，献出了他全部的青春。从青涩懵懂到如今的沉稳可靠，他几乎把最宝贵的年华都留在了这里。那些日子里，他从一个略带羞涩的新人成长为可以独当一面的骨干。他带着责任、热情和倔强，走过了公司最辉煌的几年，也陪它一起走进了低谷。可即便如此，还是没能逃过那份冰冷的裁员名单。</p>\n<p>最近公司受大环境影响，业务增长放缓，开始出现亏损。人心开始浮动，办公室的灯不再像以前那样彻夜亮着，茶水间的笑声也少了。裁员这把火，终究还是烧到了他头上。</p>\n<p>当他说出“我领大礼包”那一刻，虽有心理准备，但终究还是有点猝不及防。</p>\n<p>啤酒瓶的碰撞声、烤串滋滋作响的声音、我们之间的沉默与笑声交织在一起，组成了一场难以复制的送别。</p>\n<h2 id=\"回忆里那些不加班也睡不着的日子\"><a href=\"#回忆里那些不加班也睡不着的日子\" class=\"headerlink\" title=\"回忆里那些不加班也睡不着的日子\"></a>回忆里那些不加班也睡不着的日子</h2><p>喝了几杯，话题就自然而然地飘回了从前。</p>\n<p>“你还记得之前发布那个 agent 客户端的 bug 吗？系统疯狂告警。”</p>\n<p>“当然记得，咱几个连夜修复代码、打包、测试，忙到凌晨还在发布更新。”</p>\n<p>“就为了赶在客户上班前把问题解决。虽然整宿没睡，第二天照样若无其事地上班。”</p>\n<p><img src=\"/blog/./images/send-off-1/work-overtime.png\" alt=\"喝酒\"></p>\n<p>那一夜，我们没有抱怨，没有犹豫，像打仗一样分工明确、默契配合。从研发、测试到运维，每个人都拧成一股绳，只为了把这个坑补上。凌晨十二点半，发版完成后，我们在工位上瘫坐着，看着日志终于不再报错，那种成就感比任何一次表扬都更真实。</p>\n<p>我们回忆起刚入行时的青涩，曾因为一个接口设计争得面红耳赤，也曾因为一个“Hello World”跑通就欣喜若狂。那些年，代码写得烂，但热情是真的燃；思路不清晰，但眼睛里有光。工作固然辛苦，但那时候大家都还相信代码能改变一点什么，哪怕只是一点。</p>\n<p>他几乎见证了这家公司从草创到壮大的全过程，也陪我们经历了每一次产品的推翻与重来。他是那种“对事不对人”的典型代表，做事讲原则，逻辑清晰，说话从不绕弯子。</p>\n<p>他还有个“爱抬杠”的小毛病，我们经常笑他是公司的“ETC”——只要一说话，就能精准地“怼”回来。但越是熟悉他，就越知道他是个刀子嘴豆腐心的人。他会在你犯错时毫不留情地指出，但也会悄悄帮你把问题补救好。他曾说过一句我们都记得的话：<strong>“虽然天天加班累成狗，但能看到自己搭的系统在跑，还是挺有成就感的。”</strong></p>\n<h2 id=\"工作之外，其实我们也是彼此生活的一部分\"><a href=\"#工作之外，其实我们也是彼此生活的一部分\" class=\"headerlink\" title=\"工作之外，其实我们也是彼此生活的一部分\"></a>工作之外，其实我们也是彼此生活的一部分</h2><p>平时我们斗嘴、互损、抬杠不断，但有事的时候，从来没含糊过。下班后能坐在一起吃个饭、吐个槽，遇到技术上的难题有人第一时间响应、扛事、补位，这种默契不是靠制度约束出来的，是多年协作一点一滴磨出来的。</p>\n<p>虽然各自岗位不同，但彼此了解、信任，很多时候一个眼神就知道对方想干嘛。说实话，换了别的环境，想找到这样一群人太难了。</p>\n<p>不夸张地说，能在同一家公司共事多年，本身就是一种缘分。不是每个团队都有这样的稳定性，也不是每段关系都能经得起时间的考验。</p>\n<h2 id=\"离开，并不代表结束\"><a href=\"#离开，并不代表结束\" class=\"headerlink\" title=\"离开，并不代表结束\"></a>离开，并不代表结束</h2><p>“你以后准备去哪儿？”</p>\n<p>“先休息一下吧，然后想去做点自己真正喜欢的事。”</p>\n<p>“好啊，趁现在还来得及。”</p>\n<p>他说得轻描淡写，但我们都知道，那些年留下的辛苦和委屈，终究压在心头太久了。12年，是一个人全部的黄金时间。能在这家公司坚持这么久，需要的不只是能力，更是信念。而当信念逐渐被现实磨掉，离开，也是一种成全。</p>\n<p>离开，并不是失败，只是另一段旅程的开始。他的离开，就像春天一棵老树落叶，不是凋零，而是在为新的生命腾出空间。或许哪一天，我们会在另一家公司、另一个项目里再次并肩；也或许他真的会远离互联网，开个小店，做点安静的事。</p>\n<p>没有人能永远在同一家公司，不变的，是我们之间的记忆和友谊。</p>\n<p>这一晚，我们没有刻意煽情，只是在烤串的香气和啤酒的微醺中，把多年共事的点点滴滴都揉进了话语里。大家轮流举杯，有人讲笑话，有人沉默，有人悄悄红了眼眶。最后的告别并没有“再见”二字，只是简单的一句：</p>\n<p><strong>“你走了，咱们少了个队友；但我们也多了一个朋友。”</strong></p>\n<p><img src=\"/blog/./images/send-off-1/goodbye.png\" alt=\"再见\"></p>\n<p>愿你前路清澈、身后有光，愿下次再见时，我们都还是彼此骄傲的样子。</p>\n"},{"title":"别再乱用箭头函数了！JavaScript 三种函数写法的终极指南","date":"2025-08-06T07:36:41.000Z","_content":"\n\n在 JavaScript 中，我们有多种方式来定义函数。最常见的两种就是普通函数（使用 `function` 关键字）和箭头函数（`=>`）。虽然它们看起来有些相似，但实际上它们之间有不少微妙的区别，尤其是在 `this`、`new`、`yield` 等语义上的差异。如果你也常常纠结“我该用哪种写法更合适？”，那本文或许能帮你厘清思路。\n\n---\n\n# 三种创建函数的方式\n\n## 1. 函数声明（Function Declaration）\n\n最传统的方式是使用 `function` 关键字直接声明函数：\n\n```js\nfunction helloWorld() {\n  console.log('Hello, world!');\n}\n```\n\n这种方式是**函数声明语句**，在作用域中具有名称绑定，并且最重要的一点是，它会被**提升（hoisting）**到当前作用域的顶部。\n\n```js\n<script type=\"text/javascript\">\nsayHello(); // ✅ 可以提前调用，输出：Hello, world!\n\nfunction sayHello() {\n  console.log('Hello, world!');\n}\n</script>\n```\n\n### 🔍 为什么这样不会报错？\n这是因为 函数声明 会在代码运行前被 JavaScript 引擎“提升”到当前作用域的顶部。也就是说，在你执行 sayHello() 的时候，这个函数其实已经“存在”了。\n\n---\n\n## 2. 函数表达式（Function Expression）\n\n你也可以将匿名函数赋值给变量：\n\n```js\nvar sayHi = function() {\n  console.log('Hi!');\n}\n\nsayHi(); // ✅ 可以调用，输出：Hi!\n```\n\n这种写法称为函数表达式，它不像声明那样会被提升，必须在使用前先定义。\n\n### 1️⃣ 函数声明会被完整提升，而函数表达式不会\n\n```js\nsayHi(); // ❌ TypeError: sayHi is not a function\n\nvar sayHi = function() {\n  console.log('Hi!');\n}\n```\n\n虽然变量 sayHi 被提升了，但它的值（即函数体）并没有被赋值。在 sayHi() 执行时，变量的值是 undefined，调用它会报错。\n\n\n### 2️⃣ 匿名函数表达式在调试堆栈中可能丢失函数名\n\n很多时候我们写函数表达式时是匿名的，比如：\n\n```js\nconst handler = function(a, b) {\n  throw new Error('Oops!');\n};\n```\n\n虽然你赋值给了变量 `handler`，但 JavaScript 引擎不一定能在调试堆栈中正确还原这个名称，特别是在打包压缩或 V8 优化场景中。\n\n\n有趣的是，我们还可以给函数表达式命名：\n\n```js\nconst throwError = function error(predicate, arr) {\n  throw new Error('Oops');\n}\n```\n\n虽然我们无法直接通过 `error()` 调用它，但如果出错，错误堆栈中会显示这个名称，有利于调试。\n\n![堆栈](./images/js-arrow-function/stack.png)\n\n\n**注意：** 使用 `let` 或 `const` 声明函数表达式时，甚至连变量提升都不会发生，会抛出 `ReferenceError`：\n\n```js\nsayHello(); // ❌ ReferenceError: Cannot access 'sayHello' before initialization\n\nconst sayHello = function() {\n  console.log('Hello');\n};\n```\n\n---\n\n## 3. 箭头函数（Arrow Function）\n\n箭头函数是 ES6 引入的语法，语法更短，也更现代：\n\n```js\ndouble(2); // ❌ TypeError: greet is not a function\n\nconst double = (x) => {\n  return x * 2;\n};\n```\n\n如果函数体只有一行返回语句，还可以进一步简化：\n\n```js\nconst double = (x) => x * 2;\n```\n\n如果参数只有一个，连小括号都可以省略：\n\n```js\nconst double = x => x * 2;\n```\n\n但别被这些简洁迷惑了，箭头函数背后隐藏着一些重要差异。\n\n---\n\n# 箭头函数 ≠ 普通函数\n\n## 1. 箭头函数没有自己的 this\n\n```js\nfunction getName() {\n  return this.userName;\n}\n\nconst getNameArrow = () => this.userName;\n\nconst User = {\n  userName: 'Tim Cook',\n  getName,\n  getNameArrow\n};\n\nconsole.log(User.getName()); // ✅ 正常输出 Tim Cook\nconsole.log(User.getNameArrow()); // ❌ undefined\n```\n\n箭头函数会捕获**定义时**的 `this` 值，而不是调用时的。这也是为什么它不适合用作对象的方法或类的原型方法。\n\n---\n\n## 2. 箭头函数不能用作构造函数\n\n```js\nconst User = (userName, age) => {\n  this.userName = userName;\n  this.age = age;\n};\n\nconst myUser = new User('Tim Cook', 55); // ❌ TypeError: User is not a constructor\n```\n\n你不能用 `new` 调用箭头函数，它们没有 `prototype`，也没有 `new.target`。\n\n---\n\n## 3. 箭头函数不能使用 yield\n\n```js\n// ❌ 不合法，不能在箭头函数里使用 yield\nfunction* numberGen() {\n  const show = () => {\n    yield 1; // SyntaxError\n  };\n}\n```\n\n箭头函数无法作为生成器使用，不能使用 `yield`，也无法被声明为 `function*`。\n\n---\n\n# 应该何时使用箭头函数？\n\n简单总结：\n\n| 使用场景             | 推荐写法              |\n| ---------------- | ----------------- |\n| 不使用 this / yield | ✅ 箭头函数更简洁         |\n| 需要 this 正确指向     | ✅ 使用普通函数          |\n| 函数需要提前调用（如顶层函数）  | ✅ 函数声明更合适         |\n| 用作构造函数           | ✅ 使用普通函数或 class   |\n| 编写 generator 函数  | ✅ 必须使用 function\\* |\n\n比如我们可以这样使用箭头函数作为回调：\n\n```js\n['a', 'b', 'c'].map(x => x.toUpperCase());\n```\n\n或者创建一个通用的日志方法：\n\n```js\nconst log = (obj) => console.log(obj.toLogString());\n```\n\n只要不涉及 `this`，箭头函数通常都是更简洁的选择。\n\n---\n\n# 函数声明带来的 hoisting 优势\n\n有时你可能希望把实现细节放在文件底部，而逻辑入口放在顶部，这时候函数声明的提升就很有用了：\n\n```js\nconst result = processOrder('pending');\nconsole.log(result); // 输出：请尽快支付订单！\n\n// --- 下面是逻辑实现部分 ---\nfunction processOrder(status) {\n  if (isCancelled(status)) {\n    return '订单已取消';\n  }\n\n  if (isPaid(status)) {\n    return '感谢您的购买！';\n  }\n\n  if (isPending(status)) {\n    return '请尽快支付订单！';\n  }\n\n  return '未知状态';\n}\n\nfunction isCancelled(status) {\n  return status === 'cancelled';\n}\n\nfunction isPaid(status) {\n  return status === 'paid';\n}\n\nfunction isPending(status) {\n  return status === 'pending';\n}\n\n```\n\n这种结构让代码阅读起来更清晰：先看到“大意”，再了解“细节”。\n\n---\n\n# 总结：一张选择函数写法的流程图\n\n我们可以根据以下几个问题，快速判断使用哪种函数写法更合适：\n\n![流程](./images/js-arrow-function/choose.png)\n\n1. **是否需要使用 `yield`？** → 用 `function*`\n2. **是否使用 `this`？** → 用普通函数（method or function expression）\n3. **是否希望提前调用该函数？** → 用函数声明（`function name() {}`）\n4. **其余情况？** → 用箭头函数，代码更简洁\n\n当然，规范不应束缚创作，你完全可以根据团队风格、可读性或调试需要选择你喜欢的写法。但理解这些差异，可以让你写出更稳健、更清晰的 JavaScript 代码。\n\n---\n\n# 结语\n\n箭头函数不是 function 的替代品，而是一个补充。当你理解它们之间的本质差异后，就能更合理地在项目中权衡使用了。\n\n如果你有自己的选择标准，欢迎留言分享你的实践经验！\n\n","source":"_posts/js-arrow-function.md","raw":"---\ntitle: 别再乱用箭头函数了！JavaScript 三种函数写法的终极指南\ndate: 2025-08-06 15:36:41\ntags:\n---\n\n\n在 JavaScript 中，我们有多种方式来定义函数。最常见的两种就是普通函数（使用 `function` 关键字）和箭头函数（`=>`）。虽然它们看起来有些相似，但实际上它们之间有不少微妙的区别，尤其是在 `this`、`new`、`yield` 等语义上的差异。如果你也常常纠结“我该用哪种写法更合适？”，那本文或许能帮你厘清思路。\n\n---\n\n# 三种创建函数的方式\n\n## 1. 函数声明（Function Declaration）\n\n最传统的方式是使用 `function` 关键字直接声明函数：\n\n```js\nfunction helloWorld() {\n  console.log('Hello, world!');\n}\n```\n\n这种方式是**函数声明语句**，在作用域中具有名称绑定，并且最重要的一点是，它会被**提升（hoisting）**到当前作用域的顶部。\n\n```js\n<script type=\"text/javascript\">\nsayHello(); // ✅ 可以提前调用，输出：Hello, world!\n\nfunction sayHello() {\n  console.log('Hello, world!');\n}\n</script>\n```\n\n### 🔍 为什么这样不会报错？\n这是因为 函数声明 会在代码运行前被 JavaScript 引擎“提升”到当前作用域的顶部。也就是说，在你执行 sayHello() 的时候，这个函数其实已经“存在”了。\n\n---\n\n## 2. 函数表达式（Function Expression）\n\n你也可以将匿名函数赋值给变量：\n\n```js\nvar sayHi = function() {\n  console.log('Hi!');\n}\n\nsayHi(); // ✅ 可以调用，输出：Hi!\n```\n\n这种写法称为函数表达式，它不像声明那样会被提升，必须在使用前先定义。\n\n### 1️⃣ 函数声明会被完整提升，而函数表达式不会\n\n```js\nsayHi(); // ❌ TypeError: sayHi is not a function\n\nvar sayHi = function() {\n  console.log('Hi!');\n}\n```\n\n虽然变量 sayHi 被提升了，但它的值（即函数体）并没有被赋值。在 sayHi() 执行时，变量的值是 undefined，调用它会报错。\n\n\n### 2️⃣ 匿名函数表达式在调试堆栈中可能丢失函数名\n\n很多时候我们写函数表达式时是匿名的，比如：\n\n```js\nconst handler = function(a, b) {\n  throw new Error('Oops!');\n};\n```\n\n虽然你赋值给了变量 `handler`，但 JavaScript 引擎不一定能在调试堆栈中正确还原这个名称，特别是在打包压缩或 V8 优化场景中。\n\n\n有趣的是，我们还可以给函数表达式命名：\n\n```js\nconst throwError = function error(predicate, arr) {\n  throw new Error('Oops');\n}\n```\n\n虽然我们无法直接通过 `error()` 调用它，但如果出错，错误堆栈中会显示这个名称，有利于调试。\n\n![堆栈](./images/js-arrow-function/stack.png)\n\n\n**注意：** 使用 `let` 或 `const` 声明函数表达式时，甚至连变量提升都不会发生，会抛出 `ReferenceError`：\n\n```js\nsayHello(); // ❌ ReferenceError: Cannot access 'sayHello' before initialization\n\nconst sayHello = function() {\n  console.log('Hello');\n};\n```\n\n---\n\n## 3. 箭头函数（Arrow Function）\n\n箭头函数是 ES6 引入的语法，语法更短，也更现代：\n\n```js\ndouble(2); // ❌ TypeError: greet is not a function\n\nconst double = (x) => {\n  return x * 2;\n};\n```\n\n如果函数体只有一行返回语句，还可以进一步简化：\n\n```js\nconst double = (x) => x * 2;\n```\n\n如果参数只有一个，连小括号都可以省略：\n\n```js\nconst double = x => x * 2;\n```\n\n但别被这些简洁迷惑了，箭头函数背后隐藏着一些重要差异。\n\n---\n\n# 箭头函数 ≠ 普通函数\n\n## 1. 箭头函数没有自己的 this\n\n```js\nfunction getName() {\n  return this.userName;\n}\n\nconst getNameArrow = () => this.userName;\n\nconst User = {\n  userName: 'Tim Cook',\n  getName,\n  getNameArrow\n};\n\nconsole.log(User.getName()); // ✅ 正常输出 Tim Cook\nconsole.log(User.getNameArrow()); // ❌ undefined\n```\n\n箭头函数会捕获**定义时**的 `this` 值，而不是调用时的。这也是为什么它不适合用作对象的方法或类的原型方法。\n\n---\n\n## 2. 箭头函数不能用作构造函数\n\n```js\nconst User = (userName, age) => {\n  this.userName = userName;\n  this.age = age;\n};\n\nconst myUser = new User('Tim Cook', 55); // ❌ TypeError: User is not a constructor\n```\n\n你不能用 `new` 调用箭头函数，它们没有 `prototype`，也没有 `new.target`。\n\n---\n\n## 3. 箭头函数不能使用 yield\n\n```js\n// ❌ 不合法，不能在箭头函数里使用 yield\nfunction* numberGen() {\n  const show = () => {\n    yield 1; // SyntaxError\n  };\n}\n```\n\n箭头函数无法作为生成器使用，不能使用 `yield`，也无法被声明为 `function*`。\n\n---\n\n# 应该何时使用箭头函数？\n\n简单总结：\n\n| 使用场景             | 推荐写法              |\n| ---------------- | ----------------- |\n| 不使用 this / yield | ✅ 箭头函数更简洁         |\n| 需要 this 正确指向     | ✅ 使用普通函数          |\n| 函数需要提前调用（如顶层函数）  | ✅ 函数声明更合适         |\n| 用作构造函数           | ✅ 使用普通函数或 class   |\n| 编写 generator 函数  | ✅ 必须使用 function\\* |\n\n比如我们可以这样使用箭头函数作为回调：\n\n```js\n['a', 'b', 'c'].map(x => x.toUpperCase());\n```\n\n或者创建一个通用的日志方法：\n\n```js\nconst log = (obj) => console.log(obj.toLogString());\n```\n\n只要不涉及 `this`，箭头函数通常都是更简洁的选择。\n\n---\n\n# 函数声明带来的 hoisting 优势\n\n有时你可能希望把实现细节放在文件底部，而逻辑入口放在顶部，这时候函数声明的提升就很有用了：\n\n```js\nconst result = processOrder('pending');\nconsole.log(result); // 输出：请尽快支付订单！\n\n// --- 下面是逻辑实现部分 ---\nfunction processOrder(status) {\n  if (isCancelled(status)) {\n    return '订单已取消';\n  }\n\n  if (isPaid(status)) {\n    return '感谢您的购买！';\n  }\n\n  if (isPending(status)) {\n    return '请尽快支付订单！';\n  }\n\n  return '未知状态';\n}\n\nfunction isCancelled(status) {\n  return status === 'cancelled';\n}\n\nfunction isPaid(status) {\n  return status === 'paid';\n}\n\nfunction isPending(status) {\n  return status === 'pending';\n}\n\n```\n\n这种结构让代码阅读起来更清晰：先看到“大意”，再了解“细节”。\n\n---\n\n# 总结：一张选择函数写法的流程图\n\n我们可以根据以下几个问题，快速判断使用哪种函数写法更合适：\n\n![流程](./images/js-arrow-function/choose.png)\n\n1. **是否需要使用 `yield`？** → 用 `function*`\n2. **是否使用 `this`？** → 用普通函数（method or function expression）\n3. **是否希望提前调用该函数？** → 用函数声明（`function name() {}`）\n4. **其余情况？** → 用箭头函数，代码更简洁\n\n当然，规范不应束缚创作，你完全可以根据团队风格、可读性或调试需要选择你喜欢的写法。但理解这些差异，可以让你写出更稳健、更清晰的 JavaScript 代码。\n\n---\n\n# 结语\n\n箭头函数不是 function 的替代品，而是一个补充。当你理解它们之间的本质差异后，就能更合理地在项目中权衡使用了。\n\n如果你有自己的选择标准，欢迎留言分享你的实践经验！\n\n","slug":"js-arrow-function","published":1,"updated":"2025-08-08T07:22:36.728Z","_id":"cme10ek9u0000uop14tsk9ps8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 JavaScript 中，我们有多种方式来定义函数。最常见的两种就是普通函数（使用 <code>function</code> 关键字）和箭头函数（<code>=&gt;</code>）。虽然它们看起来有些相似，但实际上它们之间有不少微妙的区别，尤其是在 <code>this</code>、<code>new</code>、<code>yield</code> 等语义上的差异。如果你也常常纠结“我该用哪种写法更合适？”，那本文或许能帮你厘清思路。</p>\n<hr>\n<h1 id=\"三种创建函数的方式\"><a href=\"#三种创建函数的方式\" class=\"headerlink\" title=\"三种创建函数的方式\"></a>三种创建函数的方式</h1><h2 id=\"1-函数声明（Function-Declaration）\"><a href=\"#1-函数声明（Function-Declaration）\" class=\"headerlink\" title=\"1. 函数声明（Function Declaration）\"></a>1. 函数声明（Function Declaration）</h2><p>最传统的方式是使用 <code>function</code> 关键字直接声明函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">helloWorld</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式是<strong>函数声明语句</strong>，在作用域中具有名称绑定，并且最重要的一点是，它会被<strong>提升（hoisting）</strong>到当前作用域的顶部。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\"><span class=\"title function_\">sayHello</span>(); <span class=\"comment\">// ✅ 可以提前调用，输出：Hello, world!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔍-为什么这样不会报错？\"><a href=\"#🔍-为什么这样不会报错？\" class=\"headerlink\" title=\"🔍 为什么这样不会报错？\"></a>🔍 为什么这样不会报错？</h3><p>这是因为 函数声明 会在代码运行前被 JavaScript 引擎“提升”到当前作用域的顶部。也就是说，在你执行 sayHello() 的时候，这个函数其实已经“存在”了。</p>\n<hr>\n<h2 id=\"2-函数表达式（Function-Expression）\"><a href=\"#2-函数表达式（Function-Expression）\" class=\"headerlink\" title=\"2. 函数表达式（Function Expression）\"></a>2. 函数表达式（Function Expression）</h2><p>你也可以将匿名函数赋值给变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayHi = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hi!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">sayHi</span>(); <span class=\"comment\">// ✅ 可以调用，输出：Hi!</span></span><br></pre></td></tr></table></figure>\n\n<p>这种写法称为函数表达式，它不像声明那样会被提升，必须在使用前先定义。</p>\n<h3 id=\"1️⃣-函数声明会被完整提升，而函数表达式不会\"><a href=\"#1️⃣-函数声明会被完整提升，而函数表达式不会\" class=\"headerlink\" title=\"1️⃣ 函数声明会被完整提升，而函数表达式不会\"></a>1️⃣ 函数声明会被完整提升，而函数表达式不会</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHi</span>(); <span class=\"comment\">// ❌ TypeError: sayHi is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHi = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hi!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然变量 sayHi 被提升了，但它的值（即函数体）并没有被赋值。在 sayHi() 执行时，变量的值是 undefined，调用它会报错。</p>\n<h3 id=\"2️⃣-匿名函数表达式在调试堆栈中可能丢失函数名\"><a href=\"#2️⃣-匿名函数表达式在调试堆栈中可能丢失函数名\" class=\"headerlink\" title=\"2️⃣ 匿名函数表达式在调试堆栈中可能丢失函数名\"></a>2️⃣ 匿名函数表达式在调试堆栈中可能丢失函数名</h3><p>很多时候我们写函数表达式时是匿名的，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Oops!&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>虽然你赋值给了变量 <code>handler</code>，但 JavaScript 引擎不一定能在调试堆栈中正确还原这个名称，特别是在打包压缩或 V8 优化场景中。</p>\n<p>有趣的是，我们还可以给函数表达式命名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwError = <span class=\"keyword\">function</span> <span class=\"title function_\">error</span>(<span class=\"params\">predicate, arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Oops&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们无法直接通过 <code>error()</code> 调用它，但如果出错，错误堆栈中会显示这个名称，有利于调试。</p>\n<p><img src=\"/blog/./images/js-arrow-function/stack.png\" alt=\"堆栈\"></p>\n<p><strong>注意：</strong> 使用 <code>let</code> 或 <code>const</code> 声明函数表达式时，甚至连变量提升都不会发生，会抛出 <code>ReferenceError</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHello</span>(); <span class=\"comment\">// ❌ ReferenceError: Cannot access &#x27;sayHello&#x27; before initialization</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sayHello = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-箭头函数（Arrow-Function）\"><a href=\"#3-箭头函数（Arrow-Function）\" class=\"headerlink\" title=\"3. 箭头函数（Arrow Function）\"></a>3. 箭头函数（Arrow Function）</h2><p>箭头函数是 ES6 引入的语法，语法更短，也更现代：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">double</span>(<span class=\"number\">2</span>); <span class=\"comment\">// ❌ TypeError: greet is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">double</span> = (<span class=\"params\">x</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果函数体只有一行返回语句，还可以进一步简化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">double</span> = (<span class=\"params\">x</span>) =&gt; x * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果参数只有一个，连小括号都可以省略：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">double</span> = x =&gt; x * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但别被这些简洁迷惑了，箭头函数背后隐藏着一些重要差异。</p>\n<hr>\n<h1 id=\"箭头函数-≠-普通函数\"><a href=\"#箭头函数-≠-普通函数\" class=\"headerlink\" title=\"箭头函数 ≠ 普通函数\"></a>箭头函数 ≠ 普通函数</h1><h2 id=\"1-箭头函数没有自己的-this\"><a href=\"#1-箭头函数没有自己的-this\" class=\"headerlink\" title=\"1. 箭头函数没有自己的 this\"></a>1. 箭头函数没有自己的 this</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getNameArrow</span> = (<span class=\"params\"></span>) =&gt; <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;Tim Cook&#x27;</span>,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">  getNameArrow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">getName</span>()); <span class=\"comment\">// ✅ 正常输出 Tim Cook</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">getNameArrow</span>()); <span class=\"comment\">// ❌ undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>箭头函数会捕获<strong>定义时</strong>的 <code>this</code> 值，而不是调用时的。这也是为什么它不适合用作对象的方法或类的原型方法。</p>\n<hr>\n<h2 id=\"2-箭头函数不能用作构造函数\"><a href=\"#2-箭头函数不能用作构造函数\" class=\"headerlink\" title=\"2. 箭头函数不能用作构造函数\"></a>2. 箭头函数不能用作构造函数</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">User</span> = (<span class=\"params\">userName, age</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span> = userName;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myUser = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&#x27;Tim Cook&#x27;</span>, <span class=\"number\">55</span>); <span class=\"comment\">// ❌ TypeError: User is not a constructor</span></span><br></pre></td></tr></table></figure>\n\n<p>你不能用 <code>new</code> 调用箭头函数，它们没有 <code>prototype</code>，也没有 <code>new.target</code>。</p>\n<hr>\n<h2 id=\"3-箭头函数不能使用-yield\"><a href=\"#3-箭头函数不能使用-yield\" class=\"headerlink\" title=\"3. 箭头函数不能使用 yield\"></a>3. 箭头函数不能使用 yield</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ❌ 不合法，不能在箭头函数里使用 yield</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">numberGen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">show</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>; <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>箭头函数无法作为生成器使用，不能使用 <code>yield</code>，也无法被声明为 <code>function*</code>。</p>\n<hr>\n<h1 id=\"应该何时使用箭头函数？\"><a href=\"#应该何时使用箭头函数？\" class=\"headerlink\" title=\"应该何时使用箭头函数？\"></a>应该何时使用箭头函数？</h1><p>简单总结：</p>\n<table>\n<thead>\n<tr>\n<th>使用场景</th>\n<th>推荐写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>不使用 this &#x2F; yield</td>\n<td>✅ 箭头函数更简洁</td>\n</tr>\n<tr>\n<td>需要 this 正确指向</td>\n<td>✅ 使用普通函数</td>\n</tr>\n<tr>\n<td>函数需要提前调用（如顶层函数）</td>\n<td>✅ 函数声明更合适</td>\n</tr>\n<tr>\n<td>用作构造函数</td>\n<td>✅ 使用普通函数或 class</td>\n</tr>\n<tr>\n<td>编写 generator 函数</td>\n<td>✅ 必须使用 function*</td>\n</tr>\n</tbody></table>\n<p>比如我们可以这样使用箭头函数作为回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>].<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.<span class=\"title function_\">toUpperCase</span>());</span><br></pre></td></tr></table></figure>\n\n<p>或者创建一个通用的日志方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">log</span> = (<span class=\"params\">obj</span>) =&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">toLogString</span>());</span><br></pre></td></tr></table></figure>\n\n<p>只要不涉及 <code>this</code>，箭头函数通常都是更简洁的选择。</p>\n<hr>\n<h1 id=\"函数声明带来的-hoisting-优势\"><a href=\"#函数声明带来的-hoisting-优势\" class=\"headerlink\" title=\"函数声明带来的 hoisting 优势\"></a>函数声明带来的 hoisting 优势</h1><p>有时你可能希望把实现细节放在文件底部，而逻辑入口放在顶部，这时候函数声明的提升就很有用了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"title function_\">processOrder</span>(<span class=\"string\">&#x27;pending&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 输出：请尽快支付订单！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// --- 下面是逻辑实现部分 ---</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processOrder</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isCancelled</span>(status)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;订单已取消&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isPaid</span>(status)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;感谢您的购买！&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isPending</span>(status)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;请尽快支付订单！&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;未知状态&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isCancelled</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status === <span class=\"string\">&#x27;cancelled&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPaid</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status === <span class=\"string\">&#x27;paid&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPending</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status === <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种结构让代码阅读起来更清晰：先看到“大意”，再了解“细节”。</p>\n<hr>\n<h1 id=\"总结：一张选择函数写法的流程图\"><a href=\"#总结：一张选择函数写法的流程图\" class=\"headerlink\" title=\"总结：一张选择函数写法的流程图\"></a>总结：一张选择函数写法的流程图</h1><p>我们可以根据以下几个问题，快速判断使用哪种函数写法更合适：</p>\n<p><img src=\"/blog/./images/js-arrow-function/choose.png\" alt=\"流程\"></p>\n<ol>\n<li><strong>是否需要使用 <code>yield</code>？</strong> → 用 <code>function*</code></li>\n<li><strong>是否使用 <code>this</code>？</strong> → 用普通函数（method or function expression）</li>\n<li><strong>是否希望提前调用该函数？</strong> → 用函数声明（<code>function name() &#123;&#125;</code>）</li>\n<li><strong>其余情况？</strong> → 用箭头函数，代码更简洁</li>\n</ol>\n<p>当然，规范不应束缚创作，你完全可以根据团队风格、可读性或调试需要选择你喜欢的写法。但理解这些差异，可以让你写出更稳健、更清晰的 JavaScript 代码。</p>\n<hr>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>箭头函数不是 function 的替代品，而是一个补充。当你理解它们之间的本质差异后，就能更合理地在项目中权衡使用了。</p>\n<p>如果你有自己的选择标准，欢迎留言分享你的实践经验！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 JavaScript 中，我们有多种方式来定义函数。最常见的两种就是普通函数（使用 <code>function</code> 关键字）和箭头函数（<code>=&gt;</code>）。虽然它们看起来有些相似，但实际上它们之间有不少微妙的区别，尤其是在 <code>this</code>、<code>new</code>、<code>yield</code> 等语义上的差异。如果你也常常纠结“我该用哪种写法更合适？”，那本文或许能帮你厘清思路。</p>\n<hr>\n<h1 id=\"三种创建函数的方式\"><a href=\"#三种创建函数的方式\" class=\"headerlink\" title=\"三种创建函数的方式\"></a>三种创建函数的方式</h1><h2 id=\"1-函数声明（Function-Declaration）\"><a href=\"#1-函数声明（Function-Declaration）\" class=\"headerlink\" title=\"1. 函数声明（Function Declaration）\"></a>1. 函数声明（Function Declaration）</h2><p>最传统的方式是使用 <code>function</code> 关键字直接声明函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">helloWorld</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式是<strong>函数声明语句</strong>，在作用域中具有名称绑定，并且最重要的一点是，它会被<strong>提升（hoisting）</strong>到当前作用域的顶部。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\"><span class=\"title function_\">sayHello</span>(); <span class=\"comment\">// ✅ 可以提前调用，输出：Hello, world!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, world!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🔍-为什么这样不会报错？\"><a href=\"#🔍-为什么这样不会报错？\" class=\"headerlink\" title=\"🔍 为什么这样不会报错？\"></a>🔍 为什么这样不会报错？</h3><p>这是因为 函数声明 会在代码运行前被 JavaScript 引擎“提升”到当前作用域的顶部。也就是说，在你执行 sayHello() 的时候，这个函数其实已经“存在”了。</p>\n<hr>\n<h2 id=\"2-函数表达式（Function-Expression）\"><a href=\"#2-函数表达式（Function-Expression）\" class=\"headerlink\" title=\"2. 函数表达式（Function Expression）\"></a>2. 函数表达式（Function Expression）</h2><p>你也可以将匿名函数赋值给变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sayHi = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hi!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">sayHi</span>(); <span class=\"comment\">// ✅ 可以调用，输出：Hi!</span></span><br></pre></td></tr></table></figure>\n\n<p>这种写法称为函数表达式，它不像声明那样会被提升，必须在使用前先定义。</p>\n<h3 id=\"1️⃣-函数声明会被完整提升，而函数表达式不会\"><a href=\"#1️⃣-函数声明会被完整提升，而函数表达式不会\" class=\"headerlink\" title=\"1️⃣ 函数声明会被完整提升，而函数表达式不会\"></a>1️⃣ 函数声明会被完整提升，而函数表达式不会</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHi</span>(); <span class=\"comment\">// ❌ TypeError: sayHi is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sayHi = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hi!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然变量 sayHi 被提升了，但它的值（即函数体）并没有被赋值。在 sayHi() 执行时，变量的值是 undefined，调用它会报错。</p>\n<h3 id=\"2️⃣-匿名函数表达式在调试堆栈中可能丢失函数名\"><a href=\"#2️⃣-匿名函数表达式在调试堆栈中可能丢失函数名\" class=\"headerlink\" title=\"2️⃣ 匿名函数表达式在调试堆栈中可能丢失函数名\"></a>2️⃣ 匿名函数表达式在调试堆栈中可能丢失函数名</h3><p>很多时候我们写函数表达式时是匿名的，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Oops!&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>虽然你赋值给了变量 <code>handler</code>，但 JavaScript 引擎不一定能在调试堆栈中正确还原这个名称，特别是在打包压缩或 V8 优化场景中。</p>\n<p>有趣的是，我们还可以给函数表达式命名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwError = <span class=\"keyword\">function</span> <span class=\"title function_\">error</span>(<span class=\"params\">predicate, arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Oops&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然我们无法直接通过 <code>error()</code> 调用它，但如果出错，错误堆栈中会显示这个名称，有利于调试。</p>\n<p><img src=\"/blog/./images/js-arrow-function/stack.png\" alt=\"堆栈\"></p>\n<p><strong>注意：</strong> 使用 <code>let</code> 或 <code>const</code> 声明函数表达式时，甚至连变量提升都不会发生，会抛出 <code>ReferenceError</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">sayHello</span>(); <span class=\"comment\">// ❌ ReferenceError: Cannot access &#x27;sayHello&#x27; before initialization</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sayHello = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-箭头函数（Arrow-Function）\"><a href=\"#3-箭头函数（Arrow-Function）\" class=\"headerlink\" title=\"3. 箭头函数（Arrow Function）\"></a>3. 箭头函数（Arrow Function）</h2><p>箭头函数是 ES6 引入的语法，语法更短，也更现代：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">double</span>(<span class=\"number\">2</span>); <span class=\"comment\">// ❌ TypeError: greet is not a function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">double</span> = (<span class=\"params\">x</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果函数体只有一行返回语句，还可以进一步简化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">double</span> = (<span class=\"params\">x</span>) =&gt; x * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果参数只有一个，连小括号都可以省略：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">double</span> = x =&gt; x * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但别被这些简洁迷惑了，箭头函数背后隐藏着一些重要差异。</p>\n<hr>\n<h1 id=\"箭头函数-≠-普通函数\"><a href=\"#箭头函数-≠-普通函数\" class=\"headerlink\" title=\"箭头函数 ≠ 普通函数\"></a>箭头函数 ≠ 普通函数</h1><h2 id=\"1-箭头函数没有自己的-this\"><a href=\"#1-箭头函数没有自己的-this\" class=\"headerlink\" title=\"1. 箭头函数没有自己的 this\"></a>1. 箭头函数没有自己的 this</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getNameArrow</span> = (<span class=\"params\"></span>) =&gt; <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">User</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;Tim Cook&#x27;</span>,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">  getNameArrow</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">getName</span>()); <span class=\"comment\">// ✅ 正常输出 Tim Cook</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">getNameArrow</span>()); <span class=\"comment\">// ❌ undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>箭头函数会捕获<strong>定义时</strong>的 <code>this</code> 值，而不是调用时的。这也是为什么它不适合用作对象的方法或类的原型方法。</p>\n<hr>\n<h2 id=\"2-箭头函数不能用作构造函数\"><a href=\"#2-箭头函数不能用作构造函数\" class=\"headerlink\" title=\"2. 箭头函数不能用作构造函数\"></a>2. 箭头函数不能用作构造函数</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">User</span> = (<span class=\"params\">userName, age</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">userName</span> = userName;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myUser = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&#x27;Tim Cook&#x27;</span>, <span class=\"number\">55</span>); <span class=\"comment\">// ❌ TypeError: User is not a constructor</span></span><br></pre></td></tr></table></figure>\n\n<p>你不能用 <code>new</code> 调用箭头函数，它们没有 <code>prototype</code>，也没有 <code>new.target</code>。</p>\n<hr>\n<h2 id=\"3-箭头函数不能使用-yield\"><a href=\"#3-箭头函数不能使用-yield\" class=\"headerlink\" title=\"3. 箭头函数不能使用 yield\"></a>3. 箭头函数不能使用 yield</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ❌ 不合法，不能在箭头函数里使用 yield</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">numberGen</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">show</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>; <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>箭头函数无法作为生成器使用，不能使用 <code>yield</code>，也无法被声明为 <code>function*</code>。</p>\n<hr>\n<h1 id=\"应该何时使用箭头函数？\"><a href=\"#应该何时使用箭头函数？\" class=\"headerlink\" title=\"应该何时使用箭头函数？\"></a>应该何时使用箭头函数？</h1><p>简单总结：</p>\n<table>\n<thead>\n<tr>\n<th>使用场景</th>\n<th>推荐写法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>不使用 this &#x2F; yield</td>\n<td>✅ 箭头函数更简洁</td>\n</tr>\n<tr>\n<td>需要 this 正确指向</td>\n<td>✅ 使用普通函数</td>\n</tr>\n<tr>\n<td>函数需要提前调用（如顶层函数）</td>\n<td>✅ 函数声明更合适</td>\n</tr>\n<tr>\n<td>用作构造函数</td>\n<td>✅ 使用普通函数或 class</td>\n</tr>\n<tr>\n<td>编写 generator 函数</td>\n<td>✅ 必须使用 function*</td>\n</tr>\n</tbody></table>\n<p>比如我们可以这样使用箭头函数作为回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>].<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.<span class=\"title function_\">toUpperCase</span>());</span><br></pre></td></tr></table></figure>\n\n<p>或者创建一个通用的日志方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">log</span> = (<span class=\"params\">obj</span>) =&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">toLogString</span>());</span><br></pre></td></tr></table></figure>\n\n<p>只要不涉及 <code>this</code>，箭头函数通常都是更简洁的选择。</p>\n<hr>\n<h1 id=\"函数声明带来的-hoisting-优势\"><a href=\"#函数声明带来的-hoisting-优势\" class=\"headerlink\" title=\"函数声明带来的 hoisting 优势\"></a>函数声明带来的 hoisting 优势</h1><p>有时你可能希望把实现细节放在文件底部，而逻辑入口放在顶部，这时候函数声明的提升就很有用了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"title function_\">processOrder</span>(<span class=\"string\">&#x27;pending&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 输出：请尽快支付订单！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// --- 下面是逻辑实现部分 ---</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processOrder</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isCancelled</span>(status)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;订单已取消&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isPaid</span>(status)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;感谢您的购买！&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">isPending</span>(status)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;请尽快支付订单！&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;未知状态&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isCancelled</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status === <span class=\"string\">&#x27;cancelled&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPaid</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status === <span class=\"string\">&#x27;paid&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isPending</span>(<span class=\"params\">status</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> status === <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种结构让代码阅读起来更清晰：先看到“大意”，再了解“细节”。</p>\n<hr>\n<h1 id=\"总结：一张选择函数写法的流程图\"><a href=\"#总结：一张选择函数写法的流程图\" class=\"headerlink\" title=\"总结：一张选择函数写法的流程图\"></a>总结：一张选择函数写法的流程图</h1><p>我们可以根据以下几个问题，快速判断使用哪种函数写法更合适：</p>\n<p><img src=\"/blog/./images/js-arrow-function/choose.png\" alt=\"流程\"></p>\n<ol>\n<li><strong>是否需要使用 <code>yield</code>？</strong> → 用 <code>function*</code></li>\n<li><strong>是否使用 <code>this</code>？</strong> → 用普通函数（method or function expression）</li>\n<li><strong>是否希望提前调用该函数？</strong> → 用函数声明（<code>function name() &#123;&#125;</code>）</li>\n<li><strong>其余情况？</strong> → 用箭头函数，代码更简洁</li>\n</ol>\n<p>当然，规范不应束缚创作，你完全可以根据团队风格、可读性或调试需要选择你喜欢的写法。但理解这些差异，可以让你写出更稳健、更清晰的 JavaScript 代码。</p>\n<hr>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>箭头函数不是 function 的替代品，而是一个补充。当你理解它们之间的本质差异后，就能更合理地在项目中权衡使用了。</p>\n<p>如果你有自己的选择标准，欢迎留言分享你的实践经验！</p>\n"},{"title":"OAuth：为什么登录要绕一大圈？","date":"2025-09-04T03:50:52.000Z","_content":"\n\n# 引子：为什么我登录个网站还要跳到别的地方？\n\n想象一下，你在一个新网站上注册时，它说：\n👉 “你可以用 **Google 账号** 登录哦！”\n\n结果你点开后，页面一转，跳去了 Google：\n\n* Google 问你：“要不要允许这个网站获取你的邮箱？”\n* 你点了“允许”，然后才被带回到原来的网站。\n\n这个过程，看起来绕来绕去，让人一头雾水。为什么不能直接输入邮箱和密码就好了呢？这就是 **OAuth** 出场的原因。\n\n---\n\n# 1. 问题的根源：密码太危险了\n\n以前的网站常用的做法是：\n\n* 用户把 **账号和密码** 直接给第三方网站。\n* 这个网站再用这些信息去访问你的资源。\n\n问题在于：\n\n在互联网发展早期，许多网站或应用为了获取用户在其他平台上的信息，会要求用户直接提供在其他平台的用户名和密码。这种做法存在明显的安全隐患和不便之处：\n\n- **安全风险：** 第三方应用会保存用户密码，增加泄露风险，而且服务提供商也不得不开放密码登录，这本身并不安全。\n- **权限不可控：** 一旦提供了密码，第三方应用相当于获得了用户在该平台上的完全访问权，用户无法限制其访问范围和有效期。\n- **撤销不便：** 用户若想收回授权，只能修改密码。这会导致所有已授权的第三方应用全部失效，影响正常使用。\n- **牵一发而动全身：** 任一第三方应用被攻破，都会导致用户密码泄漏，进而威胁用户在所有平台上的数据安全。\n\n这就是 **共享密码的风险**。\n\n正是为了解决上述问题，**OAuth** 应运而生。OAuth 提供了一种安全的授权机制，让用户可以给予第三方应用**有限的访问权限**，而**无需透露账号密码**。这种机制类似于给第三方应用一把“有限权限的钥匙”而非直接交出主钥匙：第三方只能在授权范围和有效期内行使权限，用户也可随时收回授权。\n\nOAuth 的目标就是：\n✅ 不要再把密码交给第三方网站。\n---\n\n# 2. OAuth 的基本思路：借一把“门禁卡”\n![门禁](./images/oauth/door.png)\n\nOAuth 的核心思想就像“门禁卡”：\n\n* 你要进某个写字楼的办公室（= 访问用户的资源）。\n* 但是你不能直接拿楼主的钥匙（= 密码）。\n* 楼主（Google）可以给你一张 **临时的门禁卡**（= token）。\n* 门禁卡只能开指定的门（= 只允许访问邮箱）。\n* 卡还可以设置 **有效期**，过期了就无效。\n\n这样，既保证了安全性，也给了用户更细的控制。\n\n---\n\n# 3. OAuth 的核心概念与角色\n\n要理解 OAuth 的工作原理，需要认识其中的几个核心角色：\n\n- **用户（资源所有者，Resource Owner）：** 拥有受保护资源的终端用户，例如照片、联系人等数据的拥有者。用户通过授权决定第三方应用能否访问其资源。\n- **客户端（第三方应用，Client）：** 请求访问受保护资源的应用程序。它可以是网站、移动App等。\n- **授权服务器（Authorization Server）：** 授权服务提供商用于处理认证和授权的服务器。它负责验证用户身份、记录用户授权意愿，并在用户同意后颁发令牌。\n- **资源服务器（Resource Server）：** 存储用户受保护资源的服务器。资源服务器根据令牌所包含的权限范围向客户端开放相应资源。\n\n---\n\n# 4. 一次 OAuth 登录的“绕圈之旅”\n![OAuth 登录流程](./images/oauth/oauth.png)\n\n整个流程大概分 5 步：\n\n1. **客户端请求授权**\n   第三方网站跳转你到 Google，问你要不要授权。\n\n2. **用户同意授权**\n   你点了“允许”。\n\n3. **授权服务器发放授权码**\n   Google 给了客户端一个“授权码”（一次性、短期）。\n\n4. **客户端换取令牌**\n   网站用这个授权码去 Google 换取一个 **访问令牌（Access Token）**。\n\n5. **使用令牌访问资源**\n   网站拿着令牌，就能去请求你的邮箱地址或头像。\n\n👉 整个过程，密码从来没离开 Google，安全性就大大提高了。\n\n---\n\n\n# OAuth 的实际用途\n\n## 1. 第三方登录\n例如“使用微信登录”、“Sign in with Google”，让用户无需记住多个密码，应用通过 OAuth 获取有限的用户信息。\n\n## 2. API 授权\n用户可以授权第三方应用访问其在另一平台的数据（如 Google 日历、GitHub 仓库）。\n\n## 3. 微服务内部认证\n企业微服务架构中，通过统一认证服务颁发令牌，实现服务间安全通信。\n\n---\n\n# OAuth 与 OpenID Connect 的关系\n\n- **OAuth 专注于授权**：解决“应用能不能访问我的数据”的问题。\n- **OIDC 专注于认证**：解决“你是谁”的问题。\n- OIDC 在 OAuth 基础上增加了 **ID Token**（通常是 JWT），用于传递用户身份信息，实现单点登录。\n\n---\n\n# 常见误区与最佳实践\n\n1. **令牌安全**  \n   - 始终使用 HTTPS 传输令牌。  \n   - 令牌有效期应尽可能短。  \n   - 不要在 URL 参数中传递令牌。  \n\n2. **作用域管理**  \n   - 遵循最小权限原则。  \n   - 按需请求权限，避免一次性请求过多权限。  \n\n3. **刷新令牌机制**  \n   - 访问令牌短期有效，刷新令牌长期有效。  \n   - 刷新令牌必须安全存储。  \n   - 支持刷新令牌轮换，降低泄露风险。  \n\n---\n\n\n\n# 5. 常见的几种 OAuth 授权方式\n\nOAuth 有几种“授权模式”，常见的有：\n\n* **授权码模式（Authorization Code Flow）**：最安全，常见于 Web 应用。\n* **隐式模式（Implicit Flow）**：早期为单页应用准备，现在已不推荐。\n* **客户端模式（Client Credentials Flow）**：适合应用自己和 API 沟通。\n* **密码模式（Resource Owner Password Flow）**：直接用用户名密码，几乎不用了。\n\n---\n\n# 6. OAuth 带来的好处\n\n1. 用户不用把密码交给第三方。\n2. 用户可以精确控制权限，比如只给“读取邮箱”，不允许“删除邮件”。\n3. 用户可以随时在 Google 安全中心撤销某个应用的访问。\n4. 网站开发者也不用管理复杂的密码存储问题。\n\n---\n\n# 7. 总结\n\nOAuth 看起来流程复杂，其实就是一个安全设计：\n\n* **别交出钥匙**，只给对方一张 **临时门禁卡**；\n* **用户可控**，随时撤销权限；\n* **安全性更高**，即使门禁卡被偷，也只是部分权限，且很快失效。\n\n下次你在新网站点“用 Google 登录”的时候，就知道为什么它要带你绕一圈了。😉\n\n---\n\n\n<style>\nimg[alt=\"门禁\"] {\n  width: 30%;\n  height: 30%;\n}\n</style>","source":"_posts/oauth.md","raw":"---\ntitle: OAuth：为什么登录要绕一大圈？\ndate: 2025-09-04 11:50:52\ntags:\n---\n\n\n# 引子：为什么我登录个网站还要跳到别的地方？\n\n想象一下，你在一个新网站上注册时，它说：\n👉 “你可以用 **Google 账号** 登录哦！”\n\n结果你点开后，页面一转，跳去了 Google：\n\n* Google 问你：“要不要允许这个网站获取你的邮箱？”\n* 你点了“允许”，然后才被带回到原来的网站。\n\n这个过程，看起来绕来绕去，让人一头雾水。为什么不能直接输入邮箱和密码就好了呢？这就是 **OAuth** 出场的原因。\n\n---\n\n# 1. 问题的根源：密码太危险了\n\n以前的网站常用的做法是：\n\n* 用户把 **账号和密码** 直接给第三方网站。\n* 这个网站再用这些信息去访问你的资源。\n\n问题在于：\n\n在互联网发展早期，许多网站或应用为了获取用户在其他平台上的信息，会要求用户直接提供在其他平台的用户名和密码。这种做法存在明显的安全隐患和不便之处：\n\n- **安全风险：** 第三方应用会保存用户密码，增加泄露风险，而且服务提供商也不得不开放密码登录，这本身并不安全。\n- **权限不可控：** 一旦提供了密码，第三方应用相当于获得了用户在该平台上的完全访问权，用户无法限制其访问范围和有效期。\n- **撤销不便：** 用户若想收回授权，只能修改密码。这会导致所有已授权的第三方应用全部失效，影响正常使用。\n- **牵一发而动全身：** 任一第三方应用被攻破，都会导致用户密码泄漏，进而威胁用户在所有平台上的数据安全。\n\n这就是 **共享密码的风险**。\n\n正是为了解决上述问题，**OAuth** 应运而生。OAuth 提供了一种安全的授权机制，让用户可以给予第三方应用**有限的访问权限**，而**无需透露账号密码**。这种机制类似于给第三方应用一把“有限权限的钥匙”而非直接交出主钥匙：第三方只能在授权范围和有效期内行使权限，用户也可随时收回授权。\n\nOAuth 的目标就是：\n✅ 不要再把密码交给第三方网站。\n---\n\n# 2. OAuth 的基本思路：借一把“门禁卡”\n![门禁](./images/oauth/door.png)\n\nOAuth 的核心思想就像“门禁卡”：\n\n* 你要进某个写字楼的办公室（= 访问用户的资源）。\n* 但是你不能直接拿楼主的钥匙（= 密码）。\n* 楼主（Google）可以给你一张 **临时的门禁卡**（= token）。\n* 门禁卡只能开指定的门（= 只允许访问邮箱）。\n* 卡还可以设置 **有效期**，过期了就无效。\n\n这样，既保证了安全性，也给了用户更细的控制。\n\n---\n\n# 3. OAuth 的核心概念与角色\n\n要理解 OAuth 的工作原理，需要认识其中的几个核心角色：\n\n- **用户（资源所有者，Resource Owner）：** 拥有受保护资源的终端用户，例如照片、联系人等数据的拥有者。用户通过授权决定第三方应用能否访问其资源。\n- **客户端（第三方应用，Client）：** 请求访问受保护资源的应用程序。它可以是网站、移动App等。\n- **授权服务器（Authorization Server）：** 授权服务提供商用于处理认证和授权的服务器。它负责验证用户身份、记录用户授权意愿，并在用户同意后颁发令牌。\n- **资源服务器（Resource Server）：** 存储用户受保护资源的服务器。资源服务器根据令牌所包含的权限范围向客户端开放相应资源。\n\n---\n\n# 4. 一次 OAuth 登录的“绕圈之旅”\n![OAuth 登录流程](./images/oauth/oauth.png)\n\n整个流程大概分 5 步：\n\n1. **客户端请求授权**\n   第三方网站跳转你到 Google，问你要不要授权。\n\n2. **用户同意授权**\n   你点了“允许”。\n\n3. **授权服务器发放授权码**\n   Google 给了客户端一个“授权码”（一次性、短期）。\n\n4. **客户端换取令牌**\n   网站用这个授权码去 Google 换取一个 **访问令牌（Access Token）**。\n\n5. **使用令牌访问资源**\n   网站拿着令牌，就能去请求你的邮箱地址或头像。\n\n👉 整个过程，密码从来没离开 Google，安全性就大大提高了。\n\n---\n\n\n# OAuth 的实际用途\n\n## 1. 第三方登录\n例如“使用微信登录”、“Sign in with Google”，让用户无需记住多个密码，应用通过 OAuth 获取有限的用户信息。\n\n## 2. API 授权\n用户可以授权第三方应用访问其在另一平台的数据（如 Google 日历、GitHub 仓库）。\n\n## 3. 微服务内部认证\n企业微服务架构中，通过统一认证服务颁发令牌，实现服务间安全通信。\n\n---\n\n# OAuth 与 OpenID Connect 的关系\n\n- **OAuth 专注于授权**：解决“应用能不能访问我的数据”的问题。\n- **OIDC 专注于认证**：解决“你是谁”的问题。\n- OIDC 在 OAuth 基础上增加了 **ID Token**（通常是 JWT），用于传递用户身份信息，实现单点登录。\n\n---\n\n# 常见误区与最佳实践\n\n1. **令牌安全**  \n   - 始终使用 HTTPS 传输令牌。  \n   - 令牌有效期应尽可能短。  \n   - 不要在 URL 参数中传递令牌。  \n\n2. **作用域管理**  \n   - 遵循最小权限原则。  \n   - 按需请求权限，避免一次性请求过多权限。  \n\n3. **刷新令牌机制**  \n   - 访问令牌短期有效，刷新令牌长期有效。  \n   - 刷新令牌必须安全存储。  \n   - 支持刷新令牌轮换，降低泄露风险。  \n\n---\n\n\n\n# 5. 常见的几种 OAuth 授权方式\n\nOAuth 有几种“授权模式”，常见的有：\n\n* **授权码模式（Authorization Code Flow）**：最安全，常见于 Web 应用。\n* **隐式模式（Implicit Flow）**：早期为单页应用准备，现在已不推荐。\n* **客户端模式（Client Credentials Flow）**：适合应用自己和 API 沟通。\n* **密码模式（Resource Owner Password Flow）**：直接用用户名密码，几乎不用了。\n\n---\n\n# 6. OAuth 带来的好处\n\n1. 用户不用把密码交给第三方。\n2. 用户可以精确控制权限，比如只给“读取邮箱”，不允许“删除邮件”。\n3. 用户可以随时在 Google 安全中心撤销某个应用的访问。\n4. 网站开发者也不用管理复杂的密码存储问题。\n\n---\n\n# 7. 总结\n\nOAuth 看起来流程复杂，其实就是一个安全设计：\n\n* **别交出钥匙**，只给对方一张 **临时门禁卡**；\n* **用户可控**，随时撤销权限；\n* **安全性更高**，即使门禁卡被偷，也只是部分权限，且很快失效。\n\n下次你在新网站点“用 Google 登录”的时候，就知道为什么它要带你绕一圈了。😉\n\n---\n\n\n<style>\nimg[alt=\"门禁\"] {\n  width: 30%;\n  height: 30%;\n}\n</style>","slug":"oauth","published":1,"updated":"2025-09-11T01:12:39.750Z","_id":"cmf6jnf3u00008wp1c8s12p3s","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"引子：为什么我登录个网站还要跳到别的地方？\"><a href=\"#引子：为什么我登录个网站还要跳到别的地方？\" class=\"headerlink\" title=\"引子：为什么我登录个网站还要跳到别的地方？\"></a>引子：为什么我登录个网站还要跳到别的地方？</h1><p>想象一下，你在一个新网站上注册时，它说：<br>👉 “你可以用 <strong>Google 账号</strong> 登录哦！”</p>\n<p>结果你点开后，页面一转，跳去了 Google：</p>\n<ul>\n<li>Google 问你：“要不要允许这个网站获取你的邮箱？”</li>\n<li>你点了“允许”，然后才被带回到原来的网站。</li>\n</ul>\n<p>这个过程，看起来绕来绕去，让人一头雾水。为什么不能直接输入邮箱和密码就好了呢？这就是 <strong>OAuth</strong> 出场的原因。</p>\n<hr>\n<h1 id=\"1-问题的根源：密码太危险了\"><a href=\"#1-问题的根源：密码太危险了\" class=\"headerlink\" title=\"1. 问题的根源：密码太危险了\"></a>1. 问题的根源：密码太危险了</h1><p>以前的网站常用的做法是：</p>\n<ul>\n<li>用户把 <strong>账号和密码</strong> 直接给第三方网站。</li>\n<li>这个网站再用这些信息去访问你的资源。</li>\n</ul>\n<p>问题在于：</p>\n<p>在互联网发展早期，许多网站或应用为了获取用户在其他平台上的信息，会要求用户直接提供在其他平台的用户名和密码。这种做法存在明显的安全隐患和不便之处：</p>\n<ul>\n<li><strong>安全风险：</strong> 第三方应用会保存用户密码，增加泄露风险，而且服务提供商也不得不开放密码登录，这本身并不安全。</li>\n<li><strong>权限不可控：</strong> 一旦提供了密码，第三方应用相当于获得了用户在该平台上的完全访问权，用户无法限制其访问范围和有效期。</li>\n<li><strong>撤销不便：</strong> 用户若想收回授权，只能修改密码。这会导致所有已授权的第三方应用全部失效，影响正常使用。</li>\n<li><strong>牵一发而动全身：</strong> 任一第三方应用被攻破，都会导致用户密码泄漏，进而威胁用户在所有平台上的数据安全。</li>\n</ul>\n<p>这就是 <strong>共享密码的风险</strong>。</p>\n<p>正是为了解决上述问题，<strong>OAuth</strong> 应运而生。OAuth 提供了一种安全的授权机制，让用户可以给予第三方应用<strong>有限的访问权限</strong>，而<strong>无需透露账号密码</strong>。这种机制类似于给第三方应用一把“有限权限的钥匙”而非直接交出主钥匙：第三方只能在授权范围和有效期内行使权限，用户也可随时收回授权。</p>\n<h2 id=\"OAuth-的目标就是：✅-不要再把密码交给第三方网站。\"><a href=\"#OAuth-的目标就是：✅-不要再把密码交给第三方网站。\" class=\"headerlink\" title=\"OAuth 的目标就是：✅ 不要再把密码交给第三方网站。\"></a>OAuth 的目标就是：<br>✅ 不要再把密码交给第三方网站。</h2><h1 id=\"2-OAuth-的基本思路：借一把“门禁卡”\"><a href=\"#2-OAuth-的基本思路：借一把“门禁卡”\" class=\"headerlink\" title=\"2. OAuth 的基本思路：借一把“门禁卡”\"></a>2. OAuth 的基本思路：借一把“门禁卡”</h1><p><img src=\"/blog/./images/oauth/door.png\" alt=\"门禁\"></p>\n<p>OAuth 的核心思想就像“门禁卡”：</p>\n<ul>\n<li>你要进某个写字楼的办公室（&#x3D; 访问用户的资源）。</li>\n<li>但是你不能直接拿楼主的钥匙（&#x3D; 密码）。</li>\n<li>楼主（Google）可以给你一张 <strong>临时的门禁卡</strong>（&#x3D; token）。</li>\n<li>门禁卡只能开指定的门（&#x3D; 只允许访问邮箱）。</li>\n<li>卡还可以设置 <strong>有效期</strong>，过期了就无效。</li>\n</ul>\n<p>这样，既保证了安全性，也给了用户更细的控制。</p>\n<hr>\n<h1 id=\"3-OAuth-的核心概念与角色\"><a href=\"#3-OAuth-的核心概念与角色\" class=\"headerlink\" title=\"3. OAuth 的核心概念与角色\"></a>3. OAuth 的核心概念与角色</h1><p>要理解 OAuth 的工作原理，需要认识其中的几个核心角色：</p>\n<ul>\n<li><strong>用户（资源所有者，Resource Owner）：</strong> 拥有受保护资源的终端用户，例如照片、联系人等数据的拥有者。用户通过授权决定第三方应用能否访问其资源。</li>\n<li><strong>客户端（第三方应用，Client）：</strong> 请求访问受保护资源的应用程序。它可以是网站、移动App等。</li>\n<li><strong>授权服务器（Authorization Server）：</strong> 授权服务提供商用于处理认证和授权的服务器。它负责验证用户身份、记录用户授权意愿，并在用户同意后颁发令牌。</li>\n<li><strong>资源服务器（Resource Server）：</strong> 存储用户受保护资源的服务器。资源服务器根据令牌所包含的权限范围向客户端开放相应资源。</li>\n</ul>\n<hr>\n<h1 id=\"4-一次-OAuth-登录的“绕圈之旅”\"><a href=\"#4-一次-OAuth-登录的“绕圈之旅”\" class=\"headerlink\" title=\"4. 一次 OAuth 登录的“绕圈之旅”\"></a>4. 一次 OAuth 登录的“绕圈之旅”</h1><p><img src=\"/blog/./images/oauth/oauth.png\" alt=\"OAuth 登录流程\"></p>\n<p>整个流程大概分 5 步：</p>\n<ol>\n<li><p><strong>客户端请求授权</strong><br>第三方网站跳转你到 Google，问你要不要授权。</p>\n</li>\n<li><p><strong>用户同意授权</strong><br>你点了“允许”。</p>\n</li>\n<li><p><strong>授权服务器发放授权码</strong><br>Google 给了客户端一个“授权码”（一次性、短期）。</p>\n</li>\n<li><p><strong>客户端换取令牌</strong><br>网站用这个授权码去 Google 换取一个 <strong>访问令牌（Access Token）</strong>。</p>\n</li>\n<li><p><strong>使用令牌访问资源</strong><br>网站拿着令牌，就能去请求你的邮箱地址或头像。</p>\n</li>\n</ol>\n<p>👉 整个过程，密码从来没离开 Google，安全性就大大提高了。</p>\n<hr>\n<h1 id=\"OAuth-的实际用途\"><a href=\"#OAuth-的实际用途\" class=\"headerlink\" title=\"OAuth 的实际用途\"></a>OAuth 的实际用途</h1><h2 id=\"1-第三方登录\"><a href=\"#1-第三方登录\" class=\"headerlink\" title=\"1. 第三方登录\"></a>1. 第三方登录</h2><p>例如“使用微信登录”、“Sign in with Google”，让用户无需记住多个密码，应用通过 OAuth 获取有限的用户信息。</p>\n<h2 id=\"2-API-授权\"><a href=\"#2-API-授权\" class=\"headerlink\" title=\"2. API 授权\"></a>2. API 授权</h2><p>用户可以授权第三方应用访问其在另一平台的数据（如 Google 日历、GitHub 仓库）。</p>\n<h2 id=\"3-微服务内部认证\"><a href=\"#3-微服务内部认证\" class=\"headerlink\" title=\"3. 微服务内部认证\"></a>3. 微服务内部认证</h2><p>企业微服务架构中，通过统一认证服务颁发令牌，实现服务间安全通信。</p>\n<hr>\n<h1 id=\"OAuth-与-OpenID-Connect-的关系\"><a href=\"#OAuth-与-OpenID-Connect-的关系\" class=\"headerlink\" title=\"OAuth 与 OpenID Connect 的关系\"></a>OAuth 与 OpenID Connect 的关系</h1><ul>\n<li><strong>OAuth 专注于授权</strong>：解决“应用能不能访问我的数据”的问题。</li>\n<li><strong>OIDC 专注于认证</strong>：解决“你是谁”的问题。</li>\n<li>OIDC 在 OAuth 基础上增加了 <strong>ID Token</strong>（通常是 JWT），用于传递用户身份信息，实现单点登录。</li>\n</ul>\n<hr>\n<h1 id=\"常见误区与最佳实践\"><a href=\"#常见误区与最佳实践\" class=\"headerlink\" title=\"常见误区与最佳实践\"></a>常见误区与最佳实践</h1><ol>\n<li><p><strong>令牌安全</strong>  </p>\n<ul>\n<li>始终使用 HTTPS 传输令牌。  </li>\n<li>令牌有效期应尽可能短。  </li>\n<li>不要在 URL 参数中传递令牌。</li>\n</ul>\n</li>\n<li><p><strong>作用域管理</strong>  </p>\n<ul>\n<li>遵循最小权限原则。  </li>\n<li>按需请求权限，避免一次性请求过多权限。</li>\n</ul>\n</li>\n<li><p><strong>刷新令牌机制</strong>  </p>\n<ul>\n<li>访问令牌短期有效，刷新令牌长期有效。  </li>\n<li>刷新令牌必须安全存储。  </li>\n<li>支持刷新令牌轮换，降低泄露风险。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1 id=\"5-常见的几种-OAuth-授权方式\"><a href=\"#5-常见的几种-OAuth-授权方式\" class=\"headerlink\" title=\"5. 常见的几种 OAuth 授权方式\"></a>5. 常见的几种 OAuth 授权方式</h1><p>OAuth 有几种“授权模式”，常见的有：</p>\n<ul>\n<li><strong>授权码模式（Authorization Code Flow）</strong>：最安全，常见于 Web 应用。</li>\n<li><strong>隐式模式（Implicit Flow）</strong>：早期为单页应用准备，现在已不推荐。</li>\n<li><strong>客户端模式（Client Credentials Flow）</strong>：适合应用自己和 API 沟通。</li>\n<li><strong>密码模式（Resource Owner Password Flow）</strong>：直接用用户名密码，几乎不用了。</li>\n</ul>\n<hr>\n<h1 id=\"6-OAuth-带来的好处\"><a href=\"#6-OAuth-带来的好处\" class=\"headerlink\" title=\"6. OAuth 带来的好处\"></a>6. OAuth 带来的好处</h1><ol>\n<li>用户不用把密码交给第三方。</li>\n<li>用户可以精确控制权限，比如只给“读取邮箱”，不允许“删除邮件”。</li>\n<li>用户可以随时在 Google 安全中心撤销某个应用的访问。</li>\n<li>网站开发者也不用管理复杂的密码存储问题。</li>\n</ol>\n<hr>\n<h1 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h1><p>OAuth 看起来流程复杂，其实就是一个安全设计：</p>\n<ul>\n<li><strong>别交出钥匙</strong>，只给对方一张 <strong>临时门禁卡</strong>；</li>\n<li><strong>用户可控</strong>，随时撤销权限；</li>\n<li><strong>安全性更高</strong>，即使门禁卡被偷，也只是部分权限，且很快失效。</li>\n</ul>\n<p>下次你在新网站点“用 Google 登录”的时候，就知道为什么它要带你绕一圈了。😉</p>\n<hr>\n<style>\nimg[alt=\"门禁\"] {\n  width: 30%;\n  height: 30%;\n}\n</style>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引子：为什么我登录个网站还要跳到别的地方？\"><a href=\"#引子：为什么我登录个网站还要跳到别的地方？\" class=\"headerlink\" title=\"引子：为什么我登录个网站还要跳到别的地方？\"></a>引子：为什么我登录个网站还要跳到别的地方？</h1><p>想象一下，你在一个新网站上注册时，它说：<br>👉 “你可以用 <strong>Google 账号</strong> 登录哦！”</p>\n<p>结果你点开后，页面一转，跳去了 Google：</p>\n<ul>\n<li>Google 问你：“要不要允许这个网站获取你的邮箱？”</li>\n<li>你点了“允许”，然后才被带回到原来的网站。</li>\n</ul>\n<p>这个过程，看起来绕来绕去，让人一头雾水。为什么不能直接输入邮箱和密码就好了呢？这就是 <strong>OAuth</strong> 出场的原因。</p>\n<hr>\n<h1 id=\"1-问题的根源：密码太危险了\"><a href=\"#1-问题的根源：密码太危险了\" class=\"headerlink\" title=\"1. 问题的根源：密码太危险了\"></a>1. 问题的根源：密码太危险了</h1><p>以前的网站常用的做法是：</p>\n<ul>\n<li>用户把 <strong>账号和密码</strong> 直接给第三方网站。</li>\n<li>这个网站再用这些信息去访问你的资源。</li>\n</ul>\n<p>问题在于：</p>\n<p>在互联网发展早期，许多网站或应用为了获取用户在其他平台上的信息，会要求用户直接提供在其他平台的用户名和密码。这种做法存在明显的安全隐患和不便之处：</p>\n<ul>\n<li><strong>安全风险：</strong> 第三方应用会保存用户密码，增加泄露风险，而且服务提供商也不得不开放密码登录，这本身并不安全。</li>\n<li><strong>权限不可控：</strong> 一旦提供了密码，第三方应用相当于获得了用户在该平台上的完全访问权，用户无法限制其访问范围和有效期。</li>\n<li><strong>撤销不便：</strong> 用户若想收回授权，只能修改密码。这会导致所有已授权的第三方应用全部失效，影响正常使用。</li>\n<li><strong>牵一发而动全身：</strong> 任一第三方应用被攻破，都会导致用户密码泄漏，进而威胁用户在所有平台上的数据安全。</li>\n</ul>\n<p>这就是 <strong>共享密码的风险</strong>。</p>\n<p>正是为了解决上述问题，<strong>OAuth</strong> 应运而生。OAuth 提供了一种安全的授权机制，让用户可以给予第三方应用<strong>有限的访问权限</strong>，而<strong>无需透露账号密码</strong>。这种机制类似于给第三方应用一把“有限权限的钥匙”而非直接交出主钥匙：第三方只能在授权范围和有效期内行使权限，用户也可随时收回授权。</p>\n<h2 id=\"OAuth-的目标就是：✅-不要再把密码交给第三方网站。\"><a href=\"#OAuth-的目标就是：✅-不要再把密码交给第三方网站。\" class=\"headerlink\" title=\"OAuth 的目标就是：✅ 不要再把密码交给第三方网站。\"></a>OAuth 的目标就是：<br>✅ 不要再把密码交给第三方网站。</h2><h1 id=\"2-OAuth-的基本思路：借一把“门禁卡”\"><a href=\"#2-OAuth-的基本思路：借一把“门禁卡”\" class=\"headerlink\" title=\"2. OAuth 的基本思路：借一把“门禁卡”\"></a>2. OAuth 的基本思路：借一把“门禁卡”</h1><p><img src=\"/blog/./images/oauth/door.png\" alt=\"门禁\"></p>\n<p>OAuth 的核心思想就像“门禁卡”：</p>\n<ul>\n<li>你要进某个写字楼的办公室（&#x3D; 访问用户的资源）。</li>\n<li>但是你不能直接拿楼主的钥匙（&#x3D; 密码）。</li>\n<li>楼主（Google）可以给你一张 <strong>临时的门禁卡</strong>（&#x3D; token）。</li>\n<li>门禁卡只能开指定的门（&#x3D; 只允许访问邮箱）。</li>\n<li>卡还可以设置 <strong>有效期</strong>，过期了就无效。</li>\n</ul>\n<p>这样，既保证了安全性，也给了用户更细的控制。</p>\n<hr>\n<h1 id=\"3-OAuth-的核心概念与角色\"><a href=\"#3-OAuth-的核心概念与角色\" class=\"headerlink\" title=\"3. OAuth 的核心概念与角色\"></a>3. OAuth 的核心概念与角色</h1><p>要理解 OAuth 的工作原理，需要认识其中的几个核心角色：</p>\n<ul>\n<li><strong>用户（资源所有者，Resource Owner）：</strong> 拥有受保护资源的终端用户，例如照片、联系人等数据的拥有者。用户通过授权决定第三方应用能否访问其资源。</li>\n<li><strong>客户端（第三方应用，Client）：</strong> 请求访问受保护资源的应用程序。它可以是网站、移动App等。</li>\n<li><strong>授权服务器（Authorization Server）：</strong> 授权服务提供商用于处理认证和授权的服务器。它负责验证用户身份、记录用户授权意愿，并在用户同意后颁发令牌。</li>\n<li><strong>资源服务器（Resource Server）：</strong> 存储用户受保护资源的服务器。资源服务器根据令牌所包含的权限范围向客户端开放相应资源。</li>\n</ul>\n<hr>\n<h1 id=\"4-一次-OAuth-登录的“绕圈之旅”\"><a href=\"#4-一次-OAuth-登录的“绕圈之旅”\" class=\"headerlink\" title=\"4. 一次 OAuth 登录的“绕圈之旅”\"></a>4. 一次 OAuth 登录的“绕圈之旅”</h1><p><img src=\"/blog/./images/oauth/oauth.png\" alt=\"OAuth 登录流程\"></p>\n<p>整个流程大概分 5 步：</p>\n<ol>\n<li><p><strong>客户端请求授权</strong><br>第三方网站跳转你到 Google，问你要不要授权。</p>\n</li>\n<li><p><strong>用户同意授权</strong><br>你点了“允许”。</p>\n</li>\n<li><p><strong>授权服务器发放授权码</strong><br>Google 给了客户端一个“授权码”（一次性、短期）。</p>\n</li>\n<li><p><strong>客户端换取令牌</strong><br>网站用这个授权码去 Google 换取一个 <strong>访问令牌（Access Token）</strong>。</p>\n</li>\n<li><p><strong>使用令牌访问资源</strong><br>网站拿着令牌，就能去请求你的邮箱地址或头像。</p>\n</li>\n</ol>\n<p>👉 整个过程，密码从来没离开 Google，安全性就大大提高了。</p>\n<hr>\n<h1 id=\"OAuth-的实际用途\"><a href=\"#OAuth-的实际用途\" class=\"headerlink\" title=\"OAuth 的实际用途\"></a>OAuth 的实际用途</h1><h2 id=\"1-第三方登录\"><a href=\"#1-第三方登录\" class=\"headerlink\" title=\"1. 第三方登录\"></a>1. 第三方登录</h2><p>例如“使用微信登录”、“Sign in with Google”，让用户无需记住多个密码，应用通过 OAuth 获取有限的用户信息。</p>\n<h2 id=\"2-API-授权\"><a href=\"#2-API-授权\" class=\"headerlink\" title=\"2. API 授权\"></a>2. API 授权</h2><p>用户可以授权第三方应用访问其在另一平台的数据（如 Google 日历、GitHub 仓库）。</p>\n<h2 id=\"3-微服务内部认证\"><a href=\"#3-微服务内部认证\" class=\"headerlink\" title=\"3. 微服务内部认证\"></a>3. 微服务内部认证</h2><p>企业微服务架构中，通过统一认证服务颁发令牌，实现服务间安全通信。</p>\n<hr>\n<h1 id=\"OAuth-与-OpenID-Connect-的关系\"><a href=\"#OAuth-与-OpenID-Connect-的关系\" class=\"headerlink\" title=\"OAuth 与 OpenID Connect 的关系\"></a>OAuth 与 OpenID Connect 的关系</h1><ul>\n<li><strong>OAuth 专注于授权</strong>：解决“应用能不能访问我的数据”的问题。</li>\n<li><strong>OIDC 专注于认证</strong>：解决“你是谁”的问题。</li>\n<li>OIDC 在 OAuth 基础上增加了 <strong>ID Token</strong>（通常是 JWT），用于传递用户身份信息，实现单点登录。</li>\n</ul>\n<hr>\n<h1 id=\"常见误区与最佳实践\"><a href=\"#常见误区与最佳实践\" class=\"headerlink\" title=\"常见误区与最佳实践\"></a>常见误区与最佳实践</h1><ol>\n<li><p><strong>令牌安全</strong>  </p>\n<ul>\n<li>始终使用 HTTPS 传输令牌。  </li>\n<li>令牌有效期应尽可能短。  </li>\n<li>不要在 URL 参数中传递令牌。</li>\n</ul>\n</li>\n<li><p><strong>作用域管理</strong>  </p>\n<ul>\n<li>遵循最小权限原则。  </li>\n<li>按需请求权限，避免一次性请求过多权限。</li>\n</ul>\n</li>\n<li><p><strong>刷新令牌机制</strong>  </p>\n<ul>\n<li>访问令牌短期有效，刷新令牌长期有效。  </li>\n<li>刷新令牌必须安全存储。  </li>\n<li>支持刷新令牌轮换，降低泄露风险。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1 id=\"5-常见的几种-OAuth-授权方式\"><a href=\"#5-常见的几种-OAuth-授权方式\" class=\"headerlink\" title=\"5. 常见的几种 OAuth 授权方式\"></a>5. 常见的几种 OAuth 授权方式</h1><p>OAuth 有几种“授权模式”，常见的有：</p>\n<ul>\n<li><strong>授权码模式（Authorization Code Flow）</strong>：最安全，常见于 Web 应用。</li>\n<li><strong>隐式模式（Implicit Flow）</strong>：早期为单页应用准备，现在已不推荐。</li>\n<li><strong>客户端模式（Client Credentials Flow）</strong>：适合应用自己和 API 沟通。</li>\n<li><strong>密码模式（Resource Owner Password Flow）</strong>：直接用用户名密码，几乎不用了。</li>\n</ul>\n<hr>\n<h1 id=\"6-OAuth-带来的好处\"><a href=\"#6-OAuth-带来的好处\" class=\"headerlink\" title=\"6. OAuth 带来的好处\"></a>6. OAuth 带来的好处</h1><ol>\n<li>用户不用把密码交给第三方。</li>\n<li>用户可以精确控制权限，比如只给“读取邮箱”，不允许“删除邮件”。</li>\n<li>用户可以随时在 Google 安全中心撤销某个应用的访问。</li>\n<li>网站开发者也不用管理复杂的密码存储问题。</li>\n</ol>\n<hr>\n<h1 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h1><p>OAuth 看起来流程复杂，其实就是一个安全设计：</p>\n<ul>\n<li><strong>别交出钥匙</strong>，只给对方一张 <strong>临时门禁卡</strong>；</li>\n<li><strong>用户可控</strong>，随时撤销权限；</li>\n<li><strong>安全性更高</strong>，即使门禁卡被偷，也只是部分权限，且很快失效。</li>\n</ul>\n<p>下次你在新网站点“用 Google 登录”的时候，就知道为什么它要带你绕一圈了。😉</p>\n<hr>\n<style>\nimg[alt=\"门禁\"] {\n  width: 30%;\n  height: 30%;\n}\n</style>"},{"title":"GEO 入门：从 SEO 到 GEO 的转变","date":"2025-09-11T01:13:32.000Z","_content":"\n![bg](./images/geo/bg.png)\n\n# 前言\n\n随着 ChatGPT、Bard、Claude 等生成式 AI 工具的普及，我们正步入**生成式引擎优化（GEO）**的新时代。在这个 AI 主导的信息检索时代，用户习惯于直接向 AI 提问而非搜索引擎获取答案。这意味着内容创作者和营销人员必须重新思考如何让自己的内容**被看见、被引用、被推荐**。GEO 并非传统 SEO 的简单延伸，而是一种全新的内容优化思维：要求我们以更自然、权威且结构清晰的方式创作内容，以确保在 AI 模型训练和回答生成过程中脱颖而出。\n\n当前，AI 驱动的搜索流量呈爆发式增长：ChatGPT 月活跃用户已超 1.8 亿，AI 搜索引擎 Perplexity 的使用量同比激增 858%，达到千万级。有预测显示，到 2028 年 AI 搜索将占据约14%的搜索市场份额。面对这股趋势，**如果品牌内容无法被 AI 模型“看见”，就仿佛从搜索结果中消失**。因此，我们亟需掌握 GEO 策略，让企业知识成为 AI 的“优先记忆”，实现在 AI 答案中的**无点击曝光**。\n\n本文将深入阐述 GEO 的定义和现状，比较 SEO 与 GEO 的联系区别，并提供面向 SEO 从业者和技术写作者的实用优化策略和案例，帮助大家在生成式引擎优化时代保持竞争优势。\n\n---\n\n# GEO 的定义、发展背景与现状\n\n**什么是 GEO？**  \n\nGEO（Generative Engine Optimization，生成式引擎优化）是一种专为**AI 驱动的生成式搜索引擎**量身打造的内容优化策略。其核心目标是在 AI 模型生成回答时，让您的网站内容**更频繁、更优先地被引用或推荐**。简单来说，GEO 关注的不是网页在搜索结果中的排名高低，而是当用户向 AI 提问时，**AI 会主动引用您的品牌内容作为答案来源**。\n\n**发展背景：**  \n\n传统 SEO（搜索引擎优化）诞生于上世纪 90 年代末，此后经历了关键词堆砌、内容为王、用户体验优先等阶段的演进。而近年来，大型语言模型（LLM）的崛起改变了信息获取模式——用户不再满足于点击多个网页寻找答案，而是希望由 AI 直接给出**精确且个性化的解答**。这种行为转变催生了 GEO 这一新概念，它可被视为 SEO 在 AI 时代的延续和升级。\n\n**现状：**  \n\n目前市面上涌现出多种生成式 AI 引擎，例如 OpenAI 的 ChatGPT、Anthropic 的 Claude、Microsoft Bing Chat（集成 GPT-4 模型）、Google 即将推出的 Gemini，以及主打实时引用的 Perplexity AI 等。这些工具在用户查询时往往直接给出融合了多个来源的信息答案。例如，Perplexity AI 会实时搜索互联网并**引用网页链接**来回答用户问题；微软新版必应（Bing Chat）每句话后都会标注来源，用户悬停引用即可看到完整链接。甚至 ChatGPT 本身在引入联网搜索功能后，也开始在回答中附上来源链接，方便用户了解 AI 输出背后的依据。可以说，**搜索引擎正在从“链接列表”演变为“整合答案”**，而 GEO 正是帮助内容适应这一演变的关键策略。\n\n---\n\n# SEO 与 GEO：区别与联系\n\nGEO 与传统 SEO 密切相关又有所不同。两者的共同点在于：**没有良好的 SEO 基础，GEO 无从谈起**。因为如果网页不能被爬取和索引，AI **根本无法检索或引用你的内容**。实际上，AI 型搜索依然依赖搜索引擎抓取海量网页作为候选资料，因此**GEO 以 SEO 为前提**。正如公式所示：**GEO = SEO + RAG**（检索增强生成）。第一步要通过传统 SEO 让搜索引擎“找到你”，第二步再通过内容优化让 AI 在生成答案时“选中你”。\n\n尽管联系紧密，GEO 与 SEO 的目标和策略仍存在显著区别。下面将两者核心差异进行对比：\n\n| 对比维度   | 传统 SEO 优化目标                     | GEO 优化目标                         |\n| ---------- | -------------------------------------- | ------------------------------------ |\n| **优化目标** | 提升网站在搜索引擎结果页的排名        | 让企业信息在 AI 生成的答案中优先出现 |\n| **关注重点** | 关键词匹配、外部链接数量等技术指标    | 语义理解、内容权威性和结构化数据     |\n| **用户交互** | 用户点击搜索结果进入网站获取信息      | AI 直接在回答中呈现品牌内容，无需点击 |\n| **技术手段** | 关键词布局、链接建设等传统手段        | 语义优化、权威内容构建、结构化数据标注 |\n\n![对比](./images/geo/SEO-GEO.png)\n\n可以看出，**SEO 更关注被搜索引擎“看到”，GEO 则关注被 AI “说到”**。SEO追求的是排名和点击流量，而GEO追求的是**内容在AI答案中的出现频率和权威性**。这导致评价标准的变化：SEO 看重流量、点击率；GEO 则关注 AI 对内容的引用次数、品牌在对话中的被提及率等新指标。\n\n---\n\n# 生成式 AI 引擎如何“引用”网络内容\n\n生成式 AI 引擎（如 ChatGPT、Perplexity、Claude、Gemini 等）的工作方式一般包括两个阶段：\n\n1. **信息检索阶段**  \n   当用户提出问题时，AI 系统会先从互联网或自身知识库中**搜索相关内容**。例如，Bing Chat 背后依托必应搜索；ChatGPT 的浏览模式调用的是 Bing 的结果；Perplexity 则有自建的搜索索引来实时查询网页。\n\n2. **内容生成阶段**  \n   AI 模型读取检索到的内容，将其中的关键信息**综合、重组并生成**答案。为提高可信度，不少 AI 引擎会在回答中附上来源引用。例如，新版必应在回答每句话后添加脚注，标明信息来源；Perplexity 明确展示相关网页链接；ChatGPT 在联网模式下也会附上引用链接。\n\n从技术角度看，大部分生成式AI搜索采用了 **RAG（Retrieval-Augmented Generation，检索增强生成）** 架构。即：模型先检索文档，再将结果与用户问题一起输入大模型生成答案。这样可以避免模型胡乱编造，提高答案的实时性和准确性。\n\n因此，GEO 的任务，就是让您的内容**既能进入 AI 的视野（被检索到），又能顺利融入它的回答（被引用）**。\n\n---\n\n# GEO 实践策略：让内容更适合 AI 引擎\n\n## 1. 内容结构优化\n1. 使用清晰的标题层级（H1-H3）\n   这种清晰且富有逻辑的 Heading 标签结构有助于 AI 理解内容组织\n2. 利用列表、表格展示要点\n   使用列表、表格等形式展示要点，使信息更加一目了然\n3. 在开头给出结论或定义，在结尾做总结\n   良好的内容结构不仅提升用户阅读体验，也方便 AI 抓取和提炼重点。\n\n例如：\n```markdown\n# TCP 与 QUIC 的区别（结论：QUIC 更适合现代网络）\n\n# TCP 的特点\n- 面向连接，依赖三次握手\n- 容易出现队头阻塞\n- 缺乏原生加密\n\n# QUIC 的特点\n- 基于 UDP，减少握手延迟\n- 支持多路复用，解决队头阻塞\n- 内置加密，更适合移动端\n\n# 对比总结\n| 协议 | 建立连接 | 队头阻塞 | 移动端支持 |\n| ---- | -------- | -------- | ---------- |\n| TCP  | 三次握手 | 存在     | 较差       |\n| QUIC | 0-RTT   | 已解决   | 较好       |\n\n# 总结\nQUIC 在延迟、安全性和移动性上更优，是未来互联网传输的趋势。\n``` \n👉 开头给出结论，分点介绍，再用表格总结，最后收尾。结构清晰，AI 易于抓取要点。\n\n## 2. FAQ 式写作风格\n采用问答形式组织内容，例如：\n\n```markdown\n# 常见问题（FAQ）\n\nQ: TCP 和 QUIC 的最大区别是什么？  \nA: TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。  \n\nQ: QUIC 为什么能避免队头阻塞？  \nA: QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。  \n\nQ: QUIC 更适合哪些场景？  \nA: 移动网络、视频流媒体和在线游戏，因为它支持连接迁移和更低延迟。\n\n```\n\n这种 “开门见山” 的回答方式非常契合 AI 摘取信息的逻辑，可显著提高内容被AI选中的机会。此外，配合使用 FAQPage 模式的 Schema 标记，向搜索引擎和AI明确标识问答对的结构，效果更佳。\n\n## 3. 结构化数据与 Schema 标注\n利用结构化数据（Structured Data）向搜索引擎和AI提供内容的机器可读语义信息。例如，在网页中嵌入 JSON-LD Schema，例如 FAQPage、HowTo、Article 等，帮助 AI 更好识别网页信息。\n\n```markdown\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"TCP 和 QUIC 的最大区别是什么？\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"QUIC 为什么能避免队头阻塞？\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。\"\n      }\n    }\n  ]\n}\n</script>\n```\n\n## 4. 内容更新与时效性\n定期更新文章（年份、数据、案例），保持内容新鲜度。\n👉 通过更新年份和应用场景，让 AI 更倾向引用你的页面，而不是引用过时资料。\n\n## 5. 引用引导（外链与锚点优化）\n- 获取权威网站的反向链接\n- 在文章中合理使用内部链接与锚点\n- 在内容中主动注明出处与数据来源\n\n```markdown\n根据 [IETF QUIC 标准草案](https://datatracker.ietf.org/doc/html/rfc9000)，\nQUIC 在传输层引入了多路复用和 0-RTT 握手设计。\n```\n👉 外链提升权威性，内部锚点建立知识网络，AI 在引用时更容易“选中你”的文章。\n\n---\n\n# LLM.txt：AI 时代的 robots.txt\n\n在 SEO 时代，**robots.txt** 控制爬虫抓取范围；在 GEO 时代，出现了新尝试：**LLM.txt**。\n\n## 什么是 LLM.txt？\n\nLLM.txt 是一种新兴规范，旨在让网站管理员决定 **AI 模型是否、以及如何使用网站内容**。它相当于 AI 版的 robots.txt。\n\n## 功能示例\n\n```txt\n# 允许 AI 模型引用博客内容\nAllow: /blog/\n\n# 禁止使用内部资料\nDisallow: /internal/\n\n# 要求引用时必须加来源\nAttribution: required\n```\n\n---\n\n# GEO 与 RAG 结合：技术写作者与企业内容开发者的对策\n\n1. **构建专属的 RAG 知识库**  \n   将文档存入向量数据库，结合 Embedding + GPT 接口，打造企业专属聊天机器人。\n\n2. **开放接口和插件**  \n   开发 ChatGPT 插件或开放 API，让 AI 工具直接访问你的知识库。\n\n3. **主动融入大模型训练集**  \n   将高质量数据集开放给 AI 训练社区，提高在模型中的“内置引用”概率。\n\n4. **利用 OpenAI API 进行内容测试**  \n   使用 GPT-4 模拟用户提问，测试 AI 是否会引用你的文章，迭代优化。\n\n---\n\n# 未来畅想：搜索的下一个十年\n\n随着生成式 AI 的快速演进，我们正处于搜索方式彻底重构的前夜。\n\n## 1. 搜索的未来形态\n\n未来的搜索，可能不再是“输入关键词 → 点击链接 → 获取答案”，而是更接近 **个性化顾问** 的模式：\n\n* 用户用自然语言直接提问，AI 会结合 **实时互联网 + 私有知识库** 给出答案；\n* 搜索不再是“十个蓝色链接”，而是一个 **对话持续、动态追问** 的过程；\n* 每个人看到的结果都高度定制化，甚至同一问题，不同用户会得到完全不同的回答。\n\n## 2. 对服务厂商的挑战\n\n这对现有面向 C 端用户的厂商提出了前所未有的挑战：\n\n* **流量入口被重构**：传统的 SEO 流量红利逐渐消失，品牌如何在 AI 对话中被“提及”，成为新的生存问题。\n* **商业模式变化**：广告和推荐位如何融入 AI 答案？如果用户停留在对话界面，厂商可能失去流量分发的主导权。\n* **技术适配成本**：企业需要维护开放 API、RAG 知识库、LLM.txt 等基础设施，才能被 AI 平台持续“看见”。\n\n## 3. 对用户的变化\n\n用户的体验也会发生质变：\n\n* **更少点击**：未来用户可能很少需要打开多个网页比对答案，AI 会直接给出最优解释。\n* **更强信任**：如果 AI 能提供透明引用和解释链路，用户会把它当作“第一问答入口”。\n* **更多个性化**：AI 会结合用户的历史行为、上下文语境，给出高度定制化的答案，这会让信息检索更高效。\n\n---\n\n📌 **总结畅想**\n未来的搜索可能会变成 **“AI 伴随式信息获取”**：\n\n* 用户只需要提出问题，AI 就会主动结合公开知识和私有上下文，给出答案和下一步建议；\n* 品牌和内容提供者必须思考如何在这种对话里 **被引用、被信任、被推荐**；\n* 对用户来说，信息更快、更准，但也带来“答案是否被 AI 垄断”的新挑战。\n\n可以说，SEO 到 GEO 的转变只是开始。真正的挑战，是当搜索彻底对话化、场景化之后，**我们该如何让内容和品牌继续被用户看见**。\n","source":"_posts/GEO.md","raw":"---\ntitle: GEO 入门：从 SEO 到 GEO 的转变\ndate: 2025-09-11 09:13:32\ntags:\n---\n\n![bg](./images/geo/bg.png)\n\n# 前言\n\n随着 ChatGPT、Bard、Claude 等生成式 AI 工具的普及，我们正步入**生成式引擎优化（GEO）**的新时代。在这个 AI 主导的信息检索时代，用户习惯于直接向 AI 提问而非搜索引擎获取答案。这意味着内容创作者和营销人员必须重新思考如何让自己的内容**被看见、被引用、被推荐**。GEO 并非传统 SEO 的简单延伸，而是一种全新的内容优化思维：要求我们以更自然、权威且结构清晰的方式创作内容，以确保在 AI 模型训练和回答生成过程中脱颖而出。\n\n当前，AI 驱动的搜索流量呈爆发式增长：ChatGPT 月活跃用户已超 1.8 亿，AI 搜索引擎 Perplexity 的使用量同比激增 858%，达到千万级。有预测显示，到 2028 年 AI 搜索将占据约14%的搜索市场份额。面对这股趋势，**如果品牌内容无法被 AI 模型“看见”，就仿佛从搜索结果中消失**。因此，我们亟需掌握 GEO 策略，让企业知识成为 AI 的“优先记忆”，实现在 AI 答案中的**无点击曝光**。\n\n本文将深入阐述 GEO 的定义和现状，比较 SEO 与 GEO 的联系区别，并提供面向 SEO 从业者和技术写作者的实用优化策略和案例，帮助大家在生成式引擎优化时代保持竞争优势。\n\n---\n\n# GEO 的定义、发展背景与现状\n\n**什么是 GEO？**  \n\nGEO（Generative Engine Optimization，生成式引擎优化）是一种专为**AI 驱动的生成式搜索引擎**量身打造的内容优化策略。其核心目标是在 AI 模型生成回答时，让您的网站内容**更频繁、更优先地被引用或推荐**。简单来说，GEO 关注的不是网页在搜索结果中的排名高低，而是当用户向 AI 提问时，**AI 会主动引用您的品牌内容作为答案来源**。\n\n**发展背景：**  \n\n传统 SEO（搜索引擎优化）诞生于上世纪 90 年代末，此后经历了关键词堆砌、内容为王、用户体验优先等阶段的演进。而近年来，大型语言模型（LLM）的崛起改变了信息获取模式——用户不再满足于点击多个网页寻找答案，而是希望由 AI 直接给出**精确且个性化的解答**。这种行为转变催生了 GEO 这一新概念，它可被视为 SEO 在 AI 时代的延续和升级。\n\n**现状：**  \n\n目前市面上涌现出多种生成式 AI 引擎，例如 OpenAI 的 ChatGPT、Anthropic 的 Claude、Microsoft Bing Chat（集成 GPT-4 模型）、Google 即将推出的 Gemini，以及主打实时引用的 Perplexity AI 等。这些工具在用户查询时往往直接给出融合了多个来源的信息答案。例如，Perplexity AI 会实时搜索互联网并**引用网页链接**来回答用户问题；微软新版必应（Bing Chat）每句话后都会标注来源，用户悬停引用即可看到完整链接。甚至 ChatGPT 本身在引入联网搜索功能后，也开始在回答中附上来源链接，方便用户了解 AI 输出背后的依据。可以说，**搜索引擎正在从“链接列表”演变为“整合答案”**，而 GEO 正是帮助内容适应这一演变的关键策略。\n\n---\n\n# SEO 与 GEO：区别与联系\n\nGEO 与传统 SEO 密切相关又有所不同。两者的共同点在于：**没有良好的 SEO 基础，GEO 无从谈起**。因为如果网页不能被爬取和索引，AI **根本无法检索或引用你的内容**。实际上，AI 型搜索依然依赖搜索引擎抓取海量网页作为候选资料，因此**GEO 以 SEO 为前提**。正如公式所示：**GEO = SEO + RAG**（检索增强生成）。第一步要通过传统 SEO 让搜索引擎“找到你”，第二步再通过内容优化让 AI 在生成答案时“选中你”。\n\n尽管联系紧密，GEO 与 SEO 的目标和策略仍存在显著区别。下面将两者核心差异进行对比：\n\n| 对比维度   | 传统 SEO 优化目标                     | GEO 优化目标                         |\n| ---------- | -------------------------------------- | ------------------------------------ |\n| **优化目标** | 提升网站在搜索引擎结果页的排名        | 让企业信息在 AI 生成的答案中优先出现 |\n| **关注重点** | 关键词匹配、外部链接数量等技术指标    | 语义理解、内容权威性和结构化数据     |\n| **用户交互** | 用户点击搜索结果进入网站获取信息      | AI 直接在回答中呈现品牌内容，无需点击 |\n| **技术手段** | 关键词布局、链接建设等传统手段        | 语义优化、权威内容构建、结构化数据标注 |\n\n![对比](./images/geo/SEO-GEO.png)\n\n可以看出，**SEO 更关注被搜索引擎“看到”，GEO 则关注被 AI “说到”**。SEO追求的是排名和点击流量，而GEO追求的是**内容在AI答案中的出现频率和权威性**。这导致评价标准的变化：SEO 看重流量、点击率；GEO 则关注 AI 对内容的引用次数、品牌在对话中的被提及率等新指标。\n\n---\n\n# 生成式 AI 引擎如何“引用”网络内容\n\n生成式 AI 引擎（如 ChatGPT、Perplexity、Claude、Gemini 等）的工作方式一般包括两个阶段：\n\n1. **信息检索阶段**  \n   当用户提出问题时，AI 系统会先从互联网或自身知识库中**搜索相关内容**。例如，Bing Chat 背后依托必应搜索；ChatGPT 的浏览模式调用的是 Bing 的结果；Perplexity 则有自建的搜索索引来实时查询网页。\n\n2. **内容生成阶段**  \n   AI 模型读取检索到的内容，将其中的关键信息**综合、重组并生成**答案。为提高可信度，不少 AI 引擎会在回答中附上来源引用。例如，新版必应在回答每句话后添加脚注，标明信息来源；Perplexity 明确展示相关网页链接；ChatGPT 在联网模式下也会附上引用链接。\n\n从技术角度看，大部分生成式AI搜索采用了 **RAG（Retrieval-Augmented Generation，检索增强生成）** 架构。即：模型先检索文档，再将结果与用户问题一起输入大模型生成答案。这样可以避免模型胡乱编造，提高答案的实时性和准确性。\n\n因此，GEO 的任务，就是让您的内容**既能进入 AI 的视野（被检索到），又能顺利融入它的回答（被引用）**。\n\n---\n\n# GEO 实践策略：让内容更适合 AI 引擎\n\n## 1. 内容结构优化\n1. 使用清晰的标题层级（H1-H3）\n   这种清晰且富有逻辑的 Heading 标签结构有助于 AI 理解内容组织\n2. 利用列表、表格展示要点\n   使用列表、表格等形式展示要点，使信息更加一目了然\n3. 在开头给出结论或定义，在结尾做总结\n   良好的内容结构不仅提升用户阅读体验，也方便 AI 抓取和提炼重点。\n\n例如：\n```markdown\n# TCP 与 QUIC 的区别（结论：QUIC 更适合现代网络）\n\n# TCP 的特点\n- 面向连接，依赖三次握手\n- 容易出现队头阻塞\n- 缺乏原生加密\n\n# QUIC 的特点\n- 基于 UDP，减少握手延迟\n- 支持多路复用，解决队头阻塞\n- 内置加密，更适合移动端\n\n# 对比总结\n| 协议 | 建立连接 | 队头阻塞 | 移动端支持 |\n| ---- | -------- | -------- | ---------- |\n| TCP  | 三次握手 | 存在     | 较差       |\n| QUIC | 0-RTT   | 已解决   | 较好       |\n\n# 总结\nQUIC 在延迟、安全性和移动性上更优，是未来互联网传输的趋势。\n``` \n👉 开头给出结论，分点介绍，再用表格总结，最后收尾。结构清晰，AI 易于抓取要点。\n\n## 2. FAQ 式写作风格\n采用问答形式组织内容，例如：\n\n```markdown\n# 常见问题（FAQ）\n\nQ: TCP 和 QUIC 的最大区别是什么？  \nA: TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。  \n\nQ: QUIC 为什么能避免队头阻塞？  \nA: QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。  \n\nQ: QUIC 更适合哪些场景？  \nA: 移动网络、视频流媒体和在线游戏，因为它支持连接迁移和更低延迟。\n\n```\n\n这种 “开门见山” 的回答方式非常契合 AI 摘取信息的逻辑，可显著提高内容被AI选中的机会。此外，配合使用 FAQPage 模式的 Schema 标记，向搜索引擎和AI明确标识问答对的结构，效果更佳。\n\n## 3. 结构化数据与 Schema 标注\n利用结构化数据（Structured Data）向搜索引擎和AI提供内容的机器可读语义信息。例如，在网页中嵌入 JSON-LD Schema，例如 FAQPage、HowTo、Article 等，帮助 AI 更好识别网页信息。\n\n```markdown\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"FAQPage\",\n  \"mainEntity\": [\n    {\n      \"@type\": \"Question\",\n      \"name\": \"TCP 和 QUIC 的最大区别是什么？\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。\"\n      }\n    },\n    {\n      \"@type\": \"Question\",\n      \"name\": \"QUIC 为什么能避免队头阻塞？\",\n      \"acceptedAnswer\": {\n        \"@type\": \"Answer\",\n        \"text\": \"QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。\"\n      }\n    }\n  ]\n}\n</script>\n```\n\n## 4. 内容更新与时效性\n定期更新文章（年份、数据、案例），保持内容新鲜度。\n👉 通过更新年份和应用场景，让 AI 更倾向引用你的页面，而不是引用过时资料。\n\n## 5. 引用引导（外链与锚点优化）\n- 获取权威网站的反向链接\n- 在文章中合理使用内部链接与锚点\n- 在内容中主动注明出处与数据来源\n\n```markdown\n根据 [IETF QUIC 标准草案](https://datatracker.ietf.org/doc/html/rfc9000)，\nQUIC 在传输层引入了多路复用和 0-RTT 握手设计。\n```\n👉 外链提升权威性，内部锚点建立知识网络，AI 在引用时更容易“选中你”的文章。\n\n---\n\n# LLM.txt：AI 时代的 robots.txt\n\n在 SEO 时代，**robots.txt** 控制爬虫抓取范围；在 GEO 时代，出现了新尝试：**LLM.txt**。\n\n## 什么是 LLM.txt？\n\nLLM.txt 是一种新兴规范，旨在让网站管理员决定 **AI 模型是否、以及如何使用网站内容**。它相当于 AI 版的 robots.txt。\n\n## 功能示例\n\n```txt\n# 允许 AI 模型引用博客内容\nAllow: /blog/\n\n# 禁止使用内部资料\nDisallow: /internal/\n\n# 要求引用时必须加来源\nAttribution: required\n```\n\n---\n\n# GEO 与 RAG 结合：技术写作者与企业内容开发者的对策\n\n1. **构建专属的 RAG 知识库**  \n   将文档存入向量数据库，结合 Embedding + GPT 接口，打造企业专属聊天机器人。\n\n2. **开放接口和插件**  \n   开发 ChatGPT 插件或开放 API，让 AI 工具直接访问你的知识库。\n\n3. **主动融入大模型训练集**  \n   将高质量数据集开放给 AI 训练社区，提高在模型中的“内置引用”概率。\n\n4. **利用 OpenAI API 进行内容测试**  \n   使用 GPT-4 模拟用户提问，测试 AI 是否会引用你的文章，迭代优化。\n\n---\n\n# 未来畅想：搜索的下一个十年\n\n随着生成式 AI 的快速演进，我们正处于搜索方式彻底重构的前夜。\n\n## 1. 搜索的未来形态\n\n未来的搜索，可能不再是“输入关键词 → 点击链接 → 获取答案”，而是更接近 **个性化顾问** 的模式：\n\n* 用户用自然语言直接提问，AI 会结合 **实时互联网 + 私有知识库** 给出答案；\n* 搜索不再是“十个蓝色链接”，而是一个 **对话持续、动态追问** 的过程；\n* 每个人看到的结果都高度定制化，甚至同一问题，不同用户会得到完全不同的回答。\n\n## 2. 对服务厂商的挑战\n\n这对现有面向 C 端用户的厂商提出了前所未有的挑战：\n\n* **流量入口被重构**：传统的 SEO 流量红利逐渐消失，品牌如何在 AI 对话中被“提及”，成为新的生存问题。\n* **商业模式变化**：广告和推荐位如何融入 AI 答案？如果用户停留在对话界面，厂商可能失去流量分发的主导权。\n* **技术适配成本**：企业需要维护开放 API、RAG 知识库、LLM.txt 等基础设施，才能被 AI 平台持续“看见”。\n\n## 3. 对用户的变化\n\n用户的体验也会发生质变：\n\n* **更少点击**：未来用户可能很少需要打开多个网页比对答案，AI 会直接给出最优解释。\n* **更强信任**：如果 AI 能提供透明引用和解释链路，用户会把它当作“第一问答入口”。\n* **更多个性化**：AI 会结合用户的历史行为、上下文语境，给出高度定制化的答案，这会让信息检索更高效。\n\n---\n\n📌 **总结畅想**\n未来的搜索可能会变成 **“AI 伴随式信息获取”**：\n\n* 用户只需要提出问题，AI 就会主动结合公开知识和私有上下文，给出答案和下一步建议；\n* 品牌和内容提供者必须思考如何在这种对话里 **被引用、被信任、被推荐**；\n* 对用户来说，信息更快、更准，但也带来“答案是否被 AI 垄断”的新挑战。\n\n可以说，SEO 到 GEO 的转变只是开始。真正的挑战，是当搜索彻底对话化、场景化之后，**我们该如何让内容和品牌继续被用户看见**。\n","slug":"GEO","published":1,"updated":"2025-09-12T07:23:31.300Z","_id":"cmfgafy8z000020p1hua22ysb","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/blog/./images/geo/bg.png\" alt=\"bg\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>随着 ChatGPT、Bard、Claude 等生成式 AI 工具的普及，我们正步入<strong>生成式引擎优化（GEO）</strong>的新时代。在这个 AI 主导的信息检索时代，用户习惯于直接向 AI 提问而非搜索引擎获取答案。这意味着内容创作者和营销人员必须重新思考如何让自己的内容<strong>被看见、被引用、被推荐</strong>。GEO 并非传统 SEO 的简单延伸，而是一种全新的内容优化思维：要求我们以更自然、权威且结构清晰的方式创作内容，以确保在 AI 模型训练和回答生成过程中脱颖而出。</p>\n<p>当前，AI 驱动的搜索流量呈爆发式增长：ChatGPT 月活跃用户已超 1.8 亿，AI 搜索引擎 Perplexity 的使用量同比激增 858%，达到千万级。有预测显示，到 2028 年 AI 搜索将占据约14%的搜索市场份额。面对这股趋势，<strong>如果品牌内容无法被 AI 模型“看见”，就仿佛从搜索结果中消失</strong>。因此，我们亟需掌握 GEO 策略，让企业知识成为 AI 的“优先记忆”，实现在 AI 答案中的<strong>无点击曝光</strong>。</p>\n<p>本文将深入阐述 GEO 的定义和现状，比较 SEO 与 GEO 的联系区别，并提供面向 SEO 从业者和技术写作者的实用优化策略和案例，帮助大家在生成式引擎优化时代保持竞争优势。</p>\n<hr>\n<h1 id=\"GEO-的定义、发展背景与现状\"><a href=\"#GEO-的定义、发展背景与现状\" class=\"headerlink\" title=\"GEO 的定义、发展背景与现状\"></a>GEO 的定义、发展背景与现状</h1><p><strong>什么是 GEO？</strong>  </p>\n<p>GEO（Generative Engine Optimization，生成式引擎优化）是一种专为<strong>AI 驱动的生成式搜索引擎</strong>量身打造的内容优化策略。其核心目标是在 AI 模型生成回答时，让您的网站内容<strong>更频繁、更优先地被引用或推荐</strong>。简单来说，GEO 关注的不是网页在搜索结果中的排名高低，而是当用户向 AI 提问时，<strong>AI 会主动引用您的品牌内容作为答案来源</strong>。</p>\n<p><strong>发展背景：</strong>  </p>\n<p>传统 SEO（搜索引擎优化）诞生于上世纪 90 年代末，此后经历了关键词堆砌、内容为王、用户体验优先等阶段的演进。而近年来，大型语言模型（LLM）的崛起改变了信息获取模式——用户不再满足于点击多个网页寻找答案，而是希望由 AI 直接给出<strong>精确且个性化的解答</strong>。这种行为转变催生了 GEO 这一新概念，它可被视为 SEO 在 AI 时代的延续和升级。</p>\n<p><strong>现状：</strong>  </p>\n<p>目前市面上涌现出多种生成式 AI 引擎，例如 OpenAI 的 ChatGPT、Anthropic 的 Claude、Microsoft Bing Chat（集成 GPT-4 模型）、Google 即将推出的 Gemini，以及主打实时引用的 Perplexity AI 等。这些工具在用户查询时往往直接给出融合了多个来源的信息答案。例如，Perplexity AI 会实时搜索互联网并<strong>引用网页链接</strong>来回答用户问题；微软新版必应（Bing Chat）每句话后都会标注来源，用户悬停引用即可看到完整链接。甚至 ChatGPT 本身在引入联网搜索功能后，也开始在回答中附上来源链接，方便用户了解 AI 输出背后的依据。可以说，<strong>搜索引擎正在从“链接列表”演变为“整合答案”</strong>，而 GEO 正是帮助内容适应这一演变的关键策略。</p>\n<hr>\n<h1 id=\"SEO-与-GEO：区别与联系\"><a href=\"#SEO-与-GEO：区别与联系\" class=\"headerlink\" title=\"SEO 与 GEO：区别与联系\"></a>SEO 与 GEO：区别与联系</h1><p>GEO 与传统 SEO 密切相关又有所不同。两者的共同点在于：<strong>没有良好的 SEO 基础，GEO 无从谈起</strong>。因为如果网页不能被爬取和索引，AI <strong>根本无法检索或引用你的内容</strong>。实际上，AI 型搜索依然依赖搜索引擎抓取海量网页作为候选资料，因此<strong>GEO 以 SEO 为前提</strong>。正如公式所示：<strong>GEO &#x3D; SEO + RAG</strong>（检索增强生成）。第一步要通过传统 SEO 让搜索引擎“找到你”，第二步再通过内容优化让 AI 在生成答案时“选中你”。</p>\n<p>尽管联系紧密，GEO 与 SEO 的目标和策略仍存在显著区别。下面将两者核心差异进行对比：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>传统 SEO 优化目标</th>\n<th>GEO 优化目标</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>优化目标</strong></td>\n<td>提升网站在搜索引擎结果页的排名</td>\n<td>让企业信息在 AI 生成的答案中优先出现</td>\n</tr>\n<tr>\n<td><strong>关注重点</strong></td>\n<td>关键词匹配、外部链接数量等技术指标</td>\n<td>语义理解、内容权威性和结构化数据</td>\n</tr>\n<tr>\n<td><strong>用户交互</strong></td>\n<td>用户点击搜索结果进入网站获取信息</td>\n<td>AI 直接在回答中呈现品牌内容，无需点击</td>\n</tr>\n<tr>\n<td><strong>技术手段</strong></td>\n<td>关键词布局、链接建设等传统手段</td>\n<td>语义优化、权威内容构建、结构化数据标注</td>\n</tr>\n</tbody></table>\n<p><img src=\"/blog/./images/geo/SEO-GEO.png\" alt=\"对比\"></p>\n<p>可以看出，<strong>SEO 更关注被搜索引擎“看到”，GEO 则关注被 AI “说到”</strong>。SEO追求的是排名和点击流量，而GEO追求的是<strong>内容在AI答案中的出现频率和权威性</strong>。这导致评价标准的变化：SEO 看重流量、点击率；GEO 则关注 AI 对内容的引用次数、品牌在对话中的被提及率等新指标。</p>\n<hr>\n<h1 id=\"生成式-AI-引擎如何“引用”网络内容\"><a href=\"#生成式-AI-引擎如何“引用”网络内容\" class=\"headerlink\" title=\"生成式 AI 引擎如何“引用”网络内容\"></a>生成式 AI 引擎如何“引用”网络内容</h1><p>生成式 AI 引擎（如 ChatGPT、Perplexity、Claude、Gemini 等）的工作方式一般包括两个阶段：</p>\n<ol>\n<li><p><strong>信息检索阶段</strong><br>当用户提出问题时，AI 系统会先从互联网或自身知识库中<strong>搜索相关内容</strong>。例如，Bing Chat 背后依托必应搜索；ChatGPT 的浏览模式调用的是 Bing 的结果；Perplexity 则有自建的搜索索引来实时查询网页。</p>\n</li>\n<li><p><strong>内容生成阶段</strong><br>AI 模型读取检索到的内容，将其中的关键信息<strong>综合、重组并生成</strong>答案。为提高可信度，不少 AI 引擎会在回答中附上来源引用。例如，新版必应在回答每句话后添加脚注，标明信息来源；Perplexity 明确展示相关网页链接；ChatGPT 在联网模式下也会附上引用链接。</p>\n</li>\n</ol>\n<p>从技术角度看，大部分生成式AI搜索采用了 <strong>RAG（Retrieval-Augmented Generation，检索增强生成）</strong> 架构。即：模型先检索文档，再将结果与用户问题一起输入大模型生成答案。这样可以避免模型胡乱编造，提高答案的实时性和准确性。</p>\n<p>因此，GEO 的任务，就是让您的内容<strong>既能进入 AI 的视野（被检索到），又能顺利融入它的回答（被引用）</strong>。</p>\n<hr>\n<h1 id=\"GEO-实践策略：让内容更适合-AI-引擎\"><a href=\"#GEO-实践策略：让内容更适合-AI-引擎\" class=\"headerlink\" title=\"GEO 实践策略：让内容更适合 AI 引擎\"></a>GEO 实践策略：让内容更适合 AI 引擎</h1><h2 id=\"1-内容结构优化\"><a href=\"#1-内容结构优化\" class=\"headerlink\" title=\"1. 内容结构优化\"></a>1. 内容结构优化</h2><ol>\n<li>使用清晰的标题层级（H1-H3）<br>这种清晰且富有逻辑的 Heading 标签结构有助于 AI 理解内容组织</li>\n<li>利用列表、表格展示要点<br>使用列表、表格等形式展示要点，使信息更加一目了然</li>\n<li>在开头给出结论或定义，在结尾做总结<br>良好的内容结构不仅提升用户阅读体验，也方便 AI 抓取和提炼重点。</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># TCP 与 QUIC 的区别（结论：QUIC 更适合现代网络）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># TCP 的特点</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 面向连接，依赖三次握手</span><br><span class=\"line\"><span class=\"bullet\">-</span> 容易出现队头阻塞</span><br><span class=\"line\"><span class=\"bullet\">-</span> 缺乏原生加密</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># QUIC 的特点</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 基于 UDP，减少握手延迟</span><br><span class=\"line\"><span class=\"bullet\">-</span> 支持多路复用，解决队头阻塞</span><br><span class=\"line\"><span class=\"bullet\">-</span> 内置加密，更适合移动端</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># 对比总结</span></span><br><span class=\"line\">| 协议 | 建立连接 | 队头阻塞 | 移动端支持 |</span><br><span class=\"line\">| ---- | -------- | -------- | ---------- |</span><br><span class=\"line\">| TCP  | 三次握手 | 存在     | 较差       |</span><br><span class=\"line\">| QUIC | 0-RTT   | 已解决   | 较好       |</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># 总结</span></span><br><span class=\"line\">QUIC 在延迟、安全性和移动性上更优，是未来互联网传输的趋势。</span><br></pre></td></tr></table></figure>\n<p>👉 开头给出结论，分点介绍，再用表格总结，最后收尾。结构清晰，AI 易于抓取要点。</p>\n<h2 id=\"2-FAQ-式写作风格\"><a href=\"#2-FAQ-式写作风格\" class=\"headerlink\" title=\"2. FAQ 式写作风格\"></a>2. FAQ 式写作风格</h2><p>采用问答形式组织内容，例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 常见问题（FAQ）</span></span><br><span class=\"line\"></span><br><span class=\"line\">Q: TCP 和 QUIC 的最大区别是什么？  </span><br><span class=\"line\">A: TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。  </span><br><span class=\"line\"></span><br><span class=\"line\">Q: QUIC 为什么能避免队头阻塞？  </span><br><span class=\"line\">A: QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。  </span><br><span class=\"line\"></span><br><span class=\"line\">Q: QUIC 更适合哪些场景？  </span><br><span class=\"line\">A: 移动网络、视频流媒体和在线游戏，因为它支持连接迁移和更低延迟。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种 “开门见山” 的回答方式非常契合 AI 摘取信息的逻辑，可显著提高内容被AI选中的机会。此外，配合使用 FAQPage 模式的 Schema 标记，向搜索引擎和AI明确标识问答对的结构，效果更佳。</p>\n<h2 id=\"3-结构化数据与-Schema-标注\"><a href=\"#3-结构化数据与-Schema-标注\" class=\"headerlink\" title=\"3. 结构化数据与 Schema 标注\"></a>3. 结构化数据与 Schema 标注</h2><p>利用结构化数据（Structured Data）向搜索引擎和AI提供内容的机器可读语义信息。例如，在网页中嵌入 JSON-LD Schema，例如 FAQPage、HowTo、Article 等，帮助 AI 更好识别网页信息。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;application/ld+json&quot;</span>&gt;</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;@context&quot;: &quot;https://schema.org&quot;,</span><br><span class=\"line\">  &quot;@type&quot;: &quot;FAQPage&quot;,</span><br><span class=\"line\">  &quot;mainEntity&quot;: [</span><br><span class=\"line\"><span class=\"code\">    &#123;</span></span><br><span class=\"line\"><span class=\"code\">      &quot;@type&quot;: &quot;Question&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;name&quot;: &quot;TCP 和 QUIC 的最大区别是什么？&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;acceptedAnswer&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"code\">        &quot;@type&quot;: &quot;Answer&quot;,</span></span><br><span class=\"line\"><span class=\"code\">        &quot;text&quot;: &quot;TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。&quot;</span></span><br><span class=\"line\"><span class=\"code\">      &#125;</span></span><br><span class=\"line\"><span class=\"code\">    &#125;,</span></span><br><span class=\"line\"><span class=\"code\">    &#123;</span></span><br><span class=\"line\"><span class=\"code\">      &quot;@type&quot;: &quot;Question&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;name&quot;: &quot;QUIC 为什么能避免队头阻塞？&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;acceptedAnswer&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"code\">        &quot;@type&quot;: &quot;Answer&quot;,</span></span><br><span class=\"line\"><span class=\"code\">        &quot;text&quot;: &quot;QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。&quot;</span></span><br><span class=\"line\"><span class=\"code\">      &#125;</span></span><br><span class=\"line\"><span class=\"code\">    &#125;</span></span><br><span class=\"line\"><span class=\"code\">  ]</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br><span class=\"line\"><span class=\"code\">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-内容更新与时效性\"><a href=\"#4-内容更新与时效性\" class=\"headerlink\" title=\"4. 内容更新与时效性\"></a>4. 内容更新与时效性</h2><p>定期更新文章（年份、数据、案例），保持内容新鲜度。<br>👉 通过更新年份和应用场景，让 AI 更倾向引用你的页面，而不是引用过时资料。</p>\n<h2 id=\"5-引用引导（外链与锚点优化）\"><a href=\"#5-引用引导（外链与锚点优化）\" class=\"headerlink\" title=\"5. 引用引导（外链与锚点优化）\"></a>5. 引用引导（外链与锚点优化）</h2><ul>\n<li>获取权威网站的反向链接</li>\n<li>在文章中合理使用内部链接与锚点</li>\n<li>在内容中主动注明出处与数据来源</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据 [<span class=\"string\">IETF QUIC 标准草案</span>](<span class=\"link\">https://datatracker.ietf.org/doc/html/rfc9000</span>)，</span><br><span class=\"line\">QUIC 在传输层引入了多路复用和 0-RTT 握手设计。</span><br></pre></td></tr></table></figure>\n<p>👉 外链提升权威性，内部锚点建立知识网络，AI 在引用时更容易“选中你”的文章。</p>\n<hr>\n<h1 id=\"LLM-txt：AI-时代的-robots-txt\"><a href=\"#LLM-txt：AI-时代的-robots-txt\" class=\"headerlink\" title=\"LLM.txt：AI 时代的 robots.txt\"></a>LLM.txt：AI 时代的 robots.txt</h1><p>在 SEO 时代，<strong>robots.txt</strong> 控制爬虫抓取范围；在 GEO 时代，出现了新尝试：<strong>LLM.txt</strong>。</p>\n<h2 id=\"什么是-LLM-txt？\"><a href=\"#什么是-LLM-txt？\" class=\"headerlink\" title=\"什么是 LLM.txt？\"></a>什么是 LLM.txt？</h2><p>LLM.txt 是一种新兴规范，旨在让网站管理员决定 <strong>AI 模型是否、以及如何使用网站内容</strong>。它相当于 AI 版的 robots.txt。</p>\n<h2 id=\"功能示例\"><a href=\"#功能示例\" class=\"headerlink\" title=\"功能示例\"></a>功能示例</h2><figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 允许 AI 模型引用博客内容</span><br><span class=\"line\">Allow: /blog/</span><br><span class=\"line\"></span><br><span class=\"line\"># 禁止使用内部资料</span><br><span class=\"line\">Disallow: /internal/</span><br><span class=\"line\"></span><br><span class=\"line\"># 要求引用时必须加来源</span><br><span class=\"line\">Attribution: required</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"GEO-与-RAG-结合：技术写作者与企业内容开发者的对策\"><a href=\"#GEO-与-RAG-结合：技术写作者与企业内容开发者的对策\" class=\"headerlink\" title=\"GEO 与 RAG 结合：技术写作者与企业内容开发者的对策\"></a>GEO 与 RAG 结合：技术写作者与企业内容开发者的对策</h1><ol>\n<li><p><strong>构建专属的 RAG 知识库</strong><br>将文档存入向量数据库，结合 Embedding + GPT 接口，打造企业专属聊天机器人。</p>\n</li>\n<li><p><strong>开放接口和插件</strong><br>开发 ChatGPT 插件或开放 API，让 AI 工具直接访问你的知识库。</p>\n</li>\n<li><p><strong>主动融入大模型训练集</strong><br>将高质量数据集开放给 AI 训练社区，提高在模型中的“内置引用”概率。</p>\n</li>\n<li><p><strong>利用 OpenAI API 进行内容测试</strong><br>使用 GPT-4 模拟用户提问，测试 AI 是否会引用你的文章，迭代优化。</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"未来畅想：搜索的下一个十年\"><a href=\"#未来畅想：搜索的下一个十年\" class=\"headerlink\" title=\"未来畅想：搜索的下一个十年\"></a>未来畅想：搜索的下一个十年</h1><p>随着生成式 AI 的快速演进，我们正处于搜索方式彻底重构的前夜。</p>\n<h2 id=\"1-搜索的未来形态\"><a href=\"#1-搜索的未来形态\" class=\"headerlink\" title=\"1. 搜索的未来形态\"></a>1. 搜索的未来形态</h2><p>未来的搜索，可能不再是“输入关键词 → 点击链接 → 获取答案”，而是更接近 <strong>个性化顾问</strong> 的模式：</p>\n<ul>\n<li>用户用自然语言直接提问，AI 会结合 <strong>实时互联网 + 私有知识库</strong> 给出答案；</li>\n<li>搜索不再是“十个蓝色链接”，而是一个 <strong>对话持续、动态追问</strong> 的过程；</li>\n<li>每个人看到的结果都高度定制化，甚至同一问题，不同用户会得到完全不同的回答。</li>\n</ul>\n<h2 id=\"2-对服务厂商的挑战\"><a href=\"#2-对服务厂商的挑战\" class=\"headerlink\" title=\"2. 对服务厂商的挑战\"></a>2. 对服务厂商的挑战</h2><p>这对现有面向 C 端用户的厂商提出了前所未有的挑战：</p>\n<ul>\n<li><strong>流量入口被重构</strong>：传统的 SEO 流量红利逐渐消失，品牌如何在 AI 对话中被“提及”，成为新的生存问题。</li>\n<li><strong>商业模式变化</strong>：广告和推荐位如何融入 AI 答案？如果用户停留在对话界面，厂商可能失去流量分发的主导权。</li>\n<li><strong>技术适配成本</strong>：企业需要维护开放 API、RAG 知识库、LLM.txt 等基础设施，才能被 AI 平台持续“看见”。</li>\n</ul>\n<h2 id=\"3-对用户的变化\"><a href=\"#3-对用户的变化\" class=\"headerlink\" title=\"3. 对用户的变化\"></a>3. 对用户的变化</h2><p>用户的体验也会发生质变：</p>\n<ul>\n<li><strong>更少点击</strong>：未来用户可能很少需要打开多个网页比对答案，AI 会直接给出最优解释。</li>\n<li><strong>更强信任</strong>：如果 AI 能提供透明引用和解释链路，用户会把它当作“第一问答入口”。</li>\n<li><strong>更多个性化</strong>：AI 会结合用户的历史行为、上下文语境，给出高度定制化的答案，这会让信息检索更高效。</li>\n</ul>\n<hr>\n<p>📌 <strong>总结畅想</strong><br>未来的搜索可能会变成 <strong>“AI 伴随式信息获取”</strong>：</p>\n<ul>\n<li>用户只需要提出问题，AI 就会主动结合公开知识和私有上下文，给出答案和下一步建议；</li>\n<li>品牌和内容提供者必须思考如何在这种对话里 <strong>被引用、被信任、被推荐</strong>；</li>\n<li>对用户来说，信息更快、更准，但也带来“答案是否被 AI 垄断”的新挑战。</li>\n</ul>\n<p>可以说，SEO 到 GEO 的转变只是开始。真正的挑战，是当搜索彻底对话化、场景化之后，<strong>我们该如何让内容和品牌继续被用户看见</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/blog/./images/geo/bg.png\" alt=\"bg\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>随着 ChatGPT、Bard、Claude 等生成式 AI 工具的普及，我们正步入<strong>生成式引擎优化（GEO）</strong>的新时代。在这个 AI 主导的信息检索时代，用户习惯于直接向 AI 提问而非搜索引擎获取答案。这意味着内容创作者和营销人员必须重新思考如何让自己的内容<strong>被看见、被引用、被推荐</strong>。GEO 并非传统 SEO 的简单延伸，而是一种全新的内容优化思维：要求我们以更自然、权威且结构清晰的方式创作内容，以确保在 AI 模型训练和回答生成过程中脱颖而出。</p>\n<p>当前，AI 驱动的搜索流量呈爆发式增长：ChatGPT 月活跃用户已超 1.8 亿，AI 搜索引擎 Perplexity 的使用量同比激增 858%，达到千万级。有预测显示，到 2028 年 AI 搜索将占据约14%的搜索市场份额。面对这股趋势，<strong>如果品牌内容无法被 AI 模型“看见”，就仿佛从搜索结果中消失</strong>。因此，我们亟需掌握 GEO 策略，让企业知识成为 AI 的“优先记忆”，实现在 AI 答案中的<strong>无点击曝光</strong>。</p>\n<p>本文将深入阐述 GEO 的定义和现状，比较 SEO 与 GEO 的联系区别，并提供面向 SEO 从业者和技术写作者的实用优化策略和案例，帮助大家在生成式引擎优化时代保持竞争优势。</p>\n<hr>\n<h1 id=\"GEO-的定义、发展背景与现状\"><a href=\"#GEO-的定义、发展背景与现状\" class=\"headerlink\" title=\"GEO 的定义、发展背景与现状\"></a>GEO 的定义、发展背景与现状</h1><p><strong>什么是 GEO？</strong>  </p>\n<p>GEO（Generative Engine Optimization，生成式引擎优化）是一种专为<strong>AI 驱动的生成式搜索引擎</strong>量身打造的内容优化策略。其核心目标是在 AI 模型生成回答时，让您的网站内容<strong>更频繁、更优先地被引用或推荐</strong>。简单来说，GEO 关注的不是网页在搜索结果中的排名高低，而是当用户向 AI 提问时，<strong>AI 会主动引用您的品牌内容作为答案来源</strong>。</p>\n<p><strong>发展背景：</strong>  </p>\n<p>传统 SEO（搜索引擎优化）诞生于上世纪 90 年代末，此后经历了关键词堆砌、内容为王、用户体验优先等阶段的演进。而近年来，大型语言模型（LLM）的崛起改变了信息获取模式——用户不再满足于点击多个网页寻找答案，而是希望由 AI 直接给出<strong>精确且个性化的解答</strong>。这种行为转变催生了 GEO 这一新概念，它可被视为 SEO 在 AI 时代的延续和升级。</p>\n<p><strong>现状：</strong>  </p>\n<p>目前市面上涌现出多种生成式 AI 引擎，例如 OpenAI 的 ChatGPT、Anthropic 的 Claude、Microsoft Bing Chat（集成 GPT-4 模型）、Google 即将推出的 Gemini，以及主打实时引用的 Perplexity AI 等。这些工具在用户查询时往往直接给出融合了多个来源的信息答案。例如，Perplexity AI 会实时搜索互联网并<strong>引用网页链接</strong>来回答用户问题；微软新版必应（Bing Chat）每句话后都会标注来源，用户悬停引用即可看到完整链接。甚至 ChatGPT 本身在引入联网搜索功能后，也开始在回答中附上来源链接，方便用户了解 AI 输出背后的依据。可以说，<strong>搜索引擎正在从“链接列表”演变为“整合答案”</strong>，而 GEO 正是帮助内容适应这一演变的关键策略。</p>\n<hr>\n<h1 id=\"SEO-与-GEO：区别与联系\"><a href=\"#SEO-与-GEO：区别与联系\" class=\"headerlink\" title=\"SEO 与 GEO：区别与联系\"></a>SEO 与 GEO：区别与联系</h1><p>GEO 与传统 SEO 密切相关又有所不同。两者的共同点在于：<strong>没有良好的 SEO 基础，GEO 无从谈起</strong>。因为如果网页不能被爬取和索引，AI <strong>根本无法检索或引用你的内容</strong>。实际上，AI 型搜索依然依赖搜索引擎抓取海量网页作为候选资料，因此<strong>GEO 以 SEO 为前提</strong>。正如公式所示：<strong>GEO &#x3D; SEO + RAG</strong>（检索增强生成）。第一步要通过传统 SEO 让搜索引擎“找到你”，第二步再通过内容优化让 AI 在生成答案时“选中你”。</p>\n<p>尽管联系紧密，GEO 与 SEO 的目标和策略仍存在显著区别。下面将两者核心差异进行对比：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>传统 SEO 优化目标</th>\n<th>GEO 优化目标</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>优化目标</strong></td>\n<td>提升网站在搜索引擎结果页的排名</td>\n<td>让企业信息在 AI 生成的答案中优先出现</td>\n</tr>\n<tr>\n<td><strong>关注重点</strong></td>\n<td>关键词匹配、外部链接数量等技术指标</td>\n<td>语义理解、内容权威性和结构化数据</td>\n</tr>\n<tr>\n<td><strong>用户交互</strong></td>\n<td>用户点击搜索结果进入网站获取信息</td>\n<td>AI 直接在回答中呈现品牌内容，无需点击</td>\n</tr>\n<tr>\n<td><strong>技术手段</strong></td>\n<td>关键词布局、链接建设等传统手段</td>\n<td>语义优化、权威内容构建、结构化数据标注</td>\n</tr>\n</tbody></table>\n<p><img src=\"/blog/./images/geo/SEO-GEO.png\" alt=\"对比\"></p>\n<p>可以看出，<strong>SEO 更关注被搜索引擎“看到”，GEO 则关注被 AI “说到”</strong>。SEO追求的是排名和点击流量，而GEO追求的是<strong>内容在AI答案中的出现频率和权威性</strong>。这导致评价标准的变化：SEO 看重流量、点击率；GEO 则关注 AI 对内容的引用次数、品牌在对话中的被提及率等新指标。</p>\n<hr>\n<h1 id=\"生成式-AI-引擎如何“引用”网络内容\"><a href=\"#生成式-AI-引擎如何“引用”网络内容\" class=\"headerlink\" title=\"生成式 AI 引擎如何“引用”网络内容\"></a>生成式 AI 引擎如何“引用”网络内容</h1><p>生成式 AI 引擎（如 ChatGPT、Perplexity、Claude、Gemini 等）的工作方式一般包括两个阶段：</p>\n<ol>\n<li><p><strong>信息检索阶段</strong><br>当用户提出问题时，AI 系统会先从互联网或自身知识库中<strong>搜索相关内容</strong>。例如，Bing Chat 背后依托必应搜索；ChatGPT 的浏览模式调用的是 Bing 的结果；Perplexity 则有自建的搜索索引来实时查询网页。</p>\n</li>\n<li><p><strong>内容生成阶段</strong><br>AI 模型读取检索到的内容，将其中的关键信息<strong>综合、重组并生成</strong>答案。为提高可信度，不少 AI 引擎会在回答中附上来源引用。例如，新版必应在回答每句话后添加脚注，标明信息来源；Perplexity 明确展示相关网页链接；ChatGPT 在联网模式下也会附上引用链接。</p>\n</li>\n</ol>\n<p>从技术角度看，大部分生成式AI搜索采用了 <strong>RAG（Retrieval-Augmented Generation，检索增强生成）</strong> 架构。即：模型先检索文档，再将结果与用户问题一起输入大模型生成答案。这样可以避免模型胡乱编造，提高答案的实时性和准确性。</p>\n<p>因此，GEO 的任务，就是让您的内容<strong>既能进入 AI 的视野（被检索到），又能顺利融入它的回答（被引用）</strong>。</p>\n<hr>\n<h1 id=\"GEO-实践策略：让内容更适合-AI-引擎\"><a href=\"#GEO-实践策略：让内容更适合-AI-引擎\" class=\"headerlink\" title=\"GEO 实践策略：让内容更适合 AI 引擎\"></a>GEO 实践策略：让内容更适合 AI 引擎</h1><h2 id=\"1-内容结构优化\"><a href=\"#1-内容结构优化\" class=\"headerlink\" title=\"1. 内容结构优化\"></a>1. 内容结构优化</h2><ol>\n<li>使用清晰的标题层级（H1-H3）<br>这种清晰且富有逻辑的 Heading 标签结构有助于 AI 理解内容组织</li>\n<li>利用列表、表格展示要点<br>使用列表、表格等形式展示要点，使信息更加一目了然</li>\n<li>在开头给出结论或定义，在结尾做总结<br>良好的内容结构不仅提升用户阅读体验，也方便 AI 抓取和提炼重点。</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># TCP 与 QUIC 的区别（结论：QUIC 更适合现代网络）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># TCP 的特点</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 面向连接，依赖三次握手</span><br><span class=\"line\"><span class=\"bullet\">-</span> 容易出现队头阻塞</span><br><span class=\"line\"><span class=\"bullet\">-</span> 缺乏原生加密</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># QUIC 的特点</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> 基于 UDP，减少握手延迟</span><br><span class=\"line\"><span class=\"bullet\">-</span> 支持多路复用，解决队头阻塞</span><br><span class=\"line\"><span class=\"bullet\">-</span> 内置加密，更适合移动端</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># 对比总结</span></span><br><span class=\"line\">| 协议 | 建立连接 | 队头阻塞 | 移动端支持 |</span><br><span class=\"line\">| ---- | -------- | -------- | ---------- |</span><br><span class=\"line\">| TCP  | 三次握手 | 存在     | 较差       |</span><br><span class=\"line\">| QUIC | 0-RTT   | 已解决   | 较好       |</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># 总结</span></span><br><span class=\"line\">QUIC 在延迟、安全性和移动性上更优，是未来互联网传输的趋势。</span><br></pre></td></tr></table></figure>\n<p>👉 开头给出结论，分点介绍，再用表格总结，最后收尾。结构清晰，AI 易于抓取要点。</p>\n<h2 id=\"2-FAQ-式写作风格\"><a href=\"#2-FAQ-式写作风格\" class=\"headerlink\" title=\"2. FAQ 式写作风格\"></a>2. FAQ 式写作风格</h2><p>采用问答形式组织内容，例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 常见问题（FAQ）</span></span><br><span class=\"line\"></span><br><span class=\"line\">Q: TCP 和 QUIC 的最大区别是什么？  </span><br><span class=\"line\">A: TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。  </span><br><span class=\"line\"></span><br><span class=\"line\">Q: QUIC 为什么能避免队头阻塞？  </span><br><span class=\"line\">A: QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。  </span><br><span class=\"line\"></span><br><span class=\"line\">Q: QUIC 更适合哪些场景？  </span><br><span class=\"line\">A: 移动网络、视频流媒体和在线游戏，因为它支持连接迁移和更低延迟。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这种 “开门见山” 的回答方式非常契合 AI 摘取信息的逻辑，可显著提高内容被AI选中的机会。此外，配合使用 FAQPage 模式的 Schema 标记，向搜索引擎和AI明确标识问答对的结构，效果更佳。</p>\n<h2 id=\"3-结构化数据与-Schema-标注\"><a href=\"#3-结构化数据与-Schema-标注\" class=\"headerlink\" title=\"3. 结构化数据与 Schema 标注\"></a>3. 结构化数据与 Schema 标注</h2><p>利用结构化数据（Structured Data）向搜索引擎和AI提供内容的机器可读语义信息。例如，在网页中嵌入 JSON-LD Schema，例如 FAQPage、HowTo、Article 等，帮助 AI 更好识别网页信息。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;application/ld+json&quot;</span>&gt;</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;@context&quot;: &quot;https://schema.org&quot;,</span><br><span class=\"line\">  &quot;@type&quot;: &quot;FAQPage&quot;,</span><br><span class=\"line\">  &quot;mainEntity&quot;: [</span><br><span class=\"line\"><span class=\"code\">    &#123;</span></span><br><span class=\"line\"><span class=\"code\">      &quot;@type&quot;: &quot;Question&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;name&quot;: &quot;TCP 和 QUIC 的最大区别是什么？&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;acceptedAnswer&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"code\">        &quot;@type&quot;: &quot;Answer&quot;,</span></span><br><span class=\"line\"><span class=\"code\">        &quot;text&quot;: &quot;TCP 需要三次握手建立连接，而 QUIC 基于 UDP，可以实现 0-RTT 连接，减少延迟。&quot;</span></span><br><span class=\"line\"><span class=\"code\">      &#125;</span></span><br><span class=\"line\"><span class=\"code\">    &#125;,</span></span><br><span class=\"line\"><span class=\"code\">    &#123;</span></span><br><span class=\"line\"><span class=\"code\">      &quot;@type&quot;: &quot;Question&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;name&quot;: &quot;QUIC 为什么能避免队头阻塞？&quot;,</span></span><br><span class=\"line\"><span class=\"code\">      &quot;acceptedAnswer&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"code\">        &quot;@type&quot;: &quot;Answer&quot;,</span></span><br><span class=\"line\"><span class=\"code\">        &quot;text&quot;: &quot;QUIC 支持多路复用，一个流阻塞不会影响其他流，因此解决了 TCP 的队头阻塞问题。&quot;</span></span><br><span class=\"line\"><span class=\"code\">      &#125;</span></span><br><span class=\"line\"><span class=\"code\">    &#125;</span></span><br><span class=\"line\"><span class=\"code\">  ]</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br><span class=\"line\"><span class=\"code\">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-内容更新与时效性\"><a href=\"#4-内容更新与时效性\" class=\"headerlink\" title=\"4. 内容更新与时效性\"></a>4. 内容更新与时效性</h2><p>定期更新文章（年份、数据、案例），保持内容新鲜度。<br>👉 通过更新年份和应用场景，让 AI 更倾向引用你的页面，而不是引用过时资料。</p>\n<h2 id=\"5-引用引导（外链与锚点优化）\"><a href=\"#5-引用引导（外链与锚点优化）\" class=\"headerlink\" title=\"5. 引用引导（外链与锚点优化）\"></a>5. 引用引导（外链与锚点优化）</h2><ul>\n<li>获取权威网站的反向链接</li>\n<li>在文章中合理使用内部链接与锚点</li>\n<li>在内容中主动注明出处与数据来源</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据 [<span class=\"string\">IETF QUIC 标准草案</span>](<span class=\"link\">https://datatracker.ietf.org/doc/html/rfc9000</span>)，</span><br><span class=\"line\">QUIC 在传输层引入了多路复用和 0-RTT 握手设计。</span><br></pre></td></tr></table></figure>\n<p>👉 外链提升权威性，内部锚点建立知识网络，AI 在引用时更容易“选中你”的文章。</p>\n<hr>\n<h1 id=\"LLM-txt：AI-时代的-robots-txt\"><a href=\"#LLM-txt：AI-时代的-robots-txt\" class=\"headerlink\" title=\"LLM.txt：AI 时代的 robots.txt\"></a>LLM.txt：AI 时代的 robots.txt</h1><p>在 SEO 时代，<strong>robots.txt</strong> 控制爬虫抓取范围；在 GEO 时代，出现了新尝试：<strong>LLM.txt</strong>。</p>\n<h2 id=\"什么是-LLM-txt？\"><a href=\"#什么是-LLM-txt？\" class=\"headerlink\" title=\"什么是 LLM.txt？\"></a>什么是 LLM.txt？</h2><p>LLM.txt 是一种新兴规范，旨在让网站管理员决定 <strong>AI 模型是否、以及如何使用网站内容</strong>。它相当于 AI 版的 robots.txt。</p>\n<h2 id=\"功能示例\"><a href=\"#功能示例\" class=\"headerlink\" title=\"功能示例\"></a>功能示例</h2><figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 允许 AI 模型引用博客内容</span><br><span class=\"line\">Allow: /blog/</span><br><span class=\"line\"></span><br><span class=\"line\"># 禁止使用内部资料</span><br><span class=\"line\">Disallow: /internal/</span><br><span class=\"line\"></span><br><span class=\"line\"># 要求引用时必须加来源</span><br><span class=\"line\">Attribution: required</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"GEO-与-RAG-结合：技术写作者与企业内容开发者的对策\"><a href=\"#GEO-与-RAG-结合：技术写作者与企业内容开发者的对策\" class=\"headerlink\" title=\"GEO 与 RAG 结合：技术写作者与企业内容开发者的对策\"></a>GEO 与 RAG 结合：技术写作者与企业内容开发者的对策</h1><ol>\n<li><p><strong>构建专属的 RAG 知识库</strong><br>将文档存入向量数据库，结合 Embedding + GPT 接口，打造企业专属聊天机器人。</p>\n</li>\n<li><p><strong>开放接口和插件</strong><br>开发 ChatGPT 插件或开放 API，让 AI 工具直接访问你的知识库。</p>\n</li>\n<li><p><strong>主动融入大模型训练集</strong><br>将高质量数据集开放给 AI 训练社区，提高在模型中的“内置引用”概率。</p>\n</li>\n<li><p><strong>利用 OpenAI API 进行内容测试</strong><br>使用 GPT-4 模拟用户提问，测试 AI 是否会引用你的文章，迭代优化。</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"未来畅想：搜索的下一个十年\"><a href=\"#未来畅想：搜索的下一个十年\" class=\"headerlink\" title=\"未来畅想：搜索的下一个十年\"></a>未来畅想：搜索的下一个十年</h1><p>随着生成式 AI 的快速演进，我们正处于搜索方式彻底重构的前夜。</p>\n<h2 id=\"1-搜索的未来形态\"><a href=\"#1-搜索的未来形态\" class=\"headerlink\" title=\"1. 搜索的未来形态\"></a>1. 搜索的未来形态</h2><p>未来的搜索，可能不再是“输入关键词 → 点击链接 → 获取答案”，而是更接近 <strong>个性化顾问</strong> 的模式：</p>\n<ul>\n<li>用户用自然语言直接提问，AI 会结合 <strong>实时互联网 + 私有知识库</strong> 给出答案；</li>\n<li>搜索不再是“十个蓝色链接”，而是一个 <strong>对话持续、动态追问</strong> 的过程；</li>\n<li>每个人看到的结果都高度定制化，甚至同一问题，不同用户会得到完全不同的回答。</li>\n</ul>\n<h2 id=\"2-对服务厂商的挑战\"><a href=\"#2-对服务厂商的挑战\" class=\"headerlink\" title=\"2. 对服务厂商的挑战\"></a>2. 对服务厂商的挑战</h2><p>这对现有面向 C 端用户的厂商提出了前所未有的挑战：</p>\n<ul>\n<li><strong>流量入口被重构</strong>：传统的 SEO 流量红利逐渐消失，品牌如何在 AI 对话中被“提及”，成为新的生存问题。</li>\n<li><strong>商业模式变化</strong>：广告和推荐位如何融入 AI 答案？如果用户停留在对话界面，厂商可能失去流量分发的主导权。</li>\n<li><strong>技术适配成本</strong>：企业需要维护开放 API、RAG 知识库、LLM.txt 等基础设施，才能被 AI 平台持续“看见”。</li>\n</ul>\n<h2 id=\"3-对用户的变化\"><a href=\"#3-对用户的变化\" class=\"headerlink\" title=\"3. 对用户的变化\"></a>3. 对用户的变化</h2><p>用户的体验也会发生质变：</p>\n<ul>\n<li><strong>更少点击</strong>：未来用户可能很少需要打开多个网页比对答案，AI 会直接给出最优解释。</li>\n<li><strong>更强信任</strong>：如果 AI 能提供透明引用和解释链路，用户会把它当作“第一问答入口”。</li>\n<li><strong>更多个性化</strong>：AI 会结合用户的历史行为、上下文语境，给出高度定制化的答案，这会让信息检索更高效。</li>\n</ul>\n<hr>\n<p>📌 <strong>总结畅想</strong><br>未来的搜索可能会变成 <strong>“AI 伴随式信息获取”</strong>：</p>\n<ul>\n<li>用户只需要提出问题，AI 就会主动结合公开知识和私有上下文，给出答案和下一步建议；</li>\n<li>品牌和内容提供者必须思考如何在这种对话里 <strong>被引用、被信任、被推荐</strong>；</li>\n<li>对用户来说，信息更快、更准，但也带来“答案是否被 AI 垄断”的新挑战。</li>\n</ul>\n<p>可以说，SEO 到 GEO 的转变只是开始。真正的挑战，是当搜索彻底对话化、场景化之后，<strong>我们该如何让内容和品牌继续被用户看见</strong>。</p>\n"},{"title":"用 HTTP OPTIONS 发现 API 的隐藏能力","date":"2025-09-25T01:31:53.000Z","_content":"\n# 引子：一个常见的问题\n\n假设你正在开发一个前端应用，遇到这样一个接口：\n\n```\nPOST /api/orders\n```\n\n你心里冒出几个问题：\n\n* 这个接口除了 `POST`，还能不能用 `GET` 来获取订单？\n* 如果能更新订单，是 `PUT` 还是 `PATCH`？\n* 服务器期望的数据格式是 JSON、XML，还是 `form-data`？\n* 这个接口有没有写权限，或者我只能读？\n\n通常我们需要查文档（比如 OpenAPI、Swagger），但如果文档缺失、过时或者不完整呢？\n其实 HTTP 协议早就提供了一种“问 API 自己”的方式，那就是 **OPTIONS 方法**。\n\n很多人第一次接触 OPTIONS 是在跨域请求（CORS）里：浏览器会先发一个预检请求 `OPTIONS`，确认目标服务器是否允许真正的请求。但 **OPTIONS 的价值远不止于此**。它的设计初衷是让客户端能够被动地发现“在这里我能做什么”。\n\n接下来，我们就深入聊聊 OPTIONS 的用途，并配合实际案例演示。\n\n---\n\n# 基本用法：Allow 头部\n\n最经典的 OPTIONS 用法是通过 `Allow` 头部告诉客户端，某个资源支持哪些方法。\n\n比如我们对 `/api/orders/123` 发起请求：\n\n```bash\ncurl -X OPTIONS http://localhost:8080/api/orders/123\n```\n\n可能会得到：\n\n```\nHTTP/1.1 204 No Content\nDate: Tue, 24 Sep 2025 12:00:00 GMT\nServer: DemoServer/1.2\nAllow: GET, PUT, DELETE, OPTIONS\n```\n\n从 `Allow` 头就能看出：\n\n* 这个订单可以 `GET`（查看）\n* 可以 `PUT`（更新）\n* 可以 `DELETE`（删除）\n* 当然，OPTIONS 也被允许\n\n这就像 API 自己在告诉你“菜单上有哪些菜”。\n\n---\n\n## 动态 Allow：权限控制\n\n更有意思的是，`Allow` 可以根据**用户角色**动态返回。\n\n## 普通用户：\n\n```\nAllow: GET, OPTIONS\n```\n\n只能查看订单，不能修改。\n\n## 管理员用户：\n\n```\nAllow: GET, PUT, DELETE, OPTIONS\n```\n\n可以修改和删除订单。\n\n这意味着，前端应用完全可以在渲染按钮之前，先发一个 OPTIONS 请求，根据 `Allow` 动态决定界面上是否显示“删除订单”按钮。\n\n这种做法的好处是 **前后端解耦**：前端不需要硬编码权限逻辑，直接让 API 自己说话。\n\n---\n\n# 进一步探索：Accept 和 Accept-\\* 系列头\n\nOPTIONS 不只是告诉你支持哪些方法，它还能说明**支持哪些数据格式**。\n\n## Accept 响应头\n\n比如：\n\n```\nHTTP/1.1 204 No Content\nDate: Tue, 24 Sep 2025 12:10:00 GMT\nServer: DemoServer/1.2\nAllow: GET, POST, OPTIONS\nAccept: application/json, application/xml\n```\n\n这里的 `Accept` 表示该接口支持返回 **JSON** 和 **XML**。\n这对客户端来说很有用：\n\n* 如果你是浏览器，可以直接选择 JSON\n* 如果是一个老系统，需要 XML 也没问题\n\n---\n\n## Accept-Post\n\n对于 `POST` 请求，还能通过 `Accept-Post` 指定可接受的请求体类型：\n\n```\nHTTP/1.1 204 No Content\nAllow: POST, OPTIONS\nAccept-Post: multipart/form-data, application/json\n```\n\n这告诉我们：\n\n* 你可以用 `multipart/form-data` 来上传文件\n* 也可以用 JSON 来创建数据\n\n举个例子，前端上传头像时用：\n\n```js\nconst form = new FormData();\nform.append(\"avatar\", file);\nawait fetch(\"/api/profile/avatar\", {\n  method: \"POST\",\n  body: form\n});\n```\n\n而创建用户时则用：\n\n```js\nawait fetch(\"/api/users\", {\n  method: \"POST\",\n  headers: {\"Content-Type\": \"application/json\"},\n  body: JSON.stringify({name: \"Alice\", email: \"a@example.com\"})\n});\n```\n\n---\n\n## Accept-Patch\n\nPATCH 方法常见于部分更新资源，比如只更新订单状态。\n\n```\nHTTP/1.1 204 No Content\nAllow: PATCH, OPTIONS\nAccept-Patch: application/merge-patch+json, application/json-patch+json\n```\n\n这意味着服务器支持两种 PATCH 格式：\n\n* **JSON Merge Patch**：整体覆盖部分字段\n* **JSON Patch**：通过操作指令更新特定字段\n\n示例请求（JSON Patch）：\n\n```json\n[\n  { \"op\": \"replace\", \"path\": \"/status\", \"value\": \"shipped\" }\n]\n```\n\n---\n\n## Accept-Query\n\n这是一个不常见但很有潜力的头部，表示接口支持某种查询语言。\n\n```\nHTTP/1.1 204 No Content\nAllow: QUERY, OPTIONS\nAccept-Query: application/graphql\n```\n\n说明你可以通过 `QUERY` 方法发 GraphQL 查询。虽然大多数框架不常用 QUERY 方法，但它在协议层面完全合法。\n\n---\n\n# OPTIONS 响应中的文档链接\n\nOPTIONS 还可以充当“接口说明书入口”。\n\n例如：\n\n```\nHTTP/1.1 200 OK\nAllow: GET, POST, OPTIONS\nLink: <https://api.example.com/docs/orders>; rel=\"help\"\nLink: <https://api.example.com/openapi.yaml>; rel=\"service-desc\" type=\"application/openapi+yaml\"\nContent-Type: text/plain\n\n你可以在 https://api.example.com/docs/orders 找到详细文档。\n```\n\n这里有几点：\n\n* `Link` 头指向了 API 文档和 OpenAPI 描述\n* 响应体里返回了友好的提示\n\n这样即便文档站点挂了，至少还能找到线索。\n\n---\n\n# OPTIONS \\* ：探测整个服务\n\n平时我们都是对某个路径发 OPTIONS，比如 `/api/orders`。\n但协议里还规定了一个特殊格式：\n\n```\nOPTIONS * HTTP/1.1\n```\n\n注意 `*` 不是路径，而是“整个服务器”。\n\n用 `curl` 可以这样试：\n\n```bash\ncurl -vX OPTIONS --request-target '*' http://localhost:8080\n```\n\n可能返回：\n\n```\nHTTP/1.1 204 No Content\nAllow: GET, POST, PUT, DELETE, PATCH, OPTIONS\n```\n\n这表示服务器全局支持的方法。\n虽然现代 fetch() 不支持 `OPTIONS *`，但老牌服务器（如 Apache、Nginx）大多兼容。\n\n---\n\n# 特殊用法：WebDAV 与扩展\n\nOPTIONS 也常用于 WebDAV、CalDAV、CardDAV 这类扩展协议。\n\n例如：\n\n```\nHTTP/1.1 204 No Content\nAllow: GET, PROPFIND, MKCOL, LOCK, UNLOCK\nDAV: 1, 2, calendar-access, addressbook\n```\n\n这就超出了传统 REST 的范围，进入了文件共享、日历、联系人等场景。\n\n这类协议通常依赖 OPTIONS 来声明自己支持的扩展能力。\n\n---\n\n# 实战：用 Node.js 实现一个 OPTIONS\n\n为了直观，我们用 Node.js/Express 搭个例子：\n\n```js\nimport express from \"express\";\nconst app = express();\n\napp.use(express.json());\n\napp.options(\"/api/orders\", (req, res) => {\n  res.set(\"Allow\", \"GET, POST, OPTIONS\");\n  res.set(\"Accept\", \"application/json, application/xml\");\n  res.set(\"Accept-Post\", \"application/json, multipart/form-data\");\n  res.status(204).send();\n});\n\napp.listen(8080, () => console.log(\"Server started\"));\n```\n\n测试：\n\n```bash\ncurl -i -X OPTIONS http://localhost:8080/api/orders\n```\n\n结果：\n\n```\nHTTP/1.1 204 No Content\nAllow: GET, POST, OPTIONS\nAccept: application/json, application/xml\nAccept-Post: application/json, multipart/form-data\n```\n\n这样前端开发者无需文档就能获知接口支持情况。\n\n---\n\n# 插图建议\n\n为了让文章更直观，可以配几张图：\n\n1. **交互时序图**\n\n   * 客户端发送 OPTIONS\n   * 服务器返回 Allow 和 Accept\n   * 客户端根据返回结果决定后续操作\n\n2. **权限差异图**\n\n   * 普通用户只显示“查看”按钮\n   * 管理员多了“编辑”“删除”按钮\n\n3. **全局探测图**\n\n   * OPTIONS \\* 请求 → 服务器返回全局支持的方法\n\n4. **请求头对照表**\n\n   * 列出 Allow / Accept / Accept-Post / Accept-Patch 的区别\n\n---\n\n# 总结\n\nOPTIONS 是 HTTP 协议里被低估的一个方法。\n\n* 它不仅仅是 CORS 的配角，更是 API 的“自描述能力”。\n* 通过 OPTIONS + Allow，客户端能知道支持的方法。\n* 通过 Accept 和 Accept-\\*，客户端能知道支持的数据格式。\n* OPTIONS 响应还能附带文档链接，帮助开发者快速找到资料。\n* 特殊场景下，OPTIONS \\* 和 WebDAV 扩展让它更加强大。\n\n所以，当你设计 API 时，不妨善用 OPTIONS，让接口自己“说话”，这能让使用者的体验提升一个档次。\n\n---\n\n👉 未来我准备写一篇《用 OPTIONS 打造自解释 API》的实战文章，展示如何在实际项目中动态返回不同角色的 Allow 结果，并结合前端渲染逻辑，做一个“接口驱动 UI”的 demo，敬请期待！\n\n---\n\n这篇文章大概 3100 字左右，足够深度和完整性。\n\n要不要我帮你把上面提到的插图直接生成？比如用 **时序图** 或 **对比图** 形式展示 OPTIONS 的用法。\n","source":"_posts/http-option.md","raw":"---\ntitle: 用 HTTP OPTIONS 发现 API 的隐藏能力\ndate: 2025-09-25 09:31:53\ntags:\n---\n\n# 引子：一个常见的问题\n\n假设你正在开发一个前端应用，遇到这样一个接口：\n\n```\nPOST /api/orders\n```\n\n你心里冒出几个问题：\n\n* 这个接口除了 `POST`，还能不能用 `GET` 来获取订单？\n* 如果能更新订单，是 `PUT` 还是 `PATCH`？\n* 服务器期望的数据格式是 JSON、XML，还是 `form-data`？\n* 这个接口有没有写权限，或者我只能读？\n\n通常我们需要查文档（比如 OpenAPI、Swagger），但如果文档缺失、过时或者不完整呢？\n其实 HTTP 协议早就提供了一种“问 API 自己”的方式，那就是 **OPTIONS 方法**。\n\n很多人第一次接触 OPTIONS 是在跨域请求（CORS）里：浏览器会先发一个预检请求 `OPTIONS`，确认目标服务器是否允许真正的请求。但 **OPTIONS 的价值远不止于此**。它的设计初衷是让客户端能够被动地发现“在这里我能做什么”。\n\n接下来，我们就深入聊聊 OPTIONS 的用途，并配合实际案例演示。\n\n---\n\n# 基本用法：Allow 头部\n\n最经典的 OPTIONS 用法是通过 `Allow` 头部告诉客户端，某个资源支持哪些方法。\n\n比如我们对 `/api/orders/123` 发起请求：\n\n```bash\ncurl -X OPTIONS http://localhost:8080/api/orders/123\n```\n\n可能会得到：\n\n```\nHTTP/1.1 204 No Content\nDate: Tue, 24 Sep 2025 12:00:00 GMT\nServer: DemoServer/1.2\nAllow: GET, PUT, DELETE, OPTIONS\n```\n\n从 `Allow` 头就能看出：\n\n* 这个订单可以 `GET`（查看）\n* 可以 `PUT`（更新）\n* 可以 `DELETE`（删除）\n* 当然，OPTIONS 也被允许\n\n这就像 API 自己在告诉你“菜单上有哪些菜”。\n\n---\n\n## 动态 Allow：权限控制\n\n更有意思的是，`Allow` 可以根据**用户角色**动态返回。\n\n## 普通用户：\n\n```\nAllow: GET, OPTIONS\n```\n\n只能查看订单，不能修改。\n\n## 管理员用户：\n\n```\nAllow: GET, PUT, DELETE, OPTIONS\n```\n\n可以修改和删除订单。\n\n这意味着，前端应用完全可以在渲染按钮之前，先发一个 OPTIONS 请求，根据 `Allow` 动态决定界面上是否显示“删除订单”按钮。\n\n这种做法的好处是 **前后端解耦**：前端不需要硬编码权限逻辑，直接让 API 自己说话。\n\n---\n\n# 进一步探索：Accept 和 Accept-\\* 系列头\n\nOPTIONS 不只是告诉你支持哪些方法，它还能说明**支持哪些数据格式**。\n\n## Accept 响应头\n\n比如：\n\n```\nHTTP/1.1 204 No Content\nDate: Tue, 24 Sep 2025 12:10:00 GMT\nServer: DemoServer/1.2\nAllow: GET, POST, OPTIONS\nAccept: application/json, application/xml\n```\n\n这里的 `Accept` 表示该接口支持返回 **JSON** 和 **XML**。\n这对客户端来说很有用：\n\n* 如果你是浏览器，可以直接选择 JSON\n* 如果是一个老系统，需要 XML 也没问题\n\n---\n\n## Accept-Post\n\n对于 `POST` 请求，还能通过 `Accept-Post` 指定可接受的请求体类型：\n\n```\nHTTP/1.1 204 No Content\nAllow: POST, OPTIONS\nAccept-Post: multipart/form-data, application/json\n```\n\n这告诉我们：\n\n* 你可以用 `multipart/form-data` 来上传文件\n* 也可以用 JSON 来创建数据\n\n举个例子，前端上传头像时用：\n\n```js\nconst form = new FormData();\nform.append(\"avatar\", file);\nawait fetch(\"/api/profile/avatar\", {\n  method: \"POST\",\n  body: form\n});\n```\n\n而创建用户时则用：\n\n```js\nawait fetch(\"/api/users\", {\n  method: \"POST\",\n  headers: {\"Content-Type\": \"application/json\"},\n  body: JSON.stringify({name: \"Alice\", email: \"a@example.com\"})\n});\n```\n\n---\n\n## Accept-Patch\n\nPATCH 方法常见于部分更新资源，比如只更新订单状态。\n\n```\nHTTP/1.1 204 No Content\nAllow: PATCH, OPTIONS\nAccept-Patch: application/merge-patch+json, application/json-patch+json\n```\n\n这意味着服务器支持两种 PATCH 格式：\n\n* **JSON Merge Patch**：整体覆盖部分字段\n* **JSON Patch**：通过操作指令更新特定字段\n\n示例请求（JSON Patch）：\n\n```json\n[\n  { \"op\": \"replace\", \"path\": \"/status\", \"value\": \"shipped\" }\n]\n```\n\n---\n\n## Accept-Query\n\n这是一个不常见但很有潜力的头部，表示接口支持某种查询语言。\n\n```\nHTTP/1.1 204 No Content\nAllow: QUERY, OPTIONS\nAccept-Query: application/graphql\n```\n\n说明你可以通过 `QUERY` 方法发 GraphQL 查询。虽然大多数框架不常用 QUERY 方法，但它在协议层面完全合法。\n\n---\n\n# OPTIONS 响应中的文档链接\n\nOPTIONS 还可以充当“接口说明书入口”。\n\n例如：\n\n```\nHTTP/1.1 200 OK\nAllow: GET, POST, OPTIONS\nLink: <https://api.example.com/docs/orders>; rel=\"help\"\nLink: <https://api.example.com/openapi.yaml>; rel=\"service-desc\" type=\"application/openapi+yaml\"\nContent-Type: text/plain\n\n你可以在 https://api.example.com/docs/orders 找到详细文档。\n```\n\n这里有几点：\n\n* `Link` 头指向了 API 文档和 OpenAPI 描述\n* 响应体里返回了友好的提示\n\n这样即便文档站点挂了，至少还能找到线索。\n\n---\n\n# OPTIONS \\* ：探测整个服务\n\n平时我们都是对某个路径发 OPTIONS，比如 `/api/orders`。\n但协议里还规定了一个特殊格式：\n\n```\nOPTIONS * HTTP/1.1\n```\n\n注意 `*` 不是路径，而是“整个服务器”。\n\n用 `curl` 可以这样试：\n\n```bash\ncurl -vX OPTIONS --request-target '*' http://localhost:8080\n```\n\n可能返回：\n\n```\nHTTP/1.1 204 No Content\nAllow: GET, POST, PUT, DELETE, PATCH, OPTIONS\n```\n\n这表示服务器全局支持的方法。\n虽然现代 fetch() 不支持 `OPTIONS *`，但老牌服务器（如 Apache、Nginx）大多兼容。\n\n---\n\n# 特殊用法：WebDAV 与扩展\n\nOPTIONS 也常用于 WebDAV、CalDAV、CardDAV 这类扩展协议。\n\n例如：\n\n```\nHTTP/1.1 204 No Content\nAllow: GET, PROPFIND, MKCOL, LOCK, UNLOCK\nDAV: 1, 2, calendar-access, addressbook\n```\n\n这就超出了传统 REST 的范围，进入了文件共享、日历、联系人等场景。\n\n这类协议通常依赖 OPTIONS 来声明自己支持的扩展能力。\n\n---\n\n# 实战：用 Node.js 实现一个 OPTIONS\n\n为了直观，我们用 Node.js/Express 搭个例子：\n\n```js\nimport express from \"express\";\nconst app = express();\n\napp.use(express.json());\n\napp.options(\"/api/orders\", (req, res) => {\n  res.set(\"Allow\", \"GET, POST, OPTIONS\");\n  res.set(\"Accept\", \"application/json, application/xml\");\n  res.set(\"Accept-Post\", \"application/json, multipart/form-data\");\n  res.status(204).send();\n});\n\napp.listen(8080, () => console.log(\"Server started\"));\n```\n\n测试：\n\n```bash\ncurl -i -X OPTIONS http://localhost:8080/api/orders\n```\n\n结果：\n\n```\nHTTP/1.1 204 No Content\nAllow: GET, POST, OPTIONS\nAccept: application/json, application/xml\nAccept-Post: application/json, multipart/form-data\n```\n\n这样前端开发者无需文档就能获知接口支持情况。\n\n---\n\n# 插图建议\n\n为了让文章更直观，可以配几张图：\n\n1. **交互时序图**\n\n   * 客户端发送 OPTIONS\n   * 服务器返回 Allow 和 Accept\n   * 客户端根据返回结果决定后续操作\n\n2. **权限差异图**\n\n   * 普通用户只显示“查看”按钮\n   * 管理员多了“编辑”“删除”按钮\n\n3. **全局探测图**\n\n   * OPTIONS \\* 请求 → 服务器返回全局支持的方法\n\n4. **请求头对照表**\n\n   * 列出 Allow / Accept / Accept-Post / Accept-Patch 的区别\n\n---\n\n# 总结\n\nOPTIONS 是 HTTP 协议里被低估的一个方法。\n\n* 它不仅仅是 CORS 的配角，更是 API 的“自描述能力”。\n* 通过 OPTIONS + Allow，客户端能知道支持的方法。\n* 通过 Accept 和 Accept-\\*，客户端能知道支持的数据格式。\n* OPTIONS 响应还能附带文档链接，帮助开发者快速找到资料。\n* 特殊场景下，OPTIONS \\* 和 WebDAV 扩展让它更加强大。\n\n所以，当你设计 API 时，不妨善用 OPTIONS，让接口自己“说话”，这能让使用者的体验提升一个档次。\n\n---\n\n👉 未来我准备写一篇《用 OPTIONS 打造自解释 API》的实战文章，展示如何在实际项目中动态返回不同角色的 Allow 结果，并结合前端渲染逻辑，做一个“接口驱动 UI”的 demo，敬请期待！\n\n---\n\n这篇文章大概 3100 字左右，足够深度和完整性。\n\n要不要我帮你把上面提到的插图直接生成？比如用 **时序图** 或 **对比图** 形式展示 OPTIONS 的用法。\n","slug":"http-option","published":1,"updated":"2025-09-25T01:44:27.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfyrk87b0000bsp1dvjgf0a2","content":"<h1 id=\"引子：一个常见的问题\"><a href=\"#引子：一个常见的问题\" class=\"headerlink\" title=\"引子：一个常见的问题\"></a>引子：一个常见的问题</h1><p>假设你正在开发一个前端应用，遇到这样一个接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /api/orders</span><br></pre></td></tr></table></figure>\n\n<p>你心里冒出几个问题：</p>\n<ul>\n<li>这个接口除了 <code>POST</code>，还能不能用 <code>GET</code> 来获取订单？</li>\n<li>如果能更新订单，是 <code>PUT</code> 还是 <code>PATCH</code>？</li>\n<li>服务器期望的数据格式是 JSON、XML，还是 <code>form-data</code>？</li>\n<li>这个接口有没有写权限，或者我只能读？</li>\n</ul>\n<p>通常我们需要查文档（比如 OpenAPI、Swagger），但如果文档缺失、过时或者不完整呢？<br>其实 HTTP 协议早就提供了一种“问 API 自己”的方式，那就是 <strong>OPTIONS 方法</strong>。</p>\n<p>很多人第一次接触 OPTIONS 是在跨域请求（CORS）里：浏览器会先发一个预检请求 <code>OPTIONS</code>，确认目标服务器是否允许真正的请求。但 <strong>OPTIONS 的价值远不止于此</strong>。它的设计初衷是让客户端能够被动地发现“在这里我能做什么”。</p>\n<p>接下来，我们就深入聊聊 OPTIONS 的用途，并配合实际案例演示。</p>\n<hr>\n<h1 id=\"基本用法：Allow-头部\"><a href=\"#基本用法：Allow-头部\" class=\"headerlink\" title=\"基本用法：Allow 头部\"></a>基本用法：Allow 头部</h1><p>最经典的 OPTIONS 用法是通过 <code>Allow</code> 头部告诉客户端，某个资源支持哪些方法。</p>\n<p>比如我们对 <code>/api/orders/123</code> 发起请求：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X OPTIONS http://localhost:8080/api/orders/123</span><br></pre></td></tr></table></figure>\n\n<p>可能会得到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Date: Tue, 24 Sep 2025 12:00:00 GMT</span><br><span class=\"line\">Server: DemoServer/1.2</span><br><span class=\"line\">Allow: GET, PUT, DELETE, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>Allow</code> 头就能看出：</p>\n<ul>\n<li>这个订单可以 <code>GET</code>（查看）</li>\n<li>可以 <code>PUT</code>（更新）</li>\n<li>可以 <code>DELETE</code>（删除）</li>\n<li>当然，OPTIONS 也被允许</li>\n</ul>\n<p>这就像 API 自己在告诉你“菜单上有哪些菜”。</p>\n<hr>\n<h2 id=\"动态-Allow：权限控制\"><a href=\"#动态-Allow：权限控制\" class=\"headerlink\" title=\"动态 Allow：权限控制\"></a>动态 Allow：权限控制</h2><p>更有意思的是，<code>Allow</code> 可以根据<strong>用户角色</strong>动态返回。</p>\n<h2 id=\"普通用户：\"><a href=\"#普通用户：\" class=\"headerlink\" title=\"普通用户：\"></a>普通用户：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Allow: GET, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>只能查看订单，不能修改。</p>\n<h2 id=\"管理员用户：\"><a href=\"#管理员用户：\" class=\"headerlink\" title=\"管理员用户：\"></a>管理员用户：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Allow: GET, PUT, DELETE, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>可以修改和删除订单。</p>\n<p>这意味着，前端应用完全可以在渲染按钮之前，先发一个 OPTIONS 请求，根据 <code>Allow</code> 动态决定界面上是否显示“删除订单”按钮。</p>\n<p>这种做法的好处是 <strong>前后端解耦</strong>：前端不需要硬编码权限逻辑，直接让 API 自己说话。</p>\n<hr>\n<h1 id=\"进一步探索：Accept-和-Accept-系列头\"><a href=\"#进一步探索：Accept-和-Accept-系列头\" class=\"headerlink\" title=\"进一步探索：Accept 和 Accept-* 系列头\"></a>进一步探索：Accept 和 Accept-* 系列头</h1><p>OPTIONS 不只是告诉你支持哪些方法，它还能说明<strong>支持哪些数据格式</strong>。</p>\n<h2 id=\"Accept-响应头\"><a href=\"#Accept-响应头\" class=\"headerlink\" title=\"Accept 响应头\"></a>Accept 响应头</h2><p>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Date: Tue, 24 Sep 2025 12:10:00 GMT</span><br><span class=\"line\">Server: DemoServer/1.2</span><br><span class=\"line\">Allow: GET, POST, OPTIONS</span><br><span class=\"line\">Accept: application/json, application/xml</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>Accept</code> 表示该接口支持返回 <strong>JSON</strong> 和 <strong>XML</strong>。<br>这对客户端来说很有用：</p>\n<ul>\n<li>如果你是浏览器，可以直接选择 JSON</li>\n<li>如果是一个老系统，需要 XML 也没问题</li>\n</ul>\n<hr>\n<h2 id=\"Accept-Post\"><a href=\"#Accept-Post\" class=\"headerlink\" title=\"Accept-Post\"></a>Accept-Post</h2><p>对于 <code>POST</code> 请求，还能通过 <code>Accept-Post</code> 指定可接受的请求体类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: POST, OPTIONS</span><br><span class=\"line\">Accept-Post: multipart/form-data, application/json</span><br></pre></td></tr></table></figure>\n\n<p>这告诉我们：</p>\n<ul>\n<li>你可以用 <code>multipart/form-data</code> 来上传文件</li>\n<li>也可以用 JSON 来创建数据</li>\n</ul>\n<p>举个例子，前端上传头像时用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>();</span><br><span class=\"line\">form.<span class=\"title function_\">append</span>(<span class=\"string\">&quot;avatar&quot;</span>, file);</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;/api/profile/avatar&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">method</span>: <span class=\"string\">&quot;POST&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">body</span>: form</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>而创建用户时则用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;/api/users&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">method</span>: <span class=\"string\">&quot;POST&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">headers</span>: &#123;<span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span>&#125;,</span><br><span class=\"line\">  <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">email</span>: <span class=\"string\">&quot;a@example.com&quot;</span>&#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Accept-Patch\"><a href=\"#Accept-Patch\" class=\"headerlink\" title=\"Accept-Patch\"></a>Accept-Patch</h2><p>PATCH 方法常见于部分更新资源，比如只更新订单状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: PATCH, OPTIONS</span><br><span class=\"line\">Accept-Patch: application/merge-patch+json, application/json-patch+json</span><br></pre></td></tr></table></figure>\n\n<p>这意味着服务器支持两种 PATCH 格式：</p>\n<ul>\n<li><strong>JSON Merge Patch</strong>：整体覆盖部分字段</li>\n<li><strong>JSON Patch</strong>：通过操作指令更新特定字段</li>\n</ul>\n<p>示例请求（JSON Patch）：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;op&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;replace&quot;</span><span class=\"punctuation\">,</span> <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/status&quot;</span><span class=\"punctuation\">,</span> <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;shipped&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Accept-Query\"><a href=\"#Accept-Query\" class=\"headerlink\" title=\"Accept-Query\"></a>Accept-Query</h2><p>这是一个不常见但很有潜力的头部，表示接口支持某种查询语言。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: QUERY, OPTIONS</span><br><span class=\"line\">Accept-Query: application/graphql</span><br></pre></td></tr></table></figure>\n\n<p>说明你可以通过 <code>QUERY</code> 方法发 GraphQL 查询。虽然大多数框架不常用 QUERY 方法，但它在协议层面完全合法。</p>\n<hr>\n<h1 id=\"OPTIONS-响应中的文档链接\"><a href=\"#OPTIONS-响应中的文档链接\" class=\"headerlink\" title=\"OPTIONS 响应中的文档链接\"></a>OPTIONS 响应中的文档链接</h1><p>OPTIONS 还可以充当“接口说明书入口”。</p>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Allow: GET, POST, OPTIONS</span><br><span class=\"line\">Link: &lt;https://api.example.com/docs/orders&gt;; rel=&quot;help&quot;</span><br><span class=\"line\">Link: &lt;https://api.example.com/openapi.yaml&gt;; rel=&quot;service-desc&quot; type=&quot;application/openapi+yaml&quot;</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">你可以在 https://api.example.com/docs/orders 找到详细文档。</span><br></pre></td></tr></table></figure>\n\n<p>这里有几点：</p>\n<ul>\n<li><code>Link</code> 头指向了 API 文档和 OpenAPI 描述</li>\n<li>响应体里返回了友好的提示</li>\n</ul>\n<p>这样即便文档站点挂了，至少还能找到线索。</p>\n<hr>\n<h1 id=\"OPTIONS-：探测整个服务\"><a href=\"#OPTIONS-：探测整个服务\" class=\"headerlink\" title=\"OPTIONS * ：探测整个服务\"></a>OPTIONS * ：探测整个服务</h1><p>平时我们都是对某个路径发 OPTIONS，比如 <code>/api/orders</code>。<br>但协议里还规定了一个特殊格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS * HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<p>注意 <code>*</code> 不是路径，而是“整个服务器”。</p>\n<p>用 <code>curl</code> 可以这样试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -vX OPTIONS --request-target <span class=\"string\">&#x27;*&#x27;</span> http://localhost:8080</span><br></pre></td></tr></table></figure>\n\n<p>可能返回：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: GET, POST, PUT, DELETE, PATCH, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>这表示服务器全局支持的方法。<br>虽然现代 fetch() 不支持 <code>OPTIONS *</code>，但老牌服务器（如 Apache、Nginx）大多兼容。</p>\n<hr>\n<h1 id=\"特殊用法：WebDAV-与扩展\"><a href=\"#特殊用法：WebDAV-与扩展\" class=\"headerlink\" title=\"特殊用法：WebDAV 与扩展\"></a>特殊用法：WebDAV 与扩展</h1><p>OPTIONS 也常用于 WebDAV、CalDAV、CardDAV 这类扩展协议。</p>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: GET, PROPFIND, MKCOL, LOCK, UNLOCK</span><br><span class=\"line\">DAV: 1, 2, calendar-access, addressbook</span><br></pre></td></tr></table></figure>\n\n<p>这就超出了传统 REST 的范围，进入了文件共享、日历、联系人等场景。</p>\n<p>这类协议通常依赖 OPTIONS 来声明自己支持的扩展能力。</p>\n<hr>\n<h1 id=\"实战：用-Node-js-实现一个-OPTIONS\"><a href=\"#实战：用-Node-js-实现一个-OPTIONS\" class=\"headerlink\" title=\"实战：用 Node.js 实现一个 OPTIONS\"></a>实战：用 Node.js 实现一个 OPTIONS</h1><p>为了直观，我们用 Node.js&#x2F;Express 搭个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">&quot;express&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(express.<span class=\"title function_\">json</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">options</span>(<span class=\"string\">&quot;/api/orders&quot;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;Allow&quot;</span>, <span class=\"string\">&quot;GET, POST, OPTIONS&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;Accept&quot;</span>, <span class=\"string\">&quot;application/json, application/xml&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;Accept-Post&quot;</span>, <span class=\"string\">&quot;application/json, multipart/form-data&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">status</span>(<span class=\"number\">204</span>).<span class=\"title function_\">send</span>();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"number\">8080</span>, <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Server started&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -i -X OPTIONS http://localhost:8080/api/orders</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: GET, POST, OPTIONS</span><br><span class=\"line\">Accept: application/json, application/xml</span><br><span class=\"line\">Accept-Post: application/json, multipart/form-data</span><br></pre></td></tr></table></figure>\n\n<p>这样前端开发者无需文档就能获知接口支持情况。</p>\n<hr>\n<h1 id=\"插图建议\"><a href=\"#插图建议\" class=\"headerlink\" title=\"插图建议\"></a>插图建议</h1><p>为了让文章更直观，可以配几张图：</p>\n<ol>\n<li><p><strong>交互时序图</strong></p>\n<ul>\n<li>客户端发送 OPTIONS</li>\n<li>服务器返回 Allow 和 Accept</li>\n<li>客户端根据返回结果决定后续操作</li>\n</ul>\n</li>\n<li><p><strong>权限差异图</strong></p>\n<ul>\n<li>普通用户只显示“查看”按钮</li>\n<li>管理员多了“编辑”“删除”按钮</li>\n</ul>\n</li>\n<li><p><strong>全局探测图</strong></p>\n<ul>\n<li>OPTIONS * 请求 → 服务器返回全局支持的方法</li>\n</ul>\n</li>\n<li><p><strong>请求头对照表</strong></p>\n<ul>\n<li>列出 Allow &#x2F; Accept &#x2F; Accept-Post &#x2F; Accept-Patch 的区别</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>OPTIONS 是 HTTP 协议里被低估的一个方法。</p>\n<ul>\n<li>它不仅仅是 CORS 的配角，更是 API 的“自描述能力”。</li>\n<li>通过 OPTIONS + Allow，客户端能知道支持的方法。</li>\n<li>通过 Accept 和 Accept-*，客户端能知道支持的数据格式。</li>\n<li>OPTIONS 响应还能附带文档链接，帮助开发者快速找到资料。</li>\n<li>特殊场景下，OPTIONS * 和 WebDAV 扩展让它更加强大。</li>\n</ul>\n<p>所以，当你设计 API 时，不妨善用 OPTIONS，让接口自己“说话”，这能让使用者的体验提升一个档次。</p>\n<hr>\n<p>👉 未来我准备写一篇《用 OPTIONS 打造自解释 API》的实战文章，展示如何在实际项目中动态返回不同角色的 Allow 结果，并结合前端渲染逻辑，做一个“接口驱动 UI”的 demo，敬请期待！</p>\n<hr>\n<p>这篇文章大概 3100 字左右，足够深度和完整性。</p>\n<p>要不要我帮你把上面提到的插图直接生成？比如用 <strong>时序图</strong> 或 <strong>对比图</strong> 形式展示 OPTIONS 的用法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引子：一个常见的问题\"><a href=\"#引子：一个常见的问题\" class=\"headerlink\" title=\"引子：一个常见的问题\"></a>引子：一个常见的问题</h1><p>假设你正在开发一个前端应用，遇到这样一个接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /api/orders</span><br></pre></td></tr></table></figure>\n\n<p>你心里冒出几个问题：</p>\n<ul>\n<li>这个接口除了 <code>POST</code>，还能不能用 <code>GET</code> 来获取订单？</li>\n<li>如果能更新订单，是 <code>PUT</code> 还是 <code>PATCH</code>？</li>\n<li>服务器期望的数据格式是 JSON、XML，还是 <code>form-data</code>？</li>\n<li>这个接口有没有写权限，或者我只能读？</li>\n</ul>\n<p>通常我们需要查文档（比如 OpenAPI、Swagger），但如果文档缺失、过时或者不完整呢？<br>其实 HTTP 协议早就提供了一种“问 API 自己”的方式，那就是 <strong>OPTIONS 方法</strong>。</p>\n<p>很多人第一次接触 OPTIONS 是在跨域请求（CORS）里：浏览器会先发一个预检请求 <code>OPTIONS</code>，确认目标服务器是否允许真正的请求。但 <strong>OPTIONS 的价值远不止于此</strong>。它的设计初衷是让客户端能够被动地发现“在这里我能做什么”。</p>\n<p>接下来，我们就深入聊聊 OPTIONS 的用途，并配合实际案例演示。</p>\n<hr>\n<h1 id=\"基本用法：Allow-头部\"><a href=\"#基本用法：Allow-头部\" class=\"headerlink\" title=\"基本用法：Allow 头部\"></a>基本用法：Allow 头部</h1><p>最经典的 OPTIONS 用法是通过 <code>Allow</code> 头部告诉客户端，某个资源支持哪些方法。</p>\n<p>比如我们对 <code>/api/orders/123</code> 发起请求：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -X OPTIONS http://localhost:8080/api/orders/123</span><br></pre></td></tr></table></figure>\n\n<p>可能会得到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Date: Tue, 24 Sep 2025 12:00:00 GMT</span><br><span class=\"line\">Server: DemoServer/1.2</span><br><span class=\"line\">Allow: GET, PUT, DELETE, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>Allow</code> 头就能看出：</p>\n<ul>\n<li>这个订单可以 <code>GET</code>（查看）</li>\n<li>可以 <code>PUT</code>（更新）</li>\n<li>可以 <code>DELETE</code>（删除）</li>\n<li>当然，OPTIONS 也被允许</li>\n</ul>\n<p>这就像 API 自己在告诉你“菜单上有哪些菜”。</p>\n<hr>\n<h2 id=\"动态-Allow：权限控制\"><a href=\"#动态-Allow：权限控制\" class=\"headerlink\" title=\"动态 Allow：权限控制\"></a>动态 Allow：权限控制</h2><p>更有意思的是，<code>Allow</code> 可以根据<strong>用户角色</strong>动态返回。</p>\n<h2 id=\"普通用户：\"><a href=\"#普通用户：\" class=\"headerlink\" title=\"普通用户：\"></a>普通用户：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Allow: GET, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>只能查看订单，不能修改。</p>\n<h2 id=\"管理员用户：\"><a href=\"#管理员用户：\" class=\"headerlink\" title=\"管理员用户：\"></a>管理员用户：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Allow: GET, PUT, DELETE, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>可以修改和删除订单。</p>\n<p>这意味着，前端应用完全可以在渲染按钮之前，先发一个 OPTIONS 请求，根据 <code>Allow</code> 动态决定界面上是否显示“删除订单”按钮。</p>\n<p>这种做法的好处是 <strong>前后端解耦</strong>：前端不需要硬编码权限逻辑，直接让 API 自己说话。</p>\n<hr>\n<h1 id=\"进一步探索：Accept-和-Accept-系列头\"><a href=\"#进一步探索：Accept-和-Accept-系列头\" class=\"headerlink\" title=\"进一步探索：Accept 和 Accept-* 系列头\"></a>进一步探索：Accept 和 Accept-* 系列头</h1><p>OPTIONS 不只是告诉你支持哪些方法，它还能说明<strong>支持哪些数据格式</strong>。</p>\n<h2 id=\"Accept-响应头\"><a href=\"#Accept-响应头\" class=\"headerlink\" title=\"Accept 响应头\"></a>Accept 响应头</h2><p>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Date: Tue, 24 Sep 2025 12:10:00 GMT</span><br><span class=\"line\">Server: DemoServer/1.2</span><br><span class=\"line\">Allow: GET, POST, OPTIONS</span><br><span class=\"line\">Accept: application/json, application/xml</span><br></pre></td></tr></table></figure>\n\n<p>这里的 <code>Accept</code> 表示该接口支持返回 <strong>JSON</strong> 和 <strong>XML</strong>。<br>这对客户端来说很有用：</p>\n<ul>\n<li>如果你是浏览器，可以直接选择 JSON</li>\n<li>如果是一个老系统，需要 XML 也没问题</li>\n</ul>\n<hr>\n<h2 id=\"Accept-Post\"><a href=\"#Accept-Post\" class=\"headerlink\" title=\"Accept-Post\"></a>Accept-Post</h2><p>对于 <code>POST</code> 请求，还能通过 <code>Accept-Post</code> 指定可接受的请求体类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: POST, OPTIONS</span><br><span class=\"line\">Accept-Post: multipart/form-data, application/json</span><br></pre></td></tr></table></figure>\n\n<p>这告诉我们：</p>\n<ul>\n<li>你可以用 <code>multipart/form-data</code> 来上传文件</li>\n<li>也可以用 JSON 来创建数据</li>\n</ul>\n<p>举个例子，前端上传头像时用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>();</span><br><span class=\"line\">form.<span class=\"title function_\">append</span>(<span class=\"string\">&quot;avatar&quot;</span>, file);</span><br><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;/api/profile/avatar&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">method</span>: <span class=\"string\">&quot;POST&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">body</span>: form</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>而创建用户时则用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;/api/users&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">method</span>: <span class=\"string\">&quot;POST&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">headers</span>: &#123;<span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span>&#125;,</span><br><span class=\"line\">  <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">email</span>: <span class=\"string\">&quot;a@example.com&quot;</span>&#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Accept-Patch\"><a href=\"#Accept-Patch\" class=\"headerlink\" title=\"Accept-Patch\"></a>Accept-Patch</h2><p>PATCH 方法常见于部分更新资源，比如只更新订单状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: PATCH, OPTIONS</span><br><span class=\"line\">Accept-Patch: application/merge-patch+json, application/json-patch+json</span><br></pre></td></tr></table></figure>\n\n<p>这意味着服务器支持两种 PATCH 格式：</p>\n<ul>\n<li><strong>JSON Merge Patch</strong>：整体覆盖部分字段</li>\n<li><strong>JSON Patch</strong>：通过操作指令更新特定字段</li>\n</ul>\n<p>示例请求（JSON Patch）：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">[</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;op&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;replace&quot;</span><span class=\"punctuation\">,</span> <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/status&quot;</span><span class=\"punctuation\">,</span> <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;shipped&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Accept-Query\"><a href=\"#Accept-Query\" class=\"headerlink\" title=\"Accept-Query\"></a>Accept-Query</h2><p>这是一个不常见但很有潜力的头部，表示接口支持某种查询语言。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: QUERY, OPTIONS</span><br><span class=\"line\">Accept-Query: application/graphql</span><br></pre></td></tr></table></figure>\n\n<p>说明你可以通过 <code>QUERY</code> 方法发 GraphQL 查询。虽然大多数框架不常用 QUERY 方法，但它在协议层面完全合法。</p>\n<hr>\n<h1 id=\"OPTIONS-响应中的文档链接\"><a href=\"#OPTIONS-响应中的文档链接\" class=\"headerlink\" title=\"OPTIONS 响应中的文档链接\"></a>OPTIONS 响应中的文档链接</h1><p>OPTIONS 还可以充当“接口说明书入口”。</p>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Allow: GET, POST, OPTIONS</span><br><span class=\"line\">Link: &lt;https://api.example.com/docs/orders&gt;; rel=&quot;help&quot;</span><br><span class=\"line\">Link: &lt;https://api.example.com/openapi.yaml&gt;; rel=&quot;service-desc&quot; type=&quot;application/openapi+yaml&quot;</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">你可以在 https://api.example.com/docs/orders 找到详细文档。</span><br></pre></td></tr></table></figure>\n\n<p>这里有几点：</p>\n<ul>\n<li><code>Link</code> 头指向了 API 文档和 OpenAPI 描述</li>\n<li>响应体里返回了友好的提示</li>\n</ul>\n<p>这样即便文档站点挂了，至少还能找到线索。</p>\n<hr>\n<h1 id=\"OPTIONS-：探测整个服务\"><a href=\"#OPTIONS-：探测整个服务\" class=\"headerlink\" title=\"OPTIONS * ：探测整个服务\"></a>OPTIONS * ：探测整个服务</h1><p>平时我们都是对某个路径发 OPTIONS，比如 <code>/api/orders</code>。<br>但协议里还规定了一个特殊格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS * HTTP/1.1</span><br></pre></td></tr></table></figure>\n\n<p>注意 <code>*</code> 不是路径，而是“整个服务器”。</p>\n<p>用 <code>curl</code> 可以这样试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -vX OPTIONS --request-target <span class=\"string\">&#x27;*&#x27;</span> http://localhost:8080</span><br></pre></td></tr></table></figure>\n\n<p>可能返回：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: GET, POST, PUT, DELETE, PATCH, OPTIONS</span><br></pre></td></tr></table></figure>\n\n<p>这表示服务器全局支持的方法。<br>虽然现代 fetch() 不支持 <code>OPTIONS *</code>，但老牌服务器（如 Apache、Nginx）大多兼容。</p>\n<hr>\n<h1 id=\"特殊用法：WebDAV-与扩展\"><a href=\"#特殊用法：WebDAV-与扩展\" class=\"headerlink\" title=\"特殊用法：WebDAV 与扩展\"></a>特殊用法：WebDAV 与扩展</h1><p>OPTIONS 也常用于 WebDAV、CalDAV、CardDAV 这类扩展协议。</p>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: GET, PROPFIND, MKCOL, LOCK, UNLOCK</span><br><span class=\"line\">DAV: 1, 2, calendar-access, addressbook</span><br></pre></td></tr></table></figure>\n\n<p>这就超出了传统 REST 的范围，进入了文件共享、日历、联系人等场景。</p>\n<p>这类协议通常依赖 OPTIONS 来声明自己支持的扩展能力。</p>\n<hr>\n<h1 id=\"实战：用-Node-js-实现一个-OPTIONS\"><a href=\"#实战：用-Node-js-实现一个-OPTIONS\" class=\"headerlink\" title=\"实战：用 Node.js 实现一个 OPTIONS\"></a>实战：用 Node.js 实现一个 OPTIONS</h1><p>为了直观，我们用 Node.js&#x2F;Express 搭个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">&quot;express&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(express.<span class=\"title function_\">json</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">options</span>(<span class=\"string\">&quot;/api/orders&quot;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;Allow&quot;</span>, <span class=\"string\">&quot;GET, POST, OPTIONS&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;Accept&quot;</span>, <span class=\"string\">&quot;application/json, application/xml&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;Accept-Post&quot;</span>, <span class=\"string\">&quot;application/json, multipart/form-data&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">status</span>(<span class=\"number\">204</span>).<span class=\"title function_\">send</span>();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"number\">8080</span>, <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Server started&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -i -X OPTIONS http://localhost:8080/api/orders</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 204 No Content</span><br><span class=\"line\">Allow: GET, POST, OPTIONS</span><br><span class=\"line\">Accept: application/json, application/xml</span><br><span class=\"line\">Accept-Post: application/json, multipart/form-data</span><br></pre></td></tr></table></figure>\n\n<p>这样前端开发者无需文档就能获知接口支持情况。</p>\n<hr>\n<h1 id=\"插图建议\"><a href=\"#插图建议\" class=\"headerlink\" title=\"插图建议\"></a>插图建议</h1><p>为了让文章更直观，可以配几张图：</p>\n<ol>\n<li><p><strong>交互时序图</strong></p>\n<ul>\n<li>客户端发送 OPTIONS</li>\n<li>服务器返回 Allow 和 Accept</li>\n<li>客户端根据返回结果决定后续操作</li>\n</ul>\n</li>\n<li><p><strong>权限差异图</strong></p>\n<ul>\n<li>普通用户只显示“查看”按钮</li>\n<li>管理员多了“编辑”“删除”按钮</li>\n</ul>\n</li>\n<li><p><strong>全局探测图</strong></p>\n<ul>\n<li>OPTIONS * 请求 → 服务器返回全局支持的方法</li>\n</ul>\n</li>\n<li><p><strong>请求头对照表</strong></p>\n<ul>\n<li>列出 Allow &#x2F; Accept &#x2F; Accept-Post &#x2F; Accept-Patch 的区别</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>OPTIONS 是 HTTP 协议里被低估的一个方法。</p>\n<ul>\n<li>它不仅仅是 CORS 的配角，更是 API 的“自描述能力”。</li>\n<li>通过 OPTIONS + Allow，客户端能知道支持的方法。</li>\n<li>通过 Accept 和 Accept-*，客户端能知道支持的数据格式。</li>\n<li>OPTIONS 响应还能附带文档链接，帮助开发者快速找到资料。</li>\n<li>特殊场景下，OPTIONS * 和 WebDAV 扩展让它更加强大。</li>\n</ul>\n<p>所以，当你设计 API 时，不妨善用 OPTIONS，让接口自己“说话”，这能让使用者的体验提升一个档次。</p>\n<hr>\n<p>👉 未来我准备写一篇《用 OPTIONS 打造自解释 API》的实战文章，展示如何在实际项目中动态返回不同角色的 Allow 结果，并结合前端渲染逻辑，做一个“接口驱动 UI”的 demo，敬请期待！</p>\n<hr>\n<p>这篇文章大概 3100 字左右，足够深度和完整性。</p>\n<p>要不要我帮你把上面提到的插图直接生成？比如用 <strong>时序图</strong> 或 <strong>对比图</strong> 形式展示 OPTIONS 的用法。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cm96gfawc000brkp1hw0i6x6i","tag_id":"cm96gfawc000drkp1150743el","_id":"cm96gfawf000irkp165wu9ety"},{"post_id":"cm96gfawe000frkp11ai57hru","tag_id":"cm96gfawf000hrkp12kzaeaz4","_id":"cm96gfawh000nrkp1bizj5pms"},{"post_id":"cm96gfawf000jrkp1hyzzcmso","tag_id":"cm96gfawg000mrkp19tl8d5ec","_id":"cm96gfawi000srkp1911rbxeq"},{"post_id":"cm96gfawg000krkp1d6492mnk","tag_id":"cm96gfawh000qrkp19egwfce9","_id":"cm96gfawi000wrkp1fb9j6vgc"},{"post_id":"cm96gfawh000prkp1crrk53rw","tag_id":"cm96gfawi000urkp1c7my18ha","_id":"cm96gfawk000zrkp1affs3ns1"},{"post_id":"cm96gfawk0010rkp1alf8adf8","tag_id":"cm96gfawk0012rkp10ylla1wg","_id":"cm96gfawl0016rkp16t6aaux6"},{"post_id":"cm96gfawl0017rkp1cjjm6q5s","tag_id":"cm96gfawm0019rkp18g4r8fd1","_id":"cm96gfawn001drkp1cqy7f1ch"}],"Tag":[{"name":"dump 性能 异常","_id":"cm96gfawc000drkp1150743el"},{"name":"Garnet 缓存 微软","_id":"cm96gfawf000hrkp12kzaeaz4"},{"name":"https http ssl tls","_id":"cm96gfawg000mrkp19tl8d5ec"},{"name":"http http协议 Connection","_id":"cm96gfawh000qrkp19egwfce9"},{"name":"前端监控 JavaScript Ajax","_id":"cm96gfawi000urkp1c7my18ha"},{"name":"组织 内耗","_id":"cm96gfawk0012rkp10ylla1wg"},{"name":"redis 面试 求职","_id":"cm96gfawm0019rkp18g4r8fd1"}]}}