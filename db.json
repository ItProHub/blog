{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/hello-bg.png","path":"images/hello-bg.png","modified":0,"renderable":0},{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon_bak.ico","path":"assets/favicon_bak.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/wechat_qr.jpg","path":"assets/wechat_qr.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Jason.jpg","path":"avatar/Jason.jpg","modified":0,"renderable":1},{"_id":"source/images/http/http-request.png","path":"images/http/http-request.png","modified":0,"renderable":0},{"_id":"source/images/http/request-methods.png","path":"images/http/request-methods.png","modified":0,"renderable":0},{"_id":"source/images/http/TCP-connection-1.png","path":"images/http/TCP-connection-1.png","modified":0,"renderable":0},{"_id":"source/images/http/curl-header.png","path":"images/http/curl-header.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-1.png","path":"images/http/handshake-1.png","modified":0,"renderable":0},{"_id":"source/images/http/perisitent-connection.png","path":"images/http/perisitent-connection.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect.png","path":"images/http/auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/http/auto-disconnect2.png","path":"images/http/auto-disconnect2.png","modified":0,"renderable":0},{"_id":"source/images/http/handshake-2.png","path":"images/http/handshake-2.png","modified":0,"renderable":0},{"_id":"source/images/http/http-keep-alive-header.png","path":"images/http/http-keep-alive-header.png","modified":0,"renderable":0},{"_id":"source/images/internal-loss/depressed.jpg","path":"images/internal-loss/depressed.jpg","modified":0,"renderable":0},{"_id":"source/images/http/timeout-auto-disconnect.png","path":"images/http/timeout-auto-disconnect.png","modified":0,"renderable":0},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","path":"images/internal-loss/20231109_sy_01.jpg","modified":0,"renderable":0},{"_id":"source/images/internal-loss/996.jpg","path":"images/internal-loss/996.jpg","modified":0,"renderable":0},{"_id":"source/images/garnet/client.png","path":"images/garnet/client.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compatible.png","path":"images/garnet/compatible.png","modified":0,"renderable":0},{"_id":"source/images/garnet/compare1.png","path":"images/garnet/compare1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/log.png","path":"images/garnet/log.png","modified":0,"renderable":0},{"_id":"source/images/garnet/1.png","path":"images/garnet/1.png","modified":0,"renderable":0},{"_id":"source/images/garnet/connect.png","path":"images/garnet/connect.png","modified":0,"renderable":0},{"_id":"source/images/garnet/custom-command.png","path":"images/garnet/custom-command.png","modified":0,"renderable":0},{"_id":"source/images/https/bg.jpg","path":"images/https/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/https/expire.png","path":"images/https/expire.png","modified":0,"renderable":0},{"_id":"source/images/garnet/running.png","path":"images/garnet/running.png","modified":0,"renderable":0},{"_id":"source/images/https/ca.png","path":"images/https/ca.png","modified":0,"renderable":0},{"_id":"source/images/https/ca2.png","path":"images/https/ca2.png","modified":0,"renderable":0},{"_id":"source/images/https/client-hello.png","path":"images/https/client-hello.png","modified":0,"renderable":0},{"_id":"source/images/https/encrypted.png","path":"images/https/encrypted.png","modified":0,"renderable":0},{"_id":"source/images/https/security.png","path":"images/https/security.png","modified":0,"renderable":0},{"_id":"source/images/https/negotiated-cipher-suite.png","path":"images/https/negotiated-cipher-suite.png","modified":0,"renderable":0},{"_id":"source/images/https/cipher-suites.png","path":"images/https/cipher-suites.png","modified":0,"renderable":0},{"_id":"source/images/https/handshake.png","path":"images/https/handshake.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/recruitment.png","path":"images/redis-interview/recruitment.png","modified":0,"renderable":0},{"_id":"source/images/dump/bg.png","path":"images/dump/bg.png","modified":0,"renderable":0},{"_id":"source/images/dump/crash.jpeg","path":"images/dump/crash.jpeg","modified":0,"renderable":0},{"_id":"source/images/redis-interview/bg.png","path":"images/redis-interview/bg.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-avalanche.png","path":"images/redis-interview/cache-avalanche.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-breakdown.png","path":"images/redis-interview/cache-breakdown.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/memory.png","path":"images/redis-interview/memory.png","modified":0,"renderable":0},{"_id":"source/images/redis-interview/cache-penetration.png","path":"images/redis-interview/cache-penetration.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_2.png","path":"images/dump/windbg_2.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_4.png","path":"images/dump/windbg_4.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_1.png","path":"images/dump/windbg_1.png","modified":0,"renderable":0},{"_id":"source/images/dump/windbg_3.png","path":"images/dump/windbg_3.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/bg.jpg","path":"images/dead-message/bg.jpg","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","path":"images/dead-message/dead-letter-exchange-1.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-2.jpg","path":"images/dead-message/dead-letter-2.jpg","modified":0,"renderable":0},{"_id":"source/images/dead-message/dead-letter-3.png","path":"images/dead-message/dead-letter-3.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_2.png","path":"images/dead-message/delay_comsuption_2.png","modified":0,"renderable":0},{"_id":"source/images/dead-message/delay_comsuption_1.png","path":"images/dead-message/delay_comsuption_1.png","modified":0,"renderable":0},{"_id":"source/images/image-search/images.png","path":"images/image-search/images.png","modified":1,"renderable":0},{"_id":"source/images/image-search/search.gif","path":"images/image-search/search.gif","modified":1,"renderable":0},{"_id":"source/images/task-completion-source/pause-1.png","path":"images/task-completion-source/pause-1.png","modified":1,"renderable":0},{"_id":"source/images/task-completion-source/pause-2.png","path":"images/task-completion-source/pause-2.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world-bak.md1","hash":"1e16dbc0dbf8b18e83f47dbbdffd0d1f27cfe955","modified":1710398484836},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688482306000},{"_id":"themes/archer/.eslintignore","hash":"304e696987e3f31cd0a7a13a835d58d8bda3aa6c","modified":1688482306000},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1688482306000},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1688482306000},{"_id":"themes/archer/.gitignore","hash":"9a5e5d0a05fc5bee9bf00a0c5cefc712b4bf0904","modified":1688482306000},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1688482306000},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1688482306000},{"_id":"themes/archer/.prettierignore","hash":"29648a30c14f6df709eb6610f506c82825910cc8","modified":1688482306000},{"_id":"source/_posts/hello-world.md","hash":"3c422ea24b75465e6ea2a80c268251ca0a03e042","modified":1714100836002},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1688482306000},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1688482306000},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1688482306000},{"_id":"themes/archer/package.json","hash":"81af75826e854ac80f6337dc4f1ce4b51f066b0b","modified":1688482306000},{"_id":"themes/archer/_config.yml","hash":"0dd04e79b90209217c5bdff1e8160f2976b30312","modified":1710819811209},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1688482306000},{"_id":"themes/archer/README.md","hash":"63eb0f874bc056d407ee343f853adee9a5765434","modified":1688482306000},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1688482306000},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1688482306000},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1688482306000},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1688482306000},{"_id":"themes/archer/docs/README-en.md","hash":"f5e40c5803071bd6dafc94070c6939aa0c02d061","modified":1688482306000},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"c62510d3d14b38126b5a86ff30416cb71abc1d9a","modified":1688482306000},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"451b304c1a5d081313f0532a4f5665f0855d4cfd","modified":1688482306000},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1688482306000},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1688482306000},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1688482306000},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1688482306000},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1688482306000},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"edb6b06041660beb656fd5e4062d5a21577cbb3a","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"55e843652d99fae32534a7630e698d2394020baf","modified":1688482306000},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"05f24b2df012808f6410f1ef2230d4fd1a5d6cf5","modified":1688482306000},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1688482306000},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1688482306000},{"_id":"themes/archer/layout/layout.ejs","hash":"1bee90a75c1f4b04c90421419dd68acdec15b998","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1688482306000},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"18365516cd8819de853716f0d47a72a60a5edc46","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"236e6550d94519d44292e6b14e30ea8234050025","modified":1711684219591},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"687c08823e7ce43e6ebb44f2fb4b75549abfed29","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1688482306000},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1688482306000},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1688482306000},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1688482306000},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1688482306000},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"f63032391dd75905b6663628a9ca231fa0283350","modified":1688482306000},{"_id":"themes/archer/source/assets/favicon_bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1688482306000},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1688482306000},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1688482306000},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1688482306000},{"_id":"themes/archer/source/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1688482306000},{"_id":"themes/archer/source/assets/wechat_qr.jpg","hash":"20763d666624facc585e34645018deadb343b4b5","modified":1705482083315},{"_id":"themes/archer/source/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1688482306000},{"_id":"themes/archer/source/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1688482306000},{"_id":"themes/archer/source/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1688482306000},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1688482306000},{"_id":"themes/archer/source/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1688482306000},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1688482306000},{"_id":"themes/archer/source/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1688482306000},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1688482306000},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1688482306000},{"_id":"themes/archer/source/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1688482306000},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1688482306000},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1688482306000},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1688482306000},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1688482306000},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1688482306000},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1688482306000},{"_id":"themes/archer/src/js/main.js","hash":"658565fbf20adc5b9b237a53c973d0685ce60202","modified":1688482306000},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1688482306000},{"_id":"themes/archer/src/js/sidebar.js","hash":"2518f2b0b7947530851e6c73245dddc96a618a08","modified":1688482306000},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1688482306000},{"_id":"themes/archer/src/js/scroll.js","hash":"3017b329329888b287ad233831138428475749be","modified":1688482306000},{"_id":"themes/archer/src/js/toc.js","hash":"96a7e07d1976eb29a77799ac2b7abb47907f4b45","modified":1688482306000},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1688482306000},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1688482306000},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1688482306000},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1688482306000},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1688482306000},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1688482306000},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1688482306000},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1688482306000},{"_id":"themes/archer/src/scss/mobile.scss","hash":"2b542af943a8502aae26362dd2af1fbcf68eac1c","modified":1688482306000},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1688482306000},{"_id":"themes/archer/source/avatar/Jason.jpg","hash":"0eae332ea91f9e04b54f35d2ed1b17b5b37aee64","modified":1710397722571},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1688482306000},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1688482306000},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1688482306000},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1688482306000},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"91dc2a0c1ca8d25b1f27d91fa1c81ceb5ff8c3bc","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"7583c8c2004e333c5b94e4b868ac778357e0d21e","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1688482306000},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"ce683553806293fea0466f363b18de0ee341dd4e","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1688482306000},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"57accaee4bb5b502d5d3e94c7981ac6996804cf0","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1688482306000},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1688482306000},{"_id":"themes/archer/source/assets/favicon.ico","hash":"c136618e070daf370da961ac730973293a088b9e","modified":1710382119333},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1688482306000},{"_id":"themes/archer/source/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1688482306000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1688482306000},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1688482306000},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1688482306000},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1688482306000},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1688482306000},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1688482306000},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1688482306000},{"_id":"themes/archer/source/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1688482306000},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1688482306000},{"_id":"themes/archer/source/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1688482306000},{"_id":"themes/archer/package-lock.json","hash":"400ab1cc2a2f1380a5e9ab69abe3a5b93f923d8d","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1688482306000},{"_id":"themes/archer/source/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1688482306000},{"_id":"source/images/hello-bg.png","hash":"f70f2a6805ceb4ab1175e391c03923b7264bc431","modified":1705386424945},{"_id":"themes/archer/source/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1688482306000},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1688482306000},{"_id":"public/index.html","hash":"f025dd61ff56e7eebc3475a3c9d7f434c3909600","modified":1713255953227},{"_id":"public/2024/03/13/hello-world/index.html","hash":"4bf0b296c696bab720be5dcec3e6b959ce39cb6d","modified":1713255953227},{"_id":"public/archives/index.html","hash":"11ad5b8b9080e766721066453dbc969fce5154e3","modified":1713255953227},{"_id":"public/archives/2024/index.html","hash":"61a561d1066a58c3b3640c451d4e830ce36bb500","modified":1713255953227},{"_id":"public/archives/2024/03/index.html","hash":"d36a33e3caa67d60e085245ce530e16fd1525c2f","modified":1713255953227},{"_id":"public/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1713255953227},{"_id":"public/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1713255953227},{"_id":"public/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1713255953227},{"_id":"public/assets/favicon_bak.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1713255953227},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1713255953227},{"_id":"public/assets/wechat_qr.jpg","hash":"20763d666624facc585e34645018deadb343b4b5","modified":1713255953227},{"_id":"public/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1713255953227},{"_id":"public/css/dark.css.map","hash":"f49556935deae49df3158c2eb2265464129ef978","modified":1713255953227},{"_id":"public/css/mobile.css.map","hash":"c9f9dade45b119ae2eb7a93be0160baef4d494f8","modified":1713255953227},{"_id":"public/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1713255953227},{"_id":"public/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1713255953227},{"_id":"public/scripts/customFontLoader.js.map","hash":"702a44b0b1b450263592bfb1199c8d36ea9834a2","modified":1713255953227},{"_id":"public/scripts/dark.js.map","hash":"feb9e1905c4b313b839c1c3b69ad61c05f265a9a","modified":1713255953227},{"_id":"public/scripts/main.js.LICENSE.txt","hash":"959bfc660011bc6a0800fe9e7974080f64c062aa","modified":1713255953227},{"_id":"public/scripts/search.js.LICENSE.txt","hash":"2c9b607ded909550f2ed2d0f2e7271781d9f78d9","modified":1713255953227},{"_id":"public/avatar/Jason.jpg","hash":"0eae332ea91f9e04b54f35d2ed1b17b5b37aee64","modified":1713255953227},{"_id":"public/assets/favicon.ico","hash":"c136618e070daf370da961ac730973293a088b9e","modified":1713255953227},{"_id":"public/css/style.css.map","hash":"dbe8f8c1fccf8bd9d28ecf3874036a2281319aa0","modified":1713255953227},{"_id":"public/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1713255953227},{"_id":"public/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1713255953227},{"_id":"public/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1713255953227},{"_id":"public/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1713255953227},{"_id":"public/css/dark.css","hash":"4db211216f16a5e66d4d499158f4005a1bbb39f5","modified":1713255953227},{"_id":"public/css/mobile.css","hash":"acb0dfcce26ec93f59c6ec4936006abbe8daefee","modified":1713255953227},{"_id":"public/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1713255953227},{"_id":"public/scripts/customFontLoader.js","hash":"7c2f03fbd2b8340b77b1b02778a34e5ac10b560c","modified":1713255953227},{"_id":"public/scripts/dark.js","hash":"28ba818b2ab8a9454a52fe2710b5a8a81a195e4d","modified":1713255953227},{"_id":"public/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1713255953227},{"_id":"public/scripts/share.js.map","hash":"1e018aa465800a066480e33c848f380880af6743","modified":1713255953227},{"_id":"public/scripts/share.js","hash":"2210dd8dacea4f1ca11c0047dfafd0a170abd953","modified":1713255953227},{"_id":"public/css/style.css","hash":"f08b1ec3a5fe1bf936401a238d55e0487296b42c","modified":1713255953227},{"_id":"public/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1713255953227},{"_id":"public/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1713255953227},{"_id":"public/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1713255953227},{"_id":"public/images/hello-bg.png","hash":"f70f2a6805ceb4ab1175e391c03923b7264bc431","modified":1713255953227},{"_id":"public/scripts/search.js.map","hash":"bd469588b3bee82b3cf72b72d447c854f4d76875","modified":1713255953227},{"_id":"public/scripts/search.js","hash":"ac8e9d130ea410832a421d661898abee63bd8e67","modified":1713255953227},{"_id":"public/scripts/main.js.map","hash":"79d928070b7e5333ca241c5563ab4fe9cab31b74","modified":1713255953227},{"_id":"public/scripts/main.js","hash":"11fd75dddcbef7157fbfb8717b3463a80fda1fb3","modified":1713255953227},{"_id":"source/_posts/http.md","hash":"e538858062edce06c26c8060d05f61b3e6fe772b","modified":1714100804259},{"_id":"source/images/http-request.png","hash":"eed1c7354200ef63062c4290552839cea43c5c07","modified":1710907639923},{"_id":"source/images/http/http-request.png","hash":"4d29675c37a4cc0df885db03cff820aa3f98080c","modified":1710926387387},{"_id":"source/images/http/request-methods.png","hash":"5914a2642fc3c771aaddbb5a4db79d020c75ba27","modified":1710917201189},{"_id":"source/images/http/handshake-1.png","hash":"698f25b0696249dbbadbf1b71ea5e3e48b57348e","modified":1711100170452},{"_id":"source/images/http/curl-header.png","hash":"e5c4a20f54045759a1a29f7f35a344d45ee51ecb","modified":1711013282028},{"_id":"source/images/http/TCP-connection-1.png","hash":"588cade2c5e791bee0f282a6290889ba15c3a039","modified":1711091658444},{"_id":"source/images/http/perisitent-connection.png","hash":"0e16961aaa4851908823dccfa904d3f4f6989c08","modified":1711092222874},{"_id":"source/_posts/organization-internal-loss.md","hash":"b157730ebdda6cfd58233ff8ec9d9bfed27d37b1","modified":1714100795957},{"_id":"source/images/http/http-keep-alive-header.png","hash":"d2b1f6ccc2903ffbd4308627c2562b42c80a2cb7","modified":1711435826469},{"_id":"source/images/http/handshake-2.png","hash":"f50dd3fab7ff21a20cd91622aefb077b7ec74b89","modified":1711353457535},{"_id":"source/images/http/timeout-auto-disconnect.png","hash":"87f74686dc596abb5be91260a40dcf38ed3d0d17","modified":1711433208748},{"_id":"source/images/http/auto-disconnect.png","hash":"6eb07b19f5350b86e32c41503abdef786d1cc8a3","modified":1711368567428},{"_id":"source/images/internal-loss/depressed.jpg","hash":"8ff19e979ef211030d79fc29eca3bef0ed42f9e9","modified":1711678444570},{"_id":"source/images/http/auto-disconnect2.png","hash":"d96b55fe2a3d138263e29ec9ba3a171b78eaf003","modified":1711356920847},{"_id":"source/_posts/garnet.md","hash":"9fa10e3a47f78d4b6f8465f3e49e33da56758f21","modified":1714100842478},{"_id":"source/images/internal-loss/996.jpg","hash":"d712414d1167ea1a5790683d549a3dbf56cc3c8c","modified":1711684344049},{"_id":"source/images/internal-loss/20231109_sy_01.jpg","hash":"f637ac12cf901b7e557077687482f7232bbc2a72","modified":1711685199687},{"_id":"source/_posts/https.md","hash":"00df307cec478b57c6b9ab848f2b3d2ef578098a","modified":1714100800272},{"_id":"source/images/garnet/compatible.png","hash":"1714c1d5f1c6fd0421b4594015595976b5fd4ee4","modified":1712567994543},{"_id":"source/images/garnet/compare1.png","hash":"ed8a21697688433ffe376d2a4ccaa7ec53c667ff","modified":1712648062046},{"_id":"source/images/garnet/client.png","hash":"4889111b6b22a0f07ed3e80b70ee4e1e99c8045e","modified":1712652420303},{"_id":"source/images/https/expire.png","hash":"801009fef98fa9d46a677f153f097e6476c139e2","modified":1712824416637},{"_id":"source/images/garnet/connect.png","hash":"82d4fc4511b032c7c797018845ca40d83ac7aa9d","modified":1712650225409},{"_id":"source/images/garnet/custom-command.png","hash":"bea263307a51c77205885ace2c3060272e444339","modified":1712736760989},{"_id":"source/images/garnet/1.png","hash":"0d8a64004413ec34a334cce4925372781b3c88b0","modified":1712566365601},{"_id":"source/images/garnet/log.png","hash":"0c32a044823dd2b85353c2816c9109c9df0626b4","modified":1712721260633},{"_id":"source/images/garnet/running.png","hash":"3253e7a14adf9509baead2613151f614a0012ab5","modified":1712567881514},{"_id":"source/images/https/bg.jpg","hash":"9424b491fdae5f8c91344596469c3980217e2206","modified":1712821936174},{"_id":"source/images/https/ca.png","hash":"a3f65f3b7f108a2e18c61d13c3024d761586a9ca","modified":1712826407187},{"_id":"source/images/https/encrypted.png","hash":"51f01f7c79cbb8e5ace366b423a46c677483d4f3","modified":1712827358003},{"_id":"source/images/https/client-hello.png","hash":"65039f3b5656ce343d9c36842642aedef464f9d1","modified":1712827328350},{"_id":"source/images/https/ca2.png","hash":"e71ae267fc6a9eda8943e4881e2f408b0a84055f","modified":1712827074795},{"_id":"source/images/https/security.png","hash":"e040846f476100e1ac38f67dec1fc9735978fc9f","modified":1713148972216},{"_id":"source/images/https/handshake.png","hash":"9d2b92013eb6b78a0f3b84855a383b29962da2ba","modified":1713152131440},{"_id":"source/images/https/negotiated-cipher-suite.png","hash":"32d7a6f6ad24e6c5755d2ba2626e0ba71520fd50","modified":1713149675775},{"_id":"source/images/https/cipher-suites.png","hash":"e9faeff8e36d3efd82a5a0800c85a8e23d6ebf56","modified":1713149632927},{"_id":"public/2024/04/11/https/index.html","hash":"2362c2a6c75b4e53e8b103cbd0b2835a053c196d","modified":1713255953227},{"_id":"public/2024/04/07/garnet/index.html","hash":"7cff3ee5ac31859ab0e80195973947cb53b47b7f","modified":1713255953227},{"_id":"public/2024/03/28/organization-internal-loss/index.html","hash":"0f5834ba9bf426bc3eaa541aad3e766ab0999293","modified":1713255953227},{"_id":"public/2024/03/19/http/index.html","hash":"a4dbd8c74d50450f71d405b53817e86e364bd775","modified":1713255953227},{"_id":"public/archives/2024/04/index.html","hash":"568ad7f062ee32b31612d64d952b5b0bb9d75d5e","modified":1713255953227},{"_id":"public/tags/http-http协议-Connection/index.html","hash":"d3497d1a24185c46cbedbaf85f299faa6b8a3bbc","modified":1713255953227},{"_id":"public/tags/组织-内耗/index.html","hash":"d61eae406afac4c434fce25687e14d64f23503d2","modified":1713255953227},{"_id":"public/tags/Garnet-缓存-微软/index.html","hash":"c4ced32b5309e68eb92157930783b0c1be407091","modified":1713255953227},{"_id":"public/tags/https-http-ssl-tls/index.html","hash":"919e587f1e97e883ec79744b4e764b6dd551bd7f","modified":1713255953227},{"_id":"public/images/http/http-request.png","hash":"4d29675c37a4cc0df885db03cff820aa3f98080c","modified":1713255953227},{"_id":"public/images/http/TCP-connection-1.png","hash":"588cade2c5e791bee0f282a6290889ba15c3a039","modified":1713255953227},{"_id":"public/images/http/handshake-1.png","hash":"698f25b0696249dbbadbf1b71ea5e3e48b57348e","modified":1713255953227},{"_id":"public/images/http/curl-header.png","hash":"e5c4a20f54045759a1a29f7f35a344d45ee51ecb","modified":1713255953227},{"_id":"public/images/http/perisitent-connection.png","hash":"0e16961aaa4851908823dccfa904d3f4f6989c08","modified":1713255953227},{"_id":"public/images/internal-loss/depressed.jpg","hash":"8ff19e979ef211030d79fc29eca3bef0ed42f9e9","modified":1713255953227},{"_id":"public/images/http/http-keep-alive-header.png","hash":"d2b1f6ccc2903ffbd4308627c2562b42c80a2cb7","modified":1713255953227},{"_id":"public/images/garnet/client.png","hash":"4889111b6b22a0f07ed3e80b70ee4e1e99c8045e","modified":1713255953227},{"_id":"public/images/garnet/compatible.png","hash":"1714c1d5f1c6fd0421b4594015595976b5fd4ee4","modified":1713255953227},{"_id":"public/images/garnet/compare1.png","hash":"ed8a21697688433ffe376d2a4ccaa7ec53c667ff","modified":1713255953227},{"_id":"public/images/garnet/connect.png","hash":"82d4fc4511b032c7c797018845ca40d83ac7aa9d","modified":1713255953227},{"_id":"public/images/garnet/custom-command.png","hash":"bea263307a51c77205885ace2c3060272e444339","modified":1713255953227},{"_id":"public/images/https/bg.jpg","hash":"9424b491fdae5f8c91344596469c3980217e2206","modified":1713255953227},{"_id":"public/images/https/expire.png","hash":"801009fef98fa9d46a677f153f097e6476c139e2","modified":1713255953227},{"_id":"public/images/garnet/running.png","hash":"3253e7a14adf9509baead2613151f614a0012ab5","modified":1713255953227},{"_id":"public/images/https/ca.png","hash":"a3f65f3b7f108a2e18c61d13c3024d761586a9ca","modified":1713255953227},{"_id":"public/images/https/security.png","hash":"e040846f476100e1ac38f67dec1fc9735978fc9f","modified":1713255953227},{"_id":"public/images/https/handshake.png","hash":"9d2b92013eb6b78a0f3b84855a383b29962da2ba","modified":1713255953227},{"_id":"public/images/http/auto-disconnect.png","hash":"6eb07b19f5350b86e32c41503abdef786d1cc8a3","modified":1713255953227},{"_id":"public/images/http/timeout-auto-disconnect.png","hash":"87f74686dc596abb5be91260a40dcf38ed3d0d17","modified":1713255953227},{"_id":"public/images/internal-loss/20231109_sy_01.jpg","hash":"f637ac12cf901b7e557077687482f7232bbc2a72","modified":1713255953227},{"_id":"public/images/http/handshake-2.png","hash":"f50dd3fab7ff21a20cd91622aefb077b7ec74b89","modified":1713255953227},{"_id":"public/images/garnet/log.png","hash":"0c32a044823dd2b85353c2816c9109c9df0626b4","modified":1713255953227},{"_id":"public/images/garnet/1.png","hash":"0d8a64004413ec34a334cce4925372781b3c88b0","modified":1713255953227},{"_id":"public/images/internal-loss/996.jpg","hash":"d712414d1167ea1a5790683d549a3dbf56cc3c8c","modified":1713255953227},{"_id":"public/images/http/auto-disconnect2.png","hash":"d96b55fe2a3d138263e29ec9ba3a171b78eaf003","modified":1713255953227},{"_id":"public/images/https/encrypted.png","hash":"51f01f7c79cbb8e5ace366b423a46c677483d4f3","modified":1713255953227},{"_id":"public/images/https/negotiated-cipher-suite.png","hash":"32d7a6f6ad24e6c5755d2ba2626e0ba71520fd50","modified":1713255953227},{"_id":"public/images/https/cipher-suites.png","hash":"e9faeff8e36d3efd82a5a0800c85a8e23d6ebf56","modified":1713255953227},{"_id":"public/images/http/request-methods.png","hash":"5914a2642fc3c771aaddbb5a4db79d020c75ba27","modified":1713255953227},{"_id":"public/images/https/client-hello.png","hash":"65039f3b5656ce343d9c36842642aedef464f9d1","modified":1713255953227},{"_id":"public/images/https/ca2.png","hash":"e71ae267fc6a9eda8943e4881e2f408b0a84055f","modified":1713255953227},{"_id":"source/_posts/redis-interview.md","hash":"f83cab69b0f20b5d7300c5e68729006e9be6d913","modified":1713425000574},{"_id":"source/images/redis-interview/recruitment.png","hash":"9da7eff910bfb50b7f11618614003b6153e71d98","modified":1713425715760},{"_id":"source/_posts/redis-interview-1.md","hash":"951b57d41f67b3f9287684d1808c63e0ab08023d","modified":1714102286087},{"_id":"source/_posts/dump.md","hash":"fc0d11e98d4a2c35e8f590fc901c33ec87cf1654","modified":1715157478693},{"_id":"source/images/dump/crash.jpeg","hash":"e25f4327f9073e01e8b1a3e13c209ca732880e15","modified":1714290837084},{"_id":"source/images/redis-interview/memory.png","hash":"37fadd91ec8573c6c30ec5fd32562f2c3d22d5a9","modified":1714031983730},{"_id":"source/images/dump/bg.png","hash":"32c7ad31ef1117233e7691e74198041f62870e63","modified":1714290251488},{"_id":"source/images/redis-interview/cache-avalanche.png","hash":"8bcdb1787aa12c08febeb8c2324cf7fa9c6d3c02","modified":1714100497420},{"_id":"source/images/redis-interview/bg.png","hash":"e5be0650aa2343b4a62218b58ebae10c4f4b9ba6","modified":1714101428369},{"_id":"source/images/redis-interview/cache-breakdown.png","hash":"de31f8ba0958f9428c1148746206f8351fa1bf18","modified":1714100525728},{"_id":"source/images/redis-interview/cache-penetration.png","hash":"17f21e18052f40f20189a31c4bfbf749a1dedcbc","modified":1714100540904},{"_id":"source/images/dump/windbg_3.png","hash":"47fa0c7ac253a9a44eef9bc6d5dce90d96445ba2","modified":1715068901454},{"_id":"source/images/dump/windbg_2.png","hash":"e55722d89679167f37e0b851a53e27ae989663f8","modified":1714439116512},{"_id":"source/images/dump/windbg_4.png","hash":"5618b95c756aab451803e23e9c0f77b5fa94e6b4","modified":1715069009388},{"_id":"source/images/dump/windbg_1.png","hash":"fec01b96435a46269b0a241c8feb13764458b0e9","modified":1714438955774},{"_id":"source/_posts/dead-message.md","hash":"e0a8e83a589cd97cb599fd243d348f4b1896eb71","modified":1716628987803},{"_id":"source/images/dead-message/bg.jpg","hash":"e0de32bdd097eeb58f534882e876a282606db679","modified":1716366165441},{"_id":"source/images/dead-message/dead-letter-exchange-1.png","hash":"7b141675f4bd37c8d65a63b5d22612430b945720","modified":1716621402662},{"_id":"source/images/dead-message/dead-letter-2.jpg","hash":"424a4237b4485e845ed3e9e6e74ee1f34485d196","modified":1716542966790},{"_id":"source/_posts/TaskCompletionSource.md","hash":"a2bcfbda71ac8d8406e1bd14fa333169457384e5","modified":1717658556858},{"_id":"source/images/dead-message/delay_comsuption_2.png","hash":"f9b57ebe4ba7cefabad08a139f92e619fd1aae8f","modified":1716627676317},{"_id":"source/images/dead-message/dead-letter-3.png","hash":"d8017b10c2efd5448993b92f0a35783e4d0b71f7","modified":1716626485267},{"_id":"source/images/dead-message/delay_comsuption_1.png","hash":"c093bbb3f975f40087d037aa56b8fd32ed866332","modified":1716627815685},{"_id":"source/_posts/similar-image-search.md","hash":"a91310abbb89d6e291d0a697c2a966b177c92ed6","modified":1717765757632},{"_id":"source/images/task-completion-source/pause-2.png","hash":"f681d83790b004e1703e18560c2f7d2db0cd6d01","modified":1717658059375},{"_id":"source/images/task-completion-source/pause-1.png","hash":"14d301e1283ad280dd8ea0525be0e5c38531ef74","modified":1717658041988},{"_id":"source/images/image-search/search.gif","hash":"eb44e6dcab6b4292eb95ef63cbf64035ed01c878","modified":1717770772367},{"_id":"source/images/image-search/images.png","hash":"b2a77e00a2290543613f0df77f8c30337c91f441","modified":1717681798910}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"欢迎来到 ITProHub！","_content":"![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/hello-world.md","raw":"---\ntitle: 欢迎来到 ITProHub！\n---\n![background](/images/hello-bg.png)\n# 🌐 欢迎来到 ITProHub！\n\n## 🚀 你的信息技术专业中心 🚀\n\n在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。\n\n### 🔍 ITPro: 专业的信息技术支持\n\n无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。\n\n### 💼 Hub: 中心化的资源和社区\n\nITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。\n\n#### ✨ 我们的特色服务和内容包括：\n\n🎓 专业的IT技能培训课程\n\n📰 行业趋势和技术文章分享\n\n🚀 职业发展指导和招聘信息\n\n💬 与专业人士互动的社交平台\n\n👥 加入我们的社区，你将获得：\n\n与同行专业人士的互动和交流机会\n\n获取实用的职业发展建议和技术支持\n\n参与丰富多彩的线上和线下活动\n\n无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。\n\n\n## 🌐 探索无限可能，加入 ITProHub ！🌐\n\n公众号将不定期更新，欢迎订阅！\n\n#ITProHub #信息技术 #专业发展 #社区交流\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"hello-world","published":1,"date":"2024-03-13T07:54:13.172Z","updated":"2024-04-26T03:07:16.002Z","_id":"cltwq4btx0000f4p1f3yha908","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/hello-bg.png\" alt=\"background\"></p>\n<h1 id=\"🌐-欢迎来到-ITProHub！\"><a href=\"#🌐-欢迎来到-ITProHub！\" class=\"headerlink\" title=\"🌐 欢迎来到 ITProHub！\"></a>🌐 欢迎来到 ITProHub！</h1><h2 id=\"🚀-你的信息技术专业中心-🚀\"><a href=\"#🚀-你的信息技术专业中心-🚀\" class=\"headerlink\" title=\"🚀 你的信息技术专业中心 🚀\"></a>🚀 你的信息技术专业中心 🚀</h2><p>在 ITProHub，我们致力于成为信息技术领域的中心枢纽，为专业人士、学习者和技术爱好者提供丰富的资源、技能培训和社区交流平台。</p>\n<h3 id=\"🔍-ITPro-专业的信息技术支持\"><a href=\"#🔍-ITPro-专业的信息技术支持\" class=\"headerlink\" title=\"🔍 ITPro: 专业的信息技术支持\"></a>🔍 ITPro: 专业的信息技术支持</h3><p>无论你是正在寻找IT职业发展的道路，还是想提升你的专业技能，ITProHub都为你提供了全面的资源和指导。我们关注行业趋势，分享最新的技术知识，助你成为更专业的IT从业者。</p>\n<h3 id=\"💼-Hub-中心化的资源和社区\"><a href=\"#💼-Hub-中心化的资源和社区\" class=\"headerlink\" title=\"💼 Hub: 中心化的资源和社区\"></a>💼 Hub: 中心化的资源和社区</h3><p>ITProHub是一个汇聚各种IT资源的中心，包括职业指导、技术文章、培训课程等。在我们的社区中，你可以与其他IT专业人士建立联系，分享经验，共同成长。</p>\n<h4 id=\"✨-我们的特色服务和内容包括：\"><a href=\"#✨-我们的特色服务和内容包括：\" class=\"headerlink\" title=\"✨ 我们的特色服务和内容包括：\"></a>✨ 我们的特色服务和内容包括：</h4><p>🎓 专业的IT技能培训课程</p>\n<p>📰 行业趋势和技术文章分享</p>\n<p>🚀 职业发展指导和招聘信息</p>\n<p>💬 与专业人士互动的社交平台</p>\n<p>👥 加入我们的社区，你将获得：</p>\n<p>与同行专业人士的互动和交流机会</p>\n<p>获取实用的职业发展建议和技术支持</p>\n<p>参与丰富多彩的线上和线下活动</p>\n<p>无论你是刚刚踏入IT领域，还是寻求更高级别的技术挑战，ITProHub都是你信息技术之旅的理想伴侣。</p>\n<h2 id=\"🌐-探索无限可能，加入-ITProHub-！🌐\"><a href=\"#🌐-探索无限可能，加入-ITProHub-！🌐\" class=\"headerlink\" title=\"🌐 探索无限可能，加入 ITProHub ！🌐\"></a>🌐 探索无限可能，加入 ITProHub ！🌐</h2><p>公众号将不定期更新，欢迎订阅！</p>\n<p>#ITProHub #信息技术 #专业发展 #社区交流</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"深入理解 HTTP Connection 头","date":"2024-03-19T08:11:52.000Z","_content":"HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/http.md","raw":"---\ntitle: 深入理解 HTTP Connection 头\ndate: 2024-03-19 16:11:52\ntags: http http协议 Connection\n---\nHTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。\n\n在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习[超文本传输协议](https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#)\n\n\n## 作用与语法\nHTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求/响应，而不是为每个请求/响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。\n\n### 语法\n```http request\nConnection: keep-alive\nConnection: close\n```\n\nHTTP Connection头接受上面提到的两个指令，并如下所述：\n\n+ keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。\n+ close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。\n\nHttp1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。\n\n_保持连接和不保持连接区别可以参考下面的图_\n![handshake](/images/http/perisitent-connection.png)\n\n\n## Keep-Alive的优缺点\nkeep-alive 这么完美么？\n### 优点：\n\n1. 减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。\n2. 减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。\n3. 提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。\n\n### 缺点：\n1. 资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。\n2. 可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。\n\n## 怎么断开连接\n### 通过 Keep-Alive Timeout 标识\nkeep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\nKeep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：\n```http request\nKeep-Alive:timeout=5\n```\n<font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout=Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font>\n\n### 通过 Connection close 标识\n通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。\n\n注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识\n\n\n## 动手试一试\n为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子\n\n+ 主动断开连接\n```\n[HttpGet]\n[ActionTitle(Name = \"关闭连接\")]\n[Route(\"close.svc\")]\npublic void Close()\n{\n    Response.Headers.Connection = \"close\";\n    return;\n}\n```\n![主动断开连接](/images/http/handshake-2.png)\n首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。\n\n然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。\n\n+ 超时断开连接(Mozilla)\n```C#\n[HttpGet]\n[ActionTitle(Name = \"开启连接\")]\n[Route(\"start.svc\")]\npublic void Start()\n{\n    Response.Headers.KeepAlive = \"timeout=10, max=3\";\n    return;\n}\n```\n  ![主动断开连接](/images/http/timeout-auto-disconnect.png)\n在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。\n\n\n+ 被动断开连接\n![主动断开连接](/images/http/auto-disconnect.png)\n上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。\n\n**分析上图流程**\n+ 首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文\n+ 服务端会进行 Keep-Alive ACK\n+ 规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变\n+ 大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段\n\n**猜想**\n+ 客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。\n+ 探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。\n\n## TCP  Keep-Alive 机制\n> + TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 \n> + TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 \n> + 在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。\n\n以下是一些可能发送TCP Keep-Alive报文的实体：\n1. 操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。\n2. 网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。\n3. 浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP/1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。\n4. 其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。\n\n## 结语\nHTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"http","published":1,"updated":"2024-04-26T03:06:44.259Z","_id":"cltzedeaa0000d0p1ajbjc7gt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP Connection 头是 HTTP 协议中的一个重要头部字段，它用于控制客户端和服务器之间的连接行为。在本文中，我们将深入探讨 HTTP Connection 头部的作用、用法，并结合实际开发案例展示其在应用程序开发中的应用。</p>\n<p>在开始本文的阅读之前，默认屏幕前的老铁已经对HTTP有了基础的认识。如果不是，请移步学习<a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#\">超文本传输协议</a></p>\n<h2 id=\"作用与语法\"><a href=\"#作用与语法\" class=\"headerlink\" title=\"作用与语法\"></a>作用与语法</h2><p>HTTP Connection头是通用类型标头，允许发送方或客户端指定该特定连接所需的选项。Connection 帮助使用单个 TCP 连接发送或接收多个 HTTP 请求&#x2F;响应，而不是为每个请求&#x2F;响应打开一个新连接。它还控制当前事务完成后网络是否保持打开或关闭状态。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>close</span><br></pre></td></tr></table></figure>\n\n<p>HTTP Connection头接受上面提到的两个指令，并如下所述：</p>\n<ul>\n<li>keep-alive该指令表明客户端在发送响应消息后希望保持连接打开或活动。在 HTTP 1.1 版本中，默认情况下使用持久连接，该连接在事务后不会自动关闭。但HTTP 1.0不会将连接视为持久连接，因此如果要保持连接处于活动状态，则需要包含一个保持活动连接标头。</li>\n<li>close这个关闭连接指令表明客户端在发送响应消息后想要关闭连接。在 HTTP 1.0 中，默认情况下连接会关闭。但在 HTTP 1.1 中，如果您希望关闭连接，则需要将其包含在标头中。</li>\n</ul>\n<p>Http1.1 以后，Keep-Alive已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 Header 中增加一个请求头Connection: Keep-Alive，当服务器收到附带有Connection: Keep-Alive的请求时，也会在响应头中添加 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（断开方式下面介绍），当客户端发送另外一个请求时，就可以复用已建立的连接。</p>\n<p><em>保持连接和不保持连接区别可以参考下面的图</em><br><img src=\"/images/http/perisitent-connection.png\" alt=\"handshake\"></p>\n<h2 id=\"Keep-Alive的优缺点\"><a href=\"#Keep-Alive的优缺点\" class=\"headerlink\" title=\"Keep-Alive的优缺点\"></a>Keep-Alive的优缺点</h2><p>keep-alive 这么完美么？</p>\n<h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li>减少连接建立和断开的开销： 使用长连接可以避免在每次请求时都重新建立连接，从而减少了连接建立和断开的时间和开销。</li>\n<li>减少网络延迟： 由于连接已经建立，可以直接进行数据传输，不需要等待连接的建立过程，从而减少了网络延迟，提高了数据传输效率。</li>\n<li>提高性能： 长连接可以实现连接的复用，多个请求可以共享同一个连接，从而减少了服务器的负担，提高了系统的整体性能。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li>资源占用： 长连接会占用服务器和客户端的资源，尤其是在连接空闲时，会持续占用资源，可能导致资源浪费。</li>\n<li>可能造成资源不足： 如果长时间保持大量的长连接，可能会耗尽服务器和客户端的资源，导致性能下降甚至崩溃。</li>\n</ol>\n<h2 id=\"怎么断开连接\"><a href=\"#怎么断开连接\" class=\"headerlink\" title=\"怎么断开连接\"></a>怎么断开连接</h2><h3 id=\"通过-Keep-Alive-Timeout-标识\"><a href=\"#通过-Keep-Alive-Timeout-标识\" class=\"headerlink\" title=\"通过 Keep-Alive Timeout 标识\"></a>通过 Keep-Alive Timeout 标识</h3><p>keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：</p>\n<figure class=\"highlight http\"><figcaption><span>request</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keep-Alive:timeout=5</span><br></pre></td></tr></table></figure>\n<p><font color=\"#dd0000\">注意：Mozilla 和 Konquor 浏览器能识别 “Keep-Alive：Timeout&#x3D;Time” 报头字段，而 MSIE 在大约 60 秒内自行关闭保活连接。</font></p>\n<h3 id=\"通过-Connection-close-标识\"><a href=\"#通过-Connection-close-标识\" class=\"headerlink\" title=\"通过 Connection close 标识\"></a>通过 Connection close 标识</h3><p>通在 Response Header 中增加Connection close标识，来主动告诉发送端，连接已经断开了，不能再复用了；客户端接收到此标示后，会销毁连接，再次请求时会重新建立连接。</p>\n<p>注意：配置 close 配置后，并不是说每次都新建连接，而是约定此连接可以用几次，达到这个最大次数时，接收端就会返回 close 标识</p>\n<h2 id=\"动手试一试\"><a href=\"#动手试一试\" class=\"headerlink\" title=\"动手试一试\"></a>动手试一试</h2><p>为了更好的理解keep-alive是怎么玩的，我写了一个简单的例子</p>\n<ul>\n<li>主动断开连接<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;关闭连接&quot;)]</span><br><span class=\"line\">[Route(&quot;close.svc&quot;)]</span><br><span class=\"line\">public void Close()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.Connection = &quot;close&quot;;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/images/http/handshake-2.png\" alt=\"主动断开连接\"><br>首先，我们第一次调用start接口打开连接，可以看到开始的三次握手。后续我们再次发送请求的时候，由于连接还没有断开，所以就不再有三次握手的过程。</li>\n</ul>\n<p>然后，我们又主动调用了close这个接口，这个接口返回的头部信息中携带了“connection: close”，告诉浏览器要关闭连接。因此在此之后我们立马就看到了4次挥手。</p>\n<ul>\n<li><p>超时断开连接(Mozilla)</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;开启连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;start.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Response.Headers.KeepAlive = <span class=\"string\">&quot;timeout=10, max=3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/http/timeout-auto-disconnect.png\" alt=\"主动断开连接\"><br>在服务端设置10s超时。第一次主动打开连接，之后我们不再进行请求，10s之后连接自动断开。</p>\n</li>\n<li><p>被动断开连接<br><img src=\"/images/http/auto-disconnect.png\" alt=\"主动断开连接\"><br>上图可以看到，我们第一次主动打开连接。之后我们不再进行请求，一段时间之后连接自动断开。</p>\n</li>\n</ul>\n<p><strong>分析上图流程</strong></p>\n<ul>\n<li>首先：10.21.21.6（本机ip）率先向服务端 发起了 Keep-Alive 报文</li>\n<li>服务端会进行 Keep-Alive ACK</li>\n<li>规律是 客户端一直在发送 Keep-Alive ，服务端呢，一直在 Keep-Alive ACK，且 Seq 和 Ack 一直没有变</li>\n<li>大概过了 5min 服务端率先发起 FIN ACK 进入 进入挥手 断开连接阶段</li>\n</ul>\n<p><strong>猜想</strong></p>\n<ul>\n<li>客户端 TCP 在没有数据流通时有自己的探活机制，由客户端上报 Keep-Alive 报文，服务端 ACK ，双方确认彼此活着。</li>\n<li>探活有时间限制，超过限定时间，如果一直没有数据交换，即使探活心跳正常，也会进行挥手断连，释放资源。</li>\n</ul>\n<h2 id=\"TCP-Keep-Alive-机制\"><a href=\"#TCP-Keep-Alive-机制\" class=\"headerlink\" title=\"TCP  Keep-Alive 机制\"></a>TCP  Keep-Alive 机制</h2><blockquote>\n<ul>\n<li>TCP Keep-Alive 并不是 TCP 标准的一部分，而是由协议栈实现者进行拓展实现，主流操作系统 Linux、Windows、MacOS 都进行了对应的实现。 </li>\n<li>TCP Keep-Alive 报文是由操作系统或网络库实现的，而不是由特定的应用程序（如浏览器或HTTP客户端库）直接发送的。它是一种网络层的功能，用于维持两个网络设备之间的连接状态。这个机制在TCP协议中定义，允许一方在一定时间内没有收到数据时发送探测包，以确认连接的另一端是否仍然可达。 </li>\n<li>在Windows操作系统中，这通常通过发送TCP Keep-Alive探测包来实现，这些探测包是由操作系统的网络堆栈自动发送的。</li>\n</ul>\n</blockquote>\n<p>以下是一些可能发送TCP Keep-Alive报文的实体：</p>\n<ol>\n<li>操作系统网络堆栈：大多数现代操作系统都会实现TCP Keep-Alive功能。例如，在Windows中，可以通过注册表设置或使用netsh命令来配置TCP Keep-Alive参数。</li>\n<li>网络库：某些编程语言的网络库可能实现了自己的Keep-Alive逻辑。例如，Java的HttpURLConnection或C#的HttpClient可能会在底层TCP连接上启用Keep-Alive。</li>\n<li>浏览器：虽然浏览器可能不会在没有HTTP请求的情况下发送Keep-Alive报文，但它们可能会定期发送HTTP&#x2F;1.1协议中的Keep-Alive头部，这是一种应用层的机制，用于维持HTTP连接的活跃状态。</li>\n<li>其他网络应用程序：任何使用TCP连接的应用程序都可能实现自己的Keep-Alive逻辑，以确保连接的持续性。</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>HTTP Connection 头是 HTTP 协议中非常重要的头部字段之一，它控制着客户端和服务器之间的连接行为，直接影响着通信的效率和性能。在实际开发中，合理使用 HTTP Connection 头可以有效地管理网络资源，提高通信的效率。希望本文能够帮助读者更深入地理解 HTTP Connection 头的作用和用法，并在实际开发中加以应用。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"组织发展致命杀手：内耗","date":"2024-03-28T09:49:50.000Z","_content":"\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/organization-internal-loss.md","raw":"---\ntitle: 组织发展致命杀手：内耗\ndate: 2024-03-28 17:49:50\ntags: 组织 内耗\n---\n\n前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里\n![郁闷](/images/internal-loss/depressed.jpg)\n\n相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”\n\n一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。\n\n毫不夸张的说，***组织内耗*** 就是毁掉一家企业最快的方式。\n\n# 组织内耗的表现\n以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。\n## 1. 内卷（不健康的竞争）\n\n 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。\n\n这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，\n那就是**加班**。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。\n\n团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。\n\n同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。\n## 2. 信任缺失\n业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。\n\n老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。\n\n管理者怀疑员工，是不是每天上班都在摸鱼，混日子。\n\n员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。\n\n一旦疑心链形成，公司就选入了一种恶性循环：\n+ 老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。\n+ 管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！\n\n![996](/images/internal-loss/996.jpg)\n\n我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。\n公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。\n\n突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。\n\n这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！\n从感谢员工的付出，到员工要感谢公司给的工作岗位。\n\n## 3. 部门隔阂\n\n由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。\n业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。\n\n+ 沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。\n+ 决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。\n+ 资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。\n\n\n# 咋办？\n<font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font>\n\n下面是老夫自己的一点yy，随便胡侃。。。\n\n减少组织内耗，也说不上什么措施吧，只能说要坚持的原则\n\n1. 任人唯贤，疑人不用，用人不疑\n无论是对于管理者还是员工，猜疑是内耗的始作俑者\n2. 做对的事\n选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。\n\n\n# 结语\n没啥好总结的了。\n\n组织内耗是企业发展的致命杀手。\n\n选对人，做对事，拒绝内卷！\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"organization-internal-loss","published":1,"updated":"2024-04-26T03:06:35.957Z","_id":"cluc17m5x0000qsp19fjj1lmy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前段时间发表的都是技术相关的文章，今天换换口味，谈一谈最近关于组织工作上的一些思考。当然也是找个地方发发牢骚。。。可能就是想到哪里写到哪里<br><img src=\"/images/internal-loss/depressed.jpg\" alt=\"郁闷\"></p>\n<p>相信大家在此之前也常常听过一个说法“在组织管理中，人就是全部，人才之痛，是最大的痛点。”</p>\n<p>一家企业在增长的过程中，很多问题都会被隐藏或者说是忽略。但是一旦不增长或者负增长了，所有问题都会暴露出来，甚至是成倍的爆发。</p>\n<p>毫不夸张的说，<em><strong>组织内耗</strong></em> 就是毁掉一家企业最快的方式。</p>\n<h1 id=\"组织内耗的表现\"><a href=\"#组织内耗的表现\" class=\"headerlink\" title=\"组织内耗的表现\"></a>组织内耗的表现</h1><p>以下是我想到的比较重要的几个点，排名分先后！更可怕的是，这些表现一般不会单独出现，都是抱团出现的。</p>\n<h2 id=\"1-内卷（不健康的竞争）\"><a href=\"#1-内卷（不健康的竞争）\" class=\"headerlink\" title=\"1. 内卷（不健康的竞争）\"></a>1. 内卷（不健康的竞争）</h2><p> 在团队内部，组织内耗一个重要的表现形式：内卷。 啥是内卷？无意义的消耗，形式主义都可以定义为内卷。</p>\n<p>这几年行业下行，老夫就职的公司也出现了严重的业绩下滑、亏损。为了实现“逆势增长”，公司要求提高人效，于是提出了“付出120%的努力”口号。对于那多出来的20%的理解，各事业部的理解都是一致的，<br>那就是<strong>加班</strong>。于是乎各部门掀起了一波加班潮，表演式的加班潮。下班时间无论有没有事反正是走不了的，走了的就是工作量饱和。然后就衍生出了另外一个问题，“磨洋工”。明明半天能搞定的需求，硬是托着一天才解决，或者白天摸鱼，加班干活。</p>\n<p>团队管理也是这样，过度追求形式主义，只注重过程，不注重结果。最后就是人效水平更低了，坑了员工，也坑了管理者。</p>\n<p>同时，不健康的内部竞争可能导致员工之间的对抗和不合作，影响团队协作，产生下面会说到的“部门隔阂”。</p>\n<h2 id=\"2-信任缺失\"><a href=\"#2-信任缺失\" class=\"headerlink\" title=\"2. 信任缺失\"></a>2. 信任缺失</h2><p>业绩增长的时候还好，一旦业绩下滑，整个公司陷入了一条猜疑链。</p>\n<p>老板怀疑管理者是不是能力和职位不匹配，于是出台各种政策和变革，监督管理者好好干活。</p>\n<p>管理者怀疑员工，是不是每天上班都在摸鱼，混日子。</p>\n<p>员工怀疑公司，公司是不是不行了，我是不是要被开了，缺乏安全感。</p>\n<p>一旦疑心链形成，公司就选入了一种恶性循环：</p>\n<ul>\n<li>老板不敢放权管理者，降级使用。各种汇报，月度、季度、半年度。</li>\n<li>管理者用力过猛，动作变形。对员工极限压榨，两个人的事情一个人干，996搞起来！</li>\n</ul>\n<p><img src=\"/images/internal-loss/996.jpg\" alt=\"996\"></p>\n<p>我曾经听过这样一句话“怎么判断一个公司开始走下坡路了？看他是不是突然开始抓考勤了”。确实如此。<br>公司增长的时候各种宣传弹性工作制，请假半天起，2h小时以内的假期不需要发请假申请，特殊情况可以申请居家办公。</p>\n<p>突然有一天跟你说，迟到要说明原因，迟到要扣钱。请假的系统支持到了小时级，加班申请员工无法发起，要领导发起。</p>\n<p>这个时候就能知道，公司走下坡路了。而且老板没从自身找到原因，开始从员工身上找原因，员工没好好干活！<br>从感谢员工的付出，到员工要感谢公司给的工作岗位。</p>\n<h2 id=\"3-部门隔阂\"><a href=\"#3-部门隔阂\" class=\"headerlink\" title=\"3. 部门隔阂\"></a>3. 部门隔阂</h2><p>由于各部门个团队之间都是竞争关系。各部门或团队之间形成信息孤岛，缺乏合作和共享资源的意愿，导致整体效率低下。<br>业绩下滑，各团队之间互相锅甩锅。集团说销售能力差，销售说项目垃圾，项目说产品垃圾，产品说平台垃圾。</p>\n<ul>\n<li>沟通不畅：部门之间或团队成员之间的沟通存在障碍，信息传递不顺畅，导致误解和冲突。</li>\n<li>决策迟缓：决策过程中的犹豫不决、推诿责任或过度分析导致机会的丧失和项目进度的延迟。</li>\n<li>资源重复或浪费：由于缺乏协调和规划，可能导致资源在不同部门或项目中重复投入或未能有效利用。</li>\n</ul>\n<h1 id=\"咋办？\"><a href=\"#咋办？\" class=\"headerlink\" title=\"咋办？\"></a>咋办？</h1><p><font size=\"2\" color=\"#A9A9A9\">尽人事，听天命。打胜仗是最好的团建</font></p>\n<p>下面是老夫自己的一点yy，随便胡侃。。。</p>\n<p>减少组织内耗，也说不上什么措施吧，只能说要坚持的原则</p>\n<ol>\n<li>任人唯贤，疑人不用，用人不疑<br>无论是对于管理者还是员工，猜疑是内耗的始作俑者</li>\n<li>做对的事<br>选对人，还要做对的事。剩下的就交给时间吧。况且剩下的可能也不是人力能够抗衡的了。</li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>没啥好总结的了。</p>\n<p>组织内耗是企业发展的致命杀手。</p>\n<p>选对人，做对事，拒绝内卷！</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Garnet，缓存的新选择！","date":"2024-04-07T07:24:24.000Z","_content":"\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/garnet.md","raw":"---\ntitle: Garnet，缓存的新选择！\ndate: 2024-04-07 15:24:24\ntags: Garnet 缓存 微软\n---\n\n号外号外！\n1. redis不再“开源”；\n2. 微软开源了Garnet\n\n#  什么是Garnet？\nGarnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。\n\n# 特性和优势\n1. 高性能\n\n   &nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。\n  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。\n\n2. 可靠性\n\n   &nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。\n\n3. 可扩展性\n\n   &nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。\n\n4. 多种数据类型支持：\n\n   &nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。\n\n5. 丰富的功能\n\n   &nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。\n\n# 高性能\n对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。\n\n具体性能测试详情可以查看链接： [Evaluating Garnet's Performance Benefits](https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench)\n\n实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。\n\n下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet\")]\n[Route(\"test.svc\")]\npublic void Start()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = new GarnetClient(\"localhost\", 3278);\n\n    // Test data\n    string key = \"test_key\";\n    string value = \"test_value\";\n\n    // Test with Redis\n   var redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       redisDb.StringSet(key + i, value + i);\n   }\n   var redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   var garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringSet(key + i, value + i, null);\n   }\n   var garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringSet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Redis\n   redisStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       string a = redisDb.StringGet(key + i).ToString();\n   }\n   redisEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Redis: {(redisEndTime - redisStartTime).TotalMilliseconds} ms\");\n   \n   // Test with Garnet\n   garnetStartTime = DateTime.Now;\n   for( int i = 0; i < 1000; i++ ) {\n       garnet.StringGet(key + i, null);\n   }\n   garnetEndTime = DateTime.Now;\n   Console.WriteLine($\"StringGet Time taken by Garnet: {(garnetEndTime - garnetStartTime).TotalMilliseconds} ms\");\n}\n```\n最后运行的结果还是挺振奋人心的!\n\n![运行结果1](/images/garnet/compare1.png)\n\n# 兼容性\n当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。\n\n这个时候我们在官网看到这样一句话\n> Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。\n\n于是，我们再整个demo\n```C#\n[HttpGet]\n[ActionTitle(Name = \"测试Garnet连接\")]\n[Route(\"connect.svc\")]\npublic void Connect()\n{\n    // Redis connection\n    var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var redisDb = redis.GetDatabase();\n\n    // Garnet connection\n    var garnet = ConnectionMultiplexer.Connect(\"localhost:3278\");\n    var garnetDb = garnet.GetDatabase();\n\n    // Test data\n    string key = \"test_key\";\n\n    // Test with Redis\n    string a = redisDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Redis : {a}\");\n\n    // Test with Garnet\n    string b = garnetDb.StringGet(key + 1).ToString();\n    Console.WriteLine($\"StringGet by Garnet : {b}\");\n}\n```\n微软 诚不我欺！\n\n在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet\n![connect](/images/garnet/connect.png)\n\nredis桌面客户端也能直接连接Garnet\n![client](/images/garnet/client.png)\n\n\n# 日志和诊断\nGarnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：\n\n1. 详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。\n\n2. 性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。\n\n3. 异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。\n\n4. 诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。\n\n```C#\nstatic void Main(string[] args)\n{\n    try\n    {\n\n        var loggerFactory = LoggerFactory.Create(x =>\n        {\n            x.ClearProviders();\n            x.SetMinimumLevel(LogLevel.Trace);\n            x.AddZLoggerConsole(options =>\n            {\n                options.UsePlainTextFormatter(formatter =>\n                {\n                    formatter.SetPrefixFormatter($\"[{0}]\", (in MessageTemplate template, in LogInfo info) => template.Format(info.Category));\n                });\n            });\n        });\n\n\n        using var server = new GarnetServer(args, loggerFactory);\n\n        // Optional: register custom extensions\n        RegisterExtensions(server);\n\n        // Start the server\n        server.Start();\n\n        Thread.Sleep(Timeout.Infinite);\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine($\"Unable to initialize server due to exception: {ex.Message}\");\n    }\n}\n```\n![日志](/images/garnet/log.png)\n\n\n\n# 自定义命令\n想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。\n\n因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”\n\n注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。\n\n```Garnet Server\n// 测试自定义命令\nserver.Register.NewTransactionProc(\"TEST\", 0, () => new TestCustomCommand());\n\n\nsealed class TestCustomCommand : CustomTransactionProcedure\n{\n    /// <summary>\n    /// No transactional phase, skip Prepare\n    /// </summary>\n    public override bool Prepare<TGarnetReadApi>(TGarnetReadApi api, ArgSlice input)\n        => false;\n\n    /// <summary>\n    /// Main will not be called because Prepare returns false\n    /// </summary>\n    public override void Main<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n        => throw new InvalidOperationException();\n\n    /// <summary>\n    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings\n    /// </summary>\n    public override void Finalize<TGarnetApi>(TGarnetApi api, ArgSlice input, ref MemoryResult<byte> output)\n    {\n        // Return the two keys as an array of bulk strings\n        WriteSimpleString(ref output, \"Hello Garnet!\");\n    }\n}\n\n```\n\n同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令\n```Garnet client\n [HttpGet]\n [ActionTitle(Name = \"测试Garnet 自定义命令\")]\n [Route(\"custom-command.svc\")]\n public async void Test()\n {       \n     // Garnet connection\n     var garnet = new GarnetClient(\"localhost\", 3278);\n     garnet.Connect();\n     // Test data\n     string result = await garnet.ExecuteForStringResultAsync(\"TEST\");\n\n     Console.WriteLine($\"Garnet Custom Command Result: {result}\");\n\n     // 采用redis客户端连接\n     var client = ConnectionMultiplexer.Connect(\"localhost:3278\");\n     var db = client.GetDatabase();\n\n     RedisResult redisResult = db.Execute(\"TEST\");\n\n     Console.WriteLine($\"Redis Client Custom Command Result: {((string?)redisResult)}\");\n }\n```\n最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果\n![custom command result](/images/garnet/custom-command.png)\n\n# 结语\nGarnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。\n\n# 参考文档\n+ [Garnet 开发入门](https://microsoft.github.io/garnet/docs)\n\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"garnet","published":1,"updated":"2024-04-26T03:07:22.478Z","_id":"clup9vupa0000okp14bz96eiy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>号外号外！</p>\n<ol>\n<li>redis不再“开源”；</li>\n<li>微软开源了Garnet</li>\n</ol>\n<h1 id=\"什么是Garnet？\"><a href=\"#什么是Garnet？\" class=\"headerlink\" title=\"什么是Garnet？\"></a>什么是Garnet？</h1><p>Garnet是微软推出的一款远程缓存存储系统，旨在为开发者提供高性能、可靠性和可伸缩性的缓存解决方案。它采用了现代化的架构和技术，具有高度可定制性和灵活性，适用于各种规模和类型的应用场景。</p>\n<h1 id=\"特性和优势\"><a href=\"#特性和优势\" class=\"headerlink\" title=\"特性和优势\"></a>特性和优势</h1><ol>\n<li><p>高性能</p>\n<p>&nbsp; Garnet采用了高效的缓存算法和数据结构，以实现快速的数据访问和响应。它支持并发访问和高吞吐量，能够处理大规模的请求流量。</p>\n</li>\n</ol>\n<p>  Garnet通过智能缓存策略，将热点数据（经常访问的数据）存储在用户附近的节点上，从而减少了数据传输的时间和距离，实现了低延迟访问。</p>\n<ol start=\"2\">\n<li><p>可靠性</p>\n<p>&nbsp; Garnet具有强大的数据保护和容错机制，能够确保数据的持久性和一致性。它支持数据备份、复制和故障转移，有效地降低了数据丢失和系统故障的风险。</p>\n</li>\n<li><p>可扩展性</p>\n<p>&nbsp; Garnet的架构设计具有良好的水平扩展性，可以轻松地扩展到数百甚至数千台服务器。它支持动态添加和移除节点，能够根据需求灵活调整集群规模。</p>\n</li>\n<li><p>多种数据类型支持：</p>\n<p>&nbsp; 除了常规的键值对存储之外，Garnet还支持多种数据类型，包括列表、集合、哈希表等，满足了不同应用场景的需求。</p>\n</li>\n<li><p>丰富的功能</p>\n<p>&nbsp; Garnet提供了丰富的功能和工具，包括监控、调优、故障排除等，帮助开发者更好地管理和运维缓存系统。</p>\n</li>\n</ol>\n<h1 id=\"高性能\"><a href=\"#高性能\" class=\"headerlink\" title=\"高性能\"></a>高性能</h1><p>对于一个中间件来说，大家最关心的应该就是性能到底怎么样？基准测试的结果，总体还是表现不错的。</p>\n<p>具体性能测试详情可以查看链接： <a href=\"https://microsoft.github.io/garnet/docs/benchmarking/results-resp-bench\">Evaluating Garnet’s Performance Benefits</a></p>\n<p>实际应用的过程中效果到底咋样当然还需要我们在通过代码来验证一下。</p>\n<p>下面我写了一个简单的例子，直接循环往garnet和redis里面写入和读取数据。通过计算时间来对比一下两者的差距到底有多大</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;test.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Start</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = <span class=\"keyword\">new</span> GarnetClient(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">3278</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = <span class=\"string\">&quot;test_value&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       redisDb.StringSet(key + i, <span class=\"keyword\">value</span> + i);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringSet(key + i, <span class=\"keyword\">value</span> + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringSet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">   redisStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">string</span> a = redisDb.StringGet(key + i).ToString();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   redisEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Redis: <span class=\"subst\">&#123;(redisEndTime - redisStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">   garnetStartTime = DateTime.Now;</span><br><span class=\"line\">   <span class=\"keyword\">for</span>( <span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ ) &#123;</span><br><span class=\"line\">       garnet.StringGet(key + i, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   garnetEndTime = DateTime.Now;</span><br><span class=\"line\">   Console.WriteLine(<span class=\"string\">$&quot;StringGet Time taken by Garnet: <span class=\"subst\">&#123;(garnetEndTime - garnetStartTime).TotalMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后运行的结果还是挺振奋人心的!</p>\n<p><img src=\"/images/garnet/compare1.png\" alt=\"运行结果1\"></p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><p>当然在进行中间件选择的时候，切换的成本也是重点要纳入考虑的。“白嫖一时爽，重构火葬场！”这种事情显然是我们不愿意看到的。</p>\n<p>这个时候我们在官网看到这样一句话</p>\n<blockquote>\n<p>Garnet 并不是要成为 Redis 100% 完美的替代品，而是应该将其视为一个足够接近的起点，以确保对您重要的功能的兼容性。 Garnet 确实可以在未经修改的情况下与许多 Redis 客户端一起使用（我们特别对 Garnet 进行了StackExchange.Redis很好的测试），因此入门非常容易。</p>\n</blockquote>\n<p>于是，我们再整个demo</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">HttpGet</span>]</span><br><span class=\"line\">[<span class=\"meta\">ActionTitle(Name = <span class=\"string\">&quot;测试Garnet连接&quot;</span>)</span>]</span><br><span class=\"line\">[<span class=\"meta\">Route(<span class=\"string\">&quot;connect.svc&quot;</span>)</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Connect</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Redis connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> redis = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> redisDb = redis.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Garnet connection</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnet = ConnectionMultiplexer.Connect(<span class=\"string\">&quot;localhost:3278&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> garnetDb = garnet.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test data</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> key = <span class=\"string\">&quot;test_key&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Redis</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a = redisDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Redis : <span class=\"subst\">&#123;a&#125;</span>&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Test with Garnet</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> b = garnetDb.StringGet(key + <span class=\"number\">1</span>).ToString();</span><br><span class=\"line\">    Console.WriteLine(<span class=\"string\">$&quot;StringGet by Garnet : <span class=\"subst\">&#123;b&#125;</span>&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>微软 诚不我欺！</p>\n<p>在不动客户端代码的情况下，我们能够非常平滑的切换到Garnet<br><img src=\"/images/garnet/connect.png\" alt=\"connect\"></p>\n<p>redis桌面客户端也能直接连接Garnet<br><img src=\"/images/garnet/client.png\" alt=\"client\"></p>\n<h1 id=\"日志和诊断\"><a href=\"#日志和诊断\" class=\"headerlink\" title=\"日志和诊断\"></a>日志和诊断</h1><p>Garnet 提供了丰富的日志和诊断特性，以帮助开发人员监视和调试其应用程序的性能和行为。以下是 Garnet 日志和诊断特性的主要内容：</p>\n<ol>\n<li><p>详细日志记录：Garnet 具有灵活的日志记录功能，可以记录各种级别的日志消息，包括信息、警告和错误。这些日志消息可以帮助开发人员了解系统的运行情况，识别潜在的问题并进行故障排除。</p>\n</li>\n<li><p>性能指标：Garnet 还提供了丰富的性能指标，可以帮助开发人员监视系统的性能状况。这些指标可以包括各种关键性能指标，如请求响应时间、吞吐量、延迟等。</p>\n</li>\n<li><p>异常跟踪：Garnet 具有异常跟踪功能，可以捕获和记录应用程序中的异常情况。这些异常跟踪信息可以帮助开发人员快速定位和修复问题。</p>\n</li>\n<li><p>诊断工具：Garnet 还提供了一系列诊断工具，用于分析和调试系统的行为。这些工具可以帮助开发人员深入了解系统的内部工作原理，并识别潜在的性能瓶颈和问题。</p>\n</li>\n</ol>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> loggerFactory = LoggerFactory.Create(x =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            x.ClearProviders();</span><br><span class=\"line\">            x.SetMinimumLevel(LogLevel.Trace);</span><br><span class=\"line\">            x.AddZLoggerConsole(options =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                options.UsePlainTextFormatter(formatter =&gt;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    formatter.SetPrefixFormatter(<span class=\"string\">$&quot;[<span class=\"subst\">&#123;<span class=\"number\">0</span>&#125;</span>]&quot;</span>, (<span class=\"keyword\">in</span> MessageTemplate template, <span class=\"keyword\">in</span> LogInfo info) =&gt; template.Format(info.Category));</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">using</span> <span class=\"keyword\">var</span> server = <span class=\"keyword\">new</span> GarnetServer(args, loggerFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Optional: register custom extensions</span></span><br><span class=\"line\">        RegisterExtensions(server);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Start the server</span></span><br><span class=\"line\">        server.Start();</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread.Sleep(Timeout.Infinite);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">$&quot;Unable to initialize server due to exception: <span class=\"subst\">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/garnet/log.png\" alt=\"日志\"></p>\n<h1 id=\"自定义命令\"><a href=\"#自定义命令\" class=\"headerlink\" title=\"自定义命令\"></a>自定义命令</h1><p>想要在 Redis 上执行一些复杂的执行是很常见的，在 Redis 的情况下，我们过去常常使用 Lua 脚本来处理它，但使用 Garnet，我们可以在 C# 中实现和合并自定义命令。 如果你不知道 LUA 是否在性能方面，或者如果你想做一些 LUA 做不到的相当复杂的事情，你可以使用它而不会有任何性能劣势。 更好的是，服务器端提供的扩展命令遵循 RESP，因此客户端可以从 PHP 或 Go 调用它们，而不仅仅是针对 C#。</p>\n<p>因此，让我们立即创建一个名为“TEST”的自定义命令。命令很简单，直接返回一个“Hello Garnet!”</p>\n<p>注册自定义命令本身非常简单，只需添加一个实现的类，或者与命令名称一起添加即可。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>Server</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试自定义命令</span><br><span class=\"line\">server.Register.NewTransactionProc(&quot;TEST&quot;, 0, () =&gt; new TestCustomCommand());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sealed class TestCustomCommand : CustomTransactionProcedure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// No transactional phase, skip Prepare</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override bool Prepare&lt;TGarnetReadApi&gt;(TGarnetReadApi api, ArgSlice input)</span><br><span class=\"line\">        =&gt; false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Main will not be called because Prepare returns false</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Main&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">        =&gt; throw new InvalidOperationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    /// &lt;summary&gt;</span><br><span class=\"line\">    /// Finalize reads two keys (non-transactionally) and return their values as an array of bulk strings</span><br><span class=\"line\">    /// &lt;/summary&gt;</span><br><span class=\"line\">    public override void Finalize&lt;TGarnetApi&gt;(TGarnetApi api, ArgSlice input, ref MemoryResult&lt;byte&gt; output)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // Return the two keys as an array of bulk strings</span><br><span class=\"line\">        WriteSimpleString(ref output, &quot;Hello Garnet!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时还是因为Garnet遵循 RESP，因此客户端不是专用于 C#，也不是 Garnet 客户端独有的。 所以我们可以直接在redis客户端调用Garnet的自定义命令</p>\n<figure class=\"highlight plaintext\"><figcaption><span>client</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HttpGet]</span><br><span class=\"line\">[ActionTitle(Name = &quot;测试Garnet 自定义命令&quot;)]</span><br><span class=\"line\">[Route(&quot;custom-command.svc&quot;)]</span><br><span class=\"line\">public async void Test()</span><br><span class=\"line\">&#123;       </span><br><span class=\"line\">    // Garnet connection</span><br><span class=\"line\">    var garnet = new GarnetClient(&quot;localhost&quot;, 3278);</span><br><span class=\"line\">    garnet.Connect();</span><br><span class=\"line\">    // Test data</span><br><span class=\"line\">    string result = await garnet.ExecuteForStringResultAsync(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Garnet Custom Command Result: &#123;result&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 采用redis客户端连接</span><br><span class=\"line\">    var client = ConnectionMultiplexer.Connect(&quot;localhost:3278&quot;);</span><br><span class=\"line\">    var db = client.GetDatabase();</span><br><span class=\"line\"></span><br><span class=\"line\">    RedisResult redisResult = db.Execute(&quot;TEST&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Console.WriteLine($&quot;Redis Client Custom Command Result: &#123;((string?)redisResult)&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们可以看到用两种客户端执行自定义命令都输出了同样的结果<br><img src=\"/images/garnet/custom-command.png\" alt=\"custom command result\"></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>Garnet作为微软最新推出的远程缓存存储系统，为开发者提供了一种全新的选择。它具有高性能、可靠性和可伸缩性的特性，适用于各种规模和类型的应用场景。通过使用Garnet，开发者可以更好地提升应用的性能和用户体验，实现业务的快速发展和持续创新。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><ul>\n<li><a href=\"https://microsoft.github.io/garnet/docs\">Garnet 开发入门</a></li>\n</ul>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"HTTPS的工作原理以及安装","date":"2024-04-11T07:36:46.000Z","_content":"\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/https.md","raw":"---\ntitle: HTTPS的工作原理以及安装\ndate: 2024-04-11 15:36:46\ntags: https http ssl tls\n---\n\n# 什么是 HTTPS？\nHTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。\nHTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。\n\n所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。\n\n![安全连接](/images/https/security.png)\n\nHTTPS 使我们能够实现三个目标：\n\n+ 身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。\n+ 隐私：网络上的任何人都无法读取数据，因为它是加密的\n+ 完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。\n\n\n# 证书颁发机构\n证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。\n任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。\n\n证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia\n\n![ca](/images/https/ca2.png)\n\n# SSL 握手\nSSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。\n\n![握手过程](/images/https/handshake.png)图片来源：https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\n\n不深究细节，握手会经过以下步骤：\n\n1. 浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）\n2. 浏览器验证服务器的真实性（证书颁发机构）\n3. 浏览器创建会话密钥并使用服务器的公钥对其进行加密\n4. 服务器用其私钥解密先前的消息\n5. 浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。\n\n\n\n\n感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果\n![握手](/images/https/client-hello.png)\n握手完成后数据传输的都是加密的数据\n![数据加密](/images/https/encrypted.png)\n\n\n\n\n# 密码套件\nHTTPS 内存在不同级别的加密。\n如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。\n这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）\n使用：TLS v1.0、v1.1、v1.2\n\n此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。\n随着时间的推移，其中一些算法会变得很弱，必须停用：\n例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。\n\n因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。\n\n## client hello\n下面是我们通过wireshar抓包查看客户端支持的密码套件\n![客户端支持的密码套件](/images/https/cipher-suites.png)\n\n## server hello\n客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。\n![协商密码套件](/images/https/negotiated-cipher-suite.png)\n\n## 该密码串的含义\nECDHE：密钥交换算法\nECDSA：身份验证\nAES_128_CBC：用于消息加密的批量密码\nSHA：MAC 算法\n\n\n# 在 Web 服务器上安装 HTTPS\n对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。\n\n设置的主要步骤是：\n\n+ 向证书颁发机构订购 SSL 证书\n+ 在 Web 服务器中安装证书（要复制到服务器的文件）\n+ 配置网络服务器\n\n服务器的配置可能包括：\n\n+ 证书绑定的IP地址-端口/域名\n+ 激活协议的配置（TLS/SSL）\n+ 算法和密码密钥大小的配置（密码套件）\n\n```nginx\nserver {\n    listen 443 ssl;\n    server_name xxx;\n\n    ssl_certificate /cert/xxx.crt;\n    ssl_certificate_key /cert/xxx.key;\n\n    location / {\n        proxy_pass http://localhost:4000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：\nApache：  https://wiki.apache.org/httpd/SSL\nIIS： http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\nNginx： http://nginx.org/en/docs/http/configuring_https_servers.html\n\nMozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：\n\n[Mozilla SSL 配置生成器](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n\n# 保持 HTTPS 更新为最新\nHTTPS 配置不是一次性事件。安装后，必须保持其配置最新。\n很多bug都会影响一些较低版本的openSSL库(例如[Heartbleed](https://baike.baidu.com/item/Heartbleed/13580882)), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。\n\n此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。\n\n最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。\n\n相信大家在浏览网站的时候遇到过这样的情况\n![过期](/images/https/expire.png)\n\n\n# HTTPS 不做什么\n人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。\n\n## HTTPS 不会：\n1. 隐藏你正在访问的网站的名称\n\n这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。\n\n2. 保护你免受访问邪恶网站的侵害\n\nHTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。\n\n3. 提供匿名\n\nHTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。\n\n4. 防止你感染病毒\n\nHTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。\n\n5. 保护你的计算机免遭黑客攻击\n\nHTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"https","published":1,"updated":"2024-04-26T03:06:40.272Z","_id":"cluuzgyxx000088p1frvnfrom","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-HTTPS？\"><a href=\"#什么是-HTTPS？\" class=\"headerlink\" title=\"什么是 HTTPS？\"></a>什么是 HTTPS？</h1><p>HTTP 是一种用于在服务器和客户端（Web 浏览器）之间交换数据的互联网协议。 HTTPS 只不过是在HTTP的基础上添加了安全层。<br>HTTP 不是一个安全协议：它是为了纯粹的功能目标而设计的，没有考虑任何安全约束。</p>\n<p>所以我们给HTTP添加了一个安全层。更准确地说，将 HTTP 封装到安全连接中。</p>\n<p><img src=\"/images/https/security.png\" alt=\"安全连接\"></p>\n<p>HTTPS 使我们能够实现三个目标：</p>\n<ul>\n<li>身份验证：HTTPS 使用数字证书来验证服务器和客户端的身份，防止中间人攻击。服务器需要提供有效的数字证书，而客户端可以验证证书的有效性，确保与正确的服务器建立连接。</li>\n<li>隐私：网络上的任何人都无法读取数据，因为它是加密的</li>\n<li>完整性：HTTPS 使用消息摘要算法（如 SHA-256）来计算数据的摘要，并将摘要与数据一起传输。接收方可以验证数据的完整性，确保数据在传输过程中未被篡改。</li>\n</ul>\n<h1 id=\"证书颁发机构\"><a href=\"#证书颁发机构\" class=\"headerlink\" title=\"证书颁发机构\"></a>证书颁发机构</h1><p>证书颁发机构是提供 SSL 证书的公司。这些组织为网络浏览器所熟知，并接受这些机构提供的证书。<br>任何人都可以生成证书，但如果不是由已知机构提供的，浏览器会显示安全警报。</p>\n<p>证书颁发机构示例：DigiCert、GeoTrust、GlobalSign、CFCA、TrustAsia</p>\n<p><img src=\"/images/https/ca2.png\" alt=\"ca\"></p>\n<h1 id=\"SSL-握手\"><a href=\"#SSL-握手\" class=\"headerlink\" title=\"SSL 握手\"></a>SSL 握手</h1><p>SSL 握手是 Web 服务器和浏览器讨论并商定要使用的协议（特定版本中的 SSL 或 TLS）、要使用的密码套件以及最后要使用的会话密钥的过程。握手完成后进行通信。</p>\n<p><img src=\"/images/https/handshake.png\" alt=\"握手过程\">图片来源：<a href=\"https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png\">https://code-maze.com/wp-content/uploads/2017/07/TLS-handshake.png</a></p>\n<p>不深究细节，握手会经过以下步骤：</p>\n<ol>\n<li>浏览器和服务器就所使用的协议达成一致（SSL X、TLS X）</li>\n<li>浏览器验证服务器的真实性（证书颁发机构）</li>\n<li>浏览器创建会话密钥并使用服务器的公钥对其进行加密</li>\n<li>服务器用其私钥解密先前的消息</li>\n<li>浏览器和服务器使用他们刚刚商定的会话密钥进行通信。握手完毕。</li>\n</ol>\n<p>感兴趣的同学也可以抓包看一下https访问的详细过程，下面是用wireshark抓包的结果<br><img src=\"/images/https/client-hello.png\" alt=\"握手\"><br>握手完成后数据传输的都是加密的数据<br><img src=\"/images/https/encrypted.png\" alt=\"数据加密\"></p>\n<h1 id=\"密码套件\"><a href=\"#密码套件\" class=\"headerlink\" title=\"密码套件\"></a>密码套件</h1><p>HTTPS 内存在不同级别的加密。<br>如前所述，HTTPS 是将 HTTP 封装到安全协议 SSL 或 TLS 中。<br>这两种安全协议存在不同的版本，其中一些被认为是较弱的。自“POODLE”漏洞以来，SSL V2 已过时，SSL V3 也已过时。（感兴趣的同学可以自行百度）<br>使用：TLS v1.0、v1.1、v1.2</p>\n<p>此外，SSL和TLS使用不同的加密算法。这些算法在通信过程中使用，使用哪种算法取决于服务器和浏览器接受的算法。<br>随着时间的推移，其中一些算法会变得很弱，必须停用：<br>例如，我们可以提到密钥大小低于 128 位的所有密码和 RC4 算法。</p>\n<p>因此，有必要使系统保持最新，特别是 Web 服务器的 HTTPS 配置。</p>\n<h2 id=\"client-hello\"><a href=\"#client-hello\" class=\"headerlink\" title=\"client hello\"></a>client hello</h2><p>下面是我们通过wireshar抓包查看客户端支持的密码套件<br><img src=\"/images/https/cipher-suites.png\" alt=\"客户端支持的密码套件\"></p>\n<h2 id=\"server-hello\"><a href=\"#server-hello\" class=\"headerlink\" title=\"server hello\"></a>server hello</h2><p>客户端与服务端协商密码套件, 主要是从客户端支持的加密方式中选择一个合适的告诉客户端。<br><img src=\"/images/https/negotiated-cipher-suite.png\" alt=\"协商密码套件\"></p>\n<h2 id=\"该密码串的含义\"><a href=\"#该密码串的含义\" class=\"headerlink\" title=\"该密码串的含义\"></a>该密码串的含义</h2><p>ECDHE：密钥交换算法<br>ECDSA：身份验证<br>AES_128_CBC：用于消息加密的批量密码<br>SHA：MAC 算法</p>\n<h1 id=\"在-Web-服务器上安装-HTTPS\"><a href=\"#在-Web-服务器上安装-HTTPS\" class=\"headerlink\" title=\"在 Web 服务器上安装 HTTPS\"></a>在 Web 服务器上安装 HTTPS</h1><p>对于不同类型的服务器，在 Web 服务器上配置 HTTPS 相对简单，并且有详细的文档记录。</p>\n<p>设置的主要步骤是：</p>\n<ul>\n<li>向证书颁发机构订购 SSL 证书</li>\n<li>在 Web 服务器中安装证书（要复制到服务器的文件）</li>\n<li>配置网络服务器</li>\n</ul>\n<p>服务器的配置可能包括：</p>\n<ul>\n<li>证书绑定的IP地址-端口&#x2F;域名</li>\n<li>激活协议的配置（TLS&#x2F;SSL）</li>\n<li>算法和密码密钥大小的配置（密码套件）</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> xxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate</span> /cert/xxx.crt;</span><br><span class=\"line\">    <span class=\"attribute\">ssl_certificate_key</span> /cert/xxx.key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_pass</span> http://localhost:4000;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">        <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在下面找到详细说明如何在三个主要 Web 服务器上安装 SSL 的文档链接：<br>Apache：  <a href=\"https://wiki.apache.org/httpd/SSL\">https://wiki.apache.org/httpd/SSL</a><br>IIS： <a href=\"http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis\">http://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis</a><br>Nginx： <a href=\"http://nginx.org/en/docs/http/configuring_https_servers.html\">http://nginx.org/en/docs/http/configuring_https_servers.html</a></p>\n<p>Mozilla 发布了一个站点，你可以在其中生成安全的 HTTPS 配置：</p>\n<p><a href=\"https://mozilla.github.io/server-side-tls/ssl-config-generator/\">Mozilla SSL 配置生成器</a></p>\n<h1 id=\"保持-HTTPS-更新为最新\"><a href=\"#保持-HTTPS-更新为最新\" class=\"headerlink\" title=\"保持 HTTPS 更新为最新\"></a>保持 HTTPS 更新为最新</h1><p>HTTPS 配置不是一次性事件。安装后，必须保持其配置最新。<br>很多bug都会影响一些较低版本的openSSL库(例如<a href=\"https://baike.baidu.com/item/Heartbleed/13580882\">Heartbleed</a>), 系统更新可以帮助避免一些与 HTTPS 使用直接相关的漏洞。</p>\n<p>此外，有必要随时了解不同协议和密码套件的安全性。这里的目标是在某些时候被认为较弱的情况下停用其中一些。</p>\n<p>最后一点也是很重要的，也是很明显但经常被遗忘的：证书过期。一旦证书过期，网络浏览器将显示非常具有劝阻性的安全警报，鼓励用户离开网站。</p>\n<p>相信大家在浏览网站的时候遇到过这样的情况<br><img src=\"/images/https/expire.png\" alt=\"过期\"></p>\n<h1 id=\"HTTPS-不做什么\"><a href=\"#HTTPS-不做什么\" class=\"headerlink\" title=\"HTTPS 不做什么\"></a>HTTPS 不做什么</h1><p>人们很容易认为 HTTPS 是一个神奇的互联网安全解决方案，但它还有很多不能做的事情。</p>\n<h2 id=\"HTTPS-不会：\"><a href=\"#HTTPS-不会：\" class=\"headerlink\" title=\"HTTPS 不会：\"></a>HTTPS 不会：</h2><ol>\n<li>隐藏你正在访问的网站的名称</li>\n</ol>\n<p>这是因为网站的名称（又名“域”）是使用 DNS（域名服务）发送的，而 DNS 不在 HTTPS 隧道内。它在建立安全连接之前发送。中间的窃听者可以看到你要访问的网站的名称（例如 TipTopSecurity.com），他们只是无法读取来回传输的任何实际内容。直到DNSSEC完全实施后，这种情况才会改变。</p>\n<ol start=\"2\">\n<li>保护你免受访问邪恶网站的侵害</li>\n</ol>\n<p>HTTPS 不能确保网站本身的安全。仅仅因为你安全连接并不意味着你没有连接到由坏人运行的网站。我们尝试通过受信任的证书颁发机构来解决此问题，但该系统并不完美（请继续关注有关此方面的更多信息）。</p>\n<ol start=\"3\">\n<li>提供匿名</li>\n</ol>\n<p>HTTPS 不会隐藏你的物理位置或个人身份。你的个人 IP 地址（你在互联网上的地址）必须附加到加密数据的外部，因为如果你的 IP 地址也被加密，互联网将不知道将其发送到哪里。而且它也不会在你正在访问的网站上隐藏你的身份。你访问的网站仍然了解你的一切，就像在非安全连接上一样。</p>\n<ol start=\"4\">\n<li>防止你感染病毒</li>\n</ol>\n<p>HTTPS 不是过滤器。有可能通过 HTTPS 连接接收病毒和其他恶意软件。如果 Web 服务器被感染或者你所在的恶意网站正在分发恶意软件，则该恶意软件将像其他所有内容一样在 HTTPS 流中发送。然而， HTTPS确实可以防止中间的任何人将恶意软件注入到你的移动流量中。</p>\n<ol start=\"5\">\n<li>保护你的计算机免遭黑客攻击</li>\n</ol>\n<p>HTTPS 仅保护在你的计算机和 Web 服务器之间移动的数据。它不会为你的实际计算机或服务器本身提供任何保护。这也意味着，如果有恶意软件正在监视连接一端的流量，它就可以读取 HTTPS 流中加密之前和之后的流量。</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Redis成长记 - Redis的陷阱（一）","date":"2024-04-18T07:09:28.000Z","_content":"相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","source":"_posts/redis-interview-1.md","raw":"---\ntitle: Redis成长记 - Redis的陷阱（一）\ndate: 2024-04-18 15:09:28\ntags: redis 面试 求职\n---\n相信很多老铁在求职过程中都看到过类似下面这样的任职要求\n\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？\n后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。\n\n在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末[相关文章推荐](#References)\n\n\n当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。\n\n下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。\n同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。\n\n# 缓存穿透\n缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。\n\n![缓存穿透](/images/redis-interview/cache-penetration.png)\n\n## 缓存穿透的原因\n缓存穿透通常发生在以下情况下：\n\n1. 恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。\n2. 大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。\n\n## 缓存穿透的影响\n+ 数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。\n+ 系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。\n\n## 缓存穿透的解决方法\n1. 空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。\n2. 布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。\n3. 热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。\n4. 限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。\n5. 使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。\n\n下面是一个使用 C# 空对象缓存的示例代码：\n\n```C#\npublic class UserBll\n{\n    public static readonly int CACHE_NULL_TTL = 10;\n    public static readonly int CACHE_TTL = 20;\n    /** \n     * 缓存穿透* \n     * @param id \n     * @ return \n     */\n    public WebUserInfo QueryUser(string key)\n    {\n        var redis = Redis.GetDatabase(0);\n        // 1.从redis中查询store缓存\n        String value = redis.StringGet(key);\n        WebUserInfo user = null;\n        // 2.判断是否存在\n        if( value.HasValue() ) {\n            user = value.FromJson<WebUserInfo>();\n            // 3.存在，直接返回\n            return user;\n        }\n        // 判断命中是否为空值\n        if ( value == null) {\n            // 返回错误信息\n            return null;\n        }\n        // 4.不存在，根据id查询数据库\n        user = DatabaseQuery(key);\n        // 5. 不存在，返回错误\n        if( user == null ) {\n            // 向redis写入空值（缓存穿透）\n            redis.StringSet(key, \"\", new TimeSpan(0, CACHE_NULL_TTL, 0));\n            return null;\n        }\n        // 6.存在，写入redis\n        redis.StringSet(key, user.ToJson(), new TimeSpan(0, CACHE_TTL, 0));\n        // 7. 返回\n        return user;\n}\n\n\n    public WebUserInfo DatabaseQuery(string key)\n    {\n        // 模拟从数据库中查询数据\n        // 实际情况下，这里可以是访问数据库、调用外部 API 等操作\n        // 这里简化为返回 null\n        return null;\n    }\n\n\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UserBll cache = new UserBll();\n\n        // 第一次查询，缓存中不存在，但是查询结果为空\n        string result1 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 1: \" + result1); // Output: Result 1: (null)\n\n        // 第二次查询，缓存中已存在空对象缓存，直接返回空值\n        string result2 = cache.QueryUser(\"key1\");\n        Console.WriteLine(\"Result 2: \" + result2); // Output: Result 2: (null)\n\n        // 第三次查询，模拟数据库中存在对应值的情况\n        string result3 = cache.QueryUser(\"key2\");\n        Console.WriteLine(\"Result 3: \" + result3); // Output: Result 3: <value from database>\n    }\n}\n\n\n```\n上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库\n- 优点：实现简单，易于维护\n- 缺点：额外的内存消耗（可以通过添加TTL来解决）\n\n同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）\n\n# 缓存雪崩\n缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。\n\n![Cache Avalanche](/images/redis-interview/cache-avalanche.png)\n\n## 缓存雪崩的原因\n缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩\n\n## 缓存雪崩的解决方案\n### 1. 设置随机过期时间\n通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。\n\n### 2. 使用多级缓存策略\n采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。\n\n### 3. 限流和降级\n在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。\n\n### 4. 预热缓存\n在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。\n\n# 缓存击穿\n缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。\n\n![缓存击穿](/images/redis-interview/cache-breakdown.png)\n\n1. 设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。\n2. 加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。\n3. 使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。\n4. 使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。\n\n下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\npublic class Cache\n{\n    private Dictionary<string, string> cache = new Dictionary<string, string>();\n    private Mutex mutex = new Mutex();\n\n    public string Get(string key)\n    {\n        // 先尝试从缓存中获取数据\n        string value;\n        if (cache.TryGetValue(key, out value))\n        {\n            return value;\n        }\n\n        // 如果缓存中不存在，加锁查询数据库\n        mutex.WaitOne();\n        try\n        {\n            // 再次检查缓存，防止多个线程同时查询数据库\n            if (cache.TryGetValue(key, out value))\n            {\n                return value;\n            }\n\n            // 模拟从数据库中查询数据\n            value = QueryFromDatabase(key);\n\n            // 将查询结果更新到缓存中\n            cache[key] = value;\n        }\n        finally\n        {\n            mutex.ReleaseMutex();\n        }\n\n        return value;\n    }\n\n    private string QueryFromDatabase(string key)\n    {\n        // 模拟从数据库中查询数据的过程\n        Thread.Sleep(100); // 模拟耗时查询操作\n        return \"value for \" + key;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Cache cache = new Cache();\n\n        // 并发查询\n        List<Thread> threads = new List<Thread>();\n        for (int i = 0; i < 10; i++)\n        {\n            Thread thread = new Thread(() =>\n            {\n                string value = cache.Get(\"key\");\n                Console.WriteLine(Thread.CurrentThread.Name + \": \" + value);\n            });\n            thread.Name = \"Thread \" + i;\n            threads.Add(thread);\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Start();\n        }\n\n        foreach (Thread thread in threads)\n        {\n            thread.Join();\n        }\n    }\n}\n\n```\n\n# 相关文章推荐\n<div id=\"References\"></div>\n\n+ [Redis官方文档](http://redis.io/documentation)\n+ [Redis教程](https://www.runoob.com/redis/redis-tutorial.html)\n\n\n今天就不总结了，未完待续😪...\n\n\n更多一手讯息，可关注公众号：[ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)\n\n![ITProHub](https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg)","slug":"redis-interview-1","published":1,"updated":"2024-04-26T03:31:26.087Z","_id":"clv5zlgr50003fcp11585dpte","comments":1,"layout":"post","photos":[],"link":"","content":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信很多老铁在求职过程中都看到过类似下面这样的任职要求</p>\n<img src=\"/images/redis-interview/recruitment.png\" width=\"50%\">\n\n<p>你申请的岗位上面写着”熟悉Redis”，那么你已经准备好回答面试官可能会问到的问题了么？<br>后面我将开启一个针对Redis的系列分享，希望能帮助刚刚开始学习Redis的朋友们。</p>\n<p>在开始阅读本篇文章之前，默认你已经具备基础的Redis知识，如果你没有，可以先阅读文末<a href=\"#References\">相关文章推荐</a></p>\n<p>当使用 Redis 作为缓存或数据存储时，虽然它提供了高性能和灵活性，但也存在一些陷阱需要注意。之前看博客的时候看到过这样一句话”Experts aren’t the only people who know what to do. They’re the people who know what not to do.“ 专家并不是唯一知道如何做的人，他们只是知道如何避免一些陷阱。</p>\n<p>下面讲诉的是一些常见的 Redis 陷阱，或者说容易忽略的问题。内容较多，可能会分多篇文章，尽情期待。<br>同时由于要讲的内容实在是太多，所以本文更多的只是起到”抛砖“的作用，更多的详细的内容还需要老铁们自己再深层次的去学习。</p>\n<h1 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h1><p>缓存穿透指的是恶意请求或者大量不存在的 key 导致缓存无法命中，从而绕过缓存直接访问数据库，导致数据库压力过大，甚至宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-penetration.png\" alt=\"缓存穿透\"></p>\n<h2 id=\"缓存穿透的原因\"><a href=\"#缓存穿透的原因\" class=\"headerlink\" title=\"缓存穿透的原因\"></a>缓存穿透的原因</h2><p>缓存穿透通常发生在以下情况下：</p>\n<ol>\n<li>恶意请求：攻击者发送大量不存在于缓存中的 key，导致缓存无法命中，直接访问数据库。</li>\n<li>大量并发查询：当并发查询量很大时，可能会出现大量不存在于缓存中的 key，从而导致缓存穿透。</li>\n</ol>\n<h2 id=\"缓存穿透的影响\"><a href=\"#缓存穿透的影响\" class=\"headerlink\" title=\"缓存穿透的影响\"></a>缓存穿透的影响</h2><ul>\n<li>数据库压力过大：大量无效请求直接访问数据库，导致数据库压力过大，甚至导致数据库宕机。</li>\n<li>系统性能下降：数据库压力增大，可能导致系统响应变慢，影响用户体验。</li>\n</ul>\n<h2 id=\"缓存穿透的解决方法\"><a href=\"#缓存穿透的解决方法\" class=\"headerlink\" title=\"缓存穿透的解决方法\"></a>缓存穿透的解决方法</h2><ol>\n<li>空对象缓存：当查询结果为空时，也将该空结果缓存起来，但设置一个较短的过期时间，防止攻击者利用缓存穿透问题。</li>\n<li>布隆过滤器：在缓存层之前增加布隆过滤器，用于快速过滤掉不存在于缓存中的 key，从而避免缓存穿透。</li>\n<li>热点数据预热：将热点数据提前加载到缓存中，提高命中率，减少缓存穿透的发生。</li>\n<li>限流控制：对于频繁查询的接口，可以进行限流控制，防止攻击者发起大量无效请求。</li>\n<li>使用缓存锁：在查询数据库时，使用缓存锁进行串行化处理，防止大量并发查询导致缓存穿透。</li>\n</ol>\n<p>下面是一个使用 C# 空对象缓存的示例代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UserBll</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_NULL_TTL = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> <span class=\"built_in\">int</span> CACHE_TTL = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存穿透* </span></span><br><span class=\"line\"><span class=\"comment\">     * @param id </span></span><br><span class=\"line\"><span class=\"comment\">     * @ return </span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">QueryUser</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> redis = Redis.GetDatabase(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 1.从redis中查询store缓存</span></span><br><span class=\"line\">        String <span class=\"keyword\">value</span> = redis.StringGet(key);</span><br><span class=\"line\">        WebUserInfo user = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 2.判断是否存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( <span class=\"keyword\">value</span>.HasValue() ) &#123;</span><br><span class=\"line\">            user = <span class=\"keyword\">value</span>.FromJson&lt;WebUserInfo&gt;();</span><br><span class=\"line\">            <span class=\"comment\">// 3.存在，直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 判断命中是否为空值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">value</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 返回错误信息</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 4.不存在，根据id查询数据库</span></span><br><span class=\"line\">        user = DatabaseQuery(key);</span><br><span class=\"line\">        <span class=\"comment\">// 5. 不存在，返回错误</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>( user == <span class=\"literal\">null</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向redis写入空值（缓存穿透）</span></span><br><span class=\"line\">            redis.StringSet(key, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_NULL_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 6.存在，写入redis</span></span><br><span class=\"line\">        redis.StringSet(key, user.ToJson(), <span class=\"keyword\">new</span> TimeSpan(<span class=\"number\">0</span>, CACHE_TTL, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 7. 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebUserInfo <span class=\"title\">DatabaseQuery</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际情况下，这里可以是访问数据库、调用外部 API 等操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里简化为返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UserBll cache = <span class=\"keyword\">new</span> UserBll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第一次查询，缓存中不存在，但是查询结果为空</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result1 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 1: &quot;</span> + result1); <span class=\"comment\">// Output: Result 1: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第二次查询，缓存中已存在空对象缓存，直接返回空值</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result2 = cache.QueryUser(<span class=\"string\">&quot;key1&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 2: &quot;</span> + result2); <span class=\"comment\">// Output: Result 2: (null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第三次查询，模拟数据库中存在对应值的情况</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> result3 = cache.QueryUser(<span class=\"string\">&quot;key2&quot;</span>);</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;Result 3: &quot;</span> + result3); <span class=\"comment\">// Output: Result 3: &lt;value from database&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上述代码中，当用户请求一个key时，redis和数据库都不存在。我们直接将key对应的null值缓存到redis中，这样下次用户重复请求这个key的时候，redis就可以命中（hit null），只是不会询问数据库</p>\n<ul>\n<li>优点：实现简单，易于维护</li>\n<li>缺点：额外的内存消耗（可以通过添加TTL来解决）</li>\n</ul>\n<p>同时可能会造成短暂的不一致（控制TTL时间可以在一定程度上缓解）。当null被缓存时，我们只是在数据库中设置值，而用户query为空，但数据库中实际存在，会造成不一致（可以通过插入数据时自动覆盖之前的空数据来解决）</p>\n<h1 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h1><p>缓存雪崩指的是在缓存失效的瞬间，大量的请求同时涌入数据库或其他数据源，导致数据库负载剧增，甚至造成数据库宕机的情况。</p>\n<p><img src=\"/images/redis-interview/cache-avalanche.png\" alt=\"Cache Avalanche\"></p>\n<h2 id=\"缓存雪崩的原因\"><a href=\"#缓存雪崩的原因\" class=\"headerlink\" title=\"缓存雪崩的原因\"></a>缓存雪崩的原因</h2><p>缓存雪崩通常是由于缓存中的大量数据同时失效而引起的。当多个缓存键具有相同的失效时间，并且这些缓存键又在同一时间失效时，就会导致大量请求直接击穿缓存，同时涌入数据源，造成缓存雪崩</p>\n<h2 id=\"缓存雪崩的解决方案\"><a href=\"#缓存雪崩的解决方案\" class=\"headerlink\" title=\"缓存雪崩的解决方案\"></a>缓存雪崩的解决方案</h2><h3 id=\"1-设置随机过期时间\"><a href=\"#1-设置随机过期时间\" class=\"headerlink\" title=\"1. 设置随机过期时间\"></a>1. 设置随机过期时间</h3><p>通过给缓存键设置随机的过期时间，可以有效地分散缓存失效的时间点，降低大量缓存同时失效的可能性，从而减轻了缓存雪崩的风险。</p>\n<h3 id=\"2-使用多级缓存策略\"><a href=\"#2-使用多级缓存策略\" class=\"headerlink\" title=\"2. 使用多级缓存策略\"></a>2. 使用多级缓存策略</h3><p>采用多级缓存架构，包括本地缓存、分布式缓存和持久化存储，当主缓存失效时，可以从备用缓存中获取数据，降低对数据库的直接访问。</p>\n<h3 id=\"3-限流和降级\"><a href=\"#3-限流和降级\" class=\"headerlink\" title=\"3. 限流和降级\"></a>3. 限流和降级</h3><p>在缓存失效期间，可以对请求进行限流，降低请求的并发数量，从而减轻了数据库的压力。同时，可以对部分非关键请求进行降级处理，暂时屏蔽一些非必要的服务，保证核心服务的稳定性。</p>\n<h3 id=\"4-预热缓存\"><a href=\"#4-预热缓存\" class=\"headerlink\" title=\"4. 预热缓存\"></a>4. 预热缓存</h3><p>在系统启动或低峰期，预先加载缓存数据，提前将常用数据缓存起来，避免在高峰期间大量请求直接击穿缓存。</p>\n<h1 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h1><p>缓存击穿是指某个热点key突然失效或者未命中，导致大量请求直接访问数据库，造成数据库压力剧增的现象。这种情况通常发生在具有高并发访问量的系统中，特别是在缓存系统中使用了较短的过期时间或者热点数据的访问频率突然增加时。</p>\n<p><img src=\"/images/redis-interview/cache-breakdown.png\" alt=\"缓存击穿\"></p>\n<ol>\n<li>设置热点数据永不过期： 对于一些热点数据，可以设置永不过期，或者设置较长的过期时间，保证其不会在短时间内失效，从而避免了缓存击穿的发生。</li>\n<li>加锁机制： 在缓存失效时，可以通过加锁机制确保只有一个线程能够进入数据库查询数据，并将查询结果更新到缓存中，避免了多个线程同时查询数据库的情况。</li>\n<li>使用互斥锁和分布式锁： 使用互斥锁或者分布式锁来保证在查询数据库的过程中，只有一个线程能够执行查询操作，其他线程需要等待锁释放后再进行查询，避免了并发访问数据库的情况。</li>\n<li>使用缓存预热： 在系统启动或者低峰期，可以预先将热点数据加载到缓存中，提前减少了缓存失效时的并发请求量，从而避免了缓存击穿的发生。</li>\n</ol>\n<p>下面是一个用C#实现的示例代码，演示了如何使用互斥锁来解决缓存击穿问题：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Cache</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt; cache = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Mutex mutex = <span class=\"keyword\">new</span> Mutex();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">Get</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先尝试从缓存中获取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">string</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果缓存中不存在，加锁查询数据库</span></span><br><span class=\"line\">        mutex.WaitOne();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次检查缓存，防止多个线程同时查询数据库</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache.TryGetValue(key, <span class=\"keyword\">out</span> <span class=\"keyword\">value</span>))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 模拟从数据库中查询数据</span></span><br><span class=\"line\">            <span class=\"keyword\">value</span> = QueryFromDatabase(key);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将查询结果更新到缓存中</span></span><br><span class=\"line\">            cache[key] = <span class=\"keyword\">value</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            mutex.ReleaseMutex();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">value</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"built_in\">string</span> <span class=\"title\">QueryFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">string</span> key</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库中查询数据的过程</span></span><br><span class=\"line\">        Thread.Sleep(<span class=\"number\">100</span>); <span class=\"comment\">// 模拟耗时查询操作</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;value for &quot;</span> + key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Cache cache = <span class=\"keyword\">new</span> Cache();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 并发查询</span></span><br><span class=\"line\">        List&lt;Thread&gt; threads = <span class=\"keyword\">new</span> List&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread thread = <span class=\"keyword\">new</span> Thread(() =&gt;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">string</span> <span class=\"keyword\">value</span> = cache.Get(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">                Console.WriteLine(Thread.CurrentThread.Name + <span class=\"string\">&quot;: &quot;</span> + <span class=\"keyword\">value</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.Name = <span class=\"string\">&quot;Thread &quot;</span> + i;</span><br><span class=\"line\">            threads.Add(thread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">foreach</span> (Thread thread <span class=\"keyword\">in</span> threads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            thread.Join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"相关文章推荐\"><a href=\"#相关文章推荐\" class=\"headerlink\" title=\"相关文章推荐\"></a>相关文章推荐</h1><div id=\"References\"></div>\n\n<ul>\n<li><a href=\"http://redis.io/documentation\">Redis官方文档</a></li>\n<li><a href=\"https://www.runoob.com/redis/redis-tutorial.html\">Redis教程</a></li>\n</ul>\n<p>今天就不总结了，未完待续😪…</p>\n<p>更多一手讯息，可关注公众号：<a href=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\">ITProHub</a></p>\n<p><img src=\"https://myom-dev.oss-cn-hangzhou.aliyuncs.com/WechatPublicPlatformQrCode.jpg\" alt=\"ITProHub\"></p>\n"},{"title":"Dump分析入门指南","date":"2024-04-28T06:18:14.000Z","_content":"\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","source":"_posts/dump.md","raw":"---\ntitle: Dump分析入门指南\ndate: 2024-04-28 14:18:14\ntags: dump 性能 异常\n---\n\n想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。\n挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？\n\n![crash](./images/dump/crash.jpeg)\n\n在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。\n\n\n# Dump 文件是什么？\nDump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。\n\n## 常见的 Dump 文件类型\n+ 完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。\n+ 迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。\n+ 核心转储（Core Dump）： 核心转储是在 Unix/Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。\n\n# Dump 文件分析的基本步骤\n1. 收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。\n2. 选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。\n3. 分析dump文件\n    + 查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。\n    + 检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。\n    + 分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。\n    + 诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。\n4. 诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。\n\n# Dump 文件分析的实战演练\n上面说了那么多理论，下面我们来实际操作一下。\n\n首先简单介绍一下作为示例的项目背景，\n1. 程序性质：基于 .NET 的 Web 应用程序；\n2. 运行环境：运行在docker 容器中；\n3. 收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；\n3. 问题表现：内存泄漏；\n\n## 收集dump文件\n### 进入容器\n```\ndocker exec -it wpp bash\n```\n### 进入.net运行时目录\n```\nroot@4aa6a7d51e1e:/# \nroot@4aa6a7d51e1e:/# find / -name createdump\n/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump\nroot@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           \nroot@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# \n\n```\n### 运行createdump抓包\n```\ncreatedump [options] pid\n-f, --name - dump path and file name. The default is '/tmp/coredump.%p'. These specifiers are substituted with following values:\n   %p  PID of dumped process.\n   %e  The process executable filename.\n   %h  Hostname return by gethostname().\n   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).\n-n, --normal - create minidump.\n-h, --withheap - create minidump with heap (default).\n-t, --triage - create triage minidump.\n-u, --full - create full core dump.\n-d, --diag - enable diagnostic messages.\n```\ntop一下查看进程id\n```\n PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\n    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll\n11480     0 root     S     4188   0%   0% bash\n11845 11480 root     R     3268   0%   0% top\n\n```\n执行命令\n```\n./createdump -f /tmp/wpp_dump -u 1\n```\n> 如果提示没有权限，需要在docker运行时增加一个参数 --privileged=true ，以便容器以特权方式运行。\n\n### 将dump文件拷贝出来\n```\nsudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump\n```\n## WinDbg 分析dump文件\n项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量\n\n首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]\n然后穿透找到类型对应的变量的内存占用情况\n![内存占用](/images/dump/windbg_1.png)\n![变量内存](/images/dump/windbg_2.png)\n通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥\n![变量内容](/images/dump/windbg_3.png)\n通过变量的内容，找到具体代码的位置了就不是什么难事了。\n![bug位置](/images/dump/windbg_4.png)\n我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。\n对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。\n\n\n# 结语\n通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。","slug":"dump","published":1,"updated":"2024-05-08T08:37:58.693Z","_id":"clvj8jhdc0000pop171ud7xg2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>想象一下，突然有一天部署在服务器上的应用突然挂了！没有一点点防备，也没有一丝顾虑，你就这样出现。。。<br>挂就挂了吧，服务还没有输出任务的错误信息。这个时候有没有什么途径可以让我找到崩溃的原因呢？</p>\n<p><img src=\"/./images/dump/crash.jpeg\" alt=\"crash\"></p>\n<p>在软件开发和运维过程中，Dump 文件是一种非常重要的工具，可以帮助我们定位和解决各种问题，包括应用程序崩溃、性能问题、内存泄漏等。本文将介绍 Dump 文件的基本概念、常见类型以及如何进行分析和利用，帮助读者更好地理解和利用 Dump 文件进行故障排查和性能优化。</p>\n<h1 id=\"Dump-文件是什么？\"><a href=\"#Dump-文件是什么？\" class=\"headerlink\" title=\"Dump 文件是什么？\"></a>Dump 文件是什么？</h1><p>Dump 文件是在应用程序发生崩溃或异常情况时生成的一种内存转储文件，记录了应用程序在崩溃时的内存状态、线程堆栈、变量值等信息。Dump 文件通常以 .dmp 或 .core 等扩展名保存，可以被用于后续的故障排查和分析。</p>\n<h2 id=\"常见的-Dump-文件类型\"><a href=\"#常见的-Dump-文件类型\" class=\"headerlink\" title=\"常见的 Dump 文件类型\"></a>常见的 Dump 文件类型</h2><ul>\n<li>完全内存转储（Full Memory Dump）： 完全内存转储记录了整个进程的内存状态，包括代码、数据、堆栈、寄存器等信息。这种类型的 Dump 文件通常用于分析应用程序崩溃的根本原因。</li>\n<li>迷你内存转储（Mini Dump）： 迷你内存转储只记录了应用程序崩溃时的关键信息，如线程堆栈、异常信息等，体积相对较小。这种类型的 Dump 文件通常用于快速定位问题，但可能丢失一些详细信息。</li>\n<li>核心转储（Core Dump）： 核心转储是在 Unix&#x2F;Linux 系统下产生的一种内存转储文件，记录了应用程序崩溃时的内存状态。核心转储文件通常用于分析应用程序崩溃的原因和内存使用情况。</li>\n</ul>\n<h1 id=\"Dump-文件分析的基本步骤\"><a href=\"#Dump-文件分析的基本步骤\" class=\"headerlink\" title=\"Dump 文件分析的基本步骤\"></a>Dump 文件分析的基本步骤</h1><ol>\n<li>收集 Dump 文件： 首先需要收集到应用程序崩溃时生成的 Dump 文件，可以通过操作系统、监控工具或者应用程序自身设置来获取。</li>\n<li>选择合适的工具： 根据 Dump 文件的类型和问题的性质，选择合适的工具进行分析。常用的工具包括 WinDbg、GDB、Visual Studio 等。</li>\n<li>分析dump文件<ul>\n<li>查看线程堆栈： 分析线程堆栈信息，定位到异常发生时的代码位置，了解程序的执行流程和调用关系。</li>\n<li>检查内存使用情况： 分析内存使用情况，查找可能存在的内存泄漏或者过度使用内存的情况，优化内存管理和资源释放。</li>\n<li>分析异常信息： 查看异常信息，了解异常的类型、位置和原因，为故障排查提供重要线索。</li>\n<li>诊断性能问题： 分析性能指标和性能瓶颈，找出影响服务性能的原因，进行性能优化和调整。</li>\n</ul>\n</li>\n<li>诊断和解决问题： 根据分析结果，诊断出问题的根本原因，并采取相应的措施进行修复或优化。</li>\n</ol>\n<h1 id=\"Dump-文件分析的实战演练\"><a href=\"#Dump-文件分析的实战演练\" class=\"headerlink\" title=\"Dump 文件分析的实战演练\"></a>Dump 文件分析的实战演练</h1><p>上面说了那么多理论，下面我们来实际操作一下。</p>\n<p>首先简单介绍一下作为示例的项目背景，</p>\n<ol>\n<li>程序性质：基于 .NET 的 Web 应用程序；</li>\n<li>运行环境：运行在docker 容器中；</li>\n<li>收集工具：createdump是随着 .NET Core runtime 一起发布的一个创建 dump 的一个工具；</li>\n<li>问题表现：内存泄漏；</li>\n</ol>\n<h2 id=\"收集dump文件\"><a href=\"#收集dump文件\" class=\"headerlink\" title=\"收集dump文件\"></a>收集dump文件</h2><h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it wpp bash</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入-net运行时目录\"><a href=\"#进入-net运行时目录\" class=\"headerlink\" title=\"进入.net运行时目录\"></a>进入.net运行时目录</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@4aa6a7d51e1e:/# </span><br><span class=\"line\">root@4aa6a7d51e1e:/# find / -name createdump</span><br><span class=\"line\">/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0/createdump</span><br><span class=\"line\">root@4aa6a7d51e1e:/# cd /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0           </span><br><span class=\"line\">root@4aa6a7d51e1e:/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.0# </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"运行createdump抓包\"><a href=\"#运行createdump抓包\" class=\"headerlink\" title=\"运行createdump抓包\"></a>运行createdump抓包</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createdump [options] pid</span><br><span class=\"line\">-f, --name - dump path and file name. The default is &#x27;/tmp/coredump.%p&#x27;. These specifiers are substituted with following values:</span><br><span class=\"line\">   %p  PID of dumped process.</span><br><span class=\"line\">   %e  The process executable filename.</span><br><span class=\"line\">   %h  Hostname return by gethostname().</span><br><span class=\"line\">   %t  Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).</span><br><span class=\"line\">-n, --normal - create minidump.</span><br><span class=\"line\">-h, --withheap - create minidump with heap (default).</span><br><span class=\"line\">-t, --triage - create triage minidump.</span><br><span class=\"line\">-u, --full - create full core dump.</span><br><span class=\"line\">-d, --diag - enable diagnostic messages.</span><br></pre></td></tr></table></figure>\n<p>top一下查看进程id</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class=\"line\">    1     0 root     S     261g7842%   0% dotnet SubscriptionAccount.dll</span><br><span class=\"line\">11480     0 root     S     4188   0%   0% bash</span><br><span class=\"line\">11845 11480 root     R     3268   0%   0% top</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./createdump -f /tmp/wpp_dump -u 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果提示没有权限，需要在docker运行时增加一个参数 –privileged&#x3D;true ，以便容器以特权方式运行。</p>\n</blockquote>\n<h3 id=\"将dump文件拷贝出来\"><a href=\"#将dump文件拷贝出来\" class=\"headerlink\" title=\"将dump文件拷贝出来\"></a>将dump文件拷贝出来</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker cp wpp:/tmp/wpp_dump /tmp/wpp_dump</span><br></pre></td></tr></table></figure>\n<h2 id=\"WinDbg-分析dump文件\"><a href=\"#WinDbg-分析dump文件\" class=\"headerlink\" title=\"WinDbg 分析dump文件\"></a>WinDbg 分析dump文件</h2><p>项目背景里面我们也讲到了，这次我们分析的是内存泄漏的问题。所以我们分析的第一步是找到哪些内存占用比较大的变量</p>\n<p>首先，我们找到内存占用最大类型，这里我们内存占用较大的System.Byte[]<br>然后穿透找到类型对应的变量的内存占用情况<br><img src=\"/images/dump/windbg_1.png\" alt=\"内存占用\"><br><img src=\"/images/dump/windbg_2.png\" alt=\"变量内存\"><br>通过上面的命令，我们找到内存占用最高的几个变量，然后穿透到具体这个大变量里面装的是啥<br><img src=\"/images/dump/windbg_3.png\" alt=\"变量内容\"><br>通过变量的内容，找到具体代码的位置了就不是什么难事了。<br><img src=\"/images/dump/windbg_4.png\" alt=\"bug位置\"><br>我们可以看到上面的代码在拼接sql，最后生成了一个很大的字符串，导致内存占用很大。<br>对于大于 85,000 字节的对象，.NET 会将它们分配到一个称为“大对象堆（Large Object Heap，LOH）”的特殊堆中。大对象堆上的垃圾回收策略与普通堆上的策略略有不同，而且触发条件也可能不同。因此，大对象可能会存活更长的时间。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过本文的介绍，相信读者对 Dump 文件的基本概念和分析方法有了更深入的了解。Dump 文件是故障排查和性能优化的重要工具，掌握好 Dump 文件的分析技巧能够帮助我们更快地定位和解决各种问题，提高系统的稳定性和性能。</p>\n"},{"title":"深入解析消息队列中的死信队列","date":"2024-05-22T07:37:54.000Z","_content":"\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","source":"_posts/dead-message.md","raw":"---\ntitle: 深入解析消息队列中的死信队列\ndate: 2024-05-22 15:37:54\ntags:\n---\n\n>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。\n\n# 一、死信队列的定义\n死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。\n\n![死信队列](/images/dead-message/dead-letter-exchange-1.png)\n\n# 二、死信队列为什么重要\n死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：\n\n+ 提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。\n+ 问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。\n+ 防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。\n# 三、死信队列的优势\n+ 隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。\n+ 持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。\n+ 灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。\n+ 监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。\n# 四、什么时候应该使用死信队列\n死信队列适用于以下场景：\n\n1. 消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。\n2. 消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。\n```C#\nvar properties = channel.CreateBasicProperties();\nproperties.Expiration = \"60000\"; // 消息过期时间设置为60秒\n\nchannel.BasicPublish(\n    exchange: \"\",\n    routingKey: \"normal_queue\",\n    basicProperties: properties,\n    body: Encoding.UTF8.GetBytes(\"Test Message\")\n);\n```\n3. 消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。\n```C#\nvar consumer = new EventingBasicConsumer(channel);\nconsumer.Received += (model, ea) =>\n{\n    var body = ea.Body.ToArray();\n    var message = Encoding.UTF8.GetString(body);\n    \n    // 模拟拒绝消息\n    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false);\n};\n\nchannel.BasicConsume(queue: \"normal_queue\", autoAck: false, consumer: consumer);\n```\n4. 消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。\n# 五、死信队列的工作原理\n死信队列的工作原理主要包括以下几个步骤：\n\n1. 消息进入原队列：消息首先进入正常的消息队列进行处理。\n2. 消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。\n3. 消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。\n4. 死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。\n\n![工作原理](/images/dead-message/dead-letter-exchange-1.png)\n\n# 示例：RabbitMQ中的死信队列\n\n相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。\n\n需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。\n这个时候就需要我们用延迟消费来实现了\n\n1. 创建通知队列和私信队列\n\n这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。\n```C#\n//语音通知通过死信队列延迟推送\nclient.CreateQueueBind(\"Alert-Notify2.voice\");\nDictionary<string, object> args = new Dictionary<string, object>\n{\n    [\"x-dead-letter-exchange\"] = Exchanges.Direct,\n    //指定死信消息留到何处\n    [\"x-dead-letter-routing-key\"] = \"Alert-Notify2.voice\"\n};\nclient.CreateQueueBind(\"Alert-Notify2.voice_wait\", null, null, args);\n\n```\n\n2. 给队列绑定消费者\n\n这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。\n```C#\n //阿里云语音\n RabbitSubscriber.StartAsync<AlertNotifyPackage, NotifyVoiceMessageHandler>(new RabbitSubscriberArgs\n {\n     SettingName = RabbitSettings.Rabbit,\n     QueueName = \"Alert-Notify2.voice\",\n     SubscriberCount = Settings.GetInt(\"Alert_Notify2_voice_SubscriberCount\", 2)\n });\n```\n![等待队列1](/images/dead-message/delay_comsuption_1.png)\n\n![死信队列](/images/dead-message/delay_comsuption_2.png)\n\n3. 生产者产生消息，并且给消息设置了过期时间\n```C#\nusing (RabbitClient client = new RabbitClient(RabbitSettings.Rabbit, \"NotifyService.Rabbit.MQ\"))\n{\n    //消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)\n    IBasicProperties properties = client.GetBasicProperties();\n    properties.Expiration = (60 * 1000 * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                \n    client.SendMessage(package, null, \"Alert-Notify2.voice_wait\", properties);\n}\n\n```\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果\n![延迟消费](/images/dead-message/dead-letter-3.png)\n\n# 结语\n死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。","slug":"dead-message","published":1,"updated":"2024-05-25T09:23:07.803Z","_id":"clwhmpusl0000asp18nsiccvg","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在消息队列（MQ）系统中，死信队列（Dead Letter Queue, DLQ）是一个关键组件，用于处理无法被正常消费的消息。本文将详细介绍死信队列的定义、优缺点、应用场景，并探讨与延迟消息的关系。最后，通过几个示例来展示如何在实际中使用死信队列。</p>\n</blockquote>\n<h1 id=\"一、死信队列的定义\"><a href=\"#一、死信队列的定义\" class=\"headerlink\" title=\"一、死信队列的定义\"></a>一、死信队列的定义</h1><p>死信队列（Dead Letter Queue，DLQ）是一种特殊类型的消息队列，用于存储无法被正常处理的消息。当消息在原队列中因为某些原因无法被消费时，这些消息会被转移到死信队列中。死信队列的目的是确保消息系统的健壮性和稳定性，避免因为个别消息的异常而影响整个消息处理流程。</p>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"死信队列\"></p>\n<h1 id=\"二、死信队列为什么重要\"><a href=\"#二、死信队列为什么重要\" class=\"headerlink\" title=\"二、死信队列为什么重要\"></a>二、死信队列为什么重要</h1><p>死信队列在消息队列系统中扮演着关键的角色，其重要性体现在以下几个方面：</p>\n<ul>\n<li>提高系统可靠性：通过将无法处理的消息转移到死信队列，可以防止这些消息对正常消息处理流程的影响，提高系统的可靠性。</li>\n<li>问题排查与调试：死信队列可以作为一种日志记录机制，帮助开发人员排查和调试问题。通过分析死信队列中的消息，可以找到系统中的薄弱环节和异常情况。</li>\n<li>防止消息丢失：在消息处理过程中，某些消息可能由于格式错误、超时等原因无法处理。死信队列确保这些消息不会被丢弃，而是保留起来等待进一步处理或人工干预。</li>\n</ul>\n<h1 id=\"三、死信队列的优势\"><a href=\"#三、死信队列的优势\" class=\"headerlink\" title=\"三、死信队列的优势\"></a>三、死信队列的优势</h1><ul>\n<li>隔离异常消息：将无法处理的异常消息隔离到死信队列，避免其影响正常消息的处理。</li>\n<li>持久化存储：死信队列中的消息通常会被持久化存储，确保消息不会因系统重启或故障而丢失。</li>\n<li>灵活处理机制：开发人员可以针对死信队列中的消息设计不同的处理机制，例如重新处理、通知管理员或进行人工干预。</li>\n<li>监控与报警：通过监控死信队列的大小和内容，可以及时发现系统中的异常情况，并触发报警机制进行处理。</li>\n</ul>\n<h1 id=\"四、什么时候应该使用死信队列\"><a href=\"#四、什么时候应该使用死信队列\" class=\"headerlink\" title=\"四、什么时候应该使用死信队列\"></a>四、什么时候应该使用死信队列</h1><p>死信队列适用于以下场景：</p>\n<ol>\n<li>消息处理失败：当消息由于格式错误、数据不完整等原因无法被正常处理时，应使用死信队列存储这些消息。</li>\n<li>消息处理超时：当消息在规定时间内未被消费或处理完毕时，可以将其转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> properties = channel.CreateBasicProperties();</span><br><span class=\"line\">properties.Expiration = <span class=\"string\">&quot;60000&quot;</span>; <span class=\"comment\">// 消息过期时间设置为60秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicPublish(</span><br><span class=\"line\">    exchange: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    routingKey: <span class=\"string\">&quot;normal_queue&quot;</span>,</span><br><span class=\"line\">    basicProperties: properties,</span><br><span class=\"line\">    body: Encoding.UTF8.GetBytes(<span class=\"string\">&quot;Test Message&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li>消息被拒绝：当消费者显式拒绝处理某条消息时，该消息可以被转移到死信队列。<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> consumer = <span class=\"keyword\">new</span> EventingBasicConsumer(channel);</span><br><span class=\"line\">consumer.Received += (model, ea) =&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body = ea.Body.ToArray();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 模拟拒绝消息</span></span><br><span class=\"line\">    channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">channel.BasicConsume(queue: <span class=\"string\">&quot;normal_queue&quot;</span>, autoAck: <span class=\"literal\">false</span>, consumer: consumer);</span><br></pre></td></tr></table></figure></li>\n<li>消息重试达到上限：当消息经过多次重试仍然无法成功处理时，可以将其转移到死信队列，以防止无限重试导致系统资源浪费。</li>\n</ol>\n<h1 id=\"五、死信队列的工作原理\"><a href=\"#五、死信队列的工作原理\" class=\"headerlink\" title=\"五、死信队列的工作原理\"></a>五、死信队列的工作原理</h1><p>死信队列的工作原理主要包括以下几个步骤：</p>\n<ol>\n<li>消息进入原队列：消息首先进入正常的消息队列进行处理。</li>\n<li>消息处理失败：如果消息在原队列中因为某些原因无法被消费，例如处理失败、超时或被拒绝，消息会被标记为死信。</li>\n<li>消息转移到死信队列：被标记为死信的消息会被自动转移到死信队列中进行存储。</li>\n<li>死信队列处理：死信队列中的消息可以通过特定的策略进行处理，例如重新投递、记录日志或通知管理员。开发人员可以根据业务需求设计合适的处理机制。</li>\n</ol>\n<p><img src=\"/images/dead-message/dead-letter-exchange-1.png\" alt=\"工作原理\"></p>\n<h1 id=\"示例：RabbitMQ中的死信队列\"><a href=\"#示例：RabbitMQ中的死信队列\" class=\"headerlink\" title=\"示例：RabbitMQ中的死信队列\"></a>示例：RabbitMQ中的死信队列</h1><p>相信很多老铁也听说过，我们可以用死信队列来实现延迟消费，下面我结合一个实际的场景来简单介绍一下。</p>\n<p>需求背景：产品经理要求当告警产生半小时后进行电话通知，而不是立刻进行电话通知（如果自愈成功就不需要进行通知了）。<br>这个时候就需要我们用延迟消费来实现了</p>\n<ol>\n<li>创建通知队列和私信队列</li>\n</ol>\n<p>这里我们创建一个告警产生的队列，并且设置了死信队列的交换机和路由。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语音通知通过死信队列延迟推送</span></span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>);</span><br><span class=\"line\">Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt; args = <span class=\"keyword\">new</span> Dictionary&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>] = Exchanges.Direct,</span><br><span class=\"line\">    <span class=\"comment\">//指定死信消息留到何处</span></span><br><span class=\"line\">    [<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>] = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">client.CreateQueueBind(<span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>给队列绑定消费者</li>\n</ol>\n<p>这里需要注意的是，我们给死信队列绑定了消费者，而告警等待的队列是没有消费者的。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//阿里云语音</span></span><br><span class=\"line\">RabbitSubscriber.StartAsync&lt;AlertNotifyPackage, NotifyVoiceMessageHandler&gt;(<span class=\"keyword\">new</span> RabbitSubscriberArgs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SettingName = RabbitSettings.Rabbit,</span><br><span class=\"line\">    QueueName = <span class=\"string\">&quot;Alert-Notify2.voice&quot;</span>,</span><br><span class=\"line\">    SubscriberCount = Settings.GetInt(<span class=\"string\">&quot;Alert_Notify2_voice_SubscriberCount&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/dead-message/delay_comsuption_1.png\" alt=\"等待队列1\"></p>\n<p><img src=\"/images/dead-message/delay_comsuption_2.png\" alt=\"死信队列\"></p>\n<ol start=\"3\">\n<li>生产者产生消息，并且给消息设置了过期时间<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> (RabbitClient client = <span class=\"keyword\">new</span> RabbitClient(RabbitSettings.Rabbit, <span class=\"string\">&quot;NotifyService.Rabbit.MQ&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//消息发送到死信队列中，时间到期后会发送到SendMessage(Alert-Notify2.voice)</span></span><br><span class=\"line\">    IBasicProperties properties = client.GetBasicProperties();</span><br><span class=\"line\">    properties.Expiration = (<span class=\"number\">60</span> * <span class=\"number\">1000</span> * Notify2RabbitInit.VoiceConfig.TimeOut).ToString();                </span><br><span class=\"line\">    client.SendMessage(package, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Alert-Notify2.voice_wait&quot;</span>, properties);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这样我们把消息发往等待队列，而等待队列是没有消费者的。因此消息过期之后进入死信队列进行消费，从而达到延迟消费的效果<br><img src=\"/images/dead-message/dead-letter-3.png\" alt=\"延迟消费\"></li>\n</ol>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>死信队列是消息队列系统中处理异常消息的重要机制。通过合理使用死信队列，可以提高系统的可靠性和稳定性，确保消息不会在处理过程中丢失或导致系统崩溃。在实际应用中，开发人员应根据业务需求设计合适的死信队列处理策略，以充分发挥其优势。</p>\n"},{"title":"C# 学习笔记： TaskCompletionSource","date":"2024-05-30T00:52:16.000Z","published":1,"_content":"\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","source":"_posts/TaskCompletionSource.md","raw":"---\ntitle: C# 学习笔记： TaskCompletionSource\ndate: 2024-05-30 08:52:16\npublished: true\ntags:\n---\n\n在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。\n\nTaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。\n\n\n# 什么是TaskCompletionSource？\n简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var tcs = new TaskCompletionSource<bool>();\n        tcs.SetResult(true);\n    }\n}\n```\n在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。\n\n# TaskCompletionSource实现回调\n在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class CallbackExample\n{\n    public static void Main(string[] args)\n    {\n        Task task = DoSomethingAsync();\n\n        task.ContinueWith(t =>\n        {\n            if (t.IsCompletedSuccessfully)\n            {\n                Console.WriteLine(\"操作完成!\");\n            }\n        }).Wait();\n    }\n\n    public static Task DoSomethingAsync()\n    {\n        var tcs = new TaskCompletionSource<bool>();\n\n        // 模拟异步操作和回调\n        Task.Run(() =>\n        {\n            Task.Delay(2000).Wait(); // 模拟异步操作\n            tcs.SetResult(true); // 操作完成，设置结果\n        });\n\n        return tcs.Task;\n    }\n}\n```\n\n# TaskCompletionSource实现暂停\nTaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。\n我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。\n```C#\nusing System;\nusing System.Threading.Tasks;\n\npublic class PauseExample\n{\n    private static TaskCompletionSource<bool> _pauseTcs;\n\n    public static async Task Main(string[] args)\n    {\n        _pauseTcs = new TaskCompletionSource<bool>();\n\n        Task longRunningTask = LongRunningOperationAsync();\n\n        Console.WriteLine(\"按任意键继续...\");\n        Console.ReadKey();\n        _pauseTcs.SetResult(true); // 恢复任务\n\n        await longRunningTask;\n        Console.WriteLine(\"任务完成!\");\n    }\n\n    public static async Task LongRunningOperationAsync()\n    {\n        Console.WriteLine(\"任务开始...\");\n\n        await _pauseTcs.Task; // 等待任务恢复\n\n        Console.WriteLine(\"任务恢复，继续执行...\");\n        // 模拟更多工作\n        await Task.Delay(2000);\n\n        Console.WriteLine(\"任务结束。\");\n    }\n}\n```\n运行我们可以看到如下结果\n![暂停1](/images/task-completion-source/pause-1.png)\n按任意键，任务继续运行\n![暂停2](/images/task-completion-source/pause-2.png)\n\n# TaskCompletionSource的其他用途\n\n除了上述用途，TaskCompletionSource 还可以用于以下场景：\n\n1. 事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。\n2. 并发操作：管理和协调多个异步操作的完成状态。\n3. 任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。\n\n# TaskCompletionSource的建议\n\n使用 TaskCompletionSource 时，以下是一些建议：\n\n1. 明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。\n2. 避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。\n3. 线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。\n\n# 结论\nTaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。\n\n如果你有任何问题或建议，欢迎在评论区留言讨论。","slug":"TaskCompletionSource","updated":"2024-06-06T07:22:36.858Z","_id":"clwsyjjsh00003wp1ctwte4zb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在异步编程中，C# 提供了许多强大的工具来简化异步任务的管理。其中，TaskCompletionSource 是一个非常有用的类，它允许开发者创建和控制任务的完成状态。在这篇博客中，我们将了解 TaskCompletionSource 的功能和使用方法，并结合实际代码示例来帮助更好地理解和应用它。</p>\n<p>TaskCompletionSource<T>是 .NET 库中用于处理任务的极其有用的工具，尤其是在处理手动控制任务完成的时间和方式时。TaskCompletionSource <T>类表示未绑定到委托的Task<TResult>的生产者端，通过 Task 属性提供对消费者端的访问。</p>\n<h1 id=\"什么是TaskCompletionSource？\"><a href=\"#什么是TaskCompletionSource？\" class=\"headerlink\" title=\"什么是TaskCompletionSource？\"></a>什么是TaskCompletionSource？</h1><p>简单来说，TaskCompletionSource<T>是一种允许我们创建未绑定Task<T>的类型，这意味着它不与委托绑定。这让您可以手动控制任务完成的时间和方式。您可以手动设置任务的结果，或者发出信号表示任务由于取消或错误而完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Program</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\">        tcs.SetResult(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，我们创建了一个 TaskCompletionSource<bool> 对象，并通过 SetResult 方法手动完成任务。</p>\n<h1 id=\"TaskCompletionSource实现回调\"><a href=\"#TaskCompletionSource实现回调\" class=\"headerlink\" title=\"TaskCompletionSource实现回调\"></a>TaskCompletionSource实现回调</h1><p>在异步编程中，回调函数常用于在操作完成时执行某些逻辑。使用 TaskCompletionSource，我们可以将回调函数转换为任务，并等待其完成。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CallbackExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Task task = DoSomethingAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        task.ContinueWith(t =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.IsCompletedSuccessfully)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Console.WriteLine(<span class=\"string\">&quot;操作完成!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).Wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task <span class=\"title\">DoSomethingAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 模拟异步操作和回调</span></span><br><span class=\"line\">        Task.Run(() =&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Task.Delay(<span class=\"number\">2000</span>).Wait(); <span class=\"comment\">// 模拟异步操作</span></span><br><span class=\"line\">            tcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 操作完成，设置结果</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tcs.Task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"TaskCompletionSource实现暂停\"><a href=\"#TaskCompletionSource实现暂停\" class=\"headerlink\" title=\"TaskCompletionSource实现暂停\"></a>TaskCompletionSource实现暂停</h1><p>TaskCompletionSource 还可以用于实现任务的暂停和恢复。通过手动控制任务的完成状态，我们可以在特定条件下暂停任务，并在条件满足时恢复任务。<br>我们使用 TaskCompletionSource 来实现任务的暂停和恢复。当用户按下任意键时，任务将从暂停状态恢复并继续执行。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Threading.Tasks;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">PauseExample</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt; _pauseTcs;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"built_in\">string</span>[] args</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _pauseTcs = <span class=\"keyword\">new</span> TaskCompletionSource&lt;<span class=\"built_in\">bool</span>&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        Task longRunningTask = LongRunningOperationAsync();</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;按任意键继续...&quot;</span>);</span><br><span class=\"line\">        Console.ReadKey();</span><br><span class=\"line\">        _pauseTcs.SetResult(<span class=\"literal\">true</span>); <span class=\"comment\">// 恢复任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> longRunningTask;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务完成!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> Task <span class=\"title\">LongRunningOperationAsync</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务开始...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">await</span> _pauseTcs.Task; <span class=\"comment\">// 等待任务恢复</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务恢复，继续执行...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更多工作</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> Task.Delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;任务结束。&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行我们可以看到如下结果<br><img src=\"/images/task-completion-source/pause-1.png\" alt=\"暂停1\"><br>按任意键，任务继续运行<br><img src=\"/images/task-completion-source/pause-2.png\" alt=\"暂停2\"></p>\n<h1 id=\"TaskCompletionSource的其他用途\"><a href=\"#TaskCompletionSource的其他用途\" class=\"headerlink\" title=\"TaskCompletionSource的其他用途\"></a>TaskCompletionSource的其他用途</h1><p>除了上述用途，TaskCompletionSource 还可以用于以下场景：</p>\n<ol>\n<li>事件处理：将事件驱动的模型转换为任务模型，使异步编程更加简洁。</li>\n<li>并发操作：管理和协调多个异步操作的完成状态。</li>\n<li>任务组合：与其他任务组合方法（如 Task.WhenAll 和 Task.WhenAny）结合使用，实现复杂的异步逻辑。</li>\n</ol>\n<h1 id=\"TaskCompletionSource的建议\"><a href=\"#TaskCompletionSource的建议\" class=\"headerlink\" title=\"TaskCompletionSource的建议\"></a>TaskCompletionSource的建议</h1><p>使用 TaskCompletionSource 时，以下是一些建议：</p>\n<ol>\n<li>明确任务完成条件：确保在适当的时间点调用 SetResult、SetException 或 SetCanceled 方法来完成任务。</li>\n<li>避免死锁：如果在 UI 线程中使用 TaskCompletionSource，注意避免死锁情况。</li>\n<li>线程安全：如果在多个线程中使用 TaskCompletionSource，确保操作是线程安全的。</li>\n</ol>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>TaskCompletionSource 是一个强大且灵活的工具，适用于各种异步编程场景。通过本文的介绍，希望你能更好地理解和应用 TaskCompletionSource，从而编写出更加高效和可维护的异步代码。</p>\n<p>如果你有任何问题或建议，欢迎在评论区留言讨论。</p>\n"},{"title":"从零开始搭建自己的相似图片搜索引擎","date":"2024-05-30T08:02:51.000Z","_content":"\n\n在互联网时代，图片搜索引擎已成为一种重要的工具。本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n\n\n\n![图片](/images/image-search/search.gif)","source":"_posts/similar-image-search.md","raw":"---\ntitle: 从零开始搭建自己的相似图片搜索引擎\ndate: 2024-05-30 16:02:51\ntags:\n---\n\n\n在互联网时代，图片搜索引擎已成为一种重要的工具。本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。\n\n在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。\n\n    读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n\n# 前置输入\n在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：\n+ 嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。\n+ 向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。\n+ Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。\n+ OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。\n+ Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。\n\n# 整体思路\n1. 爬虫获取图片；\n2. 用CLIP获取每个图片向量编码；\n3. 把图片的路径和向量编码存入向量数据库；\n4. 用户上传图片；\n5. 用CLIP获取图片向量编码；\n6. 在向量数据库中搜索获取相似图片，并获取图片路径；\n7. 返回相似图片；\n\n# 爬虫\n既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。\n这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。\n```python\nimport os\nimport scrapy\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom scrapy.crawler import CrawlerProcess\nfrom scrapy.http import Request\nimport re  # 确保导入 re 模块\n\nclass WeiboSpider(scrapy.Spider):\n    name = 'wb'\n    start_urls = ['xxx.xxx.com']  # 替换为你要爬取的目标URL\n\n    def __init__(self, *args, **kwargs):\n        super(WeiboSpider, self).__init__(*args, **kwargs)\n        # 配置Selenium的ChromeDriver\n        chrome_options = Options()\n        chrome_options.add_argument(\"--headless\")  # 无头模式运行，不打开浏览器界面\n        chrome_service = Service('D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe')\n        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)\n\n    def parse(self, response):\n        # 使用Selenium加载页面\n        self.driver.get(response.url)\n        # 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）\n        self.driver.implicitly_wait(10)  # 隐式等待最多10秒\n        \n        # 创建 images 目录\n        images_dir = 'images'\n        if not os.path.exists(images_dir):\n            os.makedirs(images_dir)\n        \n        # 提取图片URL或进行其他操作...\n        # 这里只是一个示例，你需要根据页面的实际结构来定位图片元素\n        images = self.driver.find_elements('tag name', 'img')\n        for image in images:\n            image_url = image.get_attribute('src')\n            if image_url:\n                yield Request(image_url, callback=self.save_image)\n\n        # 关闭Selenium的ChromeDriver\n        self.driver.quit()\n\n    def save_image(self, response):\n        # 保存图片到本地\n\n```\n下面是我爬取的图片结果\n![图片](/images/image-search/images.png)\n\n\n\n\n![图片](/images/image-search/search.gif)","slug":"similar-image-search","published":1,"updated":"2024-06-07T13:09:17.632Z","_id":"clx2wbfft0000usp1aprk4rln","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在互联网时代，图片搜索引擎已成为一种重要的工具。本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；</li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。<br>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/images/image-search/images.png\" alt=\"图片\"></p>\n<p><img src=\"/images/image-search/search.gif\" alt=\"图片\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在互联网时代，图片搜索引擎已成为一种重要的工具。本文将详细介绍如何使用向量嵌入、向量数据库和 CLIP（Contrastive Language-Image Pre-Training）模型，从零开始搭建一个功能强大的图片搜索引擎。我们将分步骤讲解每个组件的作用及其实现方法，最终实现一个能够基于图片内容进行搜索的系统。</p>\n<p>在开始阅读本篇文章之前，如果你没有接触过嵌入，clip，向量数据库等，也没关系。文章内容已经尽我所能写的通俗易懂，老少咸宜。</p>\n<pre><code>读者如果感兴趣可以跳转老夫之前介绍嵌入的文章[嵌入：它是什么以及它为什么重要](https://juejin.cn/post/7325356387152707634)\n</code></pre>\n<h1 id=\"前置输入\"><a href=\"#前置输入\" class=\"headerlink\" title=\"前置输入\"></a>前置输入</h1><p>在开始阅读后面文章的内容之前，我们先简单介绍以下后面可能会出现的术语：</p>\n<ul>\n<li>嵌入：嵌入将图像文本转换为数字表示，使我们能够找到相似的图片并有效地搜索我们的库。</li>\n<li>向量数据库：向量数据库是一种存储和搜索编码项目的方法，使我们能够找到相似的项目。</li>\n<li>Word2Vec：ord2Vec 是一种突破性的技术，可将单词转换为数字向量，使我们能够执行查找语义相似的语句，不再是单纯的分词。</li>\n<li>OpenCLIP： CLIP 是 OpenAI 的模型，可将图像和文本编码为数字向量。OpenCLIP是CLIP的开源实现。许任何人使用和构建这种强大的图像和文本编码技术，而无需特殊访问或权限。</li>\n<li>Qdrant： Qdrant 是一个高效的库，用于管理和搜索大量图像向量。</li>\n</ul>\n<h1 id=\"整体思路\"><a href=\"#整体思路\" class=\"headerlink\" title=\"整体思路\"></a>整体思路</h1><ol>\n<li>爬虫获取图片；</li>\n<li>用CLIP获取每个图片向量编码；</li>\n<li>把图片的路径和向量编码存入向量数据库；</li>\n<li>用户上传图片；</li>\n<li>用CLIP获取图片向量编码；</li>\n<li>在向量数据库中搜索获取相似图片，并获取图片路径；</li>\n<li>返回相似图片；</li>\n</ol>\n<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><p>既然是图片搜索，那么我们的第一步就是有一个图片库。这里我直接用python撸了一个简单的爬虫程序，直接从WB爬取图片作为搜索的源。<br>这里有个地方需要注意一下，因为现在图片基本上都是动态加载的，所以这里我们还需要用Selenium来获取页面内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.service <span class=\"keyword\">import</span> Service</span><br><span class=\"line\"><span class=\"keyword\">from</span> selenium.webdriver.chrome.options <span class=\"keyword\">import</span> Options</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.crawler <span class=\"keyword\">import</span> CrawlerProcess</span><br><span class=\"line\"><span class=\"keyword\">from</span> scrapy.http <span class=\"keyword\">import</span> Request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re  <span class=\"comment\"># 确保导入 re 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WeiboSpider</span>(scrapy.Spider):</span><br><span class=\"line\">    name = <span class=\"string\">&#x27;wb&#x27;</span></span><br><span class=\"line\">    start_urls = [<span class=\"string\">&#x27;xxx.xxx.com&#x27;</span>]  <span class=\"comment\"># 替换为你要爬取的目标URL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, *args, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(WeiboSpider, self).__init__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 配置Selenium的ChromeDriver</span></span><br><span class=\"line\">        chrome_options = Options()</span><br><span class=\"line\">        chrome_options.add_argument(<span class=\"string\">&quot;--headless&quot;</span>)  <span class=\"comment\"># 无头模式运行，不打开浏览器界面</span></span><br><span class=\"line\">        chrome_service = Service(<span class=\"string\">&#x27;D:\\\\Program Files\\\\chromedriver\\\\chromedriver.exe&#x27;</span>)</span><br><span class=\"line\">        self.driver = webdriver.Chrome(service=chrome_service, options=chrome_options)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">parse</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 使用Selenium加载页面</span></span><br><span class=\"line\">        self.driver.get(response.url)</span><br><span class=\"line\">        <span class=\"comment\"># 等待JavaScript加载完成（这里需要根据你的实际情况调整等待时间或方式）</span></span><br><span class=\"line\">        self.driver.implicitly_wait(<span class=\"number\">10</span>)  <span class=\"comment\"># 隐式等待最多10秒</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 创建 images 目录</span></span><br><span class=\"line\">        images_dir = <span class=\"string\">&#x27;images&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(images_dir):</span><br><span class=\"line\">            os.makedirs(images_dir)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 提取图片URL或进行其他操作...</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里只是一个示例，你需要根据页面的实际结构来定位图片元素</span></span><br><span class=\"line\">        images = self.driver.find_elements(<span class=\"string\">&#x27;tag name&#x27;</span>, <span class=\"string\">&#x27;img&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">            image_url = image.get_attribute(<span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> image_url:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(image_url, callback=self.save_image)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 关闭Selenium的ChromeDriver</span></span><br><span class=\"line\">        self.driver.quit()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">save_image</span>(<span class=\"params\">self, response</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 保存图片到本地</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是我爬取的图片结果<br><img src=\"/images/image-search/images.png\" alt=\"图片\"></p>\n<p><img src=\"/images/image-search/search.gif\" alt=\"图片\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cltzedeaa0000d0p1ajbjc7gt","tag_id":"clu6lbm020000qgp12xagd7wt","_id":"clu6lbm030001qgp1fqm351zz"},{"post_id":"cluc17m5x0000qsp19fjj1lmy","tag_id":"cluc17m5z0001qsp12a5n6e97","_id":"cluc17m600002qsp19wrd4b20"},{"post_id":"clup9vupa0000okp14bz96eiy","tag_id":"clup9vupr0001okp1b20obw5k","_id":"clup9vups0002okp1f72rhs2r"},{"post_id":"cluuzgyxx000088p1frvnfrom","tag_id":"clv0mvgiy0002x4p19oeo5n65","_id":"clv0mvgiy0003x4p186o50a2h"},{"post_id":"clv5zlgr50003fcp11585dpte","tag_id":"clv4x0del0001fcp16qpg9jfq","_id":"clv5zlgr70004fcp1a7h78bur"},{"post_id":"clvj8jhdc0000pop171ud7xg2","tag_id":"clvxfh3ap0000zkp1cdrwco6s","_id":"clvxfh3as0001zkp12iuz6c4w"}],"Tag":[{"name":"http 协议 http协议","_id":"cltzedeah0001d0p1gd2rdzoo"},{"name":"http http协议 Connection","_id":"clu6lbm020000qgp12xagd7wt"},{"name":"组织 内耗","_id":"cluc17m5z0001qsp12a5n6e97"},{"name":"Garnet 缓存 微软","_id":"clup9vupr0001okp1b20obw5k"},{"name":"https http ssl tlc","_id":"clv0mvfpx0000x4p1cun49e2q"},{"name":"https http ssl tls","_id":"clv0mvgiy0002x4p19oeo5n65"},{"name":"redis 面试 求职","_id":"clv4x0del0001fcp16qpg9jfq"},{"name":"dump","_id":"clvj8jhdt0001pop1f18veod2"},{"name":"dump 性能 异常","_id":"clvxfh3ap0000zkp1cdrwco6s"}]}}